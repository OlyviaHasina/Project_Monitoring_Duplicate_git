(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // node_modules/@shopify/draggable/lib/draggable.bundle.js
  var require_draggable_bundle = __commonJS({
    "node_modules/@shopify/draggable/lib/draggable.bundle.js"(exports, module) {
      (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define("Draggable", [], factory);
        else if (typeof exports === "object")
          exports["Draggable"] = factory();
        else
          root["Draggable"] = factory();
      })(window, function() {
        return function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              i: moduleId,
              l: false,
              exports: {}
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, { enumerable: true, get: getter });
            }
          };
          __webpack_require__.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
          __webpack_require__.t = function(value, mode) {
            if (mode & 1)
              value = __webpack_require__(value);
            if (mode & 8)
              return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule)
              return value;
            var ns = Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string")
              for (var key in value)
                __webpack_require__.d(ns, key, function(key2) {
                  return value[key2];
                }.bind(null, key));
            return ns;
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? function getDefault() {
              return module2["default"];
            } : function getModuleExports() {
              return module2;
            };
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 66);
        }([
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _AbstractEvent = __webpack_require__(64);
            var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _AbstractEvent2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _AbstractPlugin = __webpack_require__(60);
            var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _AbstractPlugin2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _closest = __webpack_require__(51);
            Object.defineProperty(exports2, "closest", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_closest).default;
              }
            });
            var _requestNextAnimationFrame = __webpack_require__(49);
            Object.defineProperty(exports2, "requestNextAnimationFrame", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_requestNextAnimationFrame).default;
              }
            });
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _SensorEvent = __webpack_require__(44);
            Object.keys(_SensorEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _SensorEvent[key];
                }
              });
            });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _Sensor = __webpack_require__(47);
            var _Sensor2 = _interopRequireDefault(_Sensor);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _Sensor2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _DragEvent = __webpack_require__(14);
            Object.keys(_DragEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _DragEvent[key];
                }
              });
            });
            var _DraggableEvent = __webpack_require__(13);
            Object.keys(_DraggableEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _DraggableEvent[key];
                }
              });
            });
            var _Plugins = __webpack_require__(12);
            Object.keys(_Plugins).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _Plugins[key];
                }
              });
            });
            var _Sensors = __webpack_require__(6);
            Object.keys(_Sensors).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _Sensors[key];
                }
              });
            });
            var _Draggable = __webpack_require__(37);
            var _Draggable2 = _interopRequireDefault(_Draggable);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _Draggable2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _Sensor = __webpack_require__(4);
            Object.defineProperty(exports2, "Sensor", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_Sensor).default;
              }
            });
            var _MouseSensor = __webpack_require__(46);
            Object.defineProperty(exports2, "MouseSensor", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_MouseSensor).default;
              }
            });
            var _TouchSensor = __webpack_require__(43);
            Object.defineProperty(exports2, "TouchSensor", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_TouchSensor).default;
              }
            });
            var _DragSensor = __webpack_require__(41);
            Object.defineProperty(exports2, "DragSensor", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_DragSensor).default;
              }
            });
            var _ForceTouchSensor = __webpack_require__(39);
            Object.defineProperty(exports2, "ForceTouchSensor", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_ForceTouchSensor).default;
              }
            });
            var _SensorEvent = __webpack_require__(3);
            Object.keys(_SensorEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _SensorEvent[key];
                }
              });
            });
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _SnappableEvent = __webpack_require__(18);
            Object.keys(_SnappableEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _SnappableEvent[key];
                }
              });
            });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _CollidableEvent = __webpack_require__(23);
            Object.keys(_CollidableEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _CollidableEvent[key];
                }
              });
            });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _SortableEvent = __webpack_require__(27);
            Object.keys(_SortableEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _SortableEvent[key];
                }
              });
            });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _SwappableEvent = __webpack_require__(30);
            Object.keys(_SwappableEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _SwappableEvent[key];
                }
              });
            });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _DroppableEvent = __webpack_require__(33);
            Object.keys(_DroppableEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _DroppableEvent[key];
                }
              });
            });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _Announcement = __webpack_require__(62);
            Object.defineProperty(exports2, "Announcement", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_Announcement).default;
              }
            });
            Object.defineProperty(exports2, "defaultAnnouncementOptions", {
              enumerable: true,
              get: function() {
                return _Announcement.defaultOptions;
              }
            });
            var _Focusable = __webpack_require__(59);
            Object.defineProperty(exports2, "Focusable", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_Focusable).default;
              }
            });
            var _Mirror = __webpack_require__(57);
            Object.defineProperty(exports2, "Mirror", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_Mirror).default;
              }
            });
            Object.defineProperty(exports2, "defaultMirrorOptions", {
              enumerable: true,
              get: function() {
                return _Mirror.defaultOptions;
              }
            });
            var _Scrollable = __webpack_require__(53);
            Object.defineProperty(exports2, "Scrollable", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_Scrollable).default;
              }
            });
            Object.defineProperty(exports2, "defaultScrollableOptions", {
              enumerable: true,
              get: function() {
                return _Scrollable.defaultOptions;
              }
            });
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _DraggableEvent = __webpack_require__(63);
            Object.keys(_DraggableEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _DraggableEvent[key];
                }
              });
            });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _DragEvent = __webpack_require__(65);
            Object.keys(_DragEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _DragEvent[key];
                }
              });
            });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.defaultOptions = void 0;
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _AbstractPlugin = __webpack_require__(1);
            var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onSortableSorted = Symbol("onSortableSorted");
            const defaultOptions = exports2.defaultOptions = {
              duration: 150,
              easingFunction: "ease-in-out",
              horizontal: false
            };
            class SwapAnimation extends _AbstractPlugin2.default {
              constructor(draggable) {
                super(draggable);
                this.options = _extends({}, defaultOptions, this.getOptions());
                this.lastAnimationFrame = null;
                this[onSortableSorted] = this[onSortableSorted].bind(this);
              }
              attach() {
                this.draggable.on("sortable:sorted", this[onSortableSorted]);
              }
              detach() {
                this.draggable.off("sortable:sorted", this[onSortableSorted]);
              }
              getOptions() {
                return this.draggable.options.swapAnimation || {};
              }
              [onSortableSorted]({ oldIndex, newIndex, dragEvent }) {
                const { source, over } = dragEvent;
                cancelAnimationFrame(this.lastAnimationFrame);
                this.lastAnimationFrame = requestAnimationFrame(() => {
                  if (oldIndex >= newIndex) {
                    animate(source, over, this.options);
                  } else {
                    animate(over, source, this.options);
                  }
                });
              }
            }
            exports2.default = SwapAnimation;
            function animate(from, to, { duration, easingFunction, horizontal }) {
              for (const element of [from, to]) {
                element.style.pointerEvents = "none";
              }
              if (horizontal) {
                const width = from.offsetWidth;
                from.style.transform = `translate3d(${width}px, 0, 0)`;
                to.style.transform = `translate3d(-${width}px, 0, 0)`;
              } else {
                const height = from.offsetHeight;
                from.style.transform = `translate3d(0, ${height}px, 0)`;
                to.style.transform = `translate3d(0, -${height}px, 0)`;
              }
              requestAnimationFrame(() => {
                for (const element of [from, to]) {
                  element.addEventListener("transitionend", resetElementOnTransitionEnd);
                  element.style.transition = `transform ${duration}ms ${easingFunction}`;
                  element.style.transform = "";
                }
              });
            }
            function resetElementOnTransitionEnd(event) {
              event.target.style.transition = "";
              event.target.style.pointerEvents = "";
              event.target.removeEventListener("transitionend", resetElementOnTransitionEnd);
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.defaultOptions = void 0;
            var _SwapAnimation = __webpack_require__(15);
            var _SwapAnimation2 = _interopRequireDefault(_SwapAnimation);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _SwapAnimation2.default;
            exports2.defaultOptions = _SwapAnimation.defaultOptions;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _AbstractPlugin = __webpack_require__(1);
            var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
            var _SnappableEvent = __webpack_require__(7);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onDragStart = Symbol("onDragStart");
            const onDragStop = Symbol("onDragStop");
            const onDragOver = Symbol("onDragOver");
            const onDragOut = Symbol("onDragOut");
            const onMirrorCreated = Symbol("onMirrorCreated");
            const onMirrorDestroy = Symbol("onMirrorDestroy");
            class Snappable extends _AbstractPlugin2.default {
              constructor(draggable) {
                super(draggable);
                this.firstSource = null;
                this.mirror = null;
                this[onDragStart] = this[onDragStart].bind(this);
                this[onDragStop] = this[onDragStop].bind(this);
                this[onDragOver] = this[onDragOver].bind(this);
                this[onDragOut] = this[onDragOut].bind(this);
                this[onMirrorCreated] = this[onMirrorCreated].bind(this);
                this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);
              }
              attach() {
                this.draggable.on("drag:start", this[onDragStart]).on("drag:stop", this[onDragStop]).on("drag:over", this[onDragOver]).on("drag:out", this[onDragOut]).on("droppable:over", this[onDragOver]).on("droppable:out", this[onDragOut]).on("mirror:created", this[onMirrorCreated]).on("mirror:destroy", this[onMirrorDestroy]);
              }
              detach() {
                this.draggable.off("drag:start", this[onDragStart]).off("drag:stop", this[onDragStop]).off("drag:over", this[onDragOver]).off("drag:out", this[onDragOut]).off("droppable:over", this[onDragOver]).off("droppable:out", this[onDragOut]).off("mirror:created", this[onMirrorCreated]).off("mirror:destroy", this[onMirrorDestroy]);
              }
              [onDragStart](event) {
                if (event.canceled()) {
                  return;
                }
                this.firstSource = event.source;
              }
              [onDragStop]() {
                this.firstSource = null;
              }
              [onDragOver](event) {
                if (event.canceled()) {
                  return;
                }
                const source = event.source || event.dragEvent.source;
                if (source === this.firstSource) {
                  this.firstSource = null;
                  return;
                }
                const snapInEvent = new _SnappableEvent.SnapInEvent({
                  dragEvent: event,
                  snappable: event.over || event.droppable
                });
                this.draggable.trigger(snapInEvent);
                if (snapInEvent.canceled()) {
                  return;
                }
                if (this.mirror) {
                  this.mirror.style.display = "none";
                }
                source.classList.remove(this.draggable.getClassNameFor("source:dragging"));
                source.classList.add(this.draggable.getClassNameFor("source:placed"));
                setTimeout(() => {
                  source.classList.remove(this.draggable.getClassNameFor("source:placed"));
                }, this.draggable.options.placedTimeout);
              }
              [onDragOut](event) {
                if (event.canceled()) {
                  return;
                }
                const source = event.source || event.dragEvent.source;
                const snapOutEvent = new _SnappableEvent.SnapOutEvent({
                  dragEvent: event,
                  snappable: event.over || event.droppable
                });
                this.draggable.trigger(snapOutEvent);
                if (snapOutEvent.canceled()) {
                  return;
                }
                if (this.mirror) {
                  this.mirror.style.display = "";
                }
                source.classList.add(this.draggable.getClassNameFor("source:dragging"));
              }
              [onMirrorCreated]({ mirror }) {
                this.mirror = mirror;
              }
              [onMirrorDestroy]() {
                this.mirror = null;
              }
            }
            exports2.default = Snappable;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SnapOutEvent = exports2.SnapInEvent = exports2.SnapEvent = void 0;
            var _AbstractEvent = __webpack_require__(0);
            var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            class SnapEvent extends _AbstractEvent2.default {
              get dragEvent() {
                return this.data.dragEvent;
              }
              get snappable() {
                return this.data.snappable;
              }
            }
            exports2.SnapEvent = SnapEvent;
            SnapEvent.type = "snap";
            class SnapInEvent extends SnapEvent {
            }
            exports2.SnapInEvent = SnapInEvent;
            SnapInEvent.type = "snap:in";
            SnapInEvent.cancelable = true;
            class SnapOutEvent extends SnapEvent {
            }
            exports2.SnapOutEvent = SnapOutEvent;
            SnapOutEvent.type = "snap:out";
            SnapOutEvent.cancelable = true;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _SnappableEvent = __webpack_require__(7);
            Object.keys(_SnappableEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _SnappableEvent[key];
                }
              });
            });
            var _Snappable = __webpack_require__(17);
            var _Snappable2 = _interopRequireDefault(_Snappable);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _Snappable2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.defaultOptions = void 0;
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _AbstractPlugin = __webpack_require__(1);
            var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
            var _utils = __webpack_require__(2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onMirrorCreated = Symbol("onMirrorCreated");
            const onMirrorDestroy = Symbol("onMirrorDestroy");
            const onDragOver = Symbol("onDragOver");
            const resize = Symbol("resize");
            const defaultOptions = exports2.defaultOptions = {};
            class ResizeMirror extends _AbstractPlugin2.default {
              constructor(draggable) {
                super(draggable);
                this.options = _extends({}, defaultOptions, this.getOptions());
                this.lastWidth = 0;
                this.lastHeight = 0;
                this.mirror = null;
                this[onMirrorCreated] = this[onMirrorCreated].bind(this);
                this[onMirrorDestroy] = this[onMirrorDestroy].bind(this);
                this[onDragOver] = this[onDragOver].bind(this);
              }
              attach() {
                this.draggable.on("mirror:created", this[onMirrorCreated]).on("drag:over", this[onDragOver]).on("drag:over:container", this[onDragOver]);
              }
              detach() {
                this.draggable.off("mirror:created", this[onMirrorCreated]).off("mirror:destroy", this[onMirrorDestroy]).off("drag:over", this[onDragOver]).off("drag:over:container", this[onDragOver]);
              }
              getOptions() {
                return this.draggable.options.resizeMirror || {};
              }
              [onMirrorCreated]({ mirror }) {
                this.mirror = mirror;
              }
              [onMirrorDestroy]() {
                this.mirror = null;
              }
              [onDragOver](dragEvent) {
                this[resize](dragEvent);
              }
              [resize]({ overContainer, over }) {
                requestAnimationFrame(() => {
                  if (this.mirror.parentNode !== overContainer) {
                    overContainer.appendChild(this.mirror);
                  }
                  const overElement = over || this.draggable.getDraggableElementsForContainer(overContainer)[0];
                  if (!overElement) {
                    return;
                  }
                  (0, _utils.requestNextAnimationFrame)(() => {
                    const overRect = overElement.getBoundingClientRect();
                    if (this.lastHeight === overRect.height && this.lastWidth === overRect.width) {
                      return;
                    }
                    this.mirror.style.width = `${overRect.width}px`;
                    this.mirror.style.height = `${overRect.height}px`;
                    this.lastWidth = overRect.width;
                    this.lastHeight = overRect.height;
                  });
                });
              }
            }
            exports2.default = ResizeMirror;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.defaultOptions = void 0;
            var _ResizeMirror = __webpack_require__(20);
            var _ResizeMirror2 = _interopRequireDefault(_ResizeMirror);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _ResizeMirror2.default;
            exports2.defaultOptions = _ResizeMirror.defaultOptions;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _AbstractPlugin = __webpack_require__(1);
            var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
            var _utils = __webpack_require__(2);
            var _CollidableEvent = __webpack_require__(8);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onDragMove = Symbol("onDragMove");
            const onDragStop = Symbol("onDragStop");
            const onRequestAnimationFrame = Symbol("onRequestAnimationFrame");
            class Collidable extends _AbstractPlugin2.default {
              constructor(draggable) {
                super(draggable);
                this.currentlyCollidingElement = null;
                this.lastCollidingElement = null;
                this.currentAnimationFrame = null;
                this[onDragMove] = this[onDragMove].bind(this);
                this[onDragStop] = this[onDragStop].bind(this);
                this[onRequestAnimationFrame] = this[onRequestAnimationFrame].bind(this);
              }
              attach() {
                this.draggable.on("drag:move", this[onDragMove]).on("drag:stop", this[onDragStop]);
              }
              detach() {
                this.draggable.off("drag:move", this[onDragMove]).off("drag:stop", this[onDragStop]);
              }
              getCollidables() {
                const collidables = this.draggable.options.collidables;
                if (typeof collidables === "string") {
                  return Array.prototype.slice.call(document.querySelectorAll(collidables));
                } else if (collidables instanceof NodeList || collidables instanceof Array) {
                  return Array.prototype.slice.call(collidables);
                } else if (collidables instanceof HTMLElement) {
                  return [collidables];
                } else if (typeof collidables === "function") {
                  return collidables();
                } else {
                  return [];
                }
              }
              [onDragMove](event) {
                const target = event.sensorEvent.target;
                this.currentAnimationFrame = requestAnimationFrame(this[onRequestAnimationFrame](target));
                if (this.currentlyCollidingElement) {
                  event.cancel();
                }
                const collidableInEvent = new _CollidableEvent.CollidableInEvent({
                  dragEvent: event,
                  collidingElement: this.currentlyCollidingElement
                });
                const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({
                  dragEvent: event,
                  collidingElement: this.lastCollidingElement
                });
                const enteringCollidable = Boolean(this.currentlyCollidingElement && this.lastCollidingElement !== this.currentlyCollidingElement);
                const leavingCollidable = Boolean(!this.currentlyCollidingElement && this.lastCollidingElement);
                if (enteringCollidable) {
                  if (this.lastCollidingElement) {
                    this.draggable.trigger(collidableOutEvent);
                  }
                  this.draggable.trigger(collidableInEvent);
                } else if (leavingCollidable) {
                  this.draggable.trigger(collidableOutEvent);
                }
                this.lastCollidingElement = this.currentlyCollidingElement;
              }
              [onDragStop](event) {
                const lastCollidingElement = this.currentlyCollidingElement || this.lastCollidingElement;
                const collidableOutEvent = new _CollidableEvent.CollidableOutEvent({
                  dragEvent: event,
                  collidingElement: lastCollidingElement
                });
                if (lastCollidingElement) {
                  this.draggable.trigger(collidableOutEvent);
                }
                this.lastCollidingElement = null;
                this.currentlyCollidingElement = null;
              }
              [onRequestAnimationFrame](target) {
                return () => {
                  const collidables = this.getCollidables();
                  this.currentlyCollidingElement = (0, _utils.closest)(target, (element) => collidables.includes(element));
                };
              }
            }
            exports2.default = Collidable;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.CollidableOutEvent = exports2.CollidableInEvent = exports2.CollidableEvent = void 0;
            var _AbstractEvent = __webpack_require__(0);
            var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            class CollidableEvent extends _AbstractEvent2.default {
              get dragEvent() {
                return this.data.dragEvent;
              }
            }
            exports2.CollidableEvent = CollidableEvent;
            CollidableEvent.type = "collidable";
            class CollidableInEvent extends CollidableEvent {
              get collidingElement() {
                return this.data.collidingElement;
              }
            }
            exports2.CollidableInEvent = CollidableInEvent;
            CollidableInEvent.type = "collidable:in";
            class CollidableOutEvent extends CollidableEvent {
              get collidingElement() {
                return this.data.collidingElement;
              }
            }
            exports2.CollidableOutEvent = CollidableOutEvent;
            CollidableOutEvent.type = "collidable:out";
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _CollidableEvent = __webpack_require__(8);
            Object.keys(_CollidableEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _CollidableEvent[key];
                }
              });
            });
            var _Collidable = __webpack_require__(22);
            var _Collidable2 = _interopRequireDefault(_Collidable);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _Collidable2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _Collidable = __webpack_require__(24);
            Object.defineProperty(exports2, "Collidable", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_Collidable).default;
              }
            });
            var _ResizeMirror = __webpack_require__(21);
            Object.defineProperty(exports2, "ResizeMirror", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_ResizeMirror).default;
              }
            });
            Object.defineProperty(exports2, "defaultResizeMirrorOptions", {
              enumerable: true,
              get: function() {
                return _ResizeMirror.defaultOptions;
              }
            });
            var _Snappable = __webpack_require__(19);
            Object.defineProperty(exports2, "Snappable", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_Snappable).default;
              }
            });
            var _SwapAnimation = __webpack_require__(16);
            Object.defineProperty(exports2, "SwapAnimation", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_SwapAnimation).default;
              }
            });
            Object.defineProperty(exports2, "defaultSwapAnimationOptions", {
              enumerable: true,
              get: function() {
                return _SwapAnimation.defaultOptions;
              }
            });
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _Draggable = __webpack_require__(5);
            var _Draggable2 = _interopRequireDefault(_Draggable);
            var _SortableEvent = __webpack_require__(9);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onDragStart = Symbol("onDragStart");
            const onDragOverContainer = Symbol("onDragOverContainer");
            const onDragOver = Symbol("onDragOver");
            const onDragStop = Symbol("onDragStop");
            function onSortableSortedDefaultAnnouncement({ dragEvent }) {
              const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || "sortable element";
              if (dragEvent.over) {
                const overText = dragEvent.over.textContent.trim() || dragEvent.over.id || "sortable element";
                const isFollowing = dragEvent.source.compareDocumentPosition(dragEvent.over) & Node.DOCUMENT_POSITION_FOLLOWING;
                if (isFollowing) {
                  return `Placed ${sourceText} after ${overText}`;
                } else {
                  return `Placed ${sourceText} before ${overText}`;
                }
              } else {
                return `Placed ${sourceText} into a different container`;
              }
            }
            const defaultAnnouncements = {
              "sortable:sorted": onSortableSortedDefaultAnnouncement
            };
            class Sortable2 extends _Draggable2.default {
              constructor(containers = [], options = {}) {
                super(containers, _extends({}, options, {
                  announcements: _extends({}, defaultAnnouncements, options.announcements || {})
                }));
                this.startIndex = null;
                this.startContainer = null;
                this[onDragStart] = this[onDragStart].bind(this);
                this[onDragOverContainer] = this[onDragOverContainer].bind(this);
                this[onDragOver] = this[onDragOver].bind(this);
                this[onDragStop] = this[onDragStop].bind(this);
                this.on("drag:start", this[onDragStart]).on("drag:over:container", this[onDragOverContainer]).on("drag:over", this[onDragOver]).on("drag:stop", this[onDragStop]);
              }
              destroy() {
                super.destroy();
                this.off("drag:start", this[onDragStart]).off("drag:over:container", this[onDragOverContainer]).off("drag:over", this[onDragOver]).off("drag:stop", this[onDragStop]);
              }
              index(element) {
                return this.getDraggableElementsForContainer(element.parentNode).indexOf(element);
              }
              [onDragStart](event) {
                this.startContainer = event.source.parentNode;
                this.startIndex = this.index(event.source);
                const sortableStartEvent = new _SortableEvent.SortableStartEvent({
                  dragEvent: event,
                  startIndex: this.startIndex,
                  startContainer: this.startContainer
                });
                this.trigger(sortableStartEvent);
                if (sortableStartEvent.canceled()) {
                  event.cancel();
                }
              }
              [onDragOverContainer](event) {
                if (event.canceled()) {
                  return;
                }
                const { source, over, overContainer } = event;
                const oldIndex = this.index(source);
                const sortableSortEvent = new _SortableEvent.SortableSortEvent({
                  dragEvent: event,
                  currentIndex: oldIndex,
                  source,
                  over
                });
                this.trigger(sortableSortEvent);
                if (sortableSortEvent.canceled()) {
                  return;
                }
                const children = this.getDraggableElementsForContainer(overContainer);
                const moves = move({ source, over, overContainer, children });
                if (!moves) {
                  return;
                }
                const { oldContainer, newContainer } = moves;
                const newIndex = this.index(event.source);
                const sortableSortedEvent = new _SortableEvent.SortableSortedEvent({
                  dragEvent: event,
                  oldIndex,
                  newIndex,
                  oldContainer,
                  newContainer
                });
                this.trigger(sortableSortedEvent);
              }
              [onDragOver](event) {
                if (event.over === event.originalSource || event.over === event.source) {
                  return;
                }
                const { source, over, overContainer } = event;
                const oldIndex = this.index(source);
                const sortableSortEvent = new _SortableEvent.SortableSortEvent({
                  dragEvent: event,
                  currentIndex: oldIndex,
                  source,
                  over
                });
                this.trigger(sortableSortEvent);
                if (sortableSortEvent.canceled()) {
                  return;
                }
                const children = this.getDraggableElementsForContainer(overContainer);
                const moves = move({ source, over, overContainer, children });
                if (!moves) {
                  return;
                }
                const { oldContainer, newContainer } = moves;
                const newIndex = this.index(source);
                const sortableSortedEvent = new _SortableEvent.SortableSortedEvent({
                  dragEvent: event,
                  oldIndex,
                  newIndex,
                  oldContainer,
                  newContainer
                });
                this.trigger(sortableSortedEvent);
              }
              [onDragStop](event) {
                const sortableStopEvent = new _SortableEvent.SortableStopEvent({
                  dragEvent: event,
                  oldIndex: this.startIndex,
                  newIndex: this.index(event.source),
                  oldContainer: this.startContainer,
                  newContainer: event.source.parentNode
                });
                this.trigger(sortableStopEvent);
                this.startIndex = null;
                this.startContainer = null;
              }
            }
            exports2.default = Sortable2;
            function index(element) {
              return Array.prototype.indexOf.call(element.parentNode.children, element);
            }
            function move({ source, over, overContainer, children }) {
              const emptyOverContainer = !children.length;
              const differentContainer = source.parentNode !== overContainer;
              const sameContainer = over && !differentContainer;
              if (emptyOverContainer) {
                return moveInsideEmptyContainer(source, overContainer);
              } else if (sameContainer) {
                return moveWithinContainer(source, over);
              } else if (differentContainer) {
                return moveOutsideContainer(source, over, overContainer);
              } else {
                return null;
              }
            }
            function moveInsideEmptyContainer(source, overContainer) {
              const oldContainer = source.parentNode;
              overContainer.appendChild(source);
              return { oldContainer, newContainer: overContainer };
            }
            function moveWithinContainer(source, over) {
              const oldIndex = index(source);
              const newIndex = index(over);
              if (oldIndex < newIndex) {
                source.parentNode.insertBefore(source, over.nextElementSibling);
              } else {
                source.parentNode.insertBefore(source, over);
              }
              return { oldContainer: source.parentNode, newContainer: source.parentNode };
            }
            function moveOutsideContainer(source, over, overContainer) {
              const oldContainer = source.parentNode;
              if (over) {
                over.parentNode.insertBefore(source, over);
              } else {
                overContainer.appendChild(source);
              }
              return { oldContainer, newContainer: source.parentNode };
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SortableStopEvent = exports2.SortableSortedEvent = exports2.SortableSortEvent = exports2.SortableStartEvent = exports2.SortableEvent = void 0;
            var _AbstractEvent = __webpack_require__(0);
            var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            class SortableEvent extends _AbstractEvent2.default {
              get dragEvent() {
                return this.data.dragEvent;
              }
            }
            exports2.SortableEvent = SortableEvent;
            SortableEvent.type = "sortable";
            class SortableStartEvent extends SortableEvent {
              get startIndex() {
                return this.data.startIndex;
              }
              get startContainer() {
                return this.data.startContainer;
              }
            }
            exports2.SortableStartEvent = SortableStartEvent;
            SortableStartEvent.type = "sortable:start";
            SortableStartEvent.cancelable = true;
            class SortableSortEvent extends SortableEvent {
              get currentIndex() {
                return this.data.currentIndex;
              }
              get over() {
                return this.data.oldIndex;
              }
              get overContainer() {
                return this.data.newIndex;
              }
            }
            exports2.SortableSortEvent = SortableSortEvent;
            SortableSortEvent.type = "sortable:sort";
            SortableSortEvent.cancelable = true;
            class SortableSortedEvent extends SortableEvent {
              get oldIndex() {
                return this.data.oldIndex;
              }
              get newIndex() {
                return this.data.newIndex;
              }
              get oldContainer() {
                return this.data.oldContainer;
              }
              get newContainer() {
                return this.data.newContainer;
              }
            }
            exports2.SortableSortedEvent = SortableSortedEvent;
            SortableSortedEvent.type = "sortable:sorted";
            class SortableStopEvent extends SortableEvent {
              get oldIndex() {
                return this.data.oldIndex;
              }
              get newIndex() {
                return this.data.newIndex;
              }
              get oldContainer() {
                return this.data.oldContainer;
              }
              get newContainer() {
                return this.data.newContainer;
              }
            }
            exports2.SortableStopEvent = SortableStopEvent;
            SortableStopEvent.type = "sortable:stop";
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _SortableEvent = __webpack_require__(9);
            Object.keys(_SortableEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _SortableEvent[key];
                }
              });
            });
            var _Sortable = __webpack_require__(26);
            var _Sortable2 = _interopRequireDefault(_Sortable);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _Sortable2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _Draggable = __webpack_require__(5);
            var _Draggable2 = _interopRequireDefault(_Draggable);
            var _SwappableEvent = __webpack_require__(10);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onDragStart = Symbol("onDragStart");
            const onDragOver = Symbol("onDragOver");
            const onDragStop = Symbol("onDragStop");
            function onSwappableSwappedDefaultAnnouncement({ dragEvent, swappedElement }) {
              const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || "swappable element";
              const overText = swappedElement.textContent.trim() || swappedElement.id || "swappable element";
              return `Swapped ${sourceText} with ${overText}`;
            }
            const defaultAnnouncements = {
              "swappabled:swapped": onSwappableSwappedDefaultAnnouncement
            };
            class Swappable extends _Draggable2.default {
              constructor(containers = [], options = {}) {
                super(containers, _extends({}, options, {
                  announcements: _extends({}, defaultAnnouncements, options.announcements || {})
                }));
                this.lastOver = null;
                this[onDragStart] = this[onDragStart].bind(this);
                this[onDragOver] = this[onDragOver].bind(this);
                this[onDragStop] = this[onDragStop].bind(this);
                this.on("drag:start", this[onDragStart]).on("drag:over", this[onDragOver]).on("drag:stop", this[onDragStop]);
              }
              destroy() {
                super.destroy();
                this.off("drag:start", this._onDragStart).off("drag:over", this._onDragOver).off("drag:stop", this._onDragStop);
              }
              [onDragStart](event) {
                const swappableStartEvent = new _SwappableEvent.SwappableStartEvent({
                  dragEvent: event
                });
                this.trigger(swappableStartEvent);
                if (swappableStartEvent.canceled()) {
                  event.cancel();
                }
              }
              [onDragOver](event) {
                if (event.over === event.originalSource || event.over === event.source || event.canceled()) {
                  return;
                }
                const swappableSwapEvent = new _SwappableEvent.SwappableSwapEvent({
                  dragEvent: event,
                  over: event.over,
                  overContainer: event.overContainer
                });
                this.trigger(swappableSwapEvent);
                if (swappableSwapEvent.canceled()) {
                  return;
                }
                if (this.lastOver && this.lastOver !== event.over) {
                  swap(this.lastOver, event.source);
                }
                if (this.lastOver === event.over) {
                  this.lastOver = null;
                } else {
                  this.lastOver = event.over;
                }
                swap(event.source, event.over);
                const swappableSwappedEvent = new _SwappableEvent.SwappableSwappedEvent({
                  dragEvent: event,
                  swappedElement: event.over
                });
                this.trigger(swappableSwappedEvent);
              }
              [onDragStop](event) {
                const swappableStopEvent = new _SwappableEvent.SwappableStopEvent({
                  dragEvent: event
                });
                this.trigger(swappableStopEvent);
                this.lastOver = null;
              }
            }
            exports2.default = Swappable;
            function withTempElement(callback) {
              const tmpElement = document.createElement("div");
              callback(tmpElement);
              tmpElement.parentNode.removeChild(tmpElement);
            }
            function swap(source, over) {
              const overParent = over.parentNode;
              const sourceParent = source.parentNode;
              withTempElement((tmpElement) => {
                sourceParent.insertBefore(tmpElement, source);
                overParent.insertBefore(source, over);
                sourceParent.insertBefore(over, tmpElement);
              });
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.SwappableStopEvent = exports2.SwappableSwappedEvent = exports2.SwappableSwapEvent = exports2.SwappableStartEvent = exports2.SwappableEvent = void 0;
            var _AbstractEvent = __webpack_require__(0);
            var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            class SwappableEvent extends _AbstractEvent2.default {
              get dragEvent() {
                return this.data.dragEvent;
              }
            }
            exports2.SwappableEvent = SwappableEvent;
            SwappableEvent.type = "swappable";
            class SwappableStartEvent extends SwappableEvent {
            }
            exports2.SwappableStartEvent = SwappableStartEvent;
            SwappableStartEvent.type = "swappable:start";
            SwappableStartEvent.cancelable = true;
            class SwappableSwapEvent extends SwappableEvent {
              get over() {
                return this.data.over;
              }
              get overContainer() {
                return this.data.overContainer;
              }
            }
            exports2.SwappableSwapEvent = SwappableSwapEvent;
            SwappableSwapEvent.type = "swappable:swap";
            SwappableSwapEvent.cancelable = true;
            class SwappableSwappedEvent extends SwappableEvent {
              get swappedElement() {
                return this.data.swappedElement;
              }
            }
            exports2.SwappableSwappedEvent = SwappableSwappedEvent;
            SwappableSwappedEvent.type = "swappable:swapped";
            class SwappableStopEvent extends SwappableEvent {
            }
            exports2.SwappableStopEvent = SwappableStopEvent;
            SwappableStopEvent.type = "swappable:stop";
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _SwappableEvent = __webpack_require__(10);
            Object.keys(_SwappableEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _SwappableEvent[key];
                }
              });
            });
            var _Swappable = __webpack_require__(29);
            var _Swappable2 = _interopRequireDefault(_Swappable);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _Swappable2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _utils = __webpack_require__(2);
            var _Draggable = __webpack_require__(5);
            var _Draggable2 = _interopRequireDefault(_Draggable);
            var _DroppableEvent = __webpack_require__(11);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onDragStart = Symbol("onDragStart");
            const onDragMove = Symbol("onDragMove");
            const onDragStop = Symbol("onDragStop");
            const dropInDropzone = Symbol("dropInDropZone");
            const returnToOriginalDropzone = Symbol("returnToOriginalDropzone");
            const closestDropzone = Symbol("closestDropzone");
            const getDropzones = Symbol("getDropzones");
            function onDroppableDroppedDefaultAnnouncement({ dragEvent, dropzone }) {
              const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || "draggable element";
              const dropzoneText = dropzone.textContent.trim() || dropzone.id || "droppable element";
              return `Dropped ${sourceText} into ${dropzoneText}`;
            }
            function onDroppableReturnedDefaultAnnouncement({ dragEvent, dropzone }) {
              const sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || "draggable element";
              const dropzoneText = dropzone.textContent.trim() || dropzone.id || "droppable element";
              return `Returned ${sourceText} from ${dropzoneText}`;
            }
            const defaultAnnouncements = {
              "droppable:dropped": onDroppableDroppedDefaultAnnouncement,
              "droppable:returned": onDroppableReturnedDefaultAnnouncement
            };
            const defaultClasses = {
              "droppable:active": "draggable-dropzone--active",
              "droppable:occupied": "draggable-dropzone--occupied"
            };
            const defaultOptions = {
              dropzone: ".draggable-droppable"
            };
            class Droppable extends _Draggable2.default {
              constructor(containers = [], options = {}) {
                super(containers, _extends({}, defaultOptions, options, {
                  classes: _extends({}, defaultClasses, options.classes || {}),
                  announcements: _extends({}, defaultAnnouncements, options.announcements || {})
                }));
                this.dropzones = null;
                this.lastDropzone = null;
                this.initialDropzone = null;
                this[onDragStart] = this[onDragStart].bind(this);
                this[onDragMove] = this[onDragMove].bind(this);
                this[onDragStop] = this[onDragStop].bind(this);
                this.on("drag:start", this[onDragStart]).on("drag:move", this[onDragMove]).on("drag:stop", this[onDragStop]);
              }
              destroy() {
                super.destroy();
                this.off("drag:start", this[onDragStart]).off("drag:move", this[onDragMove]).off("drag:stop", this[onDragStop]);
              }
              [onDragStart](event) {
                if (event.canceled()) {
                  return;
                }
                this.dropzones = [...this[getDropzones]()];
                const dropzone = (0, _utils.closest)(event.sensorEvent.target, this.options.dropzone);
                if (!dropzone) {
                  event.cancel();
                  return;
                }
                const droppableStartEvent = new _DroppableEvent.DroppableStartEvent({
                  dragEvent: event,
                  dropzone
                });
                this.trigger(droppableStartEvent);
                if (droppableStartEvent.canceled()) {
                  event.cancel();
                  return;
                }
                this.initialDropzone = dropzone;
                for (const dropzoneElement of this.dropzones) {
                  if (dropzoneElement.classList.contains(this.getClassNameFor("droppable:occupied"))) {
                    continue;
                  }
                  dropzoneElement.classList.add(this.getClassNameFor("droppable:active"));
                }
              }
              [onDragMove](event) {
                if (event.canceled()) {
                  return;
                }
                const dropzone = this[closestDropzone](event.sensorEvent.target);
                const overEmptyDropzone = dropzone && !dropzone.classList.contains(this.getClassNameFor("droppable:occupied"));
                if (overEmptyDropzone && this[dropInDropzone](event, dropzone)) {
                  this.lastDropzone = dropzone;
                } else if ((!dropzone || dropzone === this.initialDropzone) && this.lastDropzone) {
                  this[returnToOriginalDropzone](event);
                  this.lastDropzone = null;
                }
              }
              [onDragStop](event) {
                const droppableStopEvent = new _DroppableEvent.DroppableStopEvent({
                  dragEvent: event,
                  dropzone: this.lastDropzone || this.initialDropzone
                });
                this.trigger(droppableStopEvent);
                const occupiedClass = this.getClassNameFor("droppable:occupied");
                for (const dropzone of this.dropzones) {
                  dropzone.classList.remove(this.getClassNameFor("droppable:active"));
                }
                if (this.lastDropzone && this.lastDropzone !== this.initialDropzone) {
                  this.initialDropzone.classList.remove(occupiedClass);
                }
                this.dropzones = null;
                this.lastDropzone = null;
                this.initialDropzone = null;
              }
              [dropInDropzone](event, dropzone) {
                const droppableDroppedEvent = new _DroppableEvent.DroppableDroppedEvent({
                  dragEvent: event,
                  dropzone
                });
                this.trigger(droppableDroppedEvent);
                if (droppableDroppedEvent.canceled()) {
                  return false;
                }
                const occupiedClass = this.getClassNameFor("droppable:occupied");
                if (this.lastDropzone) {
                  this.lastDropzone.classList.remove(occupiedClass);
                }
                dropzone.appendChild(event.source);
                dropzone.classList.add(occupiedClass);
                return true;
              }
              [returnToOriginalDropzone](event) {
                const droppableReturnedEvent = new _DroppableEvent.DroppableReturnedEvent({
                  dragEvent: event,
                  dropzone: this.lastDropzone
                });
                this.trigger(droppableReturnedEvent);
                if (droppableReturnedEvent.canceled()) {
                  return;
                }
                this.initialDropzone.appendChild(event.source);
                this.lastDropzone.classList.remove(this.getClassNameFor("droppable:occupied"));
              }
              [closestDropzone](target) {
                if (!this.dropzones) {
                  return null;
                }
                return (0, _utils.closest)(target, this.dropzones);
              }
              [getDropzones]() {
                const dropzone = this.options.dropzone;
                if (typeof dropzone === "string") {
                  return document.querySelectorAll(dropzone);
                } else if (dropzone instanceof NodeList || dropzone instanceof Array) {
                  return dropzone;
                } else if (typeof dropzone === "function") {
                  return dropzone();
                } else {
                  return [];
                }
              }
            }
            exports2.default = Droppable;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.DroppableStopEvent = exports2.DroppableReturnedEvent = exports2.DroppableDroppedEvent = exports2.DroppableStartEvent = exports2.DroppableEvent = void 0;
            var _AbstractEvent = __webpack_require__(0);
            var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            class DroppableEvent extends _AbstractEvent2.default {
              get dragEvent() {
                return this.data.dragEvent;
              }
            }
            exports2.DroppableEvent = DroppableEvent;
            DroppableEvent.type = "droppable";
            class DroppableStartEvent extends DroppableEvent {
              get dropzone() {
                return this.data.dropzone;
              }
            }
            exports2.DroppableStartEvent = DroppableStartEvent;
            DroppableStartEvent.type = "droppable:start";
            DroppableStartEvent.cancelable = true;
            class DroppableDroppedEvent extends DroppableEvent {
              get dropzone() {
                return this.data.dropzone;
              }
            }
            exports2.DroppableDroppedEvent = DroppableDroppedEvent;
            DroppableDroppedEvent.type = "droppable:dropped";
            DroppableDroppedEvent.cancelable = true;
            class DroppableReturnedEvent extends DroppableEvent {
              get dropzone() {
                return this.data.dropzone;
              }
            }
            exports2.DroppableReturnedEvent = DroppableReturnedEvent;
            DroppableReturnedEvent.type = "droppable:returned";
            DroppableReturnedEvent.cancelable = true;
            class DroppableStopEvent extends DroppableEvent {
              get dropzone() {
                return this.data.dropzone;
              }
            }
            exports2.DroppableStopEvent = DroppableStopEvent;
            DroppableStopEvent.type = "droppable:stop";
            DroppableStopEvent.cancelable = true;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _DroppableEvent = __webpack_require__(11);
            Object.keys(_DroppableEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _DroppableEvent[key];
                }
              });
            });
            var _Droppable = __webpack_require__(32);
            var _Droppable2 = _interopRequireDefault(_Droppable);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _Droppable2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            class Emitter {
              constructor() {
                this.callbacks = {};
              }
              on(type, ...callbacks) {
                if (!this.callbacks[type]) {
                  this.callbacks[type] = [];
                }
                this.callbacks[type].push(...callbacks);
                return this;
              }
              off(type, callback) {
                if (!this.callbacks[type]) {
                  return null;
                }
                const copy = this.callbacks[type].slice(0);
                for (let i = 0; i < copy.length; i++) {
                  if (callback === copy[i]) {
                    this.callbacks[type].splice(i, 1);
                  }
                }
                return this;
              }
              trigger(event) {
                if (!this.callbacks[event.type]) {
                  return null;
                }
                const callbacks = [...this.callbacks[event.type]];
                const caughtErrors = [];
                for (let i = callbacks.length - 1; i >= 0; i--) {
                  const callback = callbacks[i];
                  try {
                    callback(event);
                  } catch (error) {
                    caughtErrors.push(error);
                  }
                }
                if (caughtErrors.length) {
                  console.error(`Draggable caught errors while triggering '${event.type}'`, caughtErrors);
                }
                return this;
              }
            }
            exports2.default = Emitter;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _Emitter = __webpack_require__(35);
            var _Emitter2 = _interopRequireDefault(_Emitter);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _Emitter2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.defaultOptions = void 0;
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _utils = __webpack_require__(2);
            var _Plugins = __webpack_require__(12);
            var _Emitter = __webpack_require__(36);
            var _Emitter2 = _interopRequireDefault(_Emitter);
            var _Sensors = __webpack_require__(6);
            var _DraggableEvent = __webpack_require__(13);
            var _DragEvent = __webpack_require__(14);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onDragStart = Symbol("onDragStart");
            const onDragMove = Symbol("onDragMove");
            const onDragStop = Symbol("onDragStop");
            const onDragPressure = Symbol("onDragPressure");
            const defaultAnnouncements = {
              "drag:start": (event) => `Picked up ${event.source.textContent.trim() || event.source.id || "draggable element"}`,
              "drag:stop": (event) => `Released ${event.source.textContent.trim() || event.source.id || "draggable element"}`
            };
            const defaultClasses = {
              "container:dragging": "draggable-container--is-dragging",
              "source:dragging": "draggable-source--is-dragging",
              "source:placed": "draggable-source--placed",
              "container:placed": "draggable-container--placed",
              "body:dragging": "draggable--is-dragging",
              "draggable:over": "draggable--over",
              "container:over": "draggable-container--over",
              "source:original": "draggable--original",
              mirror: "draggable-mirror"
            };
            const defaultOptions = exports2.defaultOptions = {
              draggable: ".draggable-source",
              handle: null,
              delay: 100,
              placedTimeout: 800,
              plugins: [],
              sensors: []
            };
            class Draggable {
              constructor(containers = [document.body], options = {}) {
                if (containers instanceof NodeList || containers instanceof Array) {
                  this.containers = [...containers];
                } else if (containers instanceof HTMLElement) {
                  this.containers = [containers];
                } else {
                  throw new Error("Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`");
                }
                this.options = _extends({}, defaultOptions, options, {
                  classes: _extends({}, defaultClasses, options.classes || {}),
                  announcements: _extends({}, defaultAnnouncements, options.announcements || {})
                });
                this.emitter = new _Emitter2.default();
                this.dragging = false;
                this.plugins = [];
                this.sensors = [];
                this[onDragStart] = this[onDragStart].bind(this);
                this[onDragMove] = this[onDragMove].bind(this);
                this[onDragStop] = this[onDragStop].bind(this);
                this[onDragPressure] = this[onDragPressure].bind(this);
                document.addEventListener("drag:start", this[onDragStart], true);
                document.addEventListener("drag:move", this[onDragMove], true);
                document.addEventListener("drag:stop", this[onDragStop], true);
                document.addEventListener("drag:pressure", this[onDragPressure], true);
                const defaultPlugins = Object.values(Draggable.Plugins).map((Plugin) => Plugin);
                const defaultSensors = [_Sensors.MouseSensor, _Sensors.TouchSensor];
                this.addPlugin(...[...defaultPlugins, ...this.options.plugins]);
                this.addSensor(...[...defaultSensors, ...this.options.sensors]);
                const draggableInitializedEvent = new _DraggableEvent.DraggableInitializedEvent({
                  draggable: this
                });
                this.on("mirror:created", ({ mirror }) => this.mirror = mirror);
                this.on("mirror:destroy", () => this.mirror = null);
                this.trigger(draggableInitializedEvent);
              }
              destroy() {
                document.removeEventListener("drag:start", this[onDragStart], true);
                document.removeEventListener("drag:move", this[onDragMove], true);
                document.removeEventListener("drag:stop", this[onDragStop], true);
                document.removeEventListener("drag:pressure", this[onDragPressure], true);
                const draggableDestroyEvent = new _DraggableEvent.DraggableDestroyEvent({
                  draggable: this
                });
                this.trigger(draggableDestroyEvent);
                this.removePlugin(...this.plugins.map((plugin) => plugin.constructor));
                this.removeSensor(...this.sensors.map((sensor) => sensor.constructor));
              }
              addPlugin(...plugins) {
                const activePlugins = plugins.map((Plugin) => new Plugin(this));
                activePlugins.forEach((plugin) => plugin.attach());
                this.plugins = [...this.plugins, ...activePlugins];
                return this;
              }
              removePlugin(...plugins) {
                const removedPlugins = this.plugins.filter((plugin) => plugins.includes(plugin.constructor));
                removedPlugins.forEach((plugin) => plugin.detach());
                this.plugins = this.plugins.filter((plugin) => !plugins.includes(plugin.constructor));
                return this;
              }
              addSensor(...sensors) {
                const activeSensors = sensors.map((Sensor) => new Sensor(this.containers, this.options));
                activeSensors.forEach((sensor) => sensor.attach());
                this.sensors = [...this.sensors, ...activeSensors];
                return this;
              }
              removeSensor(...sensors) {
                const removedSensors = this.sensors.filter((sensor) => sensors.includes(sensor.constructor));
                removedSensors.forEach((sensor) => sensor.detach());
                this.sensors = this.sensors.filter((sensor) => !sensors.includes(sensor.constructor));
                return this;
              }
              addContainer(...containers) {
                this.containers = [...this.containers, ...containers];
                this.sensors.forEach((sensor) => sensor.addContainer(...containers));
                return this;
              }
              removeContainer(...containers) {
                this.containers = this.containers.filter((container) => !containers.includes(container));
                this.sensors.forEach((sensor) => sensor.removeContainer(...containers));
                return this;
              }
              on(type, ...callbacks) {
                this.emitter.on(type, ...callbacks);
                return this;
              }
              off(type, callback) {
                this.emitter.off(type, callback);
                return this;
              }
              trigger(event) {
                this.emitter.trigger(event);
                return this;
              }
              getClassNameFor(name) {
                return this.options.classes[name];
              }
              isDragging() {
                return Boolean(this.dragging);
              }
              getDraggableElements() {
                return this.containers.reduce((current, container) => {
                  return [...current, ...this.getDraggableElementsForContainer(container)];
                }, []);
              }
              getDraggableElementsForContainer(container) {
                const allDraggableElements = container.querySelectorAll(this.options.draggable);
                return [...allDraggableElements].filter((childElement) => {
                  return childElement !== this.originalSource && childElement !== this.mirror;
                });
              }
              [onDragStart](event) {
                const sensorEvent = getSensorEvent(event);
                const { target, container } = sensorEvent;
                if (!this.containers.includes(container)) {
                  return;
                }
                if (this.options.handle && target && !(0, _utils.closest)(target, this.options.handle)) {
                  sensorEvent.cancel();
                  return;
                }
                this.originalSource = (0, _utils.closest)(target, this.options.draggable);
                this.sourceContainer = container;
                if (!this.originalSource) {
                  sensorEvent.cancel();
                  return;
                }
                if (this.lastPlacedSource && this.lastPlacedContainer) {
                  clearTimeout(this.placedTimeoutID);
                  this.lastPlacedSource.classList.remove(this.getClassNameFor("source:placed"));
                  this.lastPlacedContainer.classList.remove(this.getClassNameFor("container:placed"));
                }
                this.source = this.originalSource.cloneNode(true);
                this.originalSource.parentNode.insertBefore(this.source, this.originalSource);
                this.originalSource.style.display = "none";
                const dragEvent = new _DragEvent.DragStartEvent({
                  source: this.source,
                  originalSource: this.originalSource,
                  sourceContainer: container,
                  sensorEvent
                });
                this.trigger(dragEvent);
                this.dragging = !dragEvent.canceled();
                if (dragEvent.canceled()) {
                  this.source.parentNode.removeChild(this.source);
                  this.originalSource.style.display = null;
                  return;
                }
                this.originalSource.classList.add(this.getClassNameFor("source:original"));
                this.source.classList.add(this.getClassNameFor("source:dragging"));
                this.sourceContainer.classList.add(this.getClassNameFor("container:dragging"));
                document.body.classList.add(this.getClassNameFor("body:dragging"));
                applyUserSelect(document.body, "none");
                requestAnimationFrame(() => {
                  const oldSensorEvent = getSensorEvent(event);
                  const newSensorEvent = oldSensorEvent.clone({ target: this.source });
                  this[onDragMove](_extends({}, event, {
                    detail: newSensorEvent
                  }));
                });
              }
              [onDragMove](event) {
                if (!this.dragging) {
                  return;
                }
                const sensorEvent = getSensorEvent(event);
                const { container } = sensorEvent;
                let target = sensorEvent.target;
                const dragMoveEvent = new _DragEvent.DragMoveEvent({
                  source: this.source,
                  originalSource: this.originalSource,
                  sourceContainer: container,
                  sensorEvent
                });
                this.trigger(dragMoveEvent);
                if (dragMoveEvent.canceled()) {
                  sensorEvent.cancel();
                }
                target = (0, _utils.closest)(target, this.options.draggable);
                const withinCorrectContainer = (0, _utils.closest)(sensorEvent.target, this.containers);
                const overContainer = sensorEvent.overContainer || withinCorrectContainer;
                const isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;
                const isLeavingDraggable = this.currentOver && target !== this.currentOver;
                const isOverContainer = overContainer && this.currentOverContainer !== overContainer;
                const isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;
                if (isLeavingDraggable) {
                  const dragOutEvent = new _DragEvent.DragOutEvent({
                    source: this.source,
                    originalSource: this.originalSource,
                    sourceContainer: container,
                    sensorEvent,
                    over: this.currentOver
                  });
                  this.currentOver.classList.remove(this.getClassNameFor("draggable:over"));
                  this.currentOver = null;
                  this.trigger(dragOutEvent);
                }
                if (isLeavingContainer) {
                  const dragOutContainerEvent = new _DragEvent.DragOutContainerEvent({
                    source: this.source,
                    originalSource: this.originalSource,
                    sourceContainer: container,
                    sensorEvent,
                    overContainer: this.currentOverContainer
                  });
                  this.currentOverContainer.classList.remove(this.getClassNameFor("container:over"));
                  this.currentOverContainer = null;
                  this.trigger(dragOutContainerEvent);
                }
                if (isOverContainer) {
                  overContainer.classList.add(this.getClassNameFor("container:over"));
                  const dragOverContainerEvent = new _DragEvent.DragOverContainerEvent({
                    source: this.source,
                    originalSource: this.originalSource,
                    sourceContainer: container,
                    sensorEvent,
                    overContainer
                  });
                  this.currentOverContainer = overContainer;
                  this.trigger(dragOverContainerEvent);
                }
                if (isOverDraggable) {
                  target.classList.add(this.getClassNameFor("draggable:over"));
                  const dragOverEvent = new _DragEvent.DragOverEvent({
                    source: this.source,
                    originalSource: this.originalSource,
                    sourceContainer: container,
                    sensorEvent,
                    overContainer,
                    over: target
                  });
                  this.currentOver = target;
                  this.trigger(dragOverEvent);
                }
              }
              [onDragStop](event) {
                if (!this.dragging) {
                  return;
                }
                this.dragging = false;
                const dragStopEvent = new _DragEvent.DragStopEvent({
                  source: this.source,
                  originalSource: this.originalSource,
                  sensorEvent: event.sensorEvent,
                  sourceContainer: this.sourceContainer
                });
                this.trigger(dragStopEvent);
                this.source.parentNode.insertBefore(this.originalSource, this.source);
                this.source.parentNode.removeChild(this.source);
                this.originalSource.style.display = "";
                this.source.classList.remove(this.getClassNameFor("source:dragging"));
                this.originalSource.classList.remove(this.getClassNameFor("source:original"));
                this.originalSource.classList.add(this.getClassNameFor("source:placed"));
                this.sourceContainer.classList.add(this.getClassNameFor("container:placed"));
                this.sourceContainer.classList.remove(this.getClassNameFor("container:dragging"));
                document.body.classList.remove(this.getClassNameFor("body:dragging"));
                applyUserSelect(document.body, "");
                if (this.currentOver) {
                  this.currentOver.classList.remove(this.getClassNameFor("draggable:over"));
                }
                if (this.currentOverContainer) {
                  this.currentOverContainer.classList.remove(this.getClassNameFor("container:over"));
                }
                this.lastPlacedSource = this.originalSource;
                this.lastPlacedContainer = this.sourceContainer;
                this.placedTimeoutID = setTimeout(() => {
                  if (this.lastPlacedSource) {
                    this.lastPlacedSource.classList.remove(this.getClassNameFor("source:placed"));
                  }
                  if (this.lastPlacedContainer) {
                    this.lastPlacedContainer.classList.remove(this.getClassNameFor("container:placed"));
                  }
                  this.lastPlacedSource = null;
                  this.lastPlacedContainer = null;
                }, this.options.placedTimeout);
                this.source = null;
                this.originalSource = null;
                this.currentOverContainer = null;
                this.currentOver = null;
                this.sourceContainer = null;
              }
              [onDragPressure](event) {
                if (!this.dragging) {
                  return;
                }
                const sensorEvent = getSensorEvent(event);
                const source = this.source || (0, _utils.closest)(sensorEvent.originalEvent.target, this.options.draggable);
                const dragPressureEvent = new _DragEvent.DragPressureEvent({
                  sensorEvent,
                  source,
                  pressure: sensorEvent.pressure
                });
                this.trigger(dragPressureEvent);
              }
            }
            exports2.default = Draggable;
            Draggable.Plugins = { Announcement: _Plugins.Announcement, Focusable: _Plugins.Focusable, Mirror: _Plugins.Mirror, Scrollable: _Plugins.Scrollable };
            function getSensorEvent(event) {
              return event.detail;
            }
            function applyUserSelect(element, value) {
              element.style.webkitUserSelect = value;
              element.style.mozUserSelect = value;
              element.style.msUserSelect = value;
              element.style.oUserSelect = value;
              element.style.userSelect = value;
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _Sensor = __webpack_require__(4);
            var _Sensor2 = _interopRequireDefault(_Sensor);
            var _SensorEvent = __webpack_require__(3);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onMouseForceWillBegin = Symbol("onMouseForceWillBegin");
            const onMouseForceDown = Symbol("onMouseForceDown");
            const onMouseDown = Symbol("onMouseDown");
            const onMouseForceChange = Symbol("onMouseForceChange");
            const onMouseMove = Symbol("onMouseMove");
            const onMouseUp = Symbol("onMouseUp");
            const onMouseForceGlobalChange = Symbol("onMouseForceGlobalChange");
            class ForceTouchSensor extends _Sensor2.default {
              constructor(containers = [], options = {}) {
                super(containers, options);
                this.mightDrag = false;
                this[onMouseForceWillBegin] = this[onMouseForceWillBegin].bind(this);
                this[onMouseForceDown] = this[onMouseForceDown].bind(this);
                this[onMouseDown] = this[onMouseDown].bind(this);
                this[onMouseForceChange] = this[onMouseForceChange].bind(this);
                this[onMouseMove] = this[onMouseMove].bind(this);
                this[onMouseUp] = this[onMouseUp].bind(this);
              }
              attach() {
                for (const container of this.containers) {
                  container.addEventListener("webkitmouseforcewillbegin", this[onMouseForceWillBegin], false);
                  container.addEventListener("webkitmouseforcedown", this[onMouseForceDown], false);
                  container.addEventListener("mousedown", this[onMouseDown], true);
                  container.addEventListener("webkitmouseforcechanged", this[onMouseForceChange], false);
                }
                document.addEventListener("mousemove", this[onMouseMove]);
                document.addEventListener("mouseup", this[onMouseUp]);
              }
              detach() {
                for (const container of this.containers) {
                  container.removeEventListener("webkitmouseforcewillbegin", this[onMouseForceWillBegin], false);
                  container.removeEventListener("webkitmouseforcedown", this[onMouseForceDown], false);
                  container.removeEventListener("mousedown", this[onMouseDown], true);
                  container.removeEventListener("webkitmouseforcechanged", this[onMouseForceChange], false);
                }
                document.removeEventListener("mousemove", this[onMouseMove]);
                document.removeEventListener("mouseup", this[onMouseUp]);
              }
              [onMouseForceWillBegin](event) {
                event.preventDefault();
                this.mightDrag = true;
              }
              [onMouseForceDown](event) {
                if (this.dragging) {
                  return;
                }
                const target = document.elementFromPoint(event.clientX, event.clientY);
                const container = event.currentTarget;
                const dragStartEvent = new _SensorEvent.DragStartSensorEvent({
                  clientX: event.clientX,
                  clientY: event.clientY,
                  target,
                  container,
                  originalEvent: event
                });
                this.trigger(container, dragStartEvent);
                this.currentContainer = container;
                this.dragging = !dragStartEvent.canceled();
                this.mightDrag = false;
              }
              [onMouseUp](event) {
                if (!this.dragging) {
                  return;
                }
                const dragStopEvent = new _SensorEvent.DragStopSensorEvent({
                  clientX: event.clientX,
                  clientY: event.clientY,
                  target: null,
                  container: this.currentContainer,
                  originalEvent: event
                });
                this.trigger(this.currentContainer, dragStopEvent);
                this.currentContainer = null;
                this.dragging = false;
                this.mightDrag = false;
              }
              [onMouseDown](event) {
                if (!this.mightDrag) {
                  return;
                }
                event.stopPropagation();
                event.stopImmediatePropagation();
                event.preventDefault();
              }
              [onMouseMove](event) {
                if (!this.dragging) {
                  return;
                }
                const target = document.elementFromPoint(event.clientX, event.clientY);
                const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({
                  clientX: event.clientX,
                  clientY: event.clientY,
                  target,
                  container: this.currentContainer,
                  originalEvent: event
                });
                this.trigger(this.currentContainer, dragMoveEvent);
              }
              [onMouseForceChange](event) {
                if (this.dragging) {
                  return;
                }
                const target = event.target;
                const container = event.currentTarget;
                const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({
                  pressure: event.webkitForce,
                  clientX: event.clientX,
                  clientY: event.clientY,
                  target,
                  container,
                  originalEvent: event
                });
                this.trigger(container, dragPressureEvent);
              }
              [onMouseForceGlobalChange](event) {
                if (!this.dragging) {
                  return;
                }
                const target = event.target;
                const dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({
                  pressure: event.webkitForce,
                  clientX: event.clientX,
                  clientY: event.clientY,
                  target,
                  container: this.currentContainer,
                  originalEvent: event
                });
                this.trigger(this.currentContainer, dragPressureEvent);
              }
            }
            exports2.default = ForceTouchSensor;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _ForceTouchSensor = __webpack_require__(38);
            var _ForceTouchSensor2 = _interopRequireDefault(_ForceTouchSensor);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _ForceTouchSensor2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _utils = __webpack_require__(2);
            var _Sensor = __webpack_require__(4);
            var _Sensor2 = _interopRequireDefault(_Sensor);
            var _SensorEvent = __webpack_require__(3);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onMouseDown = Symbol("onMouseDown");
            const onMouseUp = Symbol("onMouseUp");
            const onDragStart = Symbol("onDragStart");
            const onDragOver = Symbol("onDragOver");
            const onDragEnd = Symbol("onDragEnd");
            const onDrop = Symbol("onDrop");
            const reset = Symbol("reset");
            class DragSensor extends _Sensor2.default {
              constructor(containers = [], options = {}) {
                super(containers, options);
                this.mouseDownTimeout = null;
                this.draggableElement = null;
                this.nativeDraggableElement = null;
                this[onMouseDown] = this[onMouseDown].bind(this);
                this[onMouseUp] = this[onMouseUp].bind(this);
                this[onDragStart] = this[onDragStart].bind(this);
                this[onDragOver] = this[onDragOver].bind(this);
                this[onDragEnd] = this[onDragEnd].bind(this);
                this[onDrop] = this[onDrop].bind(this);
              }
              attach() {
                document.addEventListener("mousedown", this[onMouseDown], true);
              }
              detach() {
                document.removeEventListener("mousedown", this[onMouseDown], true);
              }
              [onDragStart](event) {
                event.dataTransfer.setData("text", "");
                event.dataTransfer.effectAllowed = this.options.type;
                const target = document.elementFromPoint(event.clientX, event.clientY);
                this.currentContainer = (0, _utils.closest)(event.target, this.containers);
                if (!this.currentContainer) {
                  return;
                }
                const dragStartEvent = new _SensorEvent.DragStartSensorEvent({
                  clientX: event.clientX,
                  clientY: event.clientY,
                  target,
                  container: this.currentContainer,
                  originalEvent: event
                });
                setTimeout(() => {
                  this.trigger(this.currentContainer, dragStartEvent);
                  if (dragStartEvent.canceled()) {
                    this.dragging = false;
                  } else {
                    this.dragging = true;
                  }
                }, 0);
              }
              [onDragOver](event) {
                if (!this.dragging) {
                  return;
                }
                const target = document.elementFromPoint(event.clientX, event.clientY);
                const container = this.currentContainer;
                const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({
                  clientX: event.clientX,
                  clientY: event.clientY,
                  target,
                  container,
                  originalEvent: event
                });
                this.trigger(container, dragMoveEvent);
                if (!dragMoveEvent.canceled()) {
                  event.preventDefault();
                  event.dataTransfer.dropEffect = this.options.type;
                }
              }
              [onDragEnd](event) {
                if (!this.dragging) {
                  return;
                }
                document.removeEventListener("mouseup", this[onMouseUp], true);
                const target = document.elementFromPoint(event.clientX, event.clientY);
                const container = this.currentContainer;
                const dragStopEvent = new _SensorEvent.DragStopSensorEvent({
                  clientX: event.clientX,
                  clientY: event.clientY,
                  target,
                  container,
                  originalEvent: event
                });
                this.trigger(container, dragStopEvent);
                this.dragging = false;
                this[reset]();
              }
              [onDrop](event) {
                event.preventDefault();
              }
              [onMouseDown](event) {
                if (event.target && (event.target.form || event.target.contenteditable)) {
                  return;
                }
                const nativeDraggableElement = (0, _utils.closest)(event.target, (element) => element.draggable);
                if (nativeDraggableElement) {
                  nativeDraggableElement.draggable = false;
                  this.nativeDraggableElement = nativeDraggableElement;
                }
                document.addEventListener("mouseup", this[onMouseUp], true);
                document.addEventListener("dragstart", this[onDragStart], false);
                document.addEventListener("dragover", this[onDragOver], false);
                document.addEventListener("dragend", this[onDragEnd], false);
                document.addEventListener("drop", this[onDrop], false);
                const target = (0, _utils.closest)(event.target, this.options.draggable);
                if (!target) {
                  return;
                }
                this.mouseDownTimeout = setTimeout(() => {
                  target.draggable = true;
                  this.draggableElement = target;
                }, this.options.delay);
              }
              [onMouseUp]() {
                this[reset]();
              }
              [reset]() {
                clearTimeout(this.mouseDownTimeout);
                document.removeEventListener("mouseup", this[onMouseUp], true);
                document.removeEventListener("dragstart", this[onDragStart], false);
                document.removeEventListener("dragover", this[onDragOver], false);
                document.removeEventListener("dragend", this[onDragEnd], false);
                document.removeEventListener("drop", this[onDrop], false);
                if (this.nativeDraggableElement) {
                  this.nativeDraggableElement.draggable = true;
                  this.nativeDraggableElement = null;
                }
                if (this.draggableElement) {
                  this.draggableElement.draggable = false;
                  this.draggableElement = null;
                }
              }
            }
            exports2.default = DragSensor;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _DragSensor = __webpack_require__(40);
            var _DragSensor2 = _interopRequireDefault(_DragSensor);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _DragSensor2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _utils = __webpack_require__(2);
            var _Sensor = __webpack_require__(4);
            var _Sensor2 = _interopRequireDefault(_Sensor);
            var _SensorEvent = __webpack_require__(3);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onTouchStart = Symbol("onTouchStart");
            const onTouchHold = Symbol("onTouchHold");
            const onTouchEnd = Symbol("onTouchEnd");
            const onTouchMove = Symbol("onTouchMove");
            let preventScrolling = false;
            window.addEventListener("touchmove", (event) => {
              if (!preventScrolling) {
                return;
              }
              event.preventDefault();
            }, { passive: false });
            class TouchSensor extends _Sensor2.default {
              constructor(containers = [], options = {}) {
                super(containers, options);
                this.currentScrollableParent = null;
                this.tapTimeout = null;
                this.touchMoved = false;
                this[onTouchStart] = this[onTouchStart].bind(this);
                this[onTouchHold] = this[onTouchHold].bind(this);
                this[onTouchEnd] = this[onTouchEnd].bind(this);
                this[onTouchMove] = this[onTouchMove].bind(this);
              }
              attach() {
                document.addEventListener("touchstart", this[onTouchStart]);
              }
              detach() {
                document.removeEventListener("touchstart", this[onTouchStart]);
              }
              [onTouchStart](event) {
                const container = (0, _utils.closest)(event.target, this.containers);
                if (!container) {
                  return;
                }
                document.addEventListener("touchmove", this[onTouchMove]);
                document.addEventListener("touchend", this[onTouchEnd]);
                document.addEventListener("touchcancel", this[onTouchEnd]);
                container.addEventListener("contextmenu", onContextMenu);
                this.currentContainer = container;
                this.tapTimeout = setTimeout(this[onTouchHold](event, container), this.options.delay);
              }
              [onTouchHold](event, container) {
                return () => {
                  if (this.touchMoved) {
                    return;
                  }
                  const touch = event.touches[0] || event.changedTouches[0];
                  const target = event.target;
                  const dragStartEvent = new _SensorEvent.DragStartSensorEvent({
                    clientX: touch.pageX,
                    clientY: touch.pageY,
                    target,
                    container,
                    originalEvent: event
                  });
                  this.trigger(container, dragStartEvent);
                  this.dragging = !dragStartEvent.canceled();
                  preventScrolling = this.dragging;
                };
              }
              [onTouchMove](event) {
                this.touchMoved = true;
                if (!this.dragging) {
                  return;
                }
                const touch = event.touches[0] || event.changedTouches[0];
                const target = document.elementFromPoint(touch.pageX - window.scrollX, touch.pageY - window.scrollY);
                const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({
                  clientX: touch.pageX,
                  clientY: touch.pageY,
                  target,
                  container: this.currentContainer,
                  originalEvent: event
                });
                this.trigger(this.currentContainer, dragMoveEvent);
              }
              [onTouchEnd](event) {
                this.touchMoved = false;
                preventScrolling = false;
                document.removeEventListener("touchend", this[onTouchEnd]);
                document.removeEventListener("touchcancel", this[onTouchEnd]);
                document.removeEventListener("touchmove", this[onTouchMove]);
                if (this.currentContainer) {
                  this.currentContainer.removeEventListener("contextmenu", onContextMenu);
                }
                clearTimeout(this.tapTimeout);
                if (!this.dragging) {
                  return;
                }
                const touch = event.touches[0] || event.changedTouches[0];
                const target = document.elementFromPoint(touch.pageX - window.scrollX, touch.pageY - window.scrollY);
                event.preventDefault();
                const dragStopEvent = new _SensorEvent.DragStopSensorEvent({
                  clientX: touch.pageX,
                  clientY: touch.pageY,
                  target,
                  container: this.currentContainer,
                  originalEvent: event
                });
                this.trigger(this.currentContainer, dragStopEvent);
                this.currentContainer = null;
                this.dragging = false;
              }
            }
            exports2.default = TouchSensor;
            function onContextMenu(event) {
              event.preventDefault();
              event.stopPropagation();
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _TouchSensor = __webpack_require__(42);
            var _TouchSensor2 = _interopRequireDefault(_TouchSensor);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _TouchSensor2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.DragPressureSensorEvent = exports2.DragStopSensorEvent = exports2.DragMoveSensorEvent = exports2.DragStartSensorEvent = exports2.SensorEvent = void 0;
            var _AbstractEvent = __webpack_require__(0);
            var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            class SensorEvent extends _AbstractEvent2.default {
              get originalEvent() {
                return this.data.originalEvent;
              }
              get clientX() {
                return this.data.clientX;
              }
              get clientY() {
                return this.data.clientY;
              }
              get target() {
                return this.data.target;
              }
              get container() {
                return this.data.container;
              }
              get pressure() {
                return this.data.pressure;
              }
            }
            exports2.SensorEvent = SensorEvent;
            class DragStartSensorEvent extends SensorEvent {
            }
            exports2.DragStartSensorEvent = DragStartSensorEvent;
            DragStartSensorEvent.type = "drag:start";
            class DragMoveSensorEvent extends SensorEvent {
            }
            exports2.DragMoveSensorEvent = DragMoveSensorEvent;
            DragMoveSensorEvent.type = "drag:move";
            class DragStopSensorEvent extends SensorEvent {
            }
            exports2.DragStopSensorEvent = DragStopSensorEvent;
            DragStopSensorEvent.type = "drag:stop";
            class DragPressureSensorEvent extends SensorEvent {
            }
            exports2.DragPressureSensorEvent = DragPressureSensorEvent;
            DragPressureSensorEvent.type = "drag:pressure";
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _utils = __webpack_require__(2);
            var _Sensor = __webpack_require__(4);
            var _Sensor2 = _interopRequireDefault(_Sensor);
            var _SensorEvent = __webpack_require__(3);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onContextMenuWhileDragging = Symbol("onContextMenuWhileDragging");
            const onMouseDown = Symbol("onMouseDown");
            const onMouseMove = Symbol("onMouseMove");
            const onMouseUp = Symbol("onMouseUp");
            class MouseSensor extends _Sensor2.default {
              constructor(containers = [], options = {}) {
                super(containers, options);
                this.mouseDown = false;
                this.mouseDownTimeout = null;
                this.openedContextMenu = false;
                this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this);
                this[onMouseDown] = this[onMouseDown].bind(this);
                this[onMouseMove] = this[onMouseMove].bind(this);
                this[onMouseUp] = this[onMouseUp].bind(this);
              }
              attach() {
                document.addEventListener("mousedown", this[onMouseDown], true);
              }
              detach() {
                document.removeEventListener("mousedown", this[onMouseDown], true);
              }
              [onMouseDown](event) {
                if (event.button !== 0 || event.ctrlKey || event.metaKey) {
                  return;
                }
                document.addEventListener("mouseup", this[onMouseUp]);
                const target = document.elementFromPoint(event.clientX, event.clientY);
                const container = (0, _utils.closest)(target, this.containers);
                if (!container) {
                  return;
                }
                document.addEventListener("dragstart", preventNativeDragStart);
                this.mouseDown = true;
                clearTimeout(this.mouseDownTimeout);
                this.mouseDownTimeout = setTimeout(() => {
                  if (!this.mouseDown) {
                    return;
                  }
                  const dragStartEvent = new _SensorEvent.DragStartSensorEvent({
                    clientX: event.clientX,
                    clientY: event.clientY,
                    target,
                    container,
                    originalEvent: event
                  });
                  this.trigger(container, dragStartEvent);
                  this.currentContainer = container;
                  this.dragging = !dragStartEvent.canceled();
                  if (this.dragging) {
                    document.addEventListener("contextmenu", this[onContextMenuWhileDragging]);
                    document.addEventListener("mousemove", this[onMouseMove]);
                  }
                }, this.options.delay);
              }
              [onMouseMove](event) {
                if (!this.dragging) {
                  return;
                }
                const target = document.elementFromPoint(event.clientX, event.clientY);
                const dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({
                  clientX: event.clientX,
                  clientY: event.clientY,
                  target,
                  container: this.currentContainer,
                  originalEvent: event
                });
                this.trigger(this.currentContainer, dragMoveEvent);
              }
              [onMouseUp](event) {
                this.mouseDown = Boolean(this.openedContextMenu);
                if (this.openedContextMenu) {
                  this.openedContextMenu = false;
                  return;
                }
                document.removeEventListener("mouseup", this[onMouseUp]);
                document.removeEventListener("dragstart", preventNativeDragStart);
                if (!this.dragging) {
                  return;
                }
                const target = document.elementFromPoint(event.clientX, event.clientY);
                const dragStopEvent = new _SensorEvent.DragStopSensorEvent({
                  clientX: event.clientX,
                  clientY: event.clientY,
                  target,
                  container: this.currentContainer,
                  originalEvent: event
                });
                this.trigger(this.currentContainer, dragStopEvent);
                document.removeEventListener("contextmenu", this[onContextMenuWhileDragging]);
                document.removeEventListener("mousemove", this[onMouseMove]);
                this.currentContainer = null;
                this.dragging = false;
              }
              [onContextMenuWhileDragging](event) {
                event.preventDefault();
                this.openedContextMenu = true;
              }
            }
            exports2.default = MouseSensor;
            function preventNativeDragStart(event) {
              event.preventDefault();
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _MouseSensor = __webpack_require__(45);
            var _MouseSensor2 = _interopRequireDefault(_MouseSensor);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _MouseSensor2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            class Sensor {
              constructor(containers = [], options = {}) {
                this.containers = [...containers];
                this.options = _extends({}, options);
                this.dragging = false;
                this.currentContainer = null;
              }
              attach() {
                return this;
              }
              detach() {
                return this;
              }
              addContainer(...containers) {
                this.containers = [...this.containers, ...containers];
              }
              removeContainer(...containers) {
                this.containers = this.containers.filter((container) => !containers.includes(container));
              }
              trigger(element, sensorEvent) {
                const event = document.createEvent("Event");
                event.detail = sensorEvent;
                event.initEvent(sensorEvent.type, true, true);
                element.dispatchEvent(event);
                this.lastEvent = sensorEvent;
                return sensorEvent;
              }
            }
            exports2.default = Sensor;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.default = requestNextAnimationFrame;
            function requestNextAnimationFrame(callback) {
              return requestAnimationFrame(() => {
                requestAnimationFrame(callback);
              });
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _requestNextAnimationFrame = __webpack_require__(48);
            var _requestNextAnimationFrame2 = _interopRequireDefault(_requestNextAnimationFrame);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _requestNextAnimationFrame2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.default = closest;
            const matchFunction = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector;
            function closest(element, value) {
              if (!element) {
                return null;
              }
              const selector = value;
              const callback = value;
              const nodeList = value;
              const singleElement = value;
              const isSelector = Boolean(typeof value === "string");
              const isFunction = Boolean(typeof value === "function");
              const isNodeList = Boolean(value instanceof NodeList || value instanceof Array);
              const isElement = Boolean(value instanceof HTMLElement);
              function conditionFn(currentElement) {
                if (!currentElement) {
                  return currentElement;
                } else if (isSelector) {
                  return matchFunction.call(currentElement, selector);
                } else if (isNodeList) {
                  return [...nodeList].includes(currentElement);
                } else if (isElement) {
                  return singleElement === currentElement;
                } else if (isFunction) {
                  return callback(currentElement);
                } else {
                  return null;
                }
              }
              let current = element;
              do {
                current = current.correspondingUseElement || current.correspondingElement || current;
                if (conditionFn(current)) {
                  return current;
                }
                current = current.parentNode;
              } while (current && current !== document.body && current !== document);
              return null;
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _closest = __webpack_require__(50);
            var _closest2 = _interopRequireDefault(_closest);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _closest2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.defaultOptions = exports2.scroll = exports2.onDragStop = exports2.onDragMove = exports2.onDragStart = void 0;
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _AbstractPlugin = __webpack_require__(1);
            var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
            var _utils = __webpack_require__(2);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onDragStart = exports2.onDragStart = Symbol("onDragStart");
            const onDragMove = exports2.onDragMove = Symbol("onDragMove");
            const onDragStop = exports2.onDragStop = Symbol("onDragStop");
            const scroll = exports2.scroll = Symbol("scroll");
            const defaultOptions = exports2.defaultOptions = {
              speed: 6,
              sensitivity: 50,
              scrollableElements: []
            };
            class Scrollable extends _AbstractPlugin2.default {
              constructor(draggable) {
                super(draggable);
                this.options = _extends({}, defaultOptions, this.getOptions());
                this.currentMousePosition = null;
                this.scrollAnimationFrame = null;
                this.scrollableElement = null;
                this.findScrollableElementFrame = null;
                this[onDragStart] = this[onDragStart].bind(this);
                this[onDragMove] = this[onDragMove].bind(this);
                this[onDragStop] = this[onDragStop].bind(this);
                this[scroll] = this[scroll].bind(this);
              }
              attach() {
                this.draggable.on("drag:start", this[onDragStart]).on("drag:move", this[onDragMove]).on("drag:stop", this[onDragStop]);
              }
              detach() {
                this.draggable.off("drag:start", this[onDragStart]).off("drag:move", this[onDragMove]).off("drag:stop", this[onDragStop]);
              }
              getOptions() {
                return this.draggable.options.scrollable || {};
              }
              getScrollableElement(target) {
                if (this.hasDefinedScrollableElements()) {
                  return (0, _utils.closest)(target, this.options.scrollableElements) || document.documentElement;
                } else {
                  return closestScrollableElement(target);
                }
              }
              hasDefinedScrollableElements() {
                return Boolean(this.options.scrollableElements.length !== 0);
              }
              [onDragStart](dragEvent) {
                this.findScrollableElementFrame = requestAnimationFrame(() => {
                  this.scrollableElement = this.getScrollableElement(dragEvent.source);
                });
              }
              [onDragMove](dragEvent) {
                this.findScrollableElementFrame = requestAnimationFrame(() => {
                  this.scrollableElement = this.getScrollableElement(dragEvent.sensorEvent.target);
                });
                if (!this.scrollableElement) {
                  return;
                }
                const sensorEvent = dragEvent.sensorEvent;
                const scrollOffset = { x: 0, y: 0 };
                if ("ontouchstart" in window) {
                  scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
                  scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
                }
                this.currentMousePosition = {
                  clientX: sensorEvent.clientX - scrollOffset.x,
                  clientY: sensorEvent.clientY - scrollOffset.y
                };
                this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
              }
              [onDragStop]() {
                cancelAnimationFrame(this.scrollAnimationFrame);
                cancelAnimationFrame(this.findScrollableElementFrame);
                this.scrollableElement = null;
                this.scrollAnimationFrame = null;
                this.findScrollableElementFrame = null;
                this.currentMousePosition = null;
              }
              [scroll]() {
                if (!this.scrollableElement || !this.currentMousePosition) {
                  return;
                }
                cancelAnimationFrame(this.scrollAnimationFrame);
                const { speed, sensitivity } = this.options;
                const rect = this.scrollableElement.getBoundingClientRect();
                const bottomCutOff = rect.bottom > window.innerHeight;
                const topCutOff = rect.top < 0;
                const cutOff = topCutOff || bottomCutOff;
                const documentScrollingElement = getDocumentScrollingElement();
                const scrollableElement = this.scrollableElement;
                const clientX = this.currentMousePosition.clientX;
                const clientY = this.currentMousePosition.clientY;
                if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {
                  const { offsetHeight, offsetWidth } = scrollableElement;
                  if (rect.top + offsetHeight - clientY < sensitivity) {
                    scrollableElement.scrollTop += speed;
                  } else if (clientY - rect.top < sensitivity) {
                    scrollableElement.scrollTop -= speed;
                  }
                  if (rect.left + offsetWidth - clientX < sensitivity) {
                    scrollableElement.scrollLeft += speed;
                  } else if (clientX - rect.left < sensitivity) {
                    scrollableElement.scrollLeft -= speed;
                  }
                } else {
                  const { innerHeight, innerWidth } = window;
                  if (clientY < sensitivity) {
                    documentScrollingElement.scrollTop -= speed;
                  } else if (innerHeight - clientY < sensitivity) {
                    documentScrollingElement.scrollTop += speed;
                  }
                  if (clientX < sensitivity) {
                    documentScrollingElement.scrollLeft -= speed;
                  } else if (innerWidth - clientX < sensitivity) {
                    documentScrollingElement.scrollLeft += speed;
                  }
                }
                this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
              }
            }
            exports2.default = Scrollable;
            function hasOverflow(element) {
              const overflowRegex = /(auto|scroll)/;
              const computedStyles = getComputedStyle(element, null);
              const overflow = computedStyles.getPropertyValue("overflow") + computedStyles.getPropertyValue("overflow-y") + computedStyles.getPropertyValue("overflow-x");
              return overflowRegex.test(overflow);
            }
            function isStaticallyPositioned(element) {
              const position = getComputedStyle(element).getPropertyValue("position");
              return position === "static";
            }
            function closestScrollableElement(element) {
              if (!element) {
                return getDocumentScrollingElement();
              }
              const position = getComputedStyle(element).getPropertyValue("position");
              const excludeStaticParents = position === "absolute";
              const scrollableElement = (0, _utils.closest)(element, (parent) => {
                if (excludeStaticParents && isStaticallyPositioned(parent)) {
                  return false;
                }
                return hasOverflow(parent);
              });
              if (position === "fixed" || !scrollableElement) {
                return getDocumentScrollingElement();
              } else {
                return scrollableElement;
              }
            }
            function getDocumentScrollingElement() {
              return document.scrollingElement || document.documentElement;
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.defaultOptions = void 0;
            var _Scrollable = __webpack_require__(52);
            var _Scrollable2 = _interopRequireDefault(_Scrollable);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _Scrollable2.default;
            exports2.defaultOptions = _Scrollable.defaultOptions;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.MirrorDestroyEvent = exports2.MirrorMoveEvent = exports2.MirrorAttachedEvent = exports2.MirrorCreatedEvent = exports2.MirrorCreateEvent = exports2.MirrorEvent = void 0;
            var _AbstractEvent = __webpack_require__(0);
            var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            class MirrorEvent extends _AbstractEvent2.default {
              get source() {
                return this.data.source;
              }
              get originalSource() {
                return this.data.originalSource;
              }
              get sourceContainer() {
                return this.data.sourceContainer;
              }
              get sensorEvent() {
                return this.data.sensorEvent;
              }
              get dragEvent() {
                return this.data.dragEvent;
              }
              get originalEvent() {
                if (this.sensorEvent) {
                  return this.sensorEvent.originalEvent;
                }
                return null;
              }
            }
            exports2.MirrorEvent = MirrorEvent;
            class MirrorCreateEvent extends MirrorEvent {
            }
            exports2.MirrorCreateEvent = MirrorCreateEvent;
            MirrorCreateEvent.type = "mirror:create";
            class MirrorCreatedEvent extends MirrorEvent {
              get mirror() {
                return this.data.mirror;
              }
            }
            exports2.MirrorCreatedEvent = MirrorCreatedEvent;
            MirrorCreatedEvent.type = "mirror:created";
            class MirrorAttachedEvent extends MirrorEvent {
              get mirror() {
                return this.data.mirror;
              }
            }
            exports2.MirrorAttachedEvent = MirrorAttachedEvent;
            MirrorAttachedEvent.type = "mirror:attached";
            class MirrorMoveEvent extends MirrorEvent {
              get mirror() {
                return this.data.mirror;
              }
            }
            exports2.MirrorMoveEvent = MirrorMoveEvent;
            MirrorMoveEvent.type = "mirror:move";
            MirrorMoveEvent.cancelable = true;
            class MirrorDestroyEvent extends MirrorEvent {
              get mirror() {
                return this.data.mirror;
              }
            }
            exports2.MirrorDestroyEvent = MirrorDestroyEvent;
            MirrorDestroyEvent.type = "mirror:destroy";
            MirrorDestroyEvent.cancelable = true;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _MirrorEvent = __webpack_require__(54);
            Object.keys(_MirrorEvent).forEach(function(key) {
              if (key === "default" || key === "__esModule")
                return;
              Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function() {
                  return _MirrorEvent[key];
                }
              });
            });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.defaultOptions = exports2.getAppendableContainer = exports2.onScroll = exports2.onMirrorMove = exports2.onMirrorCreated = exports2.onDragStop = exports2.onDragMove = exports2.onDragStart = void 0;
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _AbstractPlugin = __webpack_require__(1);
            var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
            var _MirrorEvent = __webpack_require__(55);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _objectWithoutProperties(obj, keys) {
              var target = {};
              for (var i in obj) {
                if (keys.indexOf(i) >= 0)
                  continue;
                if (!Object.prototype.hasOwnProperty.call(obj, i))
                  continue;
                target[i] = obj[i];
              }
              return target;
            }
            const onDragStart = exports2.onDragStart = Symbol("onDragStart");
            const onDragMove = exports2.onDragMove = Symbol("onDragMove");
            const onDragStop = exports2.onDragStop = Symbol("onDragStop");
            const onMirrorCreated = exports2.onMirrorCreated = Symbol("onMirrorCreated");
            const onMirrorMove = exports2.onMirrorMove = Symbol("onMirrorMove");
            const onScroll = exports2.onScroll = Symbol("onScroll");
            const getAppendableContainer = exports2.getAppendableContainer = Symbol("getAppendableContainer");
            const defaultOptions = exports2.defaultOptions = {
              constrainDimensions: false,
              xAxis: true,
              yAxis: true,
              cursorOffsetX: null,
              cursorOffsetY: null
            };
            class Mirror extends _AbstractPlugin2.default {
              constructor(draggable) {
                super(draggable);
                this.options = _extends({}, defaultOptions, this.getOptions());
                this.scrollOffset = { x: 0, y: 0 };
                this.initialScrollOffset = {
                  x: window.scrollX,
                  y: window.scrollY
                };
                this[onDragStart] = this[onDragStart].bind(this);
                this[onDragMove] = this[onDragMove].bind(this);
                this[onDragStop] = this[onDragStop].bind(this);
                this[onMirrorCreated] = this[onMirrorCreated].bind(this);
                this[onMirrorMove] = this[onMirrorMove].bind(this);
                this[onScroll] = this[onScroll].bind(this);
              }
              attach() {
                this.draggable.on("drag:start", this[onDragStart]).on("drag:move", this[onDragMove]).on("drag:stop", this[onDragStop]).on("mirror:created", this[onMirrorCreated]).on("mirror:move", this[onMirrorMove]);
              }
              detach() {
                this.draggable.off("drag:start", this[onDragStart]).off("drag:move", this[onDragMove]).off("drag:stop", this[onDragStop]).off("mirror:created", this[onMirrorCreated]).off("mirror:move", this[onMirrorMove]);
              }
              getOptions() {
                return this.draggable.options.mirror || {};
              }
              [onDragStart](dragEvent) {
                if (dragEvent.canceled()) {
                  return;
                }
                if ("ontouchstart" in window) {
                  document.addEventListener("scroll", this[onScroll], true);
                }
                this.initialScrollOffset = {
                  x: window.scrollX,
                  y: window.scrollY
                };
                const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;
                const mirrorCreateEvent = new _MirrorEvent.MirrorCreateEvent({
                  source,
                  originalSource,
                  sourceContainer,
                  sensorEvent,
                  dragEvent
                });
                this.draggable.trigger(mirrorCreateEvent);
                if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {
                  return;
                }
                const appendableContainer = this[getAppendableContainer](source) || sourceContainer;
                this.mirror = source.cloneNode(true);
                const mirrorCreatedEvent = new _MirrorEvent.MirrorCreatedEvent({
                  source,
                  originalSource,
                  sourceContainer,
                  sensorEvent,
                  dragEvent,
                  mirror: this.mirror
                });
                const mirrorAttachedEvent = new _MirrorEvent.MirrorAttachedEvent({
                  source,
                  originalSource,
                  sourceContainer,
                  sensorEvent,
                  dragEvent,
                  mirror: this.mirror
                });
                this.draggable.trigger(mirrorCreatedEvent);
                appendableContainer.appendChild(this.mirror);
                this.draggable.trigger(mirrorAttachedEvent);
              }
              [onDragMove](dragEvent) {
                if (!this.mirror || dragEvent.canceled()) {
                  return;
                }
                const { source, originalSource, sourceContainer, sensorEvent } = dragEvent;
                const mirrorMoveEvent = new _MirrorEvent.MirrorMoveEvent({
                  source,
                  originalSource,
                  sourceContainer,
                  sensorEvent,
                  dragEvent,
                  mirror: this.mirror
                });
                this.draggable.trigger(mirrorMoveEvent);
              }
              [onDragStop](dragEvent) {
                if ("ontouchstart" in window) {
                  document.removeEventListener("scroll", this[onScroll], true);
                }
                this.initialScrollOffset = { x: 0, y: 0 };
                this.scrollOffset = { x: 0, y: 0 };
                if (!this.mirror) {
                  return;
                }
                const { source, sourceContainer, sensorEvent } = dragEvent;
                const mirrorDestroyEvent = new _MirrorEvent.MirrorDestroyEvent({
                  source,
                  mirror: this.mirror,
                  sourceContainer,
                  sensorEvent,
                  dragEvent
                });
                this.draggable.trigger(mirrorDestroyEvent);
                if (!mirrorDestroyEvent.canceled()) {
                  this.mirror.parentNode.removeChild(this.mirror);
                }
              }
              [onScroll]() {
                this.scrollOffset = {
                  x: window.scrollX - this.initialScrollOffset.x,
                  y: window.scrollY - this.initialScrollOffset.y
                };
              }
              [onMirrorCreated]({ mirror, source, sensorEvent }) {
                const mirrorClass = this.draggable.getClassNameFor("mirror");
                const setState = (_ref) => {
                  let { mirrorOffset, initialX, initialY } = _ref, args = _objectWithoutProperties(_ref, ["mirrorOffset", "initialX", "initialY"]);
                  this.mirrorOffset = mirrorOffset;
                  this.initialX = initialX;
                  this.initialY = initialY;
                  return _extends({ mirrorOffset, initialX, initialY }, args);
                };
                const initialState = {
                  mirror,
                  source,
                  sensorEvent,
                  mirrorClass,
                  scrollOffset: this.scrollOffset,
                  options: this.options
                };
                return Promise.resolve(initialState).then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({ initial: true })).then(removeMirrorID).then(setState);
              }
              [onMirrorMove](mirrorEvent) {
                if (mirrorEvent.canceled()) {
                  return null;
                }
                const initialState = {
                  mirror: mirrorEvent.mirror,
                  sensorEvent: mirrorEvent.sensorEvent,
                  mirrorOffset: this.mirrorOffset,
                  options: this.options,
                  initialX: this.initialX,
                  initialY: this.initialY,
                  scrollOffset: this.scrollOffset
                };
                return Promise.resolve(initialState).then(positionMirror({ raf: true }));
              }
              [getAppendableContainer](source) {
                const appendTo = this.options.appendTo;
                if (typeof appendTo === "string") {
                  return document.querySelector(appendTo);
                } else if (appendTo instanceof HTMLElement) {
                  return appendTo;
                } else if (typeof appendTo === "function") {
                  return appendTo(source);
                } else {
                  return source.parentNode;
                }
              }
            }
            exports2.default = Mirror;
            function computeMirrorDimensions(_ref2) {
              let { source } = _ref2, args = _objectWithoutProperties(_ref2, ["source"]);
              return withPromise((resolve) => {
                const sourceRect = source.getBoundingClientRect();
                resolve(_extends({ source, sourceRect }, args));
              });
            }
            function calculateMirrorOffset(_ref3) {
              let { sensorEvent, sourceRect, options } = _ref3, args = _objectWithoutProperties(_ref3, ["sensorEvent", "sourceRect", "options"]);
              return withPromise((resolve) => {
                const top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;
                const left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;
                const mirrorOffset = { top, left };
                resolve(_extends({ sensorEvent, sourceRect, mirrorOffset, options }, args));
              });
            }
            function resetMirror(_ref4) {
              let { mirror, source, options } = _ref4, args = _objectWithoutProperties(_ref4, ["mirror", "source", "options"]);
              return withPromise((resolve) => {
                let offsetHeight;
                let offsetWidth;
                if (options.constrainDimensions) {
                  const computedSourceStyles = getComputedStyle(source);
                  offsetHeight = computedSourceStyles.getPropertyValue("height");
                  offsetWidth = computedSourceStyles.getPropertyValue("width");
                }
                mirror.style.position = "fixed";
                mirror.style.pointerEvents = "none";
                mirror.style.top = 0;
                mirror.style.left = 0;
                mirror.style.margin = 0;
                if (options.constrainDimensions) {
                  mirror.style.height = offsetHeight;
                  mirror.style.width = offsetWidth;
                }
                resolve(_extends({ mirror, source, options }, args));
              });
            }
            function addMirrorClasses(_ref5) {
              let { mirror, mirrorClass } = _ref5, args = _objectWithoutProperties(_ref5, ["mirror", "mirrorClass"]);
              return withPromise((resolve) => {
                mirror.classList.add(mirrorClass);
                resolve(_extends({ mirror, mirrorClass }, args));
              });
            }
            function removeMirrorID(_ref6) {
              let { mirror } = _ref6, args = _objectWithoutProperties(_ref6, ["mirror"]);
              return withPromise((resolve) => {
                mirror.removeAttribute("id");
                delete mirror.id;
                resolve(_extends({ mirror }, args));
              });
            }
            function positionMirror({ withFrame = false, initial = false } = {}) {
              return (_ref7) => {
                let { mirror, sensorEvent, mirrorOffset, initialY, initialX, scrollOffset, options } = _ref7, args = _objectWithoutProperties(_ref7, ["mirror", "sensorEvent", "mirrorOffset", "initialY", "initialX", "scrollOffset", "options"]);
                return withPromise((resolve) => {
                  const result = _extends({
                    mirror,
                    sensorEvent,
                    mirrorOffset,
                    options
                  }, args);
                  if (mirrorOffset) {
                    const x = sensorEvent.clientX - mirrorOffset.left - scrollOffset.x;
                    const y = sensorEvent.clientY - mirrorOffset.top - scrollOffset.y;
                    if (options.xAxis && options.yAxis || initial) {
                      mirror.style.transform = `translate3d(${x}px, ${y}px, 0)`;
                    } else if (options.xAxis && !options.yAxis) {
                      mirror.style.transform = `translate3d(${x}px, ${initialY}px, 0)`;
                    } else if (options.yAxis && !options.xAxis) {
                      mirror.style.transform = `translate3d(${initialX}px, ${y}px, 0)`;
                    }
                    if (initial) {
                      result.initialX = x;
                      result.initialY = y;
                    }
                  }
                  resolve(result);
                }, { frame: withFrame });
              };
            }
            function withPromise(callback, { raf = false } = {}) {
              return new Promise((resolve, reject) => {
                if (raf) {
                  requestAnimationFrame(() => {
                    callback(resolve, reject);
                  });
                } else {
                  callback(resolve, reject);
                }
              });
            }
            function isNativeDragEvent(sensorEvent) {
              return /^drag/.test(sensorEvent.originalEvent.type);
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.defaultOptions = void 0;
            var _Mirror = __webpack_require__(56);
            var _Mirror2 = _interopRequireDefault(_Mirror);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _Mirror2.default;
            exports2.defaultOptions = _Mirror.defaultOptions;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _AbstractPlugin = __webpack_require__(1);
            var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onInitialize = Symbol("onInitialize");
            const onDestroy = Symbol("onDestroy");
            const defaultOptions = {};
            class Focusable extends _AbstractPlugin2.default {
              constructor(draggable) {
                super(draggable);
                this.options = _extends({}, defaultOptions, this.getOptions());
                this[onInitialize] = this[onInitialize].bind(this);
                this[onDestroy] = this[onDestroy].bind(this);
              }
              attach() {
                this.draggable.on("draggable:initialize", this[onInitialize]).on("draggable:destroy", this[onDestroy]);
              }
              detach() {
                this.draggable.off("draggable:initialize", this[onInitialize]).off("draggable:destroy", this[onDestroy]);
              }
              getOptions() {
                return this.draggable.options.focusable || {};
              }
              getElements() {
                return [...this.draggable.containers, ...this.draggable.getDraggableElements()];
              }
              [onInitialize]() {
                requestAnimationFrame(() => {
                  this.getElements().forEach((element) => decorateElement(element));
                });
              }
              [onDestroy]() {
                requestAnimationFrame(() => {
                  this.getElements().forEach((element) => stripElement(element));
                });
              }
            }
            exports2.default = Focusable;
            const elementsWithMissingTabIndex = [];
            function decorateElement(element) {
              const hasMissingTabIndex = Boolean(!element.getAttribute("tabindex") && element.tabIndex === -1);
              if (hasMissingTabIndex) {
                elementsWithMissingTabIndex.push(element);
                element.tabIndex = 0;
              }
            }
            function stripElement(element) {
              const tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);
              if (tabIndexElementPosition !== -1) {
                element.tabIndex = -1;
                elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);
              }
            }
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _Focusable = __webpack_require__(58);
            var _Focusable2 = _interopRequireDefault(_Focusable);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _Focusable2.default;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            class AbstractPlugin {
              constructor(draggable) {
                this.draggable = draggable;
              }
              attach() {
                throw new Error("Not Implemented");
              }
              detach() {
                throw new Error("Not Implemented");
              }
            }
            exports2.default = AbstractPlugin;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.defaultOptions = void 0;
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _AbstractPlugin = __webpack_require__(1);
            var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            const onInitialize = Symbol("onInitialize");
            const onDestroy = Symbol("onDestroy");
            const announceEvent = Symbol("announceEvent");
            const announceMessage = Symbol("announceMessage");
            const ARIA_RELEVANT = "aria-relevant";
            const ARIA_ATOMIC = "aria-atomic";
            const ARIA_LIVE = "aria-live";
            const ROLE = "role";
            const defaultOptions = exports2.defaultOptions = {
              expire: 7e3
            };
            class Announcement extends _AbstractPlugin2.default {
              constructor(draggable) {
                super(draggable);
                this.options = _extends({}, defaultOptions, this.getOptions());
                this.originalTriggerMethod = this.draggable.trigger;
                this[onInitialize] = this[onInitialize].bind(this);
                this[onDestroy] = this[onDestroy].bind(this);
              }
              attach() {
                this.draggable.on("draggable:initialize", this[onInitialize]);
              }
              detach() {
                this.draggable.off("draggable:destroy", this[onDestroy]);
              }
              getOptions() {
                return this.draggable.options.announcements || {};
              }
              [announceEvent](event) {
                const message = this.options[event.type];
                if (message && typeof message === "string") {
                  this[announceMessage](message);
                }
                if (message && typeof message === "function") {
                  this[announceMessage](message(event));
                }
              }
              [announceMessage](message) {
                announce(message, { expire: this.options.expire });
              }
              [onInitialize]() {
                this.draggable.trigger = (event) => {
                  try {
                    this[announceEvent](event);
                  } finally {
                    this.originalTriggerMethod.call(this.draggable, event);
                  }
                };
              }
              [onDestroy]() {
                this.draggable.trigger = this.originalTriggerMethod;
              }
            }
            exports2.default = Announcement;
            const liveRegion = createRegion();
            function announce(message, { expire }) {
              const element = document.createElement("div");
              element.textContent = message;
              liveRegion.appendChild(element);
              return setTimeout(() => {
                liveRegion.removeChild(element);
              }, expire);
            }
            function createRegion() {
              const element = document.createElement("div");
              element.setAttribute("id", "draggable-live-region");
              element.setAttribute(ARIA_RELEVANT, "additions");
              element.setAttribute(ARIA_ATOMIC, "true");
              element.setAttribute(ARIA_LIVE, "assertive");
              element.setAttribute(ROLE, "log");
              element.style.position = "fixed";
              element.style.width = "1px";
              element.style.height = "1px";
              element.style.top = "-1px";
              element.style.overflow = "hidden";
              return element;
            }
            document.addEventListener("DOMContentLoaded", () => {
              document.body.appendChild(liveRegion);
            });
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.defaultOptions = void 0;
            var _Announcement = __webpack_require__(61);
            var _Announcement2 = _interopRequireDefault(_Announcement);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = _Announcement2.default;
            exports2.defaultOptions = _Announcement.defaultOptions;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.DraggableDestroyEvent = exports2.DraggableInitializedEvent = exports2.DraggableEvent = void 0;
            var _AbstractEvent = __webpack_require__(0);
            var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            class DraggableEvent extends _AbstractEvent2.default {
              get draggable() {
                return this.data.draggable;
              }
            }
            exports2.DraggableEvent = DraggableEvent;
            DraggableEvent.type = "draggable";
            class DraggableInitializedEvent extends DraggableEvent {
            }
            exports2.DraggableInitializedEvent = DraggableInitializedEvent;
            DraggableInitializedEvent.type = "draggable:initialize";
            class DraggableDestroyEvent extends DraggableEvent {
            }
            exports2.DraggableDestroyEvent = DraggableDestroyEvent;
            DraggableDestroyEvent.type = "draggable:destroy";
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            const canceled = Symbol("canceled");
            class AbstractEvent {
              constructor(data) {
                this[canceled] = false;
                this.data = data;
              }
              get type() {
                return this.constructor.type;
              }
              get cancelable() {
                return this.constructor.cancelable;
              }
              cancel() {
                this[canceled] = true;
              }
              canceled() {
                return Boolean(this[canceled]);
              }
              clone(data) {
                return new this.constructor(_extends({}, this.data, data));
              }
            }
            exports2.default = AbstractEvent;
            AbstractEvent.type = "event";
            AbstractEvent.cancelable = false;
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.DragStopEvent = exports2.DragPressureEvent = exports2.DragOutContainerEvent = exports2.DragOverContainerEvent = exports2.DragOutEvent = exports2.DragOverEvent = exports2.DragMoveEvent = exports2.DragStartEvent = exports2.DragEvent = void 0;
            var _AbstractEvent = __webpack_require__(0);
            var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            class DragEvent extends _AbstractEvent2.default {
              get source() {
                return this.data.source;
              }
              get originalSource() {
                return this.data.originalSource;
              }
              get mirror() {
                return this.data.mirror;
              }
              get sourceContainer() {
                return this.data.sourceContainer;
              }
              get sensorEvent() {
                return this.data.sensorEvent;
              }
              get originalEvent() {
                if (this.sensorEvent) {
                  return this.sensorEvent.originalEvent;
                }
                return null;
              }
            }
            exports2.DragEvent = DragEvent;
            DragEvent.type = "drag";
            class DragStartEvent extends DragEvent {
            }
            exports2.DragStartEvent = DragStartEvent;
            DragStartEvent.type = "drag:start";
            DragStartEvent.cancelable = true;
            class DragMoveEvent extends DragEvent {
            }
            exports2.DragMoveEvent = DragMoveEvent;
            DragMoveEvent.type = "drag:move";
            class DragOverEvent extends DragEvent {
              get overContainer() {
                return this.data.overContainer;
              }
              get over() {
                return this.data.over;
              }
            }
            exports2.DragOverEvent = DragOverEvent;
            DragOverEvent.type = "drag:over";
            DragOverEvent.cancelable = true;
            class DragOutEvent extends DragEvent {
              get overContainer() {
                return this.data.overContainer;
              }
              get over() {
                return this.data.over;
              }
            }
            exports2.DragOutEvent = DragOutEvent;
            DragOutEvent.type = "drag:out";
            class DragOverContainerEvent extends DragEvent {
              get overContainer() {
                return this.data.overContainer;
              }
            }
            exports2.DragOverContainerEvent = DragOverContainerEvent;
            DragOverContainerEvent.type = "drag:over:container";
            class DragOutContainerEvent extends DragEvent {
              get overContainer() {
                return this.data.overContainer;
              }
            }
            exports2.DragOutContainerEvent = DragOutContainerEvent;
            DragOutContainerEvent.type = "drag:out:container";
            class DragPressureEvent extends DragEvent {
              get pressure() {
                return this.data.pressure;
              }
            }
            exports2.DragPressureEvent = DragPressureEvent;
            DragPressureEvent.type = "drag:pressure";
            class DragStopEvent extends DragEvent {
            }
            exports2.DragStopEvent = DragStopEvent;
            DragStopEvent.type = "drag:stop";
          },
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            exports2.Plugins = exports2.Sensors = exports2.Sortable = exports2.Swappable = exports2.Droppable = exports2.Draggable = exports2.BasePlugin = exports2.BaseEvent = void 0;
            var _Draggable = __webpack_require__(5);
            Object.defineProperty(exports2, "Draggable", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_Draggable).default;
              }
            });
            var _Droppable = __webpack_require__(34);
            Object.defineProperty(exports2, "Droppable", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_Droppable).default;
              }
            });
            var _Swappable = __webpack_require__(31);
            Object.defineProperty(exports2, "Swappable", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_Swappable).default;
              }
            });
            var _Sortable = __webpack_require__(28);
            Object.defineProperty(exports2, "Sortable", {
              enumerable: true,
              get: function() {
                return _interopRequireDefault(_Sortable).default;
              }
            });
            var _AbstractEvent = __webpack_require__(0);
            var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);
            var _AbstractPlugin = __webpack_require__(1);
            var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);
            var _Sensors = __webpack_require__(6);
            var Sensors = _interopRequireWildcard(_Sensors);
            var _Plugins = __webpack_require__(25);
            var Plugins2 = _interopRequireWildcard(_Plugins);
            function _interopRequireWildcard(obj) {
              if (obj && obj.__esModule) {
                return obj;
              } else {
                var newObj = {};
                if (obj != null) {
                  for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key))
                      newObj[key] = obj[key];
                  }
                }
                newObj.default = obj;
                return newObj;
              }
            }
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.BaseEvent = _AbstractEvent2.default;
            exports2.BasePlugin = _AbstractPlugin2.default;
            exports2.Sensors = Sensors;
            exports2.Plugins = Plugins2;
          }
        ]);
      });
    }
  });

  // vendor/topbar.js
  var require_topbar = __commonJS({
    "vendor/topbar.js"(exports, module) {
      (function(window2, document2) {
        "use strict";
        (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x) {
            window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"];
            window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
          }
          if (!window2.requestAnimationFrame)
            window2.requestAnimationFrame = function(callback, element) {
              var currTime = new Date().getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = window2.setTimeout(function() {
                callback(currTime + timeToCall);
              }, timeToCall);
              lastTime = currTime + timeToCall;
              return id;
            };
          if (!window2.cancelAnimationFrame)
            window2.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
        })();
        var canvas, progressTimerId, fadeTimerId, currentProgress, showing, addEvent = function(elem, type, handler) {
          if (elem.addEventListener)
            elem.addEventListener(type, handler, false);
          else if (elem.attachEvent)
            elem.attachEvent("on" + type, handler);
          else
            elem["on" + type] = handler;
        }, options = {
          autoRun: true,
          barThickness: 3,
          barColors: {
            0: "rgba(26,  188, 156, .9)",
            ".25": "rgba(52,  152, 219, .9)",
            ".50": "rgba(241, 196, 15,  .9)",
            ".75": "rgba(230, 126, 34,  .9)",
            "1.0": "rgba(211, 84,  0,   .9)"
          },
          shadowBlur: 10,
          shadowColor: "rgba(0,   0,   0,   .6)",
          className: null
        }, repaint = function() {
          canvas.width = window2.innerWidth;
          canvas.height = options.barThickness * 5;
          var ctx = canvas.getContext("2d");
          ctx.shadowBlur = options.shadowBlur;
          ctx.shadowColor = options.shadowColor;
          var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          for (var stop in options.barColors)
            lineGradient.addColorStop(stop, options.barColors[stop]);
          ctx.lineWidth = options.barThickness;
          ctx.beginPath();
          ctx.moveTo(0, options.barThickness / 2);
          ctx.lineTo(Math.ceil(currentProgress * canvas.width), options.barThickness / 2);
          ctx.strokeStyle = lineGradient;
          ctx.stroke();
        }, createCanvas = function() {
          canvas = document2.createElement("canvas");
          var style = canvas.style;
          style.position = "fixed";
          style.top = style.left = style.right = style.margin = style.padding = 0;
          style.zIndex = 100001;
          style.display = "none";
          if (options.className)
            canvas.classList.add(options.className);
          document2.body.appendChild(canvas);
          addEvent(window2, "resize", repaint);
        }, topbar2 = {
          config: function(opts) {
            for (var key in opts)
              if (options.hasOwnProperty(key))
                options[key] = opts[key];
          },
          show: function() {
            if (showing)
              return;
            showing = true;
            if (fadeTimerId !== null)
              window2.cancelAnimationFrame(fadeTimerId);
            if (!canvas)
              createCanvas();
            canvas.style.opacity = 1;
            canvas.style.display = "block";
            topbar2.progress(0);
            if (options.autoRun) {
              (function loop() {
                progressTimerId = window2.requestAnimationFrame(loop);
                topbar2.progress("+" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2));
              })();
            }
          },
          progress: function(to) {
            if (typeof to === "undefined")
              return currentProgress;
            if (typeof to === "string") {
              to = (to.indexOf("+") >= 0 || to.indexOf("-") >= 0 ? currentProgress : 0) + parseFloat(to);
            }
            currentProgress = to > 1 ? 1 : to;
            repaint();
            return currentProgress;
          },
          hide: function() {
            if (!showing)
              return;
            showing = false;
            if (progressTimerId != null) {
              window2.cancelAnimationFrame(progressTimerId);
              progressTimerId = null;
            }
            (function loop() {
              if (topbar2.progress("+.1") >= 1) {
                canvas.style.opacity -= 0.05;
                if (canvas.style.opacity <= 0.05) {
                  canvas.style.display = "none";
                  fadeTimerId = null;
                  return;
                }
              }
              fadeTimerId = window2.requestAnimationFrame(loop);
            })();
          }
        };
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = topbar2;
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return topbar2;
          });
        } else {
          this.topbar = topbar2;
        }
      }).call(exports, window, document);
    }
  });

  // node_modules/chart.js/dist/chart.js
  var require_chart = __commonJS({
    "node_modules/chart.js/dist/chart.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Chart = factory());
      })(exports, function() {
        "use strict";
        function fontString(pixelSize, fontStyle, fontFamily) {
          return fontStyle + " " + pixelSize + "px " + fontFamily;
        }
        const requestAnimFrame = function() {
          if (typeof window === "undefined") {
            return function(callback2) {
              return callback2();
            };
          }
          return window.requestAnimationFrame;
        }();
        function throttled(fn, thisArg, updateFn) {
          const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
          let ticking = false;
          let args = [];
          return function(...rest) {
            args = updateArgs(rest);
            if (!ticking) {
              ticking = true;
              requestAnimFrame.call(window, () => {
                ticking = false;
                fn.apply(thisArg, args);
              });
            }
          };
        }
        function debounce(fn, delay) {
          let timeout;
          return function(...args) {
            if (delay) {
              clearTimeout(timeout);
              timeout = setTimeout(fn, delay, args);
            } else {
              fn.apply(this, args);
            }
            return delay;
          };
        }
        const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
        const _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
        const _textX = (align, left, right, rtl) => {
          const check = rtl ? "left" : "right";
          return align === check ? right : align === "center" ? (left + right) / 2 : left;
        };
        class Animator {
          constructor() {
            this._request = null;
            this._charts = /* @__PURE__ */ new Map();
            this._running = false;
            this._lastDate = void 0;
          }
          _notify(chart2, anims, date, type) {
            const callbacks = anims.listeners[type];
            const numSteps = anims.duration;
            callbacks.forEach((fn) => fn({
              chart: chart2,
              initial: anims.initial,
              numSteps,
              currentStep: Math.min(date - anims.start, numSteps)
            }));
          }
          _refresh() {
            if (this._request) {
              return;
            }
            this._running = true;
            this._request = requestAnimFrame.call(window, () => {
              this._update();
              this._request = null;
              if (this._running) {
                this._refresh();
              }
            });
          }
          _update(date = Date.now()) {
            let remaining = 0;
            this._charts.forEach((anims, chart2) => {
              if (!anims.running || !anims.items.length) {
                return;
              }
              const items = anims.items;
              let i = items.length - 1;
              let draw2 = false;
              let item;
              for (; i >= 0; --i) {
                item = items[i];
                if (item._active) {
                  if (item._total > anims.duration) {
                    anims.duration = item._total;
                  }
                  item.tick(date);
                  draw2 = true;
                } else {
                  items[i] = items[items.length - 1];
                  items.pop();
                }
              }
              if (draw2) {
                chart2.draw();
                this._notify(chart2, anims, date, "progress");
              }
              if (!items.length) {
                anims.running = false;
                this._notify(chart2, anims, date, "complete");
                anims.initial = false;
              }
              remaining += items.length;
            });
            this._lastDate = date;
            if (remaining === 0) {
              this._running = false;
            }
          }
          _getAnims(chart2) {
            const charts = this._charts;
            let anims = charts.get(chart2);
            if (!anims) {
              anims = {
                running: false,
                initial: true,
                items: [],
                listeners: {
                  complete: [],
                  progress: []
                }
              };
              charts.set(chart2, anims);
            }
            return anims;
          }
          listen(chart2, event, cb) {
            this._getAnims(chart2).listeners[event].push(cb);
          }
          add(chart2, items) {
            if (!items || !items.length) {
              return;
            }
            this._getAnims(chart2).items.push(...items);
          }
          has(chart2) {
            return this._getAnims(chart2).items.length > 0;
          }
          start(chart2) {
            const anims = this._charts.get(chart2);
            if (!anims) {
              return;
            }
            anims.running = true;
            anims.start = Date.now();
            anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
            this._refresh();
          }
          running(chart2) {
            if (!this._running) {
              return false;
            }
            const anims = this._charts.get(chart2);
            if (!anims || !anims.running || !anims.items.length) {
              return false;
            }
            return true;
          }
          stop(chart2) {
            const anims = this._charts.get(chart2);
            if (!anims || !anims.items.length) {
              return;
            }
            const items = anims.items;
            let i = items.length - 1;
            for (; i >= 0; --i) {
              items[i].cancel();
            }
            anims.items = [];
            this._notify(chart2, anims, Date.now(), "complete");
          }
          remove(chart2) {
            return this._charts.delete(chart2);
          }
        }
        var animator = new Animator();
        function round(v) {
          return v + 0.5 | 0;
        }
        const lim = (v, l, h) => Math.max(Math.min(v, h), l);
        function p2b(v) {
          return lim(round(v * 2.55), 0, 255);
        }
        function n2b(v) {
          return lim(round(v * 255), 0, 255);
        }
        function b2n(v) {
          return lim(round(v / 2.55) / 100, 0, 1);
        }
        function n2p(v) {
          return lim(round(v * 100), 0, 100);
        }
        const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
        const hex = [..."0123456789ABCDEF"];
        const h1 = (b) => hex[b & 15];
        const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
        const eq = (b) => (b & 240) >> 4 === (b & 15);
        const isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
        function hexParse(str) {
          var len = str.length;
          var ret;
          if (str[0] === "#") {
            if (len === 4 || len === 5) {
              ret = {
                r: 255 & map$1[str[1]] * 17,
                g: 255 & map$1[str[2]] * 17,
                b: 255 & map$1[str[3]] * 17,
                a: len === 5 ? map$1[str[4]] * 17 : 255
              };
            } else if (len === 7 || len === 9) {
              ret = {
                r: map$1[str[1]] << 4 | map$1[str[2]],
                g: map$1[str[3]] << 4 | map$1[str[4]],
                b: map$1[str[5]] << 4 | map$1[str[6]],
                a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
              };
            }
          }
          return ret;
        }
        const alpha = (a, f) => a < 255 ? f(a) : "";
        function hexString(v) {
          var f = isShort(v) ? h1 : h2;
          return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
        }
        const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
        function hsl2rgbn(h, s, l) {
          const a = s * Math.min(l, 1 - l);
          const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return [f(0), f(8), f(4)];
        }
        function hsv2rgbn(h, s, v) {
          const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
          return [f(5), f(3), f(1)];
        }
        function hwb2rgbn(h, w, b) {
          const rgb = hsl2rgbn(h, 1, 0.5);
          let i;
          if (w + b > 1) {
            i = 1 / (w + b);
            w *= i;
            b *= i;
          }
          for (i = 0; i < 3; i++) {
            rgb[i] *= 1 - w - b;
            rgb[i] += w;
          }
          return rgb;
        }
        function hueValue(r, g, b, d, max) {
          if (r === max) {
            return (g - b) / d + (g < b ? 6 : 0);
          }
          if (g === max) {
            return (b - r) / d + 2;
          }
          return (r - g) / d + 4;
        }
        function rgb2hsl(v) {
          const range2 = 255;
          const r = v.r / range2;
          const g = v.g / range2;
          const b = v.b / range2;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const l = (max + min) / 2;
          let h, s, d;
          if (max !== min) {
            d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            h = hueValue(r, g, b, d, max);
            h = h * 60 + 0.5;
          }
          return [h | 0, s || 0, l];
        }
        function calln(f, a, b, c) {
          return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
        }
        function hsl2rgb(h, s, l) {
          return calln(hsl2rgbn, h, s, l);
        }
        function hwb2rgb(h, w, b) {
          return calln(hwb2rgbn, h, w, b);
        }
        function hsv2rgb(h, s, v) {
          return calln(hsv2rgbn, h, s, v);
        }
        function hue(h) {
          return (h % 360 + 360) % 360;
        }
        function hueParse(str) {
          const m = HUE_RE.exec(str);
          let a = 255;
          let v;
          if (!m) {
            return;
          }
          if (m[5] !== v) {
            a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
          }
          const h = hue(+m[2]);
          const p1 = +m[3] / 100;
          const p2 = +m[4] / 100;
          if (m[1] === "hwb") {
            v = hwb2rgb(h, p1, p2);
          } else if (m[1] === "hsv") {
            v = hsv2rgb(h, p1, p2);
          } else {
            v = hsl2rgb(h, p1, p2);
          }
          return {
            r: v[0],
            g: v[1],
            b: v[2],
            a
          };
        }
        function rotate(v, deg) {
          var h = rgb2hsl(v);
          h[0] = hue(h[0] + deg);
          h = hsl2rgb(h);
          v.r = h[0];
          v.g = h[1];
          v.b = h[2];
        }
        function hslString(v) {
          if (!v) {
            return;
          }
          const a = rgb2hsl(v);
          const h = a[0];
          const s = n2p(a[1]);
          const l = n2p(a[2]);
          return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
        }
        const map$2 = {
          x: "dark",
          Z: "light",
          Y: "re",
          X: "blu",
          W: "gr",
          V: "medium",
          U: "slate",
          A: "ee",
          T: "ol",
          S: "or",
          B: "ra",
          C: "lateg",
          D: "ights",
          R: "in",
          Q: "turquois",
          E: "hi",
          P: "ro",
          O: "al",
          N: "le",
          M: "de",
          L: "yello",
          F: "en",
          K: "ch",
          G: "arks",
          H: "ea",
          I: "ightg",
          J: "wh"
        };
        const names$1 = {
          OiceXe: "f0f8ff",
          antiquewEte: "faebd7",
          aqua: "ffff",
          aquamarRe: "7fffd4",
          azuY: "f0ffff",
          beige: "f5f5dc",
          bisque: "ffe4c4",
          black: "0",
          blanKedOmond: "ffebcd",
          Xe: "ff",
          XeviTet: "8a2be2",
          bPwn: "a52a2a",
          burlywood: "deb887",
          caMtXe: "5f9ea0",
          KartYuse: "7fff00",
          KocTate: "d2691e",
          cSO: "ff7f50",
          cSnflowerXe: "6495ed",
          cSnsilk: "fff8dc",
          crimson: "dc143c",
          cyan: "ffff",
          xXe: "8b",
          xcyan: "8b8b",
          xgTMnPd: "b8860b",
          xWay: "a9a9a9",
          xgYF: "6400",
          xgYy: "a9a9a9",
          xkhaki: "bdb76b",
          xmagFta: "8b008b",
          xTivegYF: "556b2f",
          xSange: "ff8c00",
          xScEd: "9932cc",
          xYd: "8b0000",
          xsOmon: "e9967a",
          xsHgYF: "8fbc8f",
          xUXe: "483d8b",
          xUWay: "2f4f4f",
          xUgYy: "2f4f4f",
          xQe: "ced1",
          xviTet: "9400d3",
          dAppRk: "ff1493",
          dApskyXe: "bfff",
          dimWay: "696969",
          dimgYy: "696969",
          dodgerXe: "1e90ff",
          fiYbrick: "b22222",
          flSOwEte: "fffaf0",
          foYstWAn: "228b22",
          fuKsia: "ff00ff",
          gaRsbSo: "dcdcdc",
          ghostwEte: "f8f8ff",
          gTd: "ffd700",
          gTMnPd: "daa520",
          Way: "808080",
          gYF: "8000",
          gYFLw: "adff2f",
          gYy: "808080",
          honeyMw: "f0fff0",
          hotpRk: "ff69b4",
          RdianYd: "cd5c5c",
          Rdigo: "4b0082",
          ivSy: "fffff0",
          khaki: "f0e68c",
          lavFMr: "e6e6fa",
          lavFMrXsh: "fff0f5",
          lawngYF: "7cfc00",
          NmoncEffon: "fffacd",
          ZXe: "add8e6",
          ZcSO: "f08080",
          Zcyan: "e0ffff",
          ZgTMnPdLw: "fafad2",
          ZWay: "d3d3d3",
          ZgYF: "90ee90",
          ZgYy: "d3d3d3",
          ZpRk: "ffb6c1",
          ZsOmon: "ffa07a",
          ZsHgYF: "20b2aa",
          ZskyXe: "87cefa",
          ZUWay: "778899",
          ZUgYy: "778899",
          ZstAlXe: "b0c4de",
          ZLw: "ffffe0",
          lime: "ff00",
          limegYF: "32cd32",
          lRF: "faf0e6",
          magFta: "ff00ff",
          maPon: "800000",
          VaquamarRe: "66cdaa",
          VXe: "cd",
          VScEd: "ba55d3",
          VpurpN: "9370db",
          VsHgYF: "3cb371",
          VUXe: "7b68ee",
          VsprRggYF: "fa9a",
          VQe: "48d1cc",
          VviTetYd: "c71585",
          midnightXe: "191970",
          mRtcYam: "f5fffa",
          mistyPse: "ffe4e1",
          moccasR: "ffe4b5",
          navajowEte: "ffdead",
          navy: "80",
          Tdlace: "fdf5e6",
          Tive: "808000",
          TivedBb: "6b8e23",
          Sange: "ffa500",
          SangeYd: "ff4500",
          ScEd: "da70d6",
          pOegTMnPd: "eee8aa",
          pOegYF: "98fb98",
          pOeQe: "afeeee",
          pOeviTetYd: "db7093",
          papayawEp: "ffefd5",
          pHKpuff: "ffdab9",
          peru: "cd853f",
          pRk: "ffc0cb",
          plum: "dda0dd",
          powMrXe: "b0e0e6",
          purpN: "800080",
          YbeccapurpN: "663399",
          Yd: "ff0000",
          Psybrown: "bc8f8f",
          PyOXe: "4169e1",
          saddNbPwn: "8b4513",
          sOmon: "fa8072",
          sandybPwn: "f4a460",
          sHgYF: "2e8b57",
          sHshell: "fff5ee",
          siFna: "a0522d",
          silver: "c0c0c0",
          skyXe: "87ceeb",
          UXe: "6a5acd",
          UWay: "708090",
          UgYy: "708090",
          snow: "fffafa",
          sprRggYF: "ff7f",
          stAlXe: "4682b4",
          tan: "d2b48c",
          teO: "8080",
          tEstN: "d8bfd8",
          tomato: "ff6347",
          Qe: "40e0d0",
          viTet: "ee82ee",
          JHt: "f5deb3",
          wEte: "ffffff",
          wEtesmoke: "f5f5f5",
          Lw: "ffff00",
          LwgYF: "9acd32"
        };
        function unpack() {
          const unpacked = {};
          const keys = Object.keys(names$1);
          const tkeys = Object.keys(map$2);
          let i, j, k, ok, nk;
          for (i = 0; i < keys.length; i++) {
            ok = nk = keys[i];
            for (j = 0; j < tkeys.length; j++) {
              k = tkeys[j];
              nk = nk.replace(k, map$2[k]);
            }
            k = parseInt(names$1[ok], 16);
            unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
          }
          return unpacked;
        }
        let names;
        function nameParse(str) {
          if (!names) {
            names = unpack();
            names.transparent = [0, 0, 0, 0];
          }
          const a = names[str.toLowerCase()];
          return a && {
            r: a[0],
            g: a[1],
            b: a[2],
            a: a.length === 4 ? a[3] : 255
          };
        }
        const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
        function rgbParse(str) {
          const m = RGB_RE.exec(str);
          let a = 255;
          let r, g, b;
          if (!m) {
            return;
          }
          if (m[7] !== r) {
            const v = +m[7];
            a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
          }
          r = +m[1];
          g = +m[3];
          b = +m[5];
          r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
          g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
          b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
          return {
            r,
            g,
            b,
            a
          };
        }
        function rgbString(v) {
          return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
        }
        const to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
        const from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
        function interpolate$1(rgb1, rgb2, t) {
          const r = from(b2n(rgb1.r));
          const g = from(b2n(rgb1.g));
          const b = from(b2n(rgb1.b));
          return {
            r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
            g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
            b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
            a: rgb1.a + t * (rgb2.a - rgb1.a)
          };
        }
        function modHSL(v, i, ratio) {
          if (v) {
            let tmp = rgb2hsl(v);
            tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
            tmp = hsl2rgb(tmp);
            v.r = tmp[0];
            v.g = tmp[1];
            v.b = tmp[2];
          }
        }
        function clone$1(v, proto) {
          return v ? Object.assign(proto || {}, v) : v;
        }
        function fromObject(input) {
          var v = { r: 0, g: 0, b: 0, a: 255 };
          if (Array.isArray(input)) {
            if (input.length >= 3) {
              v = { r: input[0], g: input[1], b: input[2], a: 255 };
              if (input.length > 3) {
                v.a = n2b(input[3]);
              }
            }
          } else {
            v = clone$1(input, { r: 0, g: 0, b: 0, a: 1 });
            v.a = n2b(v.a);
          }
          return v;
        }
        function functionParse(str) {
          if (str.charAt(0) === "r") {
            return rgbParse(str);
          }
          return hueParse(str);
        }
        class Color {
          constructor(input) {
            if (input instanceof Color) {
              return input;
            }
            const type = typeof input;
            let v;
            if (type === "object") {
              v = fromObject(input);
            } else if (type === "string") {
              v = hexParse(input) || nameParse(input) || functionParse(input);
            }
            this._rgb = v;
            this._valid = !!v;
          }
          get valid() {
            return this._valid;
          }
          get rgb() {
            var v = clone$1(this._rgb);
            if (v) {
              v.a = b2n(v.a);
            }
            return v;
          }
          set rgb(obj) {
            this._rgb = fromObject(obj);
          }
          rgbString() {
            return this._valid ? rgbString(this._rgb) : void 0;
          }
          hexString() {
            return this._valid ? hexString(this._rgb) : void 0;
          }
          hslString() {
            return this._valid ? hslString(this._rgb) : void 0;
          }
          mix(color2, weight) {
            if (color2) {
              const c1 = this.rgb;
              const c2 = color2.rgb;
              let w2;
              const p = weight === w2 ? 0.5 : weight;
              const w = 2 * p - 1;
              const a = c1.a - c2.a;
              const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
              w2 = 1 - w1;
              c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
              c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
              c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
              c1.a = p * c1.a + (1 - p) * c2.a;
              this.rgb = c1;
            }
            return this;
          }
          interpolate(color2, t) {
            if (color2) {
              this._rgb = interpolate$1(this._rgb, color2._rgb, t);
            }
            return this;
          }
          clone() {
            return new Color(this.rgb);
          }
          alpha(a) {
            this._rgb.a = n2b(a);
            return this;
          }
          clearer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 - ratio;
            return this;
          }
          greyscale() {
            const rgb = this._rgb;
            const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
            rgb.r = rgb.g = rgb.b = val;
            return this;
          }
          opaquer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 + ratio;
            return this;
          }
          negate() {
            const v = this._rgb;
            v.r = 255 - v.r;
            v.g = 255 - v.g;
            v.b = 255 - v.b;
            return this;
          }
          lighten(ratio) {
            modHSL(this._rgb, 2, ratio);
            return this;
          }
          darken(ratio) {
            modHSL(this._rgb, 2, -ratio);
            return this;
          }
          saturate(ratio) {
            modHSL(this._rgb, 1, ratio);
            return this;
          }
          desaturate(ratio) {
            modHSL(this._rgb, 1, -ratio);
            return this;
          }
          rotate(deg) {
            rotate(this._rgb, deg);
            return this;
          }
        }
        function index_esm(input) {
          return new Color(input);
        }
        function isPatternOrGradient(value) {
          if (value && typeof value === "object") {
            const type = value.toString();
            return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
          }
          return false;
        }
        function color(value) {
          return isPatternOrGradient(value) ? value : index_esm(value);
        }
        function getHoverColor(value) {
          return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
        }
        function noop2() {
        }
        const uid = function() {
          let id = 0;
          return function() {
            return id++;
          };
        }();
        function isNullOrUndef(value) {
          return value === null || typeof value === "undefined";
        }
        function isArray(value) {
          if (Array.isArray && Array.isArray(value)) {
            return true;
          }
          const type = Object.prototype.toString.call(value);
          if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
            return true;
          }
          return false;
        }
        function isObject2(value) {
          return value !== null && Object.prototype.toString.call(value) === "[object Object]";
        }
        const isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
        function finiteOrDefault(value, defaultValue) {
          return isNumberFinite(value) ? value : defaultValue;
        }
        function valueOrDefault(value, defaultValue) {
          return typeof value === "undefined" ? defaultValue : value;
        }
        const toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
        const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
        function callback(fn, args, thisArg) {
          if (fn && typeof fn.call === "function") {
            return fn.apply(thisArg, args);
          }
        }
        function each(loopable, fn, thisArg, reverse) {
          let i, len, keys;
          if (isArray(loopable)) {
            len = loopable.length;
            if (reverse) {
              for (i = len - 1; i >= 0; i--) {
                fn.call(thisArg, loopable[i], i);
              }
            } else {
              for (i = 0; i < len; i++) {
                fn.call(thisArg, loopable[i], i);
              }
            }
          } else if (isObject2(loopable)) {
            keys = Object.keys(loopable);
            len = keys.length;
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[keys[i]], keys[i]);
            }
          }
        }
        function _elementsEqual(a0, a1) {
          let i, ilen, v0, v1;
          if (!a0 || !a1 || a0.length !== a1.length) {
            return false;
          }
          for (i = 0, ilen = a0.length; i < ilen; ++i) {
            v0 = a0[i];
            v1 = a1[i];
            if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
              return false;
            }
          }
          return true;
        }
        function clone2(source) {
          if (isArray(source)) {
            return source.map(clone2);
          }
          if (isObject2(source)) {
            const target = Object.create(null);
            const keys = Object.keys(source);
            const klen = keys.length;
            let k = 0;
            for (; k < klen; ++k) {
              target[keys[k]] = clone2(source[keys[k]]);
            }
            return target;
          }
          return source;
        }
        function isValidKey(key) {
          return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
        }
        function _merger(key, target, source, options) {
          if (!isValidKey(key)) {
            return;
          }
          const tval = target[key];
          const sval = source[key];
          if (isObject2(tval) && isObject2(sval)) {
            merge(tval, sval, options);
          } else {
            target[key] = clone2(sval);
          }
        }
        function merge(target, source, options) {
          const sources = isArray(source) ? source : [source];
          const ilen = sources.length;
          if (!isObject2(target)) {
            return target;
          }
          options = options || {};
          const merger = options.merger || _merger;
          for (let i = 0; i < ilen; ++i) {
            source = sources[i];
            if (!isObject2(source)) {
              continue;
            }
            const keys = Object.keys(source);
            for (let k = 0, klen = keys.length; k < klen; ++k) {
              merger(keys[k], target, source, options);
            }
          }
          return target;
        }
        function mergeIf(target, source) {
          return merge(target, source, { merger: _mergerIf });
        }
        function _mergerIf(key, target, source) {
          if (!isValidKey(key)) {
            return;
          }
          const tval = target[key];
          const sval = source[key];
          if (isObject2(tval) && isObject2(sval)) {
            mergeIf(tval, sval);
          } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
            target[key] = clone2(sval);
          }
        }
        function _deprecated(scope, value, previous, current) {
          if (value !== void 0) {
            console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
          }
        }
        const emptyString = "";
        const dot = ".";
        function indexOfDotOrLength(key, start) {
          const idx = key.indexOf(dot, start);
          return idx === -1 ? key.length : idx;
        }
        function resolveObjectKey(obj, key) {
          if (key === emptyString) {
            return obj;
          }
          let pos = 0;
          let idx = indexOfDotOrLength(key, pos);
          while (obj && idx > pos) {
            obj = obj[key.slice(pos, idx)];
            pos = idx + 1;
            idx = indexOfDotOrLength(key, pos);
          }
          return obj;
        }
        function _capitalize(str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        }
        const defined = (value) => typeof value !== "undefined";
        const isFunction = (value) => typeof value === "function";
        const setsEqual = (a, b) => {
          if (a.size !== b.size) {
            return false;
          }
          for (const item of a) {
            if (!b.has(item)) {
              return false;
            }
          }
          return true;
        };
        function _isClickEvent(e) {
          return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
        }
        const overrides = Object.create(null);
        const descriptors = Object.create(null);
        function getScope$1(node, key) {
          if (!key) {
            return node;
          }
          const keys = key.split(".");
          for (let i = 0, n = keys.length; i < n; ++i) {
            const k = keys[i];
            node = node[k] || (node[k] = Object.create(null));
          }
          return node;
        }
        function set(root, scope, values) {
          if (typeof scope === "string") {
            return merge(getScope$1(root, scope), values);
          }
          return merge(getScope$1(root, ""), scope);
        }
        class Defaults {
          constructor(_descriptors2) {
            this.animation = void 0;
            this.backgroundColor = "rgba(0,0,0,0.1)";
            this.borderColor = "rgba(0,0,0,0.1)";
            this.color = "#666";
            this.datasets = {};
            this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
            this.elements = {};
            this.events = [
              "mousemove",
              "mouseout",
              "click",
              "touchstart",
              "touchmove"
            ];
            this.font = {
              family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
              size: 12,
              style: "normal",
              lineHeight: 1.2,
              weight: null
            };
            this.hover = {};
            this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
            this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
            this.hoverColor = (ctx, options) => getHoverColor(options.color);
            this.indexAxis = "x";
            this.interaction = {
              mode: "nearest",
              intersect: true,
              includeInvisible: false
            };
            this.maintainAspectRatio = true;
            this.onHover = null;
            this.onClick = null;
            this.parsing = true;
            this.plugins = {};
            this.responsive = true;
            this.scale = void 0;
            this.scales = {};
            this.showLine = true;
            this.drawActiveElementsOnTop = true;
            this.describe(_descriptors2);
          }
          set(scope, values) {
            return set(this, scope, values);
          }
          get(scope) {
            return getScope$1(this, scope);
          }
          describe(scope, values) {
            return set(descriptors, scope, values);
          }
          override(scope, values) {
            return set(overrides, scope, values);
          }
          route(scope, name, targetScope, targetName) {
            const scopeObject = getScope$1(this, scope);
            const targetScopeObject = getScope$1(this, targetScope);
            const privateName = "_" + name;
            Object.defineProperties(scopeObject, {
              [privateName]: {
                value: scopeObject[name],
                writable: true
              },
              [name]: {
                enumerable: true,
                get() {
                  const local = this[privateName];
                  const target = targetScopeObject[targetName];
                  if (isObject2(local)) {
                    return Object.assign({}, target, local);
                  }
                  return valueOrDefault(local, target);
                },
                set(value) {
                  this[privateName] = value;
                }
              }
            });
          }
        }
        var defaults = new Defaults({
          _scriptable: (name) => !name.startsWith("on"),
          _indexable: (name) => name !== "events",
          hover: {
            _fallback: "interaction"
          },
          interaction: {
            _scriptable: false,
            _indexable: false
          }
        });
        function _lookup(table, value, cmp) {
          cmp = cmp || ((index2) => table[index2] < value);
          let hi = table.length - 1;
          let lo = 0;
          let mid;
          while (hi - lo > 1) {
            mid = lo + hi >> 1;
            if (cmp(mid)) {
              lo = mid;
            } else {
              hi = mid;
            }
          }
          return { lo, hi };
        }
        const _lookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] < value);
        const _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
        function _filterBetween(values, min, max) {
          let start = 0;
          let end = values.length;
          while (start < end && values[start] < min) {
            start++;
          }
          while (end > start && values[end - 1] > max) {
            end--;
          }
          return start > 0 || end < values.length ? values.slice(start, end) : values;
        }
        const arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
        function listenArrayEvents(array, listener) {
          if (array._chartjs) {
            array._chartjs.listeners.push(listener);
            return;
          }
          Object.defineProperty(array, "_chartjs", {
            configurable: true,
            enumerable: false,
            value: {
              listeners: [listener]
            }
          });
          arrayEvents.forEach((key) => {
            const method = "_onData" + _capitalize(key);
            const base = array[key];
            Object.defineProperty(array, key, {
              configurable: true,
              enumerable: false,
              value(...args) {
                const res = base.apply(this, args);
                array._chartjs.listeners.forEach((object) => {
                  if (typeof object[method] === "function") {
                    object[method](...args);
                  }
                });
                return res;
              }
            });
          });
        }
        function unlistenArrayEvents(array, listener) {
          const stub = array._chartjs;
          if (!stub) {
            return;
          }
          const listeners = stub.listeners;
          const index2 = listeners.indexOf(listener);
          if (index2 !== -1) {
            listeners.splice(index2, 1);
          }
          if (listeners.length > 0) {
            return;
          }
          arrayEvents.forEach((key) => {
            delete array[key];
          });
          delete array._chartjs;
        }
        function _arrayUnique(items) {
          const set2 = /* @__PURE__ */ new Set();
          let i, ilen;
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            set2.add(items[i]);
          }
          if (set2.size === ilen) {
            return items;
          }
          return Array.from(set2);
        }
        const PI = Math.PI;
        const TAU = 2 * PI;
        const PITAU = TAU + PI;
        const INFINITY = Number.POSITIVE_INFINITY;
        const RAD_PER_DEG = PI / 180;
        const HALF_PI = PI / 2;
        const QUARTER_PI = PI / 4;
        const TWO_THIRDS_PI = PI * 2 / 3;
        const log10 = Math.log10;
        const sign = Math.sign;
        function niceNum(range2) {
          const roundedRange = Math.round(range2);
          range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
          const niceRange = Math.pow(10, Math.floor(log10(range2)));
          const fraction = range2 / niceRange;
          const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
          return niceFraction * niceRange;
        }
        function _factorize(value) {
          const result = [];
          const sqrt = Math.sqrt(value);
          let i;
          for (i = 1; i < sqrt; i++) {
            if (value % i === 0) {
              result.push(i);
              result.push(value / i);
            }
          }
          if (sqrt === (sqrt | 0)) {
            result.push(sqrt);
          }
          result.sort((a, b) => a - b).pop();
          return result;
        }
        function isNumber(n) {
          return !isNaN(parseFloat(n)) && isFinite(n);
        }
        function almostEquals(x, y, epsilon) {
          return Math.abs(x - y) < epsilon;
        }
        function almostWhole(x, epsilon) {
          const rounded = Math.round(x);
          return rounded - epsilon <= x && rounded + epsilon >= x;
        }
        function _setMinAndMaxByKey(array, target, property) {
          let i, ilen, value;
          for (i = 0, ilen = array.length; i < ilen; i++) {
            value = array[i][property];
            if (!isNaN(value)) {
              target.min = Math.min(target.min, value);
              target.max = Math.max(target.max, value);
            }
          }
        }
        function toRadians(degrees) {
          return degrees * (PI / 180);
        }
        function toDegrees(radians) {
          return radians * (180 / PI);
        }
        function _decimalPlaces(x) {
          if (!isNumberFinite(x)) {
            return;
          }
          let e = 1;
          let p = 0;
          while (Math.round(x * e) / e !== x) {
            e *= 10;
            p++;
          }
          return p;
        }
        function getAngleFromPoint(centrePoint, anglePoint) {
          const distanceFromXCenter = anglePoint.x - centrePoint.x;
          const distanceFromYCenter = anglePoint.y - centrePoint.y;
          const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
          let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
          if (angle < -0.5 * PI) {
            angle += TAU;
          }
          return {
            angle,
            distance: radialDistanceFromCenter
          };
        }
        function distanceBetweenPoints(pt1, pt2) {
          return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
        }
        function _angleDiff(a, b) {
          return (a - b + PITAU) % TAU - PI;
        }
        function _normalizeAngle(a) {
          return (a % TAU + TAU) % TAU;
        }
        function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
          const a = _normalizeAngle(angle);
          const s = _normalizeAngle(start);
          const e = _normalizeAngle(end);
          const angleToStart = _normalizeAngle(s - a);
          const angleToEnd = _normalizeAngle(e - a);
          const startToAngle = _normalizeAngle(a - s);
          const endToAngle = _normalizeAngle(a - e);
          return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
        }
        function _limitValue(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }
        function _int16Range(value) {
          return _limitValue(value, -32768, 32767);
        }
        function _isBetween(value, start, end, epsilon = 1e-6) {
          return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
        }
        function _isDomSupported() {
          return typeof window !== "undefined" && typeof document !== "undefined";
        }
        function _getParentNode(domNode) {
          let parent = domNode.parentNode;
          if (parent && parent.toString() === "[object ShadowRoot]") {
            parent = parent.host;
          }
          return parent;
        }
        function parseMaxStyle(styleValue, node, parentProperty) {
          let valueInPixels;
          if (typeof styleValue === "string") {
            valueInPixels = parseInt(styleValue, 10);
            if (styleValue.indexOf("%") !== -1) {
              valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
            }
          } else {
            valueInPixels = styleValue;
          }
          return valueInPixels;
        }
        const getComputedStyle2 = (element) => window.getComputedStyle(element, null);
        function getStyle(el, property) {
          return getComputedStyle2(el).getPropertyValue(property);
        }
        const positions = ["top", "right", "bottom", "left"];
        function getPositionedStyle(styles, style, suffix) {
          const result = {};
          suffix = suffix ? "-" + suffix : "";
          for (let i = 0; i < 4; i++) {
            const pos = positions[i];
            result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
          }
          result.width = result.left + result.right;
          result.height = result.top + result.bottom;
          return result;
        }
        const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
        function getCanvasPosition(e, canvas) {
          const touches = e.touches;
          const source = touches && touches.length ? touches[0] : e;
          const { offsetX, offsetY } = source;
          let box = false;
          let x, y;
          if (useOffsetPos(offsetX, offsetY, e.target)) {
            x = offsetX;
            y = offsetY;
          } else {
            const rect = canvas.getBoundingClientRect();
            x = source.clientX - rect.left;
            y = source.clientY - rect.top;
            box = true;
          }
          return { x, y, box };
        }
        function getRelativePosition(evt, chart2) {
          if ("native" in evt) {
            return evt;
          }
          const { canvas, currentDevicePixelRatio } = chart2;
          const style = getComputedStyle2(canvas);
          const borderBox = style.boxSizing === "border-box";
          const paddings = getPositionedStyle(style, "padding");
          const borders = getPositionedStyle(style, "border", "width");
          const { x, y, box } = getCanvasPosition(evt, canvas);
          const xOffset = paddings.left + (box && borders.left);
          const yOffset = paddings.top + (box && borders.top);
          let { width, height } = chart2;
          if (borderBox) {
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
          }
          return {
            x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
            y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
          };
        }
        function getContainerSize(canvas, width, height) {
          let maxWidth, maxHeight;
          if (width === void 0 || height === void 0) {
            const container = _getParentNode(canvas);
            if (!container) {
              width = canvas.clientWidth;
              height = canvas.clientHeight;
            } else {
              const rect = container.getBoundingClientRect();
              const containerStyle = getComputedStyle2(container);
              const containerBorder = getPositionedStyle(containerStyle, "border", "width");
              const containerPadding = getPositionedStyle(containerStyle, "padding");
              width = rect.width - containerPadding.width - containerBorder.width;
              height = rect.height - containerPadding.height - containerBorder.height;
              maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
              maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
            }
          }
          return {
            width,
            height,
            maxWidth: maxWidth || INFINITY,
            maxHeight: maxHeight || INFINITY
          };
        }
        const round1 = (v) => Math.round(v * 10) / 10;
        function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
          const style = getComputedStyle2(canvas);
          const margins = getPositionedStyle(style, "margin");
          const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
          const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
          const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
          let { width, height } = containerSize;
          if (style.boxSizing === "content-box") {
            const borders = getPositionedStyle(style, "border", "width");
            const paddings = getPositionedStyle(style, "padding");
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
          }
          width = Math.max(0, width - margins.width);
          height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
          width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
          height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
          if (width && !height) {
            height = round1(width / 2);
          }
          return {
            width,
            height
          };
        }
        function retinaScale(chart2, forceRatio, forceStyle) {
          const pixelRatio = forceRatio || 1;
          const deviceHeight = Math.floor(chart2.height * pixelRatio);
          const deviceWidth = Math.floor(chart2.width * pixelRatio);
          chart2.height = deviceHeight / pixelRatio;
          chart2.width = deviceWidth / pixelRatio;
          const canvas = chart2.canvas;
          if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
            canvas.style.height = `${chart2.height}px`;
            canvas.style.width = `${chart2.width}px`;
          }
          if (chart2.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
            chart2.currentDevicePixelRatio = pixelRatio;
            canvas.height = deviceHeight;
            canvas.width = deviceWidth;
            chart2.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            return true;
          }
          return false;
        }
        const supportsEventListenerOptions = function() {
          let passiveSupported = false;
          try {
            const options = {
              get passive() {
                passiveSupported = true;
                return false;
              }
            };
            window.addEventListener("test", null, options);
            window.removeEventListener("test", null, options);
          } catch (e) {
          }
          return passiveSupported;
        }();
        function readUsedSize(element, property) {
          const value = getStyle(element, property);
          const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
          return matches ? +matches[1] : void 0;
        }
        function toFontString(font) {
          if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
            return null;
          }
          return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
        }
        function _measureText(ctx, data, gc, longest, string) {
          let textWidth = data[string];
          if (!textWidth) {
            textWidth = data[string] = ctx.measureText(string).width;
            gc.push(string);
          }
          if (textWidth > longest) {
            longest = textWidth;
          }
          return longest;
        }
        function _longestText(ctx, font, arrayOfThings, cache) {
          cache = cache || {};
          let data = cache.data = cache.data || {};
          let gc = cache.garbageCollect = cache.garbageCollect || [];
          if (cache.font !== font) {
            data = cache.data = {};
            gc = cache.garbageCollect = [];
            cache.font = font;
          }
          ctx.save();
          ctx.font = font;
          let longest = 0;
          const ilen = arrayOfThings.length;
          let i, j, jlen, thing, nestedThing;
          for (i = 0; i < ilen; i++) {
            thing = arrayOfThings[i];
            if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
              longest = _measureText(ctx, data, gc, longest, thing);
            } else if (isArray(thing)) {
              for (j = 0, jlen = thing.length; j < jlen; j++) {
                nestedThing = thing[j];
                if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
                  longest = _measureText(ctx, data, gc, longest, nestedThing);
                }
              }
            }
          }
          ctx.restore();
          const gcLen = gc.length / 2;
          if (gcLen > arrayOfThings.length) {
            for (i = 0; i < gcLen; i++) {
              delete data[gc[i]];
            }
            gc.splice(0, gcLen);
          }
          return longest;
        }
        function _alignPixel(chart2, pixel, width) {
          const devicePixelRatio = chart2.currentDevicePixelRatio;
          const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
          return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
        }
        function clearCanvas(canvas, ctx) {
          ctx = ctx || canvas.getContext("2d");
          ctx.save();
          ctx.resetTransform();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        }
        function drawPoint(ctx, options, x, y) {
          let type, xOffset, yOffset, size, cornerRadius;
          const style = options.pointStyle;
          const rotation = options.rotation;
          const radius = options.radius;
          let rad = (rotation || 0) * RAD_PER_DEG;
          if (style && typeof style === "object") {
            type = style.toString();
            if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
              ctx.save();
              ctx.translate(x, y);
              ctx.rotate(rad);
              ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
              ctx.restore();
              return;
            }
          }
          if (isNaN(radius) || radius <= 0) {
            return;
          }
          ctx.beginPath();
          switch (style) {
            default:
              ctx.arc(x, y, radius, 0, TAU);
              ctx.closePath();
              break;
            case "triangle":
              ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
              ctx.closePath();
              break;
            case "rectRounded":
              cornerRadius = radius * 0.516;
              size = radius - cornerRadius;
              xOffset = Math.cos(rad + QUARTER_PI) * size;
              yOffset = Math.sin(rad + QUARTER_PI) * size;
              ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
              ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
              ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
              ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
              ctx.closePath();
              break;
            case "rect":
              if (!rotation) {
                size = Math.SQRT1_2 * radius;
                ctx.rect(x - size, y - size, 2 * size, 2 * size);
                break;
              }
              rad += QUARTER_PI;
            case "rectRot":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + yOffset, y - xOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              ctx.closePath();
              break;
            case "crossRot":
              rad += QUARTER_PI;
            case "cross":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              break;
            case "star":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              rad += QUARTER_PI;
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              ctx.moveTo(x + yOffset, y - xOffset);
              ctx.lineTo(x - yOffset, y + xOffset);
              break;
            case "line":
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              break;
            case "dash":
              ctx.moveTo(x, y);
              ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
              break;
          }
          ctx.fill();
          if (options.borderWidth > 0) {
            ctx.stroke();
          }
        }
        function _isPointInArea(point, area, margin) {
          margin = margin || 0.5;
          return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
        }
        function clipArea(ctx, area) {
          ctx.save();
          ctx.beginPath();
          ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
          ctx.clip();
        }
        function unclipArea(ctx) {
          ctx.restore();
        }
        function _steppedLineTo(ctx, previous, target, flip, mode) {
          if (!previous) {
            return ctx.lineTo(target.x, target.y);
          }
          if (mode === "middle") {
            const midpoint = (previous.x + target.x) / 2;
            ctx.lineTo(midpoint, previous.y);
            ctx.lineTo(midpoint, target.y);
          } else if (mode === "after" !== !!flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }
          ctx.lineTo(target.x, target.y);
        }
        function _bezierCurveTo(ctx, previous, target, flip) {
          if (!previous) {
            return ctx.lineTo(target.x, target.y);
          }
          ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
        }
        function renderText(ctx, text, x, y, font, opts = {}) {
          const lines = isArray(text) ? text : [text];
          const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
          let i, line;
          ctx.save();
          ctx.font = font.string;
          setRenderOpts(ctx, opts);
          for (i = 0; i < lines.length; ++i) {
            line = lines[i];
            if (stroke) {
              if (opts.strokeColor) {
                ctx.strokeStyle = opts.strokeColor;
              }
              if (!isNullOrUndef(opts.strokeWidth)) {
                ctx.lineWidth = opts.strokeWidth;
              }
              ctx.strokeText(line, x, y, opts.maxWidth);
            }
            ctx.fillText(line, x, y, opts.maxWidth);
            decorateText(ctx, x, y, line, opts);
            y += font.lineHeight;
          }
          ctx.restore();
        }
        function setRenderOpts(ctx, opts) {
          if (opts.translation) {
            ctx.translate(opts.translation[0], opts.translation[1]);
          }
          if (!isNullOrUndef(opts.rotation)) {
            ctx.rotate(opts.rotation);
          }
          if (opts.color) {
            ctx.fillStyle = opts.color;
          }
          if (opts.textAlign) {
            ctx.textAlign = opts.textAlign;
          }
          if (opts.textBaseline) {
            ctx.textBaseline = opts.textBaseline;
          }
        }
        function decorateText(ctx, x, y, line, opts) {
          if (opts.strikethrough || opts.underline) {
            const metrics = ctx.measureText(line);
            const left = x - metrics.actualBoundingBoxLeft;
            const right = x + metrics.actualBoundingBoxRight;
            const top = y - metrics.actualBoundingBoxAscent;
            const bottom = y + metrics.actualBoundingBoxDescent;
            const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.beginPath();
            ctx.lineWidth = opts.decorationWidth || 2;
            ctx.moveTo(left, yDecoration);
            ctx.lineTo(right, yDecoration);
            ctx.stroke();
          }
        }
        function addRoundedRectPath(ctx, rect) {
          const { x, y, w, h, radius } = rect;
          ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
          ctx.lineTo(x, y + h - radius.bottomLeft);
          ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
          ctx.lineTo(x + w - radius.bottomRight, y + h);
          ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
          ctx.lineTo(x + w, y + radius.topRight);
          ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
          ctx.lineTo(x + radius.topLeft, y);
        }
        function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
          if (!defined(fallback)) {
            fallback = _resolve("_fallback", scopes);
          }
          const cache = {
            [Symbol.toStringTag]: "Object",
            _cacheable: true,
            _scopes: scopes,
            _rootScopes: rootScopes,
            _fallback: fallback,
            _getTarget: getTarget,
            override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
          };
          return new Proxy(cache, {
            deleteProperty(target, prop) {
              delete target[prop];
              delete target._keys;
              delete scopes[0][prop];
              return true;
            },
            get(target, prop) {
              return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
            },
            getOwnPropertyDescriptor(target, prop) {
              return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
            },
            getPrototypeOf() {
              return Reflect.getPrototypeOf(scopes[0]);
            },
            has(target, prop) {
              return getKeysFromAllScopes(target).includes(prop);
            },
            ownKeys(target) {
              return getKeysFromAllScopes(target);
            },
            set(target, prop, value) {
              const storage = target._storage || (target._storage = getTarget());
              target[prop] = storage[prop] = value;
              delete target._keys;
              return true;
            }
          });
        }
        function _attachContext(proxy, context, subProxy, descriptorDefaults) {
          const cache = {
            _cacheable: false,
            _proxy: proxy,
            _context: context,
            _subProxy: subProxy,
            _stack: /* @__PURE__ */ new Set(),
            _descriptors: _descriptors(proxy, descriptorDefaults),
            setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
            override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
          };
          return new Proxy(cache, {
            deleteProperty(target, prop) {
              delete target[prop];
              delete proxy[prop];
              return true;
            },
            get(target, prop, receiver) {
              return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
            },
            getOwnPropertyDescriptor(target, prop) {
              return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
            },
            getPrototypeOf() {
              return Reflect.getPrototypeOf(proxy);
            },
            has(target, prop) {
              return Reflect.has(proxy, prop);
            },
            ownKeys() {
              return Reflect.ownKeys(proxy);
            },
            set(target, prop, value) {
              proxy[prop] = value;
              delete target[prop];
              return true;
            }
          });
        }
        function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
          const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
          return {
            allKeys: _allKeys,
            scriptable: _scriptable,
            indexable: _indexable,
            isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
            isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
          };
        }
        const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
        const needsSubResolver = (prop, value) => isObject2(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
        function _cached(target, prop, resolve2) {
          if (Object.prototype.hasOwnProperty.call(target, prop)) {
            return target[prop];
          }
          const value = resolve2();
          target[prop] = value;
          return value;
        }
        function _resolveWithContext(target, prop, receiver) {
          const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
          let value = _proxy[prop];
          if (isFunction(value) && descriptors2.isScriptable(prop)) {
            value = _resolveScriptable(prop, value, target, receiver);
          }
          if (isArray(value) && value.length) {
            value = _resolveArray(prop, value, target, descriptors2.isIndexable);
          }
          if (needsSubResolver(prop, value)) {
            value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
          }
          return value;
        }
        function _resolveScriptable(prop, value, target, receiver) {
          const { _proxy, _context, _subProxy, _stack } = target;
          if (_stack.has(prop)) {
            throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
          }
          _stack.add(prop);
          value = value(_context, _subProxy || receiver);
          _stack.delete(prop);
          if (needsSubResolver(prop, value)) {
            value = createSubResolver(_proxy._scopes, _proxy, prop, value);
          }
          return value;
        }
        function _resolveArray(prop, value, target, isIndexable) {
          const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
          if (defined(_context.index) && isIndexable(prop)) {
            value = value[_context.index % value.length];
          } else if (isObject2(value[0])) {
            const arr = value;
            const scopes = _proxy._scopes.filter((s) => s !== arr);
            value = [];
            for (const item of arr) {
              const resolver = createSubResolver(scopes, _proxy, prop, item);
              value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
            }
          }
          return value;
        }
        function resolveFallback(fallback, prop, value) {
          return isFunction(fallback) ? fallback(prop, value) : fallback;
        }
        const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
        function addScopes(set2, parentScopes, key, parentFallback, value) {
          for (const parent of parentScopes) {
            const scope = getScope(key, parent);
            if (scope) {
              set2.add(scope);
              const fallback = resolveFallback(scope._fallback, key, value);
              if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
                return fallback;
              }
            } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
              return null;
            }
          }
          return false;
        }
        function createSubResolver(parentScopes, resolver, prop, value) {
          const rootScopes = resolver._rootScopes;
          const fallback = resolveFallback(resolver._fallback, prop, value);
          const allScopes = [...parentScopes, ...rootScopes];
          const set2 = /* @__PURE__ */ new Set();
          set2.add(value);
          let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
          if (key === null) {
            return false;
          }
          if (defined(fallback) && fallback !== prop) {
            key = addScopesFromKey(set2, allScopes, fallback, key, value);
            if (key === null) {
              return false;
            }
          }
          return _createResolver(Array.from(set2), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
        }
        function addScopesFromKey(set2, allScopes, key, fallback, item) {
          while (key) {
            key = addScopes(set2, allScopes, key, fallback, item);
          }
          return key;
        }
        function subGetTarget(resolver, prop, value) {
          const parent = resolver._getTarget();
          if (!(prop in parent)) {
            parent[prop] = {};
          }
          const target = parent[prop];
          if (isArray(target) && isObject2(value)) {
            return value;
          }
          return target;
        }
        function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
          let value;
          for (const prefix of prefixes) {
            value = _resolve(readKey(prefix, prop), scopes);
            if (defined(value)) {
              return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
            }
          }
        }
        function _resolve(key, scopes) {
          for (const scope of scopes) {
            if (!scope) {
              continue;
            }
            const value = scope[key];
            if (defined(value)) {
              return value;
            }
          }
        }
        function getKeysFromAllScopes(target) {
          let keys = target._keys;
          if (!keys) {
            keys = target._keys = resolveKeysFromAllScopes(target._scopes);
          }
          return keys;
        }
        function resolveKeysFromAllScopes(scopes) {
          const set2 = /* @__PURE__ */ new Set();
          for (const scope of scopes) {
            for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
              set2.add(key);
            }
          }
          return Array.from(set2);
        }
        function _parseObjectDataRadialScale(meta, data, start, count) {
          const { iScale } = meta;
          const { key = "r" } = this._parsing;
          const parsed = new Array(count);
          let i, ilen, index2, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index2 = i + start;
            item = data[index2];
            parsed[i] = {
              r: iScale.parse(resolveObjectKey(item, key), index2)
            };
          }
          return parsed;
        }
        const EPSILON = Number.EPSILON || 1e-14;
        const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
        const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
        function splineCurve(firstPoint, middlePoint, afterPoint, t) {
          const previous = firstPoint.skip ? middlePoint : firstPoint;
          const current = middlePoint;
          const next = afterPoint.skip ? middlePoint : afterPoint;
          const d01 = distanceBetweenPoints(current, previous);
          const d12 = distanceBetweenPoints(next, current);
          let s01 = d01 / (d01 + d12);
          let s12 = d12 / (d01 + d12);
          s01 = isNaN(s01) ? 0 : s01;
          s12 = isNaN(s12) ? 0 : s12;
          const fa = t * s01;
          const fb = t * s12;
          return {
            previous: {
              x: current.x - fa * (next.x - previous.x),
              y: current.y - fa * (next.y - previous.y)
            },
            next: {
              x: current.x + fb * (next.x - previous.x),
              y: current.y + fb * (next.y - previous.y)
            }
          };
        }
        function monotoneAdjust(points, deltaK, mK) {
          const pointsLen = points.length;
          let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (let i = 0; i < pointsLen - 1; ++i) {
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent || !pointAfter) {
              continue;
            }
            if (almostEquals(deltaK[i], 0, EPSILON)) {
              mK[i] = mK[i + 1] = 0;
              continue;
            }
            alphaK = mK[i] / deltaK[i];
            betaK = mK[i + 1] / deltaK[i];
            squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
            if (squaredMagnitude <= 9) {
              continue;
            }
            tauK = 3 / Math.sqrt(squaredMagnitude);
            mK[i] = alphaK * tauK * deltaK[i];
            mK[i + 1] = betaK * tauK * deltaK[i];
          }
        }
        function monotoneCompute(points, mK, indexAxis = "x") {
          const valueAxis = getValueAxis(indexAxis);
          const pointsLen = points.length;
          let delta, pointBefore, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (let i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
              continue;
            }
            const iPixel = pointCurrent[indexAxis];
            const vPixel = pointCurrent[valueAxis];
            if (pointBefore) {
              delta = (iPixel - pointBefore[indexAxis]) / 3;
              pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
              pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
            }
            if (pointAfter) {
              delta = (pointAfter[indexAxis] - iPixel) / 3;
              pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
              pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
            }
          }
        }
        function splineCurveMonotone(points, indexAxis = "x") {
          const valueAxis = getValueAxis(indexAxis);
          const pointsLen = points.length;
          const deltaK = Array(pointsLen).fill(0);
          const mK = Array(pointsLen);
          let i, pointBefore, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
              continue;
            }
            if (pointAfter) {
              const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
              deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
            }
            mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
          }
          monotoneAdjust(points, deltaK, mK);
          monotoneCompute(points, mK, indexAxis);
        }
        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }
        function capBezierPoints(points, area) {
          let i, ilen, point, inArea, inAreaPrev;
          let inAreaNext = _isPointInArea(points[0], area);
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            inAreaPrev = inArea;
            inArea = inAreaNext;
            inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
            if (!inArea) {
              continue;
            }
            point = points[i];
            if (inAreaPrev) {
              point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
              point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
            }
            if (inAreaNext) {
              point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
              point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
            }
          }
        }
        function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
          let i, ilen, point, controlPoints;
          if (options.spanGaps) {
            points = points.filter((pt) => !pt.skip);
          }
          if (options.cubicInterpolationMode === "monotone") {
            splineCurveMonotone(points, indexAxis);
          } else {
            let prev = loop ? points[points.length - 1] : points[0];
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              point = points[i];
              controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
              point.cp1x = controlPoints.previous.x;
              point.cp1y = controlPoints.previous.y;
              point.cp2x = controlPoints.next.x;
              point.cp2y = controlPoints.next.y;
              prev = point;
            }
          }
          if (options.capBezierPoints) {
            capBezierPoints(points, area);
          }
        }
        const atEdge = (t) => t === 0 || t === 1;
        const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
        const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
        const effects = {
          linear: (t) => t,
          easeInQuad: (t) => t * t,
          easeOutQuad: (t) => -t * (t - 2),
          easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
          easeInCubic: (t) => t * t * t,
          easeOutCubic: (t) => (t -= 1) * t * t + 1,
          easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
          easeInQuart: (t) => t * t * t * t,
          easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
          easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
          easeInQuint: (t) => t * t * t * t * t,
          easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
          easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
          easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
          easeOutSine: (t) => Math.sin(t * HALF_PI),
          easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
          easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
          easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
          easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
          easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
          easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
          easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
          easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
          easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
          easeInOutElastic(t) {
            const s = 0.1125;
            const p = 0.45;
            return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
          },
          easeInBack(t) {
            const s = 1.70158;
            return t * t * ((s + 1) * t - s);
          },
          easeOutBack(t) {
            const s = 1.70158;
            return (t -= 1) * t * ((s + 1) * t + s) + 1;
          },
          easeInOutBack(t) {
            let s = 1.70158;
            if ((t /= 0.5) < 1) {
              return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
            }
            return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
          },
          easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
          easeOutBounce(t) {
            const m = 7.5625;
            const d = 2.75;
            if (t < 1 / d) {
              return m * t * t;
            }
            if (t < 2 / d) {
              return m * (t -= 1.5 / d) * t + 0.75;
            }
            if (t < 2.5 / d) {
              return m * (t -= 2.25 / d) * t + 0.9375;
            }
            return m * (t -= 2.625 / d) * t + 0.984375;
          },
          easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
        };
        function _pointInLine(p1, p2, t, mode) {
          return {
            x: p1.x + t * (p2.x - p1.x),
            y: p1.y + t * (p2.y - p1.y)
          };
        }
        function _steppedInterpolation(p1, p2, t, mode) {
          return {
            x: p1.x + t * (p2.x - p1.x),
            y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
          };
        }
        function _bezierInterpolation(p1, p2, t, mode) {
          const cp1 = { x: p1.cp2x, y: p1.cp2y };
          const cp2 = { x: p2.cp1x, y: p2.cp1y };
          const a = _pointInLine(p1, cp1, t);
          const b = _pointInLine(cp1, cp2, t);
          const c = _pointInLine(cp2, p2, t);
          const d = _pointInLine(a, b, t);
          const e = _pointInLine(b, c, t);
          return _pointInLine(d, e, t);
        }
        const intlCache = /* @__PURE__ */ new Map();
        function getNumberFormat(locale, options) {
          options = options || {};
          const cacheKey = locale + JSON.stringify(options);
          let formatter = intlCache.get(cacheKey);
          if (!formatter) {
            formatter = new Intl.NumberFormat(locale, options);
            intlCache.set(cacheKey, formatter);
          }
          return formatter;
        }
        function formatNumber(num, locale, options) {
          return getNumberFormat(locale, options).format(num);
        }
        const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
        const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
        function toLineHeight(value, size) {
          const matches = ("" + value).match(LINE_HEIGHT);
          if (!matches || matches[1] === "normal") {
            return size * 1.2;
          }
          value = +matches[2];
          switch (matches[3]) {
            case "px":
              return value;
            case "%":
              value /= 100;
              break;
          }
          return size * value;
        }
        const numberOrZero = (v) => +v || 0;
        function _readValueToProps(value, props) {
          const ret = {};
          const objProps = isObject2(props);
          const keys = objProps ? Object.keys(props) : props;
          const read = isObject2(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
          for (const prop of keys) {
            ret[prop] = numberOrZero(read(prop));
          }
          return ret;
        }
        function toTRBL(value) {
          return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
        }
        function toTRBLCorners(value) {
          return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
        }
        function toPadding(value) {
          const obj = toTRBL(value);
          obj.width = obj.left + obj.right;
          obj.height = obj.top + obj.bottom;
          return obj;
        }
        function toFont(options, fallback) {
          options = options || {};
          fallback = fallback || defaults.font;
          let size = valueOrDefault(options.size, fallback.size);
          if (typeof size === "string") {
            size = parseInt(size, 10);
          }
          let style = valueOrDefault(options.style, fallback.style);
          if (style && !("" + style).match(FONT_STYLE)) {
            console.warn('Invalid font style specified: "' + style + '"');
            style = "";
          }
          const font = {
            family: valueOrDefault(options.family, fallback.family),
            lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
            size,
            style,
            weight: valueOrDefault(options.weight, fallback.weight),
            string: ""
          };
          font.string = toFontString(font);
          return font;
        }
        function resolve(inputs, context, index2, info) {
          let cacheable = true;
          let i, ilen, value;
          for (i = 0, ilen = inputs.length; i < ilen; ++i) {
            value = inputs[i];
            if (value === void 0) {
              continue;
            }
            if (context !== void 0 && typeof value === "function") {
              value = value(context);
              cacheable = false;
            }
            if (index2 !== void 0 && isArray(value)) {
              value = value[index2 % value.length];
              cacheable = false;
            }
            if (value !== void 0) {
              if (info && !cacheable) {
                info.cacheable = false;
              }
              return value;
            }
          }
        }
        function _addGrace(minmax, grace, beginAtZero) {
          const { min, max } = minmax;
          const change = toDimension(grace, (max - min) / 2);
          const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
          return {
            min: keepZero(min, -Math.abs(change)),
            max: keepZero(max, change)
          };
        }
        function createContext(parentContext, context) {
          return Object.assign(Object.create(parentContext), context);
        }
        const getRightToLeftAdapter = function(rectX, width) {
          return {
            x(x) {
              return rectX + rectX + width - x;
            },
            setWidth(w) {
              width = w;
            },
            textAlign(align) {
              if (align === "center") {
                return align;
              }
              return align === "right" ? "left" : "right";
            },
            xPlus(x, value) {
              return x - value;
            },
            leftForLtr(x, itemWidth) {
              return x - itemWidth;
            }
          };
        };
        const getLeftToRightAdapter = function() {
          return {
            x(x) {
              return x;
            },
            setWidth(w) {
            },
            textAlign(align) {
              return align;
            },
            xPlus(x, value) {
              return x + value;
            },
            leftForLtr(x, _itemWidth) {
              return x;
            }
          };
        };
        function getRtlAdapter(rtl, rectX, width) {
          return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
        }
        function overrideTextDirection(ctx, direction) {
          let style, original;
          if (direction === "ltr" || direction === "rtl") {
            style = ctx.canvas.style;
            original = [
              style.getPropertyValue("direction"),
              style.getPropertyPriority("direction")
            ];
            style.setProperty("direction", direction, "important");
            ctx.prevTextDirection = original;
          }
        }
        function restoreTextDirection(ctx, original) {
          if (original !== void 0) {
            delete ctx.prevTextDirection;
            ctx.canvas.style.setProperty("direction", original[0], original[1]);
          }
        }
        function propertyFn(property) {
          if (property === "angle") {
            return {
              between: _angleBetween,
              compare: _angleDiff,
              normalize: _normalizeAngle
            };
          }
          return {
            between: _isBetween,
            compare: (a, b) => a - b,
            normalize: (x) => x
          };
        }
        function normalizeSegment({ start, end, count, loop, style }) {
          return {
            start: start % count,
            end: end % count,
            loop: loop && (end - start + 1) % count === 0,
            style
          };
        }
        function getSegment(segment, points, bounds) {
          const { property, start: startBound, end: endBound } = bounds;
          const { between, normalize } = propertyFn(property);
          const count = points.length;
          let { start, end, loop } = segment;
          let i, ilen;
          if (loop) {
            start += count;
            end += count;
            for (i = 0, ilen = count; i < ilen; ++i) {
              if (!between(normalize(points[start % count][property]), startBound, endBound)) {
                break;
              }
              start--;
              end--;
            }
            start %= count;
            end %= count;
          }
          if (end < start) {
            end += count;
          }
          return { start, end, loop, style: segment.style };
        }
        function _boundSegment(segment, points, bounds) {
          if (!bounds) {
            return [segment];
          }
          const { property, start: startBound, end: endBound } = bounds;
          const count = points.length;
          const { compare, between, normalize } = propertyFn(property);
          const { start, end, loop, style } = getSegment(segment, points, bounds);
          const result = [];
          let inside = false;
          let subStart = null;
          let value, point, prevValue;
          const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
          const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
          const shouldStart = () => inside || startIsBefore();
          const shouldStop = () => !inside || endIsBefore();
          for (let i = start, prev = start; i <= end; ++i) {
            point = points[i % count];
            if (point.skip) {
              continue;
            }
            value = normalize(point[property]);
            if (value === prevValue) {
              continue;
            }
            inside = between(value, startBound, endBound);
            if (subStart === null && shouldStart()) {
              subStart = compare(value, startBound) === 0 ? i : prev;
            }
            if (subStart !== null && shouldStop()) {
              result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
              subStart = null;
            }
            prev = i;
            prevValue = value;
          }
          if (subStart !== null) {
            result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
          }
          return result;
        }
        function _boundSegments(line, bounds) {
          const result = [];
          const segments = line.segments;
          for (let i = 0; i < segments.length; i++) {
            const sub = _boundSegment(segments[i], line.points, bounds);
            if (sub.length) {
              result.push(...sub);
            }
          }
          return result;
        }
        function findStartAndEnd(points, count, loop, spanGaps) {
          let start = 0;
          let end = count - 1;
          if (loop && !spanGaps) {
            while (start < count && !points[start].skip) {
              start++;
            }
          }
          while (start < count && points[start].skip) {
            start++;
          }
          start %= count;
          if (loop) {
            end += start;
          }
          while (end > start && points[end % count].skip) {
            end--;
          }
          end %= count;
          return { start, end };
        }
        function solidSegments(points, start, max, loop) {
          const count = points.length;
          const result = [];
          let last = start;
          let prev = points[start];
          let end;
          for (end = start + 1; end <= max; ++end) {
            const cur = points[end % count];
            if (cur.skip || cur.stop) {
              if (!prev.skip) {
                loop = false;
                result.push({ start: start % count, end: (end - 1) % count, loop });
                start = last = cur.stop ? end : null;
              }
            } else {
              last = end;
              if (prev.skip) {
                start = end;
              }
            }
            prev = cur;
          }
          if (last !== null) {
            result.push({ start: start % count, end: last % count, loop });
          }
          return result;
        }
        function _computeSegments(line, segmentOptions) {
          const points = line.points;
          const spanGaps = line.options.spanGaps;
          const count = points.length;
          if (!count) {
            return [];
          }
          const loop = !!line._loop;
          const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
          if (spanGaps === true) {
            return splitByStyles(line, [{ start, end, loop }], points, segmentOptions);
          }
          const max = end < start ? end + count : end;
          const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
          return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
        }
        function splitByStyles(line, segments, points, segmentOptions) {
          if (!segmentOptions || !segmentOptions.setContext || !points) {
            return segments;
          }
          return doSplitByStyles(line, segments, points, segmentOptions);
        }
        function doSplitByStyles(line, segments, points, segmentOptions) {
          const chartContext = line._chart.getContext();
          const baseStyle = readStyle(line.options);
          const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
          const count = points.length;
          const result = [];
          let prevStyle = baseStyle;
          let start = segments[0].start;
          let i = start;
          function addStyle(s, e, l, st) {
            const dir = spanGaps ? -1 : 1;
            if (s === e) {
              return;
            }
            s += count;
            while (points[s % count].skip) {
              s -= dir;
            }
            while (points[e % count].skip) {
              e += dir;
            }
            if (s % count !== e % count) {
              result.push({ start: s % count, end: e % count, loop: l, style: st });
              prevStyle = st;
              start = e % count;
            }
          }
          for (const segment of segments) {
            start = spanGaps ? start : segment.start;
            let prev = points[start % count];
            let style;
            for (i = start + 1; i <= segment.end; i++) {
              const pt = points[i % count];
              style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                type: "segment",
                p0: prev,
                p1: pt,
                p0DataIndex: (i - 1) % count,
                p1DataIndex: i % count,
                datasetIndex
              })));
              if (styleChanged(style, prevStyle)) {
                addStyle(start, i - 1, segment.loop, prevStyle);
              }
              prev = pt;
              prevStyle = style;
            }
            if (start < i - 1) {
              addStyle(start, i - 1, segment.loop, prevStyle);
            }
          }
          return result;
        }
        function readStyle(options) {
          return {
            backgroundColor: options.backgroundColor,
            borderCapStyle: options.borderCapStyle,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderJoinStyle: options.borderJoinStyle,
            borderWidth: options.borderWidth,
            borderColor: options.borderColor
          };
        }
        function styleChanged(style, prevStyle) {
          return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
        }
        var helpers = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          easingEffects: effects,
          isPatternOrGradient,
          color,
          getHoverColor,
          noop: noop2,
          uid,
          isNullOrUndef,
          isArray,
          isObject: isObject2,
          isFinite: isNumberFinite,
          finiteOrDefault,
          valueOrDefault,
          toPercentage,
          toDimension,
          callback,
          each,
          _elementsEqual,
          clone: clone2,
          _merger,
          merge,
          mergeIf,
          _mergerIf,
          _deprecated,
          resolveObjectKey,
          _capitalize,
          defined,
          isFunction,
          setsEqual,
          _isClickEvent,
          toFontString,
          _measureText,
          _longestText,
          _alignPixel,
          clearCanvas,
          drawPoint,
          _isPointInArea,
          clipArea,
          unclipArea,
          _steppedLineTo,
          _bezierCurveTo,
          renderText,
          addRoundedRectPath,
          _lookup,
          _lookupByKey,
          _rlookupByKey,
          _filterBetween,
          listenArrayEvents,
          unlistenArrayEvents,
          _arrayUnique,
          _createResolver,
          _attachContext,
          _descriptors,
          _parseObjectDataRadialScale,
          splineCurve,
          splineCurveMonotone,
          _updateBezierControlPoints,
          _isDomSupported,
          _getParentNode,
          getStyle,
          getRelativePosition,
          getMaximumSize,
          retinaScale,
          supportsEventListenerOptions,
          readUsedSize,
          fontString,
          requestAnimFrame,
          throttled,
          debounce,
          _toLeftRightCenter,
          _alignStartEnd,
          _textX,
          _pointInLine,
          _steppedInterpolation,
          _bezierInterpolation,
          formatNumber,
          toLineHeight,
          _readValueToProps,
          toTRBL,
          toTRBLCorners,
          toPadding,
          toFont,
          resolve,
          _addGrace,
          createContext,
          PI,
          TAU,
          PITAU,
          INFINITY,
          RAD_PER_DEG,
          HALF_PI,
          QUARTER_PI,
          TWO_THIRDS_PI,
          log10,
          sign,
          niceNum,
          _factorize,
          isNumber,
          almostEquals,
          almostWhole,
          _setMinAndMaxByKey,
          toRadians,
          toDegrees,
          _decimalPlaces,
          getAngleFromPoint,
          distanceBetweenPoints,
          _angleDiff,
          _normalizeAngle,
          _angleBetween,
          _limitValue,
          _int16Range,
          _isBetween,
          getRtlAdapter,
          overrideTextDirection,
          restoreTextDirection,
          _boundSegment,
          _boundSegments,
          _computeSegments
        });
        function binarySearch(metaset, axis, value, intersect) {
          const { controller, data, _sorted } = metaset;
          const iScale = controller._cachedMeta.iScale;
          if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
            const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
            if (!intersect) {
              return lookupMethod(data, axis, value);
            } else if (controller._sharedOptions) {
              const el = data[0];
              const range2 = typeof el.getRange === "function" && el.getRange(axis);
              if (range2) {
                const start = lookupMethod(data, axis, value - range2);
                const end = lookupMethod(data, axis, value + range2);
                return { lo: start.lo, hi: end.hi };
              }
            }
          }
          return { lo: 0, hi: data.length - 1 };
        }
        function evaluateInteractionItems(chart2, axis, position, handler, intersect) {
          const metasets = chart2.getSortedVisibleDatasetMetas();
          const value = position[axis];
          for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
            const { index: index2, data } = metasets[i];
            const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
            for (let j = lo; j <= hi; ++j) {
              const element = data[j];
              if (!element.skip) {
                handler(element, index2, j);
              }
            }
          }
        }
        function getDistanceMetricForAxis(axis) {
          const useX = axis.indexOf("x") !== -1;
          const useY = axis.indexOf("y") !== -1;
          return function(pt1, pt2) {
            const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
            const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          };
        }
        function getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) {
          const items = [];
          if (!includeInvisible && !chart2.isPointInArea(position)) {
            return items;
          }
          const evaluationFunc = function(element, datasetIndex, index2) {
            if (!includeInvisible && !_isPointInArea(element, chart2.chartArea, 0)) {
              return;
            }
            if (element.inRange(position.x, position.y, useFinalPosition)) {
              items.push({ element, datasetIndex, index: index2 });
            }
          };
          evaluateInteractionItems(chart2, axis, position, evaluationFunc, true);
          return items;
        }
        function getNearestRadialItems(chart2, position, axis, useFinalPosition) {
          let items = [];
          function evaluationFunc(element, datasetIndex, index2) {
            const { startAngle, endAngle } = element.getProps(["startAngle", "endAngle"], useFinalPosition);
            const { angle } = getAngleFromPoint(element, { x: position.x, y: position.y });
            if (_angleBetween(angle, startAngle, endAngle)) {
              items.push({ element, datasetIndex, index: index2 });
            }
          }
          evaluateInteractionItems(chart2, axis, position, evaluationFunc);
          return items;
        }
        function getNearestCartesianItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible) {
          let items = [];
          const distanceMetric = getDistanceMetricForAxis(axis);
          let minDistance = Number.POSITIVE_INFINITY;
          function evaluationFunc(element, datasetIndex, index2) {
            const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
            if (intersect && !inRange2) {
              return;
            }
            const center = element.getCenterPoint(useFinalPosition);
            const pointInArea = !!includeInvisible || chart2.isPointInArea(center);
            if (!pointInArea && !inRange2) {
              return;
            }
            const distance = distanceMetric(position, center);
            if (distance < minDistance) {
              items = [{ element, datasetIndex, index: index2 }];
              minDistance = distance;
            } else if (distance === minDistance) {
              items.push({ element, datasetIndex, index: index2 });
            }
          }
          evaluateInteractionItems(chart2, axis, position, evaluationFunc);
          return items;
        }
        function getNearestItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible) {
          if (!includeInvisible && !chart2.isPointInArea(position)) {
            return [];
          }
          return axis === "r" && !intersect ? getNearestRadialItems(chart2, position, axis, useFinalPosition) : getNearestCartesianItems(chart2, position, axis, intersect, useFinalPosition, includeInvisible);
        }
        function getAxisItems(chart2, position, axis, intersect, useFinalPosition) {
          const items = [];
          const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
          let intersectsItem = false;
          evaluateInteractionItems(chart2, axis, position, (element, datasetIndex, index2) => {
            if (element[rangeMethod](position[axis], useFinalPosition)) {
              items.push({ element, datasetIndex, index: index2 });
              intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
            }
          });
          if (intersect && !intersectsItem) {
            return [];
          }
          return items;
        }
        var Interaction = {
          evaluateInteractionItems,
          modes: {
            index(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "x";
              const includeInvisible = options.includeInvisible || false;
              const items = options.intersect ? getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart2, position, axis, false, useFinalPosition, includeInvisible);
              const elements2 = [];
              if (!items.length) {
                return [];
              }
              chart2.getSortedVisibleDatasetMetas().forEach((meta) => {
                const index2 = items[0].index;
                const element = meta.data[index2];
                if (element && !element.skip) {
                  elements2.push({ element, datasetIndex: meta.index, index: index2 });
                }
              });
              return elements2;
            },
            dataset(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              let items = options.intersect ? getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart2, position, axis, false, useFinalPosition, includeInvisible);
              if (items.length > 0) {
                const datasetIndex = items[0].datasetIndex;
                const data = chart2.getDatasetMeta(datasetIndex).data;
                items = [];
                for (let i = 0; i < data.length; ++i) {
                  items.push({ element: data[i], datasetIndex, index: i });
                }
              }
              return items;
            },
            point(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              return getIntersectItems(chart2, position, axis, useFinalPosition, includeInvisible);
            },
            nearest(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              const axis = options.axis || "xy";
              const includeInvisible = options.includeInvisible || false;
              return getNearestItems(chart2, position, axis, options.intersect, useFinalPosition, includeInvisible);
            },
            x(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              return getAxisItems(chart2, position, "x", options.intersect, useFinalPosition);
            },
            y(chart2, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart2);
              return getAxisItems(chart2, position, "y", options.intersect, useFinalPosition);
            }
          }
        };
        const STATIC_POSITIONS = ["left", "top", "right", "bottom"];
        function filterByPosition(array, position) {
          return array.filter((v) => v.pos === position);
        }
        function filterDynamicPositionByAxis(array, axis) {
          return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
        }
        function sortByWeight(array, reverse) {
          return array.sort((a, b) => {
            const v0 = reverse ? b : a;
            const v1 = reverse ? a : b;
            return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
          });
        }
        function wrapBoxes(boxes) {
          const layoutBoxes = [];
          let i, ilen, box, pos, stack, stackWeight;
          for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
            box = boxes[i];
            ({ position: pos, options: { stack, stackWeight = 1 } } = box);
            layoutBoxes.push({
              index: i,
              box,
              pos,
              horizontal: box.isHorizontal(),
              weight: box.weight,
              stack: stack && pos + stack,
              stackWeight
            });
          }
          return layoutBoxes;
        }
        function buildStacks(layouts2) {
          const stacks = {};
          for (const wrap of layouts2) {
            const { stack, pos, stackWeight } = wrap;
            if (!stack || !STATIC_POSITIONS.includes(pos)) {
              continue;
            }
            const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
            _stack.count++;
            _stack.weight += stackWeight;
          }
          return stacks;
        }
        function setLayoutDims(layouts2, params) {
          const stacks = buildStacks(layouts2);
          const { vBoxMaxWidth, hBoxMaxHeight } = params;
          let i, ilen, layout;
          for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
            layout = layouts2[i];
            const { fullSize } = layout.box;
            const stack = stacks[layout.stack];
            const factor = stack && layout.stackWeight / stack.weight;
            if (layout.horizontal) {
              layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
              layout.height = hBoxMaxHeight;
            } else {
              layout.width = vBoxMaxWidth;
              layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
            }
          }
          return stacks;
        }
        function buildLayoutBoxes(boxes) {
          const layoutBoxes = wrapBoxes(boxes);
          const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
          const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
          const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
          const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
          const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
          const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
          const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
          return {
            fullSize,
            leftAndTop: left.concat(top),
            rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
            chartArea: filterByPosition(layoutBoxes, "chartArea"),
            vertical: left.concat(right).concat(centerVertical),
            horizontal: top.concat(bottom).concat(centerHorizontal)
          };
        }
        function getCombinedMax(maxPadding, chartArea, a, b) {
          return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
        }
        function updateMaxPadding(maxPadding, boxPadding) {
          maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
          maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
          maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
          maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
        }
        function updateDims(chartArea, params, layout, stacks) {
          const { pos, box } = layout;
          const maxPadding = chartArea.maxPadding;
          if (!isObject2(pos)) {
            if (layout.size) {
              chartArea[pos] -= layout.size;
            }
            const stack = stacks[layout.stack] || { size: 0, count: 1 };
            stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
            layout.size = stack.size / stack.count;
            chartArea[pos] += layout.size;
          }
          if (box.getPadding) {
            updateMaxPadding(maxPadding, box.getPadding());
          }
          const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
          const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
          const widthChanged = newWidth !== chartArea.w;
          const heightChanged = newHeight !== chartArea.h;
          chartArea.w = newWidth;
          chartArea.h = newHeight;
          return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
        }
        function handleMaxPadding(chartArea) {
          const maxPadding = chartArea.maxPadding;
          function updatePos(pos) {
            const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
            chartArea[pos] += change;
            return change;
          }
          chartArea.y += updatePos("top");
          chartArea.x += updatePos("left");
          updatePos("right");
          updatePos("bottom");
        }
        function getMargins(horizontal, chartArea) {
          const maxPadding = chartArea.maxPadding;
          function marginForPositions(positions2) {
            const margin = { left: 0, top: 0, right: 0, bottom: 0 };
            positions2.forEach((pos) => {
              margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            });
            return margin;
          }
          return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
        }
        function fitBoxes(boxes, chartArea, params, stacks) {
          const refitBoxes = [];
          let i, ilen, layout, box, refit, changed;
          for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
            const { same, other } = updateDims(chartArea, params, layout, stacks);
            refit |= same && refitBoxes.length;
            changed = changed || other;
            if (!box.fullSize) {
              refitBoxes.push(layout);
            }
          }
          return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
        }
        function setBoxDims(box, left, top, width, height) {
          box.top = top;
          box.left = left;
          box.right = left + width;
          box.bottom = top + height;
          box.width = width;
          box.height = height;
        }
        function placeBoxes(boxes, chartArea, params, stacks) {
          const userPadding = params.padding;
          let { x, y } = chartArea;
          for (const layout of boxes) {
            const box = layout.box;
            const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
            const weight = layout.stackWeight / stack.weight || 1;
            if (layout.horizontal) {
              const width = chartArea.w * weight;
              const height = stack.size || box.height;
              if (defined(stack.start)) {
                y = stack.start;
              }
              if (box.fullSize) {
                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
              } else {
                setBoxDims(box, chartArea.left + stack.placed, y, width, height);
              }
              stack.start = y;
              stack.placed += width;
              y = box.bottom;
            } else {
              const height = chartArea.h * weight;
              const width = stack.size || box.width;
              if (defined(stack.start)) {
                x = stack.start;
              }
              if (box.fullSize) {
                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
              } else {
                setBoxDims(box, x, chartArea.top + stack.placed, width, height);
              }
              stack.start = x;
              stack.placed += height;
              x = box.right;
            }
          }
          chartArea.x = x;
          chartArea.y = y;
        }
        defaults.set("layout", {
          autoPadding: true,
          padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          }
        });
        var layouts = {
          addBox(chart2, item) {
            if (!chart2.boxes) {
              chart2.boxes = [];
            }
            item.fullSize = item.fullSize || false;
            item.position = item.position || "top";
            item.weight = item.weight || 0;
            item._layers = item._layers || function() {
              return [{
                z: 0,
                draw(chartArea) {
                  item.draw(chartArea);
                }
              }];
            };
            chart2.boxes.push(item);
          },
          removeBox(chart2, layoutItem) {
            const index2 = chart2.boxes ? chart2.boxes.indexOf(layoutItem) : -1;
            if (index2 !== -1) {
              chart2.boxes.splice(index2, 1);
            }
          },
          configure(chart2, item, options) {
            item.fullSize = options.fullSize;
            item.position = options.position;
            item.weight = options.weight;
          },
          update(chart2, width, height, minPadding) {
            if (!chart2) {
              return;
            }
            const padding = toPadding(chart2.options.layout.padding);
            const availableWidth = Math.max(width - padding.width, 0);
            const availableHeight = Math.max(height - padding.height, 0);
            const boxes = buildLayoutBoxes(chart2.boxes);
            const verticalBoxes = boxes.vertical;
            const horizontalBoxes = boxes.horizontal;
            each(chart2.boxes, (box) => {
              if (typeof box.beforeLayout === "function") {
                box.beforeLayout();
              }
            });
            const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
            const params = Object.freeze({
              outerWidth: width,
              outerHeight: height,
              padding,
              availableWidth,
              availableHeight,
              vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
              hBoxMaxHeight: availableHeight / 2
            });
            const maxPadding = Object.assign({}, padding);
            updateMaxPadding(maxPadding, toPadding(minPadding));
            const chartArea = Object.assign({
              maxPadding,
              w: availableWidth,
              h: availableHeight,
              x: padding.left,
              y: padding.top
            }, padding);
            const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
            fitBoxes(boxes.fullSize, chartArea, params, stacks);
            fitBoxes(verticalBoxes, chartArea, params, stacks);
            if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
              fitBoxes(verticalBoxes, chartArea, params, stacks);
            }
            handleMaxPadding(chartArea);
            placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
            chartArea.x += chartArea.w;
            chartArea.y += chartArea.h;
            placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
            chart2.chartArea = {
              left: chartArea.left,
              top: chartArea.top,
              right: chartArea.left + chartArea.w,
              bottom: chartArea.top + chartArea.h,
              height: chartArea.h,
              width: chartArea.w
            };
            each(boxes.chartArea, (layout) => {
              const box = layout.box;
              Object.assign(box, chart2.chartArea);
              box.update(chartArea.w, chartArea.h, { left: 0, top: 0, right: 0, bottom: 0 });
            });
          }
        };
        class BasePlatform {
          acquireContext(canvas, aspectRatio) {
          }
          releaseContext(context) {
            return false;
          }
          addEventListener(chart2, type, listener) {
          }
          removeEventListener(chart2, type, listener) {
          }
          getDevicePixelRatio() {
            return 1;
          }
          getMaximumSize(element, width, height, aspectRatio) {
            width = Math.max(0, width || element.width);
            height = height || element.height;
            return {
              width,
              height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
            };
          }
          isAttached(canvas) {
            return true;
          }
          updateConfig(config) {
          }
        }
        class BasicPlatform extends BasePlatform {
          acquireContext(item) {
            return item && item.getContext && item.getContext("2d") || null;
          }
          updateConfig(config) {
            config.options.animation = false;
          }
        }
        const EXPANDO_KEY = "$chartjs";
        const EVENT_TYPES = {
          touchstart: "mousedown",
          touchmove: "mousemove",
          touchend: "mouseup",
          pointerenter: "mouseenter",
          pointerdown: "mousedown",
          pointermove: "mousemove",
          pointerup: "mouseup",
          pointerleave: "mouseout",
          pointerout: "mouseout"
        };
        const isNullOrEmpty = (value) => value === null || value === "";
        function initCanvas(canvas, aspectRatio) {
          const style = canvas.style;
          const renderHeight = canvas.getAttribute("height");
          const renderWidth = canvas.getAttribute("width");
          canvas[EXPANDO_KEY] = {
            initial: {
              height: renderHeight,
              width: renderWidth,
              style: {
                display: style.display,
                height: style.height,
                width: style.width
              }
            }
          };
          style.display = style.display || "block";
          style.boxSizing = style.boxSizing || "border-box";
          if (isNullOrEmpty(renderWidth)) {
            const displayWidth = readUsedSize(canvas, "width");
            if (displayWidth !== void 0) {
              canvas.width = displayWidth;
            }
          }
          if (isNullOrEmpty(renderHeight)) {
            if (canvas.style.height === "") {
              canvas.height = canvas.width / (aspectRatio || 2);
            } else {
              const displayHeight = readUsedSize(canvas, "height");
              if (displayHeight !== void 0) {
                canvas.height = displayHeight;
              }
            }
          }
          return canvas;
        }
        const eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
        function addListener(node, type, listener) {
          node.addEventListener(type, listener, eventListenerOptions);
        }
        function removeListener(chart2, type, listener) {
          chart2.canvas.removeEventListener(type, listener, eventListenerOptions);
        }
        function fromNativeEvent(event, chart2) {
          const type = EVENT_TYPES[event.type] || event.type;
          const { x, y } = getRelativePosition(event, chart2);
          return {
            type,
            chart: chart2,
            native: event,
            x: x !== void 0 ? x : null,
            y: y !== void 0 ? y : null
          };
        }
        function nodeListContains(nodeList, canvas) {
          for (const node of nodeList) {
            if (node === canvas || node.contains(canvas)) {
              return true;
            }
          }
        }
        function createAttachObserver(chart2, type, listener) {
          const canvas = chart2.canvas;
          const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
              trigger = trigger || nodeListContains(entry.addedNodes, canvas);
              trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
            }
            if (trigger) {
              listener();
            }
          });
          observer.observe(document, { childList: true, subtree: true });
          return observer;
        }
        function createDetachObserver(chart2, type, listener) {
          const canvas = chart2.canvas;
          const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
              trigger = trigger || nodeListContains(entry.removedNodes, canvas);
              trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
            }
            if (trigger) {
              listener();
            }
          });
          observer.observe(document, { childList: true, subtree: true });
          return observer;
        }
        const drpListeningCharts = /* @__PURE__ */ new Map();
        let oldDevicePixelRatio = 0;
        function onWindowResize() {
          const dpr = window.devicePixelRatio;
          if (dpr === oldDevicePixelRatio) {
            return;
          }
          oldDevicePixelRatio = dpr;
          drpListeningCharts.forEach((resize, chart2) => {
            if (chart2.currentDevicePixelRatio !== dpr) {
              resize();
            }
          });
        }
        function listenDevicePixelRatioChanges(chart2, resize) {
          if (!drpListeningCharts.size) {
            window.addEventListener("resize", onWindowResize);
          }
          drpListeningCharts.set(chart2, resize);
        }
        function unlistenDevicePixelRatioChanges(chart2) {
          drpListeningCharts.delete(chart2);
          if (!drpListeningCharts.size) {
            window.removeEventListener("resize", onWindowResize);
          }
        }
        function createResizeObserver(chart2, type, listener) {
          const canvas = chart2.canvas;
          const container = canvas && _getParentNode(canvas);
          if (!container) {
            return;
          }
          const resize = throttled((width, height) => {
            const w = container.clientWidth;
            listener(width, height);
            if (w < container.clientWidth) {
              listener();
            }
          }, window);
          const observer = new ResizeObserver((entries) => {
            const entry = entries[0];
            const width = entry.contentRect.width;
            const height = entry.contentRect.height;
            if (width === 0 && height === 0) {
              return;
            }
            resize(width, height);
          });
          observer.observe(container);
          listenDevicePixelRatioChanges(chart2, resize);
          return observer;
        }
        function releaseObserver(chart2, type, observer) {
          if (observer) {
            observer.disconnect();
          }
          if (type === "resize") {
            unlistenDevicePixelRatioChanges(chart2);
          }
        }
        function createProxyAndListen(chart2, type, listener) {
          const canvas = chart2.canvas;
          const proxy = throttled((event) => {
            if (chart2.ctx !== null) {
              listener(fromNativeEvent(event, chart2));
            }
          }, chart2, (args) => {
            const event = args[0];
            return [event, event.offsetX, event.offsetY];
          });
          addListener(canvas, type, proxy);
          return proxy;
        }
        class DomPlatform extends BasePlatform {
          acquireContext(canvas, aspectRatio) {
            const context = canvas && canvas.getContext && canvas.getContext("2d");
            if (context && context.canvas === canvas) {
              initCanvas(canvas, aspectRatio);
              return context;
            }
            return null;
          }
          releaseContext(context) {
            const canvas = context.canvas;
            if (!canvas[EXPANDO_KEY]) {
              return false;
            }
            const initial = canvas[EXPANDO_KEY].initial;
            ["height", "width"].forEach((prop) => {
              const value = initial[prop];
              if (isNullOrUndef(value)) {
                canvas.removeAttribute(prop);
              } else {
                canvas.setAttribute(prop, value);
              }
            });
            const style = initial.style || {};
            Object.keys(style).forEach((key) => {
              canvas.style[key] = style[key];
            });
            canvas.width = canvas.width;
            delete canvas[EXPANDO_KEY];
            return true;
          }
          addEventListener(chart2, type, listener) {
            this.removeEventListener(chart2, type);
            const proxies = chart2.$proxies || (chart2.$proxies = {});
            const handlers = {
              attach: createAttachObserver,
              detach: createDetachObserver,
              resize: createResizeObserver
            };
            const handler = handlers[type] || createProxyAndListen;
            proxies[type] = handler(chart2, type, listener);
          }
          removeEventListener(chart2, type) {
            const proxies = chart2.$proxies || (chart2.$proxies = {});
            const proxy = proxies[type];
            if (!proxy) {
              return;
            }
            const handlers = {
              attach: releaseObserver,
              detach: releaseObserver,
              resize: releaseObserver
            };
            const handler = handlers[type] || removeListener;
            handler(chart2, type, proxy);
            proxies[type] = void 0;
          }
          getDevicePixelRatio() {
            return window.devicePixelRatio;
          }
          getMaximumSize(canvas, width, height, aspectRatio) {
            return getMaximumSize(canvas, width, height, aspectRatio);
          }
          isAttached(canvas) {
            const container = _getParentNode(canvas);
            return !!(container && container.isConnected);
          }
        }
        function _detectPlatform(canvas) {
          if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
            return BasicPlatform;
          }
          return DomPlatform;
        }
        var platforms = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          _detectPlatform,
          BasePlatform,
          BasicPlatform,
          DomPlatform
        });
        const transparent = "transparent";
        const interpolators = {
          boolean(from2, to2, factor) {
            return factor > 0.5 ? to2 : from2;
          },
          color(from2, to2, factor) {
            const c0 = color(from2 || transparent);
            const c1 = c0.valid && color(to2 || transparent);
            return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
          },
          number(from2, to2, factor) {
            return from2 + (to2 - from2) * factor;
          }
        };
        class Animation {
          constructor(cfg, target, prop, to2) {
            const currentValue = target[prop];
            to2 = resolve([cfg.to, to2, currentValue, cfg.from]);
            const from2 = resolve([cfg.from, currentValue, to2]);
            this._active = true;
            this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
            this._easing = effects[cfg.easing] || effects.linear;
            this._start = Math.floor(Date.now() + (cfg.delay || 0));
            this._duration = this._total = Math.floor(cfg.duration);
            this._loop = !!cfg.loop;
            this._target = target;
            this._prop = prop;
            this._from = from2;
            this._to = to2;
            this._promises = void 0;
          }
          active() {
            return this._active;
          }
          update(cfg, to2, date) {
            if (this._active) {
              this._notify(false);
              const currentValue = this._target[this._prop];
              const elapsed = date - this._start;
              const remain = this._duration - elapsed;
              this._start = date;
              this._duration = Math.floor(Math.max(remain, cfg.duration));
              this._total += elapsed;
              this._loop = !!cfg.loop;
              this._to = resolve([cfg.to, to2, currentValue, cfg.from]);
              this._from = resolve([cfg.from, currentValue, to2]);
            }
          }
          cancel() {
            if (this._active) {
              this.tick(Date.now());
              this._active = false;
              this._notify(false);
            }
          }
          tick(date) {
            const elapsed = date - this._start;
            const duration = this._duration;
            const prop = this._prop;
            const from2 = this._from;
            const loop = this._loop;
            const to2 = this._to;
            let factor;
            this._active = from2 !== to2 && (loop || elapsed < duration);
            if (!this._active) {
              this._target[prop] = to2;
              this._notify(true);
              return;
            }
            if (elapsed < 0) {
              this._target[prop] = from2;
              return;
            }
            factor = elapsed / duration % 2;
            factor = loop && factor > 1 ? 2 - factor : factor;
            factor = this._easing(Math.min(1, Math.max(0, factor)));
            this._target[prop] = this._fn(from2, to2, factor);
          }
          wait() {
            const promises = this._promises || (this._promises = []);
            return new Promise((res, rej) => {
              promises.push({ res, rej });
            });
          }
          _notify(resolved) {
            const method = resolved ? "res" : "rej";
            const promises = this._promises || [];
            for (let i = 0; i < promises.length; i++) {
              promises[i][method]();
            }
          }
        }
        const numbers = ["x", "y", "borderWidth", "radius", "tension"];
        const colors2 = ["color", "borderColor", "backgroundColor"];
        defaults.set("animation", {
          delay: void 0,
          duration: 1e3,
          easing: "easeOutQuart",
          fn: void 0,
          from: void 0,
          loop: void 0,
          to: void 0,
          type: void 0
        });
        const animationOptions = Object.keys(defaults.animation);
        defaults.describe("animation", {
          _fallback: false,
          _indexable: false,
          _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
        });
        defaults.set("animations", {
          colors: {
            type: "color",
            properties: colors2
          },
          numbers: {
            type: "number",
            properties: numbers
          }
        });
        defaults.describe("animations", {
          _fallback: "animation"
        });
        defaults.set("transitions", {
          active: {
            animation: {
              duration: 400
            }
          },
          resize: {
            animation: {
              duration: 0
            }
          },
          show: {
            animations: {
              colors: {
                from: "transparent"
              },
              visible: {
                type: "boolean",
                duration: 0
              }
            }
          },
          hide: {
            animations: {
              colors: {
                to: "transparent"
              },
              visible: {
                type: "boolean",
                easing: "linear",
                fn: (v) => v | 0
              }
            }
          }
        });
        class Animations {
          constructor(chart2, config) {
            this._chart = chart2;
            this._properties = /* @__PURE__ */ new Map();
            this.configure(config);
          }
          configure(config) {
            if (!isObject2(config)) {
              return;
            }
            const animatedProps = this._properties;
            Object.getOwnPropertyNames(config).forEach((key) => {
              const cfg = config[key];
              if (!isObject2(cfg)) {
                return;
              }
              const resolved = {};
              for (const option of animationOptions) {
                resolved[option] = cfg[option];
              }
              (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
                if (prop === key || !animatedProps.has(prop)) {
                  animatedProps.set(prop, resolved);
                }
              });
            });
          }
          _animateOptions(target, values) {
            const newOptions = values.options;
            const options = resolveTargetOptions(target, newOptions);
            if (!options) {
              return [];
            }
            const animations = this._createAnimations(options, newOptions);
            if (newOptions.$shared) {
              awaitAll(target.options.$animations, newOptions).then(() => {
                target.options = newOptions;
              }, () => {
              });
            }
            return animations;
          }
          _createAnimations(target, values) {
            const animatedProps = this._properties;
            const animations = [];
            const running = target.$animations || (target.$animations = {});
            const props = Object.keys(values);
            const date = Date.now();
            let i;
            for (i = props.length - 1; i >= 0; --i) {
              const prop = props[i];
              if (prop.charAt(0) === "$") {
                continue;
              }
              if (prop === "options") {
                animations.push(...this._animateOptions(target, values));
                continue;
              }
              const value = values[prop];
              let animation = running[prop];
              const cfg = animatedProps.get(prop);
              if (animation) {
                if (cfg && animation.active()) {
                  animation.update(cfg, value, date);
                  continue;
                } else {
                  animation.cancel();
                }
              }
              if (!cfg || !cfg.duration) {
                target[prop] = value;
                continue;
              }
              running[prop] = animation = new Animation(cfg, target, prop, value);
              animations.push(animation);
            }
            return animations;
          }
          update(target, values) {
            if (this._properties.size === 0) {
              Object.assign(target, values);
              return;
            }
            const animations = this._createAnimations(target, values);
            if (animations.length) {
              animator.add(this._chart, animations);
              return true;
            }
          }
        }
        function awaitAll(animations, properties) {
          const running = [];
          const keys = Object.keys(properties);
          for (let i = 0; i < keys.length; i++) {
            const anim = animations[keys[i]];
            if (anim && anim.active()) {
              running.push(anim.wait());
            }
          }
          return Promise.all(running);
        }
        function resolveTargetOptions(target, newOptions) {
          if (!newOptions) {
            return;
          }
          let options = target.options;
          if (!options) {
            target.options = newOptions;
            return;
          }
          if (options.$shared) {
            target.options = options = Object.assign({}, options, { $shared: false, $animations: {} });
          }
          return options;
        }
        function scaleClip(scale, allowedOverflow) {
          const opts = scale && scale.options || {};
          const reverse = opts.reverse;
          const min = opts.min === void 0 ? allowedOverflow : 0;
          const max = opts.max === void 0 ? allowedOverflow : 0;
          return {
            start: reverse ? max : min,
            end: reverse ? min : max
          };
        }
        function defaultClip(xScale, yScale, allowedOverflow) {
          if (allowedOverflow === false) {
            return false;
          }
          const x = scaleClip(xScale, allowedOverflow);
          const y = scaleClip(yScale, allowedOverflow);
          return {
            top: y.end,
            right: x.end,
            bottom: y.start,
            left: x.start
          };
        }
        function toClip(value) {
          let t, r, b, l;
          if (isObject2(value)) {
            t = value.top;
            r = value.right;
            b = value.bottom;
            l = value.left;
          } else {
            t = r = b = l = value;
          }
          return {
            top: t,
            right: r,
            bottom: b,
            left: l,
            disabled: value === false
          };
        }
        function getSortedDatasetIndices(chart2, filterVisible) {
          const keys = [];
          const metasets = chart2._getSortedDatasetMetas(filterVisible);
          let i, ilen;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            keys.push(metasets[i].index);
          }
          return keys;
        }
        function applyStack(stack, value, dsIndex, options = {}) {
          const keys = stack.keys;
          const singleMode = options.mode === "single";
          let i, ilen, datasetIndex, otherValue;
          if (value === null) {
            return;
          }
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            datasetIndex = +keys[i];
            if (datasetIndex === dsIndex) {
              if (options.all) {
                continue;
              }
              break;
            }
            otherValue = stack.values[datasetIndex];
            if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
              value += otherValue;
            }
          }
          return value;
        }
        function convertObjectDataToArray(data) {
          const keys = Object.keys(data);
          const adata = new Array(keys.length);
          let i, ilen, key;
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            adata[i] = {
              x: key,
              y: data[key]
            };
          }
          return adata;
        }
        function isStacked(scale, meta) {
          const stacked = scale && scale.options.stacked;
          return stacked || stacked === void 0 && meta.stack !== void 0;
        }
        function getStackKey(indexScale, valueScale, meta) {
          return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
        }
        function getUserBounds(scale) {
          const { min, max, minDefined, maxDefined } = scale.getUserBounds();
          return {
            min: minDefined ? min : Number.NEGATIVE_INFINITY,
            max: maxDefined ? max : Number.POSITIVE_INFINITY
          };
        }
        function getOrCreateStack(stacks, stackKey, indexValue) {
          const subStack = stacks[stackKey] || (stacks[stackKey] = {});
          return subStack[indexValue] || (subStack[indexValue] = {});
        }
        function getLastIndexInStack(stack, vScale, positive, type) {
          for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
            const value = stack[meta.index];
            if (positive && value > 0 || !positive && value < 0) {
              return meta.index;
            }
          }
          return null;
        }
        function updateStacks(controller, parsed) {
          const { chart: chart2, _cachedMeta: meta } = controller;
          const stacks = chart2._stacks || (chart2._stacks = {});
          const { iScale, vScale, index: datasetIndex } = meta;
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const key = getStackKey(iScale, vScale, meta);
          const ilen = parsed.length;
          let stack;
          for (let i = 0; i < ilen; ++i) {
            const item = parsed[i];
            const { [iAxis]: index2, [vAxis]: value } = item;
            const itemStacks = item._stacks || (item._stacks = {});
            stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
            stack[datasetIndex] = value;
            stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
            stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
          }
        }
        function getFirstScaleId(chart2, axis) {
          const scales2 = chart2.scales;
          return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
        }
        function createDatasetContext(parent, index2) {
          return createContext(parent, {
            active: false,
            dataset: void 0,
            datasetIndex: index2,
            index: index2,
            mode: "default",
            type: "dataset"
          });
        }
        function createDataContext(parent, index2, element) {
          return createContext(parent, {
            active: false,
            dataIndex: index2,
            parsed: void 0,
            raw: void 0,
            element,
            index: index2,
            mode: "default",
            type: "data"
          });
        }
        function clearStacks(meta, items) {
          const datasetIndex = meta.controller.index;
          const axis = meta.vScale && meta.vScale.axis;
          if (!axis) {
            return;
          }
          items = items || meta._parsed;
          for (const parsed of items) {
            const stacks = parsed._stacks;
            if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
              return;
            }
            delete stacks[axis][datasetIndex];
          }
        }
        const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
        const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
        const createStack = (canStack, meta, chart2) => canStack && !meta.hidden && meta._stacked && { keys: getSortedDatasetIndices(chart2, true), values: null };
        class DatasetController {
          constructor(chart2, datasetIndex) {
            this.chart = chart2;
            this._ctx = chart2.ctx;
            this.index = datasetIndex;
            this._cachedDataOpts = {};
            this._cachedMeta = this.getMeta();
            this._type = this._cachedMeta.type;
            this.options = void 0;
            this._parsing = false;
            this._data = void 0;
            this._objectData = void 0;
            this._sharedOptions = void 0;
            this._drawStart = void 0;
            this._drawCount = void 0;
            this.enableOptionSharing = false;
            this.supportsDecimation = false;
            this.$context = void 0;
            this._syncList = [];
            this.initialize();
          }
          initialize() {
            const meta = this._cachedMeta;
            this.configure();
            this.linkScales();
            meta._stacked = isStacked(meta.vScale, meta);
            this.addElements();
          }
          updateIndex(datasetIndex) {
            if (this.index !== datasetIndex) {
              clearStacks(this._cachedMeta);
            }
            this.index = datasetIndex;
          }
          linkScales() {
            const chart2 = this.chart;
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
            const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart2, "x"));
            const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart2, "y"));
            const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart2, "r"));
            const indexAxis = meta.indexAxis;
            const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
            const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
            meta.xScale = this.getScaleForId(xid);
            meta.yScale = this.getScaleForId(yid);
            meta.rScale = this.getScaleForId(rid);
            meta.iScale = this.getScaleForId(iid);
            meta.vScale = this.getScaleForId(vid);
          }
          getDataset() {
            return this.chart.data.datasets[this.index];
          }
          getMeta() {
            return this.chart.getDatasetMeta(this.index);
          }
          getScaleForId(scaleID) {
            return this.chart.scales[scaleID];
          }
          _getOtherScale(scale) {
            const meta = this._cachedMeta;
            return scale === meta.iScale ? meta.vScale : meta.iScale;
          }
          reset() {
            this._update("reset");
          }
          _destroy() {
            const meta = this._cachedMeta;
            if (this._data) {
              unlistenArrayEvents(this._data, this);
            }
            if (meta._stacked) {
              clearStacks(meta);
            }
          }
          _dataCheck() {
            const dataset = this.getDataset();
            const data = dataset.data || (dataset.data = []);
            const _data = this._data;
            if (isObject2(data)) {
              this._data = convertObjectDataToArray(data);
            } else if (_data !== data) {
              if (_data) {
                unlistenArrayEvents(_data, this);
                const meta = this._cachedMeta;
                clearStacks(meta);
                meta._parsed = [];
              }
              if (data && Object.isExtensible(data)) {
                listenArrayEvents(data, this);
              }
              this._syncList = [];
              this._data = data;
            }
          }
          addElements() {
            const meta = this._cachedMeta;
            this._dataCheck();
            if (this.datasetElementType) {
              meta.dataset = new this.datasetElementType();
            }
          }
          buildOrUpdateElements(resetNewElements) {
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            let stackChanged = false;
            this._dataCheck();
            const oldStacked = meta._stacked;
            meta._stacked = isStacked(meta.vScale, meta);
            if (meta.stack !== dataset.stack) {
              stackChanged = true;
              clearStacks(meta);
              meta.stack = dataset.stack;
            }
            this._resyncElements(resetNewElements);
            if (stackChanged || oldStacked !== meta._stacked) {
              updateStacks(this, meta._parsed);
            }
          }
          configure() {
            const config = this.chart.config;
            const scopeKeys = config.datasetScopeKeys(this._type);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
            this.options = config.createResolver(scopes, this.getContext());
            this._parsing = this.options.parsing;
            this._cachedDataOpts = {};
          }
          parse(start, count) {
            const { _cachedMeta: meta, _data: data } = this;
            const { iScale, _stacked } = meta;
            const iAxis = iScale.axis;
            let sorted = start === 0 && count === data.length ? true : meta._sorted;
            let prev = start > 0 && meta._parsed[start - 1];
            let i, cur, parsed;
            if (this._parsing === false) {
              meta._parsed = data;
              meta._sorted = true;
              parsed = data;
            } else {
              if (isArray(data[start])) {
                parsed = this.parseArrayData(meta, data, start, count);
              } else if (isObject2(data[start])) {
                parsed = this.parseObjectData(meta, data, start, count);
              } else {
                parsed = this.parsePrimitiveData(meta, data, start, count);
              }
              const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
              for (i = 0; i < count; ++i) {
                meta._parsed[i + start] = cur = parsed[i];
                if (sorted) {
                  if (isNotInOrderComparedToPrev()) {
                    sorted = false;
                  }
                  prev = cur;
                }
              }
              meta._sorted = sorted;
            }
            if (_stacked) {
              updateStacks(this, parsed);
            }
          }
          parsePrimitiveData(meta, data, start, count) {
            const { iScale, vScale } = meta;
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const labels = iScale.getLabels();
            const singleScale = iScale === vScale;
            const parsed = new Array(count);
            let i, ilen, index2;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index2 = i + start;
              parsed[i] = {
                [iAxis]: singleScale || iScale.parse(labels[index2], index2),
                [vAxis]: vScale.parse(data[index2], index2)
              };
            }
            return parsed;
          }
          parseArrayData(meta, data, start, count) {
            const { xScale, yScale } = meta;
            const parsed = new Array(count);
            let i, ilen, index2, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index2 = i + start;
              item = data[index2];
              parsed[i] = {
                x: xScale.parse(item[0], index2),
                y: yScale.parse(item[1], index2)
              };
            }
            return parsed;
          }
          parseObjectData(meta, data, start, count) {
            const { xScale, yScale } = meta;
            const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
            const parsed = new Array(count);
            let i, ilen, index2, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index2 = i + start;
              item = data[index2];
              parsed[i] = {
                x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
                y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
              };
            }
            return parsed;
          }
          getParsed(index2) {
            return this._cachedMeta._parsed[index2];
          }
          getDataElement(index2) {
            return this._cachedMeta.data[index2];
          }
          applyStack(scale, parsed, mode) {
            const chart2 = this.chart;
            const meta = this._cachedMeta;
            const value = parsed[scale.axis];
            const stack = {
              keys: getSortedDatasetIndices(chart2, true),
              values: parsed._stacks[scale.axis]
            };
            return applyStack(stack, value, meta.index, { mode });
          }
          updateRangeFromParsed(range2, scale, parsed, stack) {
            const parsedValue = parsed[scale.axis];
            let value = parsedValue === null ? NaN : parsedValue;
            const values = stack && parsed._stacks[scale.axis];
            if (stack && values) {
              stack.values = values;
              value = applyStack(stack, parsedValue, this._cachedMeta.index);
            }
            range2.min = Math.min(range2.min, value);
            range2.max = Math.max(range2.max, value);
          }
          getMinMax(scale, canStack) {
            const meta = this._cachedMeta;
            const _parsed = meta._parsed;
            const sorted = meta._sorted && scale === meta.iScale;
            const ilen = _parsed.length;
            const otherScale = this._getOtherScale(scale);
            const stack = createStack(canStack, meta, this.chart);
            const range2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
            const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
            let i, parsed;
            function _skip() {
              parsed = _parsed[i];
              const otherValue = parsed[otherScale.axis];
              return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
            }
            for (i = 0; i < ilen; ++i) {
              if (_skip()) {
                continue;
              }
              this.updateRangeFromParsed(range2, scale, parsed, stack);
              if (sorted) {
                break;
              }
            }
            if (sorted) {
              for (i = ilen - 1; i >= 0; --i) {
                if (_skip()) {
                  continue;
                }
                this.updateRangeFromParsed(range2, scale, parsed, stack);
                break;
              }
            }
            return range2;
          }
          getAllParsedValues(scale) {
            const parsed = this._cachedMeta._parsed;
            const values = [];
            let i, ilen, value;
            for (i = 0, ilen = parsed.length; i < ilen; ++i) {
              value = parsed[i][scale.axis];
              if (isNumberFinite(value)) {
                values.push(value);
              }
            }
            return values;
          }
          getMaxOverflow() {
            return false;
          }
          getLabelAndValue(index2) {
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const vScale = meta.vScale;
            const parsed = this.getParsed(index2);
            return {
              label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
              value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
            };
          }
          _update(mode) {
            const meta = this._cachedMeta;
            this.update(mode || "default");
            meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
          }
          update(mode) {
          }
          draw() {
            const ctx = this._ctx;
            const chart2 = this.chart;
            const meta = this._cachedMeta;
            const elements2 = meta.data || [];
            const area = chart2.chartArea;
            const active = [];
            const start = this._drawStart || 0;
            const count = this._drawCount || elements2.length - start;
            const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
            let i;
            if (meta.dataset) {
              meta.dataset.draw(ctx, area, start, count);
            }
            for (i = start; i < start + count; ++i) {
              const element = elements2[i];
              if (element.hidden) {
                continue;
              }
              if (element.active && drawActiveElementsOnTop) {
                active.push(element);
              } else {
                element.draw(ctx, area);
              }
            }
            for (i = 0; i < active.length; ++i) {
              active[i].draw(ctx, area);
            }
          }
          getStyle(index2, active) {
            const mode = active ? "active" : "default";
            return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
          }
          getContext(index2, active, mode) {
            const dataset = this.getDataset();
            let context;
            if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
              const element = this._cachedMeta.data[index2];
              context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
              context.parsed = this.getParsed(index2);
              context.raw = dataset.data[index2];
              context.index = context.dataIndex = index2;
            } else {
              context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
              context.dataset = dataset;
              context.index = context.datasetIndex = this.index;
            }
            context.active = !!active;
            context.mode = mode;
            return context;
          }
          resolveDatasetElementOptions(mode) {
            return this._resolveElementOptions(this.datasetElementType.id, mode);
          }
          resolveDataElementOptions(index2, mode) {
            return this._resolveElementOptions(this.dataElementType.id, mode, index2);
          }
          _resolveElementOptions(elementType, mode = "default", index2) {
            const active = mode === "active";
            const cache = this._cachedDataOpts;
            const cacheKey = elementType + "-" + mode;
            const cached = cache[cacheKey];
            const sharing = this.enableOptionSharing && defined(index2);
            if (cached) {
              return cloneIfNotShared(cached, sharing);
            }
            const config = this.chart.config;
            const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
            const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            const names2 = Object.keys(defaults.elements[elementType]);
            const context = () => this.getContext(index2, active);
            const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
            if (values.$shared) {
              values.$shared = sharing;
              cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
            }
            return values;
          }
          _resolveAnimations(index2, transition, active) {
            const chart2 = this.chart;
            const cache = this._cachedDataOpts;
            const cacheKey = `animation-${transition}`;
            const cached = cache[cacheKey];
            if (cached) {
              return cached;
            }
            let options;
            if (chart2.options.animation !== false) {
              const config = this.chart.config;
              const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
              const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
              options = config.createResolver(scopes, this.getContext(index2, active, transition));
            }
            const animations = new Animations(chart2, options && options.animations);
            if (options && options._cacheable) {
              cache[cacheKey] = Object.freeze(animations);
            }
            return animations;
          }
          getSharedOptions(options) {
            if (!options.$shared) {
              return;
            }
            return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
          }
          includeOptions(mode, sharedOptions) {
            return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
          }
          updateElement(element, index2, properties, mode) {
            if (isDirectUpdateMode(mode)) {
              Object.assign(element, properties);
            } else {
              this._resolveAnimations(index2, mode).update(element, properties);
            }
          }
          updateSharedOptions(sharedOptions, mode, newOptions) {
            if (sharedOptions && !isDirectUpdateMode(mode)) {
              this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
            }
          }
          _setStyle(element, index2, mode, active) {
            element.active = active;
            const options = this.getStyle(index2, active);
            this._resolveAnimations(index2, mode, active).update(element, {
              options: !active && this.getSharedOptions(options) || options
            });
          }
          removeHoverStyle(element, datasetIndex, index2) {
            this._setStyle(element, index2, "active", false);
          }
          setHoverStyle(element, datasetIndex, index2) {
            this._setStyle(element, index2, "active", true);
          }
          _removeDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
              this._setStyle(element, void 0, "active", false);
            }
          }
          _setDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
              this._setStyle(element, void 0, "active", true);
            }
          }
          _resyncElements(resetNewElements) {
            const data = this._data;
            const elements2 = this._cachedMeta.data;
            for (const [method, arg1, arg2] of this._syncList) {
              this[method](arg1, arg2);
            }
            this._syncList = [];
            const numMeta = elements2.length;
            const numData = data.length;
            const count = Math.min(numData, numMeta);
            if (count) {
              this.parse(0, count);
            }
            if (numData > numMeta) {
              this._insertElements(numMeta, numData - numMeta, resetNewElements);
            } else if (numData < numMeta) {
              this._removeElements(numData, numMeta - numData);
            }
          }
          _insertElements(start, count, resetNewElements = true) {
            const meta = this._cachedMeta;
            const data = meta.data;
            const end = start + count;
            let i;
            const move = (arr) => {
              arr.length += count;
              for (i = arr.length - 1; i >= end; i--) {
                arr[i] = arr[i - count];
              }
            };
            move(data);
            for (i = start; i < end; ++i) {
              data[i] = new this.dataElementType();
            }
            if (this._parsing) {
              move(meta._parsed);
            }
            this.parse(start, count);
            if (resetNewElements) {
              this.updateElements(data, start, count, "reset");
            }
          }
          updateElements(element, start, count, mode) {
          }
          _removeElements(start, count) {
            const meta = this._cachedMeta;
            if (this._parsing) {
              const removed = meta._parsed.splice(start, count);
              if (meta._stacked) {
                clearStacks(meta, removed);
              }
            }
            meta.data.splice(start, count);
          }
          _sync(args) {
            if (this._parsing) {
              this._syncList.push(args);
            } else {
              const [method, arg1, arg2] = args;
              this[method](arg1, arg2);
            }
            this.chart._dataChanges.push([this.index, ...args]);
          }
          _onDataPush() {
            const count = arguments.length;
            this._sync(["_insertElements", this.getDataset().data.length - count, count]);
          }
          _onDataPop() {
            this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
          }
          _onDataShift() {
            this._sync(["_removeElements", 0, 1]);
          }
          _onDataSplice(start, count) {
            if (count) {
              this._sync(["_removeElements", start, count]);
            }
            const newCount = arguments.length - 2;
            if (newCount) {
              this._sync(["_insertElements", start, newCount]);
            }
          }
          _onDataUnshift() {
            this._sync(["_insertElements", 0, arguments.length]);
          }
        }
        DatasetController.defaults = {};
        DatasetController.prototype.datasetElementType = null;
        DatasetController.prototype.dataElementType = null;
        class Element2 {
          constructor() {
            this.x = void 0;
            this.y = void 0;
            this.active = false;
            this.options = void 0;
            this.$animations = void 0;
          }
          tooltipPosition(useFinalPosition) {
            const { x, y } = this.getProps(["x", "y"], useFinalPosition);
            return { x, y };
          }
          hasValue() {
            return isNumber(this.x) && isNumber(this.y);
          }
          getProps(props, final) {
            const anims = this.$animations;
            if (!final || !anims) {
              return this;
            }
            const ret = {};
            props.forEach((prop) => {
              ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
            });
            return ret;
          }
        }
        Element2.defaults = {};
        Element2.defaultRoutes = void 0;
        const formatters = {
          values(value) {
            return isArray(value) ? value : "" + value;
          },
          numeric(tickValue, index2, ticks) {
            if (tickValue === 0) {
              return "0";
            }
            const locale = this.chart.options.locale;
            let notation;
            let delta = tickValue;
            if (ticks.length > 1) {
              const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
              if (maxTick < 1e-4 || maxTick > 1e15) {
                notation = "scientific";
              }
              delta = calculateDelta(tickValue, ticks);
            }
            const logDelta = log10(Math.abs(delta));
            const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
            const options = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
            Object.assign(options, this.options.ticks.format);
            return formatNumber(tickValue, locale, options);
          },
          logarithmic(tickValue, index2, ticks) {
            if (tickValue === 0) {
              return "0";
            }
            const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
            if (remain === 1 || remain === 2 || remain === 5) {
              return formatters.numeric.call(this, tickValue, index2, ticks);
            }
            return "";
          }
        };
        function calculateDelta(tickValue, ticks) {
          let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
          if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
            delta = tickValue - Math.floor(tickValue);
          }
          return delta;
        }
        var Ticks = { formatters };
        defaults.set("scale", {
          display: true,
          offset: false,
          reverse: false,
          beginAtZero: false,
          bounds: "ticks",
          grace: 0,
          grid: {
            display: true,
            lineWidth: 1,
            drawBorder: true,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: (_ctx, options) => options.lineWidth,
            tickColor: (_ctx, options) => options.color,
            offset: false,
            borderDash: [],
            borderDashOffset: 0,
            borderWidth: 1
          },
          title: {
            display: false,
            text: "",
            padding: {
              top: 4,
              bottom: 4
            }
          },
          ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: false,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
          }
        });
        defaults.route("scale.ticks", "color", "", "color");
        defaults.route("scale.grid", "color", "", "borderColor");
        defaults.route("scale.grid", "borderColor", "", "borderColor");
        defaults.route("scale.title", "color", "", "color");
        defaults.describe("scale", {
          _fallback: false,
          _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
          _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash"
        });
        defaults.describe("scales", {
          _fallback: "scale"
        });
        defaults.describe("scale.ticks", {
          _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
          _indexable: (name) => name !== "backdropPadding"
        });
        function autoSkip(scale, ticks) {
          const tickOpts = scale.options.ticks;
          const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
          const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
          const numMajorIndices = majorIndices.length;
          const first = majorIndices[0];
          const last = majorIndices[numMajorIndices - 1];
          const newTicks = [];
          if (numMajorIndices > ticksLimit) {
            skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
            return newTicks;
          }
          const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
          if (numMajorIndices > 0) {
            let i, ilen;
            const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
            skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
            for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
              skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
            }
            skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
            return newTicks;
          }
          skip(ticks, newTicks, spacing);
          return newTicks;
        }
        function determineMaxTicks(scale) {
          const offset = scale.options.offset;
          const tickLength = scale._tickSize();
          const maxScale = scale._length / tickLength + (offset ? 0 : 1);
          const maxChart = scale._maxLength / tickLength;
          return Math.floor(Math.min(maxScale, maxChart));
        }
        function calculateSpacing(majorIndices, ticks, ticksLimit) {
          const evenMajorSpacing = getEvenSpacing(majorIndices);
          const spacing = ticks.length / ticksLimit;
          if (!evenMajorSpacing) {
            return Math.max(spacing, 1);
          }
          const factors = _factorize(evenMajorSpacing);
          for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
            const factor = factors[i];
            if (factor > spacing) {
              return factor;
            }
          }
          return Math.max(spacing, 1);
        }
        function getMajorIndices(ticks) {
          const result = [];
          let i, ilen;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (ticks[i].major) {
              result.push(i);
            }
          }
          return result;
        }
        function skipMajors(ticks, newTicks, majorIndices, spacing) {
          let count = 0;
          let next = majorIndices[0];
          let i;
          spacing = Math.ceil(spacing);
          for (i = 0; i < ticks.length; i++) {
            if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = majorIndices[count * spacing];
            }
          }
        }
        function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
          const start = valueOrDefault(majorStart, 0);
          const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
          let count = 0;
          let length, i, next;
          spacing = Math.ceil(spacing);
          if (majorEnd) {
            length = majorEnd - majorStart;
            spacing = length / Math.floor(length / spacing);
          }
          next = start;
          while (next < 0) {
            count++;
            next = Math.round(start + count * spacing);
          }
          for (i = Math.max(start, 0); i < end; i++) {
            if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = Math.round(start + count * spacing);
            }
          }
        }
        function getEvenSpacing(arr) {
          const len = arr.length;
          let i, diff;
          if (len < 2) {
            return false;
          }
          for (diff = arr[0], i = 1; i < len; ++i) {
            if (arr[i] - arr[i - 1] !== diff) {
              return false;
            }
          }
          return diff;
        }
        const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
        const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
        function sample(arr, numItems) {
          const result = [];
          const increment = arr.length / numItems;
          const len = arr.length;
          let i = 0;
          for (; i < len; i += increment) {
            result.push(arr[Math.floor(i)]);
          }
          return result;
        }
        function getPixelForGridLine(scale, index2, offsetGridLines) {
          const length = scale.ticks.length;
          const validIndex2 = Math.min(index2, length - 1);
          const start = scale._startPixel;
          const end = scale._endPixel;
          const epsilon = 1e-6;
          let lineValue = scale.getPixelForTick(validIndex2);
          let offset;
          if (offsetGridLines) {
            if (length === 1) {
              offset = Math.max(lineValue - start, end - lineValue);
            } else if (index2 === 0) {
              offset = (scale.getPixelForTick(1) - lineValue) / 2;
            } else {
              offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
            }
            lineValue += validIndex2 < index2 ? offset : -offset;
            if (lineValue < start - epsilon || lineValue > end + epsilon) {
              return;
            }
          }
          return lineValue;
        }
        function garbageCollect(caches, length) {
          each(caches, (cache) => {
            const gc = cache.gc;
            const gcLen = gc.length / 2;
            let i;
            if (gcLen > length) {
              for (i = 0; i < gcLen; ++i) {
                delete cache.data[gc[i]];
              }
              gc.splice(0, gcLen);
            }
          });
        }
        function getTickMarkLength(options) {
          return options.drawTicks ? options.tickLength : 0;
        }
        function getTitleHeight(options, fallback) {
          if (!options.display) {
            return 0;
          }
          const font = toFont(options.font, fallback);
          const padding = toPadding(options.padding);
          const lines = isArray(options.text) ? options.text.length : 1;
          return lines * font.lineHeight + padding.height;
        }
        function createScaleContext(parent, scale) {
          return createContext(parent, {
            scale,
            type: "scale"
          });
        }
        function createTickContext(parent, index2, tick) {
          return createContext(parent, {
            tick,
            index: index2,
            type: "tick"
          });
        }
        function titleAlign(align, position, reverse) {
          let ret = _toLeftRightCenter(align);
          if (reverse && position !== "right" || !reverse && position === "right") {
            ret = reverseAlign(ret);
          }
          return ret;
        }
        function titleArgs(scale, offset, position, align) {
          const { top, left, bottom, right, chart: chart2 } = scale;
          const { chartArea, scales: scales2 } = chart2;
          let rotation = 0;
          let maxWidth, titleX, titleY;
          const height = bottom - top;
          const width = right - left;
          if (scale.isHorizontal()) {
            titleX = _alignStartEnd(align, left, right);
            if (isObject2(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
            } else if (position === "center") {
              titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
            } else {
              titleY = offsetFromEdge(scale, position, offset);
            }
            maxWidth = right - left;
          } else {
            if (isObject2(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
            } else if (position === "center") {
              titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
            } else {
              titleX = offsetFromEdge(scale, position, offset);
            }
            titleY = _alignStartEnd(align, bottom, top);
            rotation = position === "left" ? -HALF_PI : HALF_PI;
          }
          return { titleX, titleY, maxWidth, rotation };
        }
        class Scale extends Element2 {
          constructor(cfg) {
            super();
            this.id = cfg.id;
            this.type = cfg.type;
            this.options = void 0;
            this.ctx = cfg.ctx;
            this.chart = cfg.chart;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.width = void 0;
            this.height = void 0;
            this._margins = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            };
            this.maxWidth = void 0;
            this.maxHeight = void 0;
            this.paddingTop = void 0;
            this.paddingBottom = void 0;
            this.paddingLeft = void 0;
            this.paddingRight = void 0;
            this.axis = void 0;
            this.labelRotation = void 0;
            this.min = void 0;
            this.max = void 0;
            this._range = void 0;
            this.ticks = [];
            this._gridLineItems = null;
            this._labelItems = null;
            this._labelSizes = null;
            this._length = 0;
            this._maxLength = 0;
            this._longestTextCache = {};
            this._startPixel = void 0;
            this._endPixel = void 0;
            this._reversePixels = false;
            this._userMax = void 0;
            this._userMin = void 0;
            this._suggestedMax = void 0;
            this._suggestedMin = void 0;
            this._ticksLength = 0;
            this._borderValue = 0;
            this._cache = {};
            this._dataLimitsCached = false;
            this.$context = void 0;
          }
          init(options) {
            this.options = options.setContext(this.getContext());
            this.axis = options.axis;
            this._userMin = this.parse(options.min);
            this._userMax = this.parse(options.max);
            this._suggestedMin = this.parse(options.suggestedMin);
            this._suggestedMax = this.parse(options.suggestedMax);
          }
          parse(raw, index2) {
            return raw;
          }
          getUserBounds() {
            let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
            _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
            _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
            _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
            _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
            return {
              min: finiteOrDefault(_userMin, _suggestedMin),
              max: finiteOrDefault(_userMax, _suggestedMax),
              minDefined: isNumberFinite(_userMin),
              maxDefined: isNumberFinite(_userMax)
            };
          }
          getMinMax(canStack) {
            let { min, max, minDefined, maxDefined } = this.getUserBounds();
            let range2;
            if (minDefined && maxDefined) {
              return { min, max };
            }
            const metas = this.getMatchingVisibleMetas();
            for (let i = 0, ilen = metas.length; i < ilen; ++i) {
              range2 = metas[i].controller.getMinMax(this, canStack);
              if (!minDefined) {
                min = Math.min(min, range2.min);
              }
              if (!maxDefined) {
                max = Math.max(max, range2.max);
              }
            }
            min = maxDefined && min > max ? max : min;
            max = minDefined && min > max ? min : max;
            return {
              min: finiteOrDefault(min, finiteOrDefault(max, min)),
              max: finiteOrDefault(max, finiteOrDefault(min, max))
            };
          }
          getPadding() {
            return {
              left: this.paddingLeft || 0,
              top: this.paddingTop || 0,
              right: this.paddingRight || 0,
              bottom: this.paddingBottom || 0
            };
          }
          getTicks() {
            return this.ticks;
          }
          getLabels() {
            const data = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
          }
          beforeLayout() {
            this._cache = {};
            this._dataLimitsCached = false;
          }
          beforeUpdate() {
            callback(this.options.beforeUpdate, [this]);
          }
          update(maxWidth, maxHeight, margins) {
            const { beginAtZero, grace, ticks: tickOpts } = this.options;
            const sampleSize = tickOpts.sampleSize;
            this.beforeUpdate();
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins = Object.assign({
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }, margins);
            this.ticks = null;
            this._labelSizes = null;
            this._gridLineItems = null;
            this._labelItems = null;
            this.beforeSetDimensions();
            this.setDimensions();
            this.afterSetDimensions();
            this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
            if (!this._dataLimitsCached) {
              this.beforeDataLimits();
              this.determineDataLimits();
              this.afterDataLimits();
              this._range = _addGrace(this, grace, beginAtZero);
              this._dataLimitsCached = true;
            }
            this.beforeBuildTicks();
            this.ticks = this.buildTicks() || [];
            this.afterBuildTicks();
            const samplingEnabled = sampleSize < this.ticks.length;
            this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
            this.configure();
            this.beforeCalculateLabelRotation();
            this.calculateLabelRotation();
            this.afterCalculateLabelRotation();
            if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
              this.ticks = autoSkip(this, this.ticks);
              this._labelSizes = null;
              this.afterAutoSkip();
            }
            if (samplingEnabled) {
              this._convertTicksToLabels(this.ticks);
            }
            this.beforeFit();
            this.fit();
            this.afterFit();
            this.afterUpdate();
          }
          configure() {
            let reversePixels = this.options.reverse;
            let startPixel, endPixel;
            if (this.isHorizontal()) {
              startPixel = this.left;
              endPixel = this.right;
            } else {
              startPixel = this.top;
              endPixel = this.bottom;
              reversePixels = !reversePixels;
            }
            this._startPixel = startPixel;
            this._endPixel = endPixel;
            this._reversePixels = reversePixels;
            this._length = endPixel - startPixel;
            this._alignToPixels = this.options.alignToPixels;
          }
          afterUpdate() {
            callback(this.options.afterUpdate, [this]);
          }
          beforeSetDimensions() {
            callback(this.options.beforeSetDimensions, [this]);
          }
          setDimensions() {
            if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = 0;
              this.right = this.width;
            } else {
              this.height = this.maxHeight;
              this.top = 0;
              this.bottom = this.height;
            }
            this.paddingLeft = 0;
            this.paddingTop = 0;
            this.paddingRight = 0;
            this.paddingBottom = 0;
          }
          afterSetDimensions() {
            callback(this.options.afterSetDimensions, [this]);
          }
          _callHooks(name) {
            this.chart.notifyPlugins(name, this.getContext());
            callback(this.options[name], [this]);
          }
          beforeDataLimits() {
            this._callHooks("beforeDataLimits");
          }
          determineDataLimits() {
          }
          afterDataLimits() {
            this._callHooks("afterDataLimits");
          }
          beforeBuildTicks() {
            this._callHooks("beforeBuildTicks");
          }
          buildTicks() {
            return [];
          }
          afterBuildTicks() {
            this._callHooks("afterBuildTicks");
          }
          beforeTickToLabelConversion() {
            callback(this.options.beforeTickToLabelConversion, [this]);
          }
          generateTickLabels(ticks) {
            const tickOpts = this.options.ticks;
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
              tick = ticks[i];
              tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);
            }
          }
          afterTickToLabelConversion() {
            callback(this.options.afterTickToLabelConversion, [this]);
          }
          beforeCalculateLabelRotation() {
            callback(this.options.beforeCalculateLabelRotation, [this]);
          }
          calculateLabelRotation() {
            const options = this.options;
            const tickOpts = options.ticks;
            const numTicks = this.ticks.length;
            const minRotation = tickOpts.minRotation || 0;
            const maxRotation = tickOpts.maxRotation;
            let labelRotation = minRotation;
            let tickWidth, maxHeight, maxLabelDiagonal;
            if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
              this.labelRotation = minRotation;
              return;
            }
            const labelSizes = this._getLabelSizes();
            const maxLabelWidth = labelSizes.widest.width;
            const maxLabelHeight = labelSizes.highest.height;
            const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
            tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
            if (maxLabelWidth + 6 > tickWidth) {
              tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
              maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
              maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
              labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
              labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
            }
            this.labelRotation = labelRotation;
          }
          afterCalculateLabelRotation() {
            callback(this.options.afterCalculateLabelRotation, [this]);
          }
          afterAutoSkip() {
          }
          beforeFit() {
            callback(this.options.beforeFit, [this]);
          }
          fit() {
            const minSize = {
              width: 0,
              height: 0
            };
            const { chart: chart2, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
            const display = this._isVisible();
            const isHorizontal = this.isHorizontal();
            if (display) {
              const titleHeight = getTitleHeight(titleOpts, chart2.options.font);
              if (isHorizontal) {
                minSize.width = this.maxWidth;
                minSize.height = getTickMarkLength(gridOpts) + titleHeight;
              } else {
                minSize.height = this.maxHeight;
                minSize.width = getTickMarkLength(gridOpts) + titleHeight;
              }
              if (tickOpts.display && this.ticks.length) {
                const { first, last, widest, highest } = this._getLabelSizes();
                const tickPadding = tickOpts.padding * 2;
                const angleRadians = toRadians(this.labelRotation);
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                if (isHorizontal) {
                  const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                  minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                } else {
                  const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                  minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                }
                this._calculatePadding(first, last, sin, cos);
              }
            }
            this._handleMargins();
            if (isHorizontal) {
              this.width = this._length = chart2.width - this._margins.left - this._margins.right;
              this.height = minSize.height;
            } else {
              this.width = minSize.width;
              this.height = this._length = chart2.height - this._margins.top - this._margins.bottom;
            }
          }
          _calculatePadding(first, last, sin, cos) {
            const { ticks: { align, padding }, position } = this.options;
            const isRotated = this.labelRotation !== 0;
            const labelsBelowTicks = position !== "top" && this.axis === "x";
            if (this.isHorizontal()) {
              const offsetLeft = this.getPixelForTick(0) - this.left;
              const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
              let paddingLeft = 0;
              let paddingRight = 0;
              if (isRotated) {
                if (labelsBelowTicks) {
                  paddingLeft = cos * first.width;
                  paddingRight = sin * last.height;
                } else {
                  paddingLeft = sin * first.height;
                  paddingRight = cos * last.width;
                }
              } else if (align === "start") {
                paddingRight = last.width;
              } else if (align === "end") {
                paddingLeft = first.width;
              } else if (align !== "inner") {
                paddingLeft = first.width / 2;
                paddingRight = last.width / 2;
              }
              this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
              this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
            } else {
              let paddingTop = last.height / 2;
              let paddingBottom = first.height / 2;
              if (align === "start") {
                paddingTop = 0;
                paddingBottom = first.height;
              } else if (align === "end") {
                paddingTop = last.height;
                paddingBottom = 0;
              }
              this.paddingTop = paddingTop + padding;
              this.paddingBottom = paddingBottom + padding;
            }
          }
          _handleMargins() {
            if (this._margins) {
              this._margins.left = Math.max(this.paddingLeft, this._margins.left);
              this._margins.top = Math.max(this.paddingTop, this._margins.top);
              this._margins.right = Math.max(this.paddingRight, this._margins.right);
              this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
            }
          }
          afterFit() {
            callback(this.options.afterFit, [this]);
          }
          isHorizontal() {
            const { axis, position } = this.options;
            return position === "top" || position === "bottom" || axis === "x";
          }
          isFullSize() {
            return this.options.fullSize;
          }
          _convertTicksToLabels(ticks) {
            this.beforeTickToLabelConversion();
            this.generateTickLabels(ticks);
            let i, ilen;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
              if (isNullOrUndef(ticks[i].label)) {
                ticks.splice(i, 1);
                ilen--;
                i--;
              }
            }
            this.afterTickToLabelConversion();
          }
          _getLabelSizes() {
            let labelSizes = this._labelSizes;
            if (!labelSizes) {
              const sampleSize = this.options.ticks.sampleSize;
              let ticks = this.ticks;
              if (sampleSize < ticks.length) {
                ticks = sample(ticks, sampleSize);
              }
              this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);
            }
            return labelSizes;
          }
          _computeLabelSizes(ticks, length) {
            const { ctx, _longestTextCache: caches } = this;
            const widths = [];
            const heights = [];
            let widestLabelSize = 0;
            let highestLabelSize = 0;
            let i, j, jlen, label, tickFont, fontString2, cache, lineHeight, width, height, nestedLabel;
            for (i = 0; i < length; ++i) {
              label = ticks[i].label;
              tickFont = this._resolveTickFontOptions(i);
              ctx.font = fontString2 = tickFont.string;
              cache = caches[fontString2] = caches[fontString2] || { data: {}, gc: [] };
              lineHeight = tickFont.lineHeight;
              width = height = 0;
              if (!isNullOrUndef(label) && !isArray(label)) {
                width = _measureText(ctx, cache.data, cache.gc, width, label);
                height = lineHeight;
              } else if (isArray(label)) {
                for (j = 0, jlen = label.length; j < jlen; ++j) {
                  nestedLabel = label[j];
                  if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                    width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                    height += lineHeight;
                  }
                }
              }
              widths.push(width);
              heights.push(height);
              widestLabelSize = Math.max(width, widestLabelSize);
              highestLabelSize = Math.max(height, highestLabelSize);
            }
            garbageCollect(caches, length);
            const widest = widths.indexOf(widestLabelSize);
            const highest = heights.indexOf(highestLabelSize);
            const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
            return {
              first: valueAt(0),
              last: valueAt(length - 1),
              widest: valueAt(widest),
              highest: valueAt(highest),
              widths,
              heights
            };
          }
          getLabelForValue(value) {
            return value;
          }
          getPixelForValue(value, index2) {
            return NaN;
          }
          getValueForPixel(pixel) {
          }
          getPixelForTick(index2) {
            const ticks = this.ticks;
            if (index2 < 0 || index2 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index2].value);
          }
          getPixelForDecimal(decimal) {
            if (this._reversePixels) {
              decimal = 1 - decimal;
            }
            const pixel = this._startPixel + decimal * this._length;
            return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
          }
          getDecimalForPixel(pixel) {
            const decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal;
          }
          getBasePixel() {
            return this.getPixelForValue(this.getBaseValue());
          }
          getBaseValue() {
            const { min, max } = this;
            return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
          }
          getContext(index2) {
            const ticks = this.ticks || [];
            if (index2 >= 0 && index2 < ticks.length) {
              const tick = ticks[index2];
              return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
            }
            return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
          }
          _tickSize() {
            const optionTicks = this.options.ticks;
            const rot = toRadians(this.labelRotation);
            const cos = Math.abs(Math.cos(rot));
            const sin = Math.abs(Math.sin(rot));
            const labelSizes = this._getLabelSizes();
            const padding = optionTicks.autoSkipPadding || 0;
            const w = labelSizes ? labelSizes.widest.width + padding : 0;
            const h = labelSizes ? labelSizes.highest.height + padding : 0;
            return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
          }
          _isVisible() {
            const display = this.options.display;
            if (display !== "auto") {
              return !!display;
            }
            return this.getMatchingVisibleMetas().length > 0;
          }
          _computeGridLineItems(chartArea) {
            const axis = this.axis;
            const chart2 = this.chart;
            const options = this.options;
            const { grid, position } = options;
            const offset = grid.offset;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const ticksLength = ticks.length + (offset ? 1 : 0);
            const tl = getTickMarkLength(grid);
            const items = [];
            const borderOpts = grid.setContext(this.getContext());
            const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
            const axisHalfWidth = axisWidth / 2;
            const alignBorderValue = function(pixel) {
              return _alignPixel(chart2, pixel, axisWidth);
            };
            let borderValue, i, lineValue, alignedLineValue;
            let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
            if (position === "top") {
              borderValue = alignBorderValue(this.bottom);
              ty1 = this.bottom - tl;
              ty2 = borderValue - axisHalfWidth;
              y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
              y2 = chartArea.bottom;
            } else if (position === "bottom") {
              borderValue = alignBorderValue(this.top);
              y1 = chartArea.top;
              y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
              ty1 = borderValue + axisHalfWidth;
              ty2 = this.top + tl;
            } else if (position === "left") {
              borderValue = alignBorderValue(this.right);
              tx1 = this.right - tl;
              tx2 = borderValue - axisHalfWidth;
              x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
              x2 = chartArea.right;
            } else if (position === "right") {
              borderValue = alignBorderValue(this.left);
              x1 = chartArea.left;
              x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
              tx1 = borderValue + axisHalfWidth;
              tx2 = this.left + tl;
            } else if (axis === "x") {
              if (position === "center") {
                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
              }
              y1 = chartArea.top;
              y2 = chartArea.bottom;
              ty1 = borderValue + axisHalfWidth;
              ty2 = ty1 + tl;
            } else if (axis === "y") {
              if (position === "center") {
                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
              }
              tx1 = borderValue - axisHalfWidth;
              tx2 = tx1 - tl;
              x1 = chartArea.left;
              x2 = chartArea.right;
            }
            const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
            const step = Math.max(1, Math.ceil(ticksLength / limit));
            for (i = 0; i < ticksLength; i += step) {
              const optsAtIndex = grid.setContext(this.getContext(i));
              const lineWidth = optsAtIndex.lineWidth;
              const lineColor = optsAtIndex.color;
              const borderDash = grid.borderDash || [];
              const borderDashOffset = optsAtIndex.borderDashOffset;
              const tickWidth = optsAtIndex.tickWidth;
              const tickColor = optsAtIndex.tickColor;
              const tickBorderDash = optsAtIndex.tickBorderDash || [];
              const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
              lineValue = getPixelForGridLine(this, i, offset);
              if (lineValue === void 0) {
                continue;
              }
              alignedLineValue = _alignPixel(chart2, lineValue, lineWidth);
              if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
              } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
              }
              items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset,
                tickWidth,
                tickColor,
                tickBorderDash,
                tickBorderDashOffset
              });
            }
            this._ticksLength = ticksLength;
            this._borderValue = borderValue;
            return items;
          }
          _computeLabelItems(chartArea) {
            const axis = this.axis;
            const options = this.options;
            const { position, ticks: optionTicks } = options;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const { align, crossAlign, padding, mirror } = optionTicks;
            const tl = getTickMarkLength(options.grid);
            const tickAndPadding = tl + padding;
            const hTickAndPadding = mirror ? -padding : tickAndPadding;
            const rotation = -toRadians(this.labelRotation);
            const items = [];
            let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
            let textBaseline = "middle";
            if (position === "top") {
              y = this.bottom - hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
            } else if (position === "bottom") {
              y = this.top + hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
            } else if (position === "left") {
              const ret = this._getYAxisLabelAlignment(tl);
              textAlign = ret.textAlign;
              x = ret.x;
            } else if (position === "right") {
              const ret = this._getYAxisLabelAlignment(tl);
              textAlign = ret.textAlign;
              x = ret.x;
            } else if (axis === "x") {
              if (position === "center") {
                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
              }
              textAlign = this._getXAxisLabelAlignment();
            } else if (axis === "y") {
              if (position === "center") {
                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
              } else if (isObject2(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                x = this.chart.scales[positionAxisID].getPixelForValue(value);
              }
              textAlign = this._getYAxisLabelAlignment(tl).textAlign;
            }
            if (axis === "y") {
              if (align === "start") {
                textBaseline = "top";
              } else if (align === "end") {
                textBaseline = "bottom";
              }
            }
            const labelSizes = this._getLabelSizes();
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              label = tick.label;
              const optsAtIndex = optionTicks.setContext(this.getContext(i));
              pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
              font = this._resolveTickFontOptions(i);
              lineHeight = font.lineHeight;
              lineCount = isArray(label) ? label.length : 1;
              const halfCount = lineCount / 2;
              const color2 = optsAtIndex.color;
              const strokeColor = optsAtIndex.textStrokeColor;
              const strokeWidth = optsAtIndex.textStrokeWidth;
              let tickTextAlign = textAlign;
              if (isHorizontal) {
                x = pixel;
                if (textAlign === "inner") {
                  if (i === ilen - 1) {
                    tickTextAlign = !this.options.reverse ? "right" : "left";
                  } else if (i === 0) {
                    tickTextAlign = !this.options.reverse ? "left" : "right";
                  } else {
                    tickTextAlign = "center";
                  }
                }
                if (position === "top") {
                  if (crossAlign === "near" || rotation !== 0) {
                    textOffset = -lineCount * lineHeight + lineHeight / 2;
                  } else if (crossAlign === "center") {
                    textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                  } else {
                    textOffset = -labelSizes.highest.height + lineHeight / 2;
                  }
                } else {
                  if (crossAlign === "near" || rotation !== 0) {
                    textOffset = lineHeight / 2;
                  } else if (crossAlign === "center") {
                    textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                  } else {
                    textOffset = labelSizes.highest.height - lineCount * lineHeight;
                  }
                }
                if (mirror) {
                  textOffset *= -1;
                }
              } else {
                y = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
              }
              let backdrop;
              if (optsAtIndex.showLabelBackdrop) {
                const labelPadding = toPadding(optsAtIndex.backdropPadding);
                const height = labelSizes.heights[i];
                const width = labelSizes.widths[i];
                let top = y + textOffset - labelPadding.top;
                let left = x - labelPadding.left;
                switch (textBaseline) {
                  case "middle":
                    top -= height / 2;
                    break;
                  case "bottom":
                    top -= height;
                    break;
                }
                switch (textAlign) {
                  case "center":
                    left -= width / 2;
                    break;
                  case "right":
                    left -= width;
                    break;
                }
                backdrop = {
                  left,
                  top,
                  width: width + labelPadding.width,
                  height: height + labelPadding.height,
                  color: optsAtIndex.backdropColor
                };
              }
              items.push({
                rotation,
                label,
                font,
                color: color2,
                strokeColor,
                strokeWidth,
                textOffset,
                textAlign: tickTextAlign,
                textBaseline,
                translation: [x, y],
                backdrop
              });
            }
            return items;
          }
          _getXAxisLabelAlignment() {
            const { position, ticks } = this.options;
            const rotation = -toRadians(this.labelRotation);
            if (rotation) {
              return position === "top" ? "left" : "right";
            }
            let align = "center";
            if (ticks.align === "start") {
              align = "left";
            } else if (ticks.align === "end") {
              align = "right";
            } else if (ticks.align === "inner") {
              align = "inner";
            }
            return align;
          }
          _getYAxisLabelAlignment(tl) {
            const { position, ticks: { crossAlign, mirror, padding } } = this.options;
            const labelSizes = this._getLabelSizes();
            const tickAndPadding = tl + padding;
            const widest = labelSizes.widest.width;
            let textAlign;
            let x;
            if (position === "left") {
              if (mirror) {
                x = this.right + padding;
                if (crossAlign === "near") {
                  textAlign = "left";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x += widest / 2;
                } else {
                  textAlign = "right";
                  x += widest;
                }
              } else {
                x = this.right - tickAndPadding;
                if (crossAlign === "near") {
                  textAlign = "right";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x -= widest / 2;
                } else {
                  textAlign = "left";
                  x = this.left;
                }
              }
            } else if (position === "right") {
              if (mirror) {
                x = this.left + padding;
                if (crossAlign === "near") {
                  textAlign = "right";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x -= widest / 2;
                } else {
                  textAlign = "left";
                  x -= widest;
                }
              } else {
                x = this.left + tickAndPadding;
                if (crossAlign === "near") {
                  textAlign = "left";
                } else if (crossAlign === "center") {
                  textAlign = "center";
                  x += widest / 2;
                } else {
                  textAlign = "right";
                  x = this.right;
                }
              }
            } else {
              textAlign = "right";
            }
            return { textAlign, x };
          }
          _computeLabelArea() {
            if (this.options.ticks.mirror) {
              return;
            }
            const chart2 = this.chart;
            const position = this.options.position;
            if (position === "left" || position === "right") {
              return { top: 0, left: this.left, bottom: chart2.height, right: this.right };
            }
            if (position === "top" || position === "bottom") {
              return { top: this.top, left: 0, bottom: this.bottom, right: chart2.width };
            }
          }
          drawBackground() {
            const { ctx, options: { backgroundColor }, left, top, width, height } = this;
            if (backgroundColor) {
              ctx.save();
              ctx.fillStyle = backgroundColor;
              ctx.fillRect(left, top, width, height);
              ctx.restore();
            }
          }
          getLineWidthForValue(value) {
            const grid = this.options.grid;
            if (!this._isVisible() || !grid.display) {
              return 0;
            }
            const ticks = this.ticks;
            const index2 = ticks.findIndex((t) => t.value === value);
            if (index2 >= 0) {
              const opts = grid.setContext(this.getContext(index2));
              return opts.lineWidth;
            }
            return 0;
          }
          drawGrid(chartArea) {
            const grid = this.options.grid;
            const ctx = this.ctx;
            const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
            let i, ilen;
            const drawLine = (p1, p2, style) => {
              if (!style.width || !style.color) {
                return;
              }
              ctx.save();
              ctx.lineWidth = style.width;
              ctx.strokeStyle = style.color;
              ctx.setLineDash(style.borderDash || []);
              ctx.lineDashOffset = style.borderDashOffset;
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
              ctx.restore();
            };
            if (grid.display) {
              for (i = 0, ilen = items.length; i < ilen; ++i) {
                const item = items[i];
                if (grid.drawOnChartArea) {
                  drawLine({ x: item.x1, y: item.y1 }, { x: item.x2, y: item.y2 }, item);
                }
                if (grid.drawTicks) {
                  drawLine({ x: item.tx1, y: item.ty1 }, { x: item.tx2, y: item.ty2 }, {
                    color: item.tickColor,
                    width: item.tickWidth,
                    borderDash: item.tickBorderDash,
                    borderDashOffset: item.tickBorderDashOffset
                  });
                }
              }
            }
          }
          drawBorder() {
            const { chart: chart2, ctx, options: { grid } } = this;
            const borderOpts = grid.setContext(this.getContext());
            const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
            if (!axisWidth) {
              return;
            }
            const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
            const borderValue = this._borderValue;
            let x1, x2, y1, y2;
            if (this.isHorizontal()) {
              x1 = _alignPixel(chart2, this.left, axisWidth) - axisWidth / 2;
              x2 = _alignPixel(chart2, this.right, lastLineWidth) + lastLineWidth / 2;
              y1 = y2 = borderValue;
            } else {
              y1 = _alignPixel(chart2, this.top, axisWidth) - axisWidth / 2;
              y2 = _alignPixel(chart2, this.bottom, lastLineWidth) + lastLineWidth / 2;
              x1 = x2 = borderValue;
            }
            ctx.save();
            ctx.lineWidth = borderOpts.borderWidth;
            ctx.strokeStyle = borderOpts.borderColor;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
          }
          drawLabels(chartArea) {
            const optionTicks = this.options.ticks;
            if (!optionTicks.display) {
              return;
            }
            const ctx = this.ctx;
            const area = this._computeLabelArea();
            if (area) {
              clipArea(ctx, area);
            }
            const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
            let i, ilen;
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              const item = items[i];
              const tickFont = item.font;
              const label = item.label;
              if (item.backdrop) {
                ctx.fillStyle = item.backdrop.color;
                ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
              }
              let y = item.textOffset;
              renderText(ctx, label, 0, y, tickFont, item);
            }
            if (area) {
              unclipArea(ctx);
            }
          }
          drawTitle() {
            const { ctx, options: { position, title, reverse } } = this;
            if (!title.display) {
              return;
            }
            const font = toFont(title.font);
            const padding = toPadding(title.padding);
            const align = title.align;
            let offset = font.lineHeight / 2;
            if (position === "bottom" || position === "center" || isObject2(position)) {
              offset += padding.bottom;
              if (isArray(title.text)) {
                offset += font.lineHeight * (title.text.length - 1);
              }
            } else {
              offset += padding.top;
            }
            const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
            renderText(ctx, title.text, 0, 0, font, {
              color: title.color,
              maxWidth,
              rotation,
              textAlign: titleAlign(align, position, reverse),
              textBaseline: "middle",
              translation: [titleX, titleY]
            });
          }
          draw(chartArea) {
            if (!this._isVisible()) {
              return;
            }
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawBorder();
            this.drawTitle();
            this.drawLabels(chartArea);
          }
          _layers() {
            const opts = this.options;
            const tz = opts.ticks && opts.ticks.z || 0;
            const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
            if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
              return [{
                z: tz,
                draw: (chartArea) => {
                  this.draw(chartArea);
                }
              }];
            }
            return [{
              z: gz,
              draw: (chartArea) => {
                this.drawBackground();
                this.drawGrid(chartArea);
                this.drawTitle();
              }
            }, {
              z: gz + 1,
              draw: () => {
                this.drawBorder();
              }
            }, {
              z: tz,
              draw: (chartArea) => {
                this.drawLabels(chartArea);
              }
            }];
          }
          getMatchingVisibleMetas(type) {
            const metas = this.chart.getSortedVisibleDatasetMetas();
            const axisID = this.axis + "AxisID";
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
              const meta = metas[i];
              if (meta[axisID] === this.id && (!type || meta.type === type)) {
                result.push(meta);
              }
            }
            return result;
          }
          _resolveTickFontOptions(index2) {
            const opts = this.options.ticks.setContext(this.getContext(index2));
            return toFont(opts.font);
          }
          _maxDigits() {
            const fontSize = this._resolveTickFontOptions(0).lineHeight;
            return (this.isHorizontal() ? this.width : this.height) / fontSize;
          }
        }
        class TypedRegistry {
          constructor(type, scope, override) {
            this.type = type;
            this.scope = scope;
            this.override = override;
            this.items = Object.create(null);
          }
          isForType(type) {
            return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
          }
          register(item) {
            const proto = Object.getPrototypeOf(item);
            let parentScope;
            if (isIChartComponent(proto)) {
              parentScope = this.register(proto);
            }
            const items = this.items;
            const id = item.id;
            const scope = this.scope + "." + id;
            if (!id) {
              throw new Error("class does not have id: " + item);
            }
            if (id in items) {
              return scope;
            }
            items[id] = item;
            registerDefaults(item, scope, parentScope);
            if (this.override) {
              defaults.override(item.id, item.overrides);
            }
            return scope;
          }
          get(id) {
            return this.items[id];
          }
          unregister(item) {
            const items = this.items;
            const id = item.id;
            const scope = this.scope;
            if (id in items) {
              delete items[id];
            }
            if (scope && id in defaults[scope]) {
              delete defaults[scope][id];
              if (this.override) {
                delete overrides[id];
              }
            }
          }
        }
        function registerDefaults(item, scope, parentScope) {
          const itemDefaults = merge(Object.create(null), [
            parentScope ? defaults.get(parentScope) : {},
            defaults.get(scope),
            item.defaults
          ]);
          defaults.set(scope, itemDefaults);
          if (item.defaultRoutes) {
            routeDefaults(scope, item.defaultRoutes);
          }
          if (item.descriptors) {
            defaults.describe(scope, item.descriptors);
          }
        }
        function routeDefaults(scope, routes) {
          Object.keys(routes).forEach((property) => {
            const propertyParts = property.split(".");
            const sourceName = propertyParts.pop();
            const sourceScope = [scope].concat(propertyParts).join(".");
            const parts = routes[property].split(".");
            const targetName = parts.pop();
            const targetScope = parts.join(".");
            defaults.route(sourceScope, sourceName, targetScope, targetName);
          });
        }
        function isIChartComponent(proto) {
          return "id" in proto && "defaults" in proto;
        }
        class Registry {
          constructor() {
            this.controllers = new TypedRegistry(DatasetController, "datasets", true);
            this.elements = new TypedRegistry(Element2, "elements");
            this.plugins = new TypedRegistry(Object, "plugins");
            this.scales = new TypedRegistry(Scale, "scales");
            this._typedRegistries = [this.controllers, this.scales, this.elements];
          }
          add(...args) {
            this._each("register", args);
          }
          remove(...args) {
            this._each("unregister", args);
          }
          addControllers(...args) {
            this._each("register", args, this.controllers);
          }
          addElements(...args) {
            this._each("register", args, this.elements);
          }
          addPlugins(...args) {
            this._each("register", args, this.plugins);
          }
          addScales(...args) {
            this._each("register", args, this.scales);
          }
          getController(id) {
            return this._get(id, this.controllers, "controller");
          }
          getElement(id) {
            return this._get(id, this.elements, "element");
          }
          getPlugin(id) {
            return this._get(id, this.plugins, "plugin");
          }
          getScale(id) {
            return this._get(id, this.scales, "scale");
          }
          removeControllers(...args) {
            this._each("unregister", args, this.controllers);
          }
          removeElements(...args) {
            this._each("unregister", args, this.elements);
          }
          removePlugins(...args) {
            this._each("unregister", args, this.plugins);
          }
          removeScales(...args) {
            this._each("unregister", args, this.scales);
          }
          _each(method, args, typedRegistry) {
            [...args].forEach((arg) => {
              const reg = typedRegistry || this._getRegistryForType(arg);
              if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
                this._exec(method, reg, arg);
              } else {
                each(arg, (item) => {
                  const itemReg = typedRegistry || this._getRegistryForType(item);
                  this._exec(method, itemReg, item);
                });
              }
            });
          }
          _exec(method, registry2, component) {
            const camelMethod = _capitalize(method);
            callback(component["before" + camelMethod], [], component);
            registry2[method](component);
            callback(component["after" + camelMethod], [], component);
          }
          _getRegistryForType(type) {
            for (let i = 0; i < this._typedRegistries.length; i++) {
              const reg = this._typedRegistries[i];
              if (reg.isForType(type)) {
                return reg;
              }
            }
            return this.plugins;
          }
          _get(id, typedRegistry, type) {
            const item = typedRegistry.get(id);
            if (item === void 0) {
              throw new Error('"' + id + '" is not a registered ' + type + ".");
            }
            return item;
          }
        }
        var registry = new Registry();
        class PluginService {
          constructor() {
            this._init = [];
          }
          notify(chart2, hook, args, filter) {
            if (hook === "beforeInit") {
              this._init = this._createDescriptors(chart2, true);
              this._notify(this._init, chart2, "install");
            }
            const descriptors2 = filter ? this._descriptors(chart2).filter(filter) : this._descriptors(chart2);
            const result = this._notify(descriptors2, chart2, hook, args);
            if (hook === "afterDestroy") {
              this._notify(descriptors2, chart2, "stop");
              this._notify(this._init, chart2, "uninstall");
            }
            return result;
          }
          _notify(descriptors2, chart2, hook, args) {
            args = args || {};
            for (const descriptor of descriptors2) {
              const plugin = descriptor.plugin;
              const method = plugin[hook];
              const params = [chart2, args, descriptor.options];
              if (callback(method, params, plugin) === false && args.cancelable) {
                return false;
              }
            }
            return true;
          }
          invalidate() {
            if (!isNullOrUndef(this._cache)) {
              this._oldCache = this._cache;
              this._cache = void 0;
            }
          }
          _descriptors(chart2) {
            if (this._cache) {
              return this._cache;
            }
            const descriptors2 = this._cache = this._createDescriptors(chart2);
            this._notifyStateChanges(chart2);
            return descriptors2;
          }
          _createDescriptors(chart2, all) {
            const config = chart2 && chart2.config;
            const options = valueOrDefault(config.options && config.options.plugins, {});
            const plugins2 = allPlugins(config);
            return options === false && !all ? [] : createDescriptors(chart2, plugins2, options, all);
          }
          _notifyStateChanges(chart2) {
            const previousDescriptors = this._oldCache || [];
            const descriptors2 = this._cache;
            const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
            this._notify(diff(previousDescriptors, descriptors2), chart2, "stop");
            this._notify(diff(descriptors2, previousDescriptors), chart2, "start");
          }
        }
        function allPlugins(config) {
          const plugins2 = [];
          const keys = Object.keys(registry.plugins.items);
          for (let i = 0; i < keys.length; i++) {
            plugins2.push(registry.getPlugin(keys[i]));
          }
          const local = config.plugins || [];
          for (let i = 0; i < local.length; i++) {
            const plugin = local[i];
            if (plugins2.indexOf(plugin) === -1) {
              plugins2.push(plugin);
            }
          }
          return plugins2;
        }
        function getOpts(options, all) {
          if (!all && options === false) {
            return null;
          }
          if (options === true) {
            return {};
          }
          return options;
        }
        function createDescriptors(chart2, plugins2, options, all) {
          const result = [];
          const context = chart2.getContext();
          for (let i = 0; i < plugins2.length; i++) {
            const plugin = plugins2[i];
            const id = plugin.id;
            const opts = getOpts(options[id], all);
            if (opts === null) {
              continue;
            }
            result.push({
              plugin,
              options: pluginOpts(chart2.config, plugin, opts, context)
            });
          }
          return result;
        }
        function pluginOpts(config, plugin, opts, context) {
          const keys = config.pluginScopeKeys(plugin);
          const scopes = config.getOptionScopes(opts, keys);
          return config.createResolver(scopes, context, [""], { scriptable: false, indexable: false, allKeys: true });
        }
        function getIndexAxis(type, options) {
          const datasetDefaults = defaults.datasets[type] || {};
          const datasetOptions = (options.datasets || {})[type] || {};
          return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
        }
        function getAxisFromDefaultScaleID(id, indexAxis) {
          let axis = id;
          if (id === "_index_") {
            axis = indexAxis;
          } else if (id === "_value_") {
            axis = indexAxis === "x" ? "y" : "x";
          }
          return axis;
        }
        function getDefaultScaleIDFromAxis(axis, indexAxis) {
          return axis === indexAxis ? "_index_" : "_value_";
        }
        function axisFromPosition(position) {
          if (position === "top" || position === "bottom") {
            return "x";
          }
          if (position === "left" || position === "right") {
            return "y";
          }
        }
        function determineAxis(id, scaleOptions) {
          if (id === "x" || id === "y") {
            return id;
          }
          return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
        }
        function mergeScaleConfig(config, options) {
          const chartDefaults = overrides[config.type] || { scales: {} };
          const configScales = options.scales || {};
          const chartIndexAxis = getIndexAxis(config.type, options);
          const firstIDs = Object.create(null);
          const scales2 = Object.create(null);
          Object.keys(configScales).forEach((id) => {
            const scaleConf = configScales[id];
            if (!isObject2(scaleConf)) {
              return console.error(`Invalid scale configuration for scale: ${id}`);
            }
            if (scaleConf._proxy) {
              return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
            }
            const axis = determineAxis(id, scaleConf);
            const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
            const defaultScaleOptions = chartDefaults.scales || {};
            firstIDs[axis] = firstIDs[axis] || id;
            scales2[id] = mergeIf(Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
          });
          config.data.datasets.forEach((dataset) => {
            const type = dataset.type || config.type;
            const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
            const datasetDefaults = overrides[type] || {};
            const defaultScaleOptions = datasetDefaults.scales || {};
            Object.keys(defaultScaleOptions).forEach((defaultID) => {
              const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
              const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
              scales2[id] = scales2[id] || Object.create(null);
              mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
            });
          });
          Object.keys(scales2).forEach((key) => {
            const scale = scales2[key];
            mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
          });
          return scales2;
        }
        function initOptions(config) {
          const options = config.options || (config.options = {});
          options.plugins = valueOrDefault(options.plugins, {});
          options.scales = mergeScaleConfig(config, options);
        }
        function initData(data) {
          data = data || {};
          data.datasets = data.datasets || [];
          data.labels = data.labels || [];
          return data;
        }
        function initConfig(config) {
          config = config || {};
          config.data = initData(config.data);
          initOptions(config);
          return config;
        }
        const keyCache = /* @__PURE__ */ new Map();
        const keysCached = /* @__PURE__ */ new Set();
        function cachedKeys(cacheKey, generate) {
          let keys = keyCache.get(cacheKey);
          if (!keys) {
            keys = generate();
            keyCache.set(cacheKey, keys);
            keysCached.add(keys);
          }
          return keys;
        }
        const addIfFound = (set2, obj, key) => {
          const opts = resolveObjectKey(obj, key);
          if (opts !== void 0) {
            set2.add(opts);
          }
        };
        class Config {
          constructor(config) {
            this._config = initConfig(config);
            this._scopeCache = /* @__PURE__ */ new Map();
            this._resolverCache = /* @__PURE__ */ new Map();
          }
          get platform() {
            return this._config.platform;
          }
          get type() {
            return this._config.type;
          }
          set type(type) {
            this._config.type = type;
          }
          get data() {
            return this._config.data;
          }
          set data(data) {
            this._config.data = initData(data);
          }
          get options() {
            return this._config.options;
          }
          set options(options) {
            this._config.options = options;
          }
          get plugins() {
            return this._config.plugins;
          }
          update() {
            const config = this._config;
            this.clearCache();
            initOptions(config);
          }
          clearCache() {
            this._scopeCache.clear();
            this._resolverCache.clear();
          }
          datasetScopeKeys(datasetType) {
            return cachedKeys(datasetType, () => [[
              `datasets.${datasetType}`,
              ""
            ]]);
          }
          datasetAnimationScopeKeys(datasetType, transition) {
            return cachedKeys(`${datasetType}.transition.${transition}`, () => [
              [
                `datasets.${datasetType}.transitions.${transition}`,
                `transitions.${transition}`
              ],
              [
                `datasets.${datasetType}`,
                ""
              ]
            ]);
          }
          datasetElementScopeKeys(datasetType, elementType) {
            return cachedKeys(`${datasetType}-${elementType}`, () => [[
              `datasets.${datasetType}.elements.${elementType}`,
              `datasets.${datasetType}`,
              `elements.${elementType}`,
              ""
            ]]);
          }
          pluginScopeKeys(plugin) {
            const id = plugin.id;
            const type = this.type;
            return cachedKeys(`${type}-plugin-${id}`, () => [[
              `plugins.${id}`,
              ...plugin.additionalOptionScopes || []
            ]]);
          }
          _cachedScopes(mainScope, resetCache) {
            const _scopeCache = this._scopeCache;
            let cache = _scopeCache.get(mainScope);
            if (!cache || resetCache) {
              cache = /* @__PURE__ */ new Map();
              _scopeCache.set(mainScope, cache);
            }
            return cache;
          }
          getOptionScopes(mainScope, keyLists, resetCache) {
            const { options, type } = this;
            const cache = this._cachedScopes(mainScope, resetCache);
            const cached = cache.get(keyLists);
            if (cached) {
              return cached;
            }
            const scopes = /* @__PURE__ */ new Set();
            keyLists.forEach((keys) => {
              if (mainScope) {
                scopes.add(mainScope);
                keys.forEach((key) => addIfFound(scopes, mainScope, key));
              }
              keys.forEach((key) => addIfFound(scopes, options, key));
              keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
              keys.forEach((key) => addIfFound(scopes, defaults, key));
              keys.forEach((key) => addIfFound(scopes, descriptors, key));
            });
            const array = Array.from(scopes);
            if (array.length === 0) {
              array.push(Object.create(null));
            }
            if (keysCached.has(keyLists)) {
              cache.set(keyLists, array);
            }
            return array;
          }
          chartOptionScopes() {
            const { options, type } = this;
            return [
              options,
              overrides[type] || {},
              defaults.datasets[type] || {},
              { type },
              defaults,
              descriptors
            ];
          }
          resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
            const result = { $shared: true };
            const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
            let options = resolver;
            if (needContext(resolver, names2)) {
              result.$shared = false;
              context = isFunction(context) ? context() : context;
              const subResolver = this.createResolver(scopes, context, subPrefixes);
              options = _attachContext(resolver, context, subResolver);
            }
            for (const prop of names2) {
              result[prop] = options[prop];
            }
            return result;
          }
          createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
            const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
            return isObject2(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
          }
        }
        function getResolver(resolverCache, scopes, prefixes) {
          let cache = resolverCache.get(scopes);
          if (!cache) {
            cache = /* @__PURE__ */ new Map();
            resolverCache.set(scopes, cache);
          }
          const cacheKey = prefixes.join();
          let cached = cache.get(cacheKey);
          if (!cached) {
            const resolver = _createResolver(scopes, prefixes);
            cached = {
              resolver,
              subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
            };
            cache.set(cacheKey, cached);
          }
          return cached;
        }
        const hasFunction = (value) => isObject2(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
        function needContext(proxy, names2) {
          const { isScriptable, isIndexable } = _descriptors(proxy);
          for (const prop of names2) {
            const scriptable = isScriptable(prop);
            const indexable = isIndexable(prop);
            const value = (indexable || scriptable) && proxy[prop];
            if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
              return true;
            }
          }
          return false;
        }
        var version = "3.8.0";
        const KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
        function positionIsHorizontal(position, axis) {
          return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
        }
        function compare2Level(l1, l2) {
          return function(a, b) {
            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
          };
        }
        function onAnimationsComplete(context) {
          const chart2 = context.chart;
          const animationOptions2 = chart2.options.animation;
          chart2.notifyPlugins("afterRender");
          callback(animationOptions2 && animationOptions2.onComplete, [context], chart2);
        }
        function onAnimationProgress(context) {
          const chart2 = context.chart;
          const animationOptions2 = chart2.options.animation;
          callback(animationOptions2 && animationOptions2.onProgress, [context], chart2);
        }
        function getCanvas(item) {
          if (_isDomSupported() && typeof item === "string") {
            item = document.getElementById(item);
          } else if (item && item.length) {
            item = item[0];
          }
          if (item && item.canvas) {
            item = item.canvas;
          }
          return item;
        }
        const instances = {};
        const getChart = (key) => {
          const canvas = getCanvas(key);
          return Object.values(instances).filter((c) => c.canvas === canvas).pop();
        };
        function moveNumericKeys(obj, start, move) {
          const keys = Object.keys(obj);
          for (const key of keys) {
            const intKey = +key;
            if (intKey >= start) {
              const value = obj[key];
              delete obj[key];
              if (move > 0 || intKey > start) {
                obj[intKey + move] = value;
              }
            }
          }
        }
        function determineLastEvent(e, lastEvent, inChartArea, isClick) {
          if (!inChartArea || e.type === "mouseout") {
            return null;
          }
          if (isClick) {
            return lastEvent;
          }
          return e;
        }
        class Chart3 {
          constructor(item, userConfig) {
            const config = this.config = new Config(userConfig);
            const initialCanvas = getCanvas(item);
            const existingChart = getChart(initialCanvas);
            if (existingChart) {
              throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas can be reused.");
            }
            const options = config.createResolver(config.chartOptionScopes(), this.getContext());
            this.platform = new (config.platform || _detectPlatform(initialCanvas))();
            this.platform.updateConfig(config);
            const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
            const canvas = context && context.canvas;
            const height = canvas && canvas.height;
            const width = canvas && canvas.width;
            this.id = uid();
            this.ctx = context;
            this.canvas = canvas;
            this.width = width;
            this.height = height;
            this._options = options;
            this._aspectRatio = this.aspectRatio;
            this._layers = [];
            this._metasets = [];
            this._stacks = void 0;
            this.boxes = [];
            this.currentDevicePixelRatio = void 0;
            this.chartArea = void 0;
            this._active = [];
            this._lastEvent = void 0;
            this._listeners = {};
            this._responsiveListeners = void 0;
            this._sortedMetasets = [];
            this.scales = {};
            this._plugins = new PluginService();
            this.$proxies = {};
            this._hiddenIndices = {};
            this.attached = false;
            this._animationsDisabled = void 0;
            this.$context = void 0;
            this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
            this._dataChanges = [];
            instances[this.id] = this;
            if (!context || !canvas) {
              console.error("Failed to create chart: can't acquire context from the given item");
              return;
            }
            animator.listen(this, "complete", onAnimationsComplete);
            animator.listen(this, "progress", onAnimationProgress);
            this._initialize();
            if (this.attached) {
              this.update();
            }
          }
          get aspectRatio() {
            const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
            if (!isNullOrUndef(aspectRatio)) {
              return aspectRatio;
            }
            if (maintainAspectRatio && _aspectRatio) {
              return _aspectRatio;
            }
            return height ? width / height : null;
          }
          get data() {
            return this.config.data;
          }
          set data(data) {
            this.config.data = data;
          }
          get options() {
            return this._options;
          }
          set options(options) {
            this.config.options = options;
          }
          _initialize() {
            this.notifyPlugins("beforeInit");
            if (this.options.responsive) {
              this.resize();
            } else {
              retinaScale(this, this.options.devicePixelRatio);
            }
            this.bindEvents();
            this.notifyPlugins("afterInit");
            return this;
          }
          clear() {
            clearCanvas(this.canvas, this.ctx);
            return this;
          }
          stop() {
            animator.stop(this);
            return this;
          }
          resize(width, height) {
            if (!animator.running(this)) {
              this._resize(width, height);
            } else {
              this._resizeBeforeDraw = { width, height };
            }
          }
          _resize(width, height) {
            const options = this.options;
            const canvas = this.canvas;
            const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
            const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
            const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
            const mode = this.width ? "resize" : "attach";
            this.width = newSize.width;
            this.height = newSize.height;
            this._aspectRatio = this.aspectRatio;
            if (!retinaScale(this, newRatio, true)) {
              return;
            }
            this.notifyPlugins("resize", { size: newSize });
            callback(options.onResize, [this, newSize], this);
            if (this.attached) {
              if (this._doResize(mode)) {
                this.render();
              }
            }
          }
          ensureScalesHaveIDs() {
            const options = this.options;
            const scalesOptions = options.scales || {};
            each(scalesOptions, (axisOptions, axisID) => {
              axisOptions.id = axisID;
            });
          }
          buildOrUpdateScales() {
            const options = this.options;
            const scaleOpts = options.scales;
            const scales2 = this.scales;
            const updated = Object.keys(scales2).reduce((obj, id) => {
              obj[id] = false;
              return obj;
            }, {});
            let items = [];
            if (scaleOpts) {
              items = items.concat(Object.keys(scaleOpts).map((id) => {
                const scaleOptions = scaleOpts[id];
                const axis = determineAxis(id, scaleOptions);
                const isRadial = axis === "r";
                const isHorizontal = axis === "x";
                return {
                  options: scaleOptions,
                  dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                  dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
                };
              }));
            }
            each(items, (item) => {
              const scaleOptions = item.options;
              const id = scaleOptions.id;
              const axis = determineAxis(id, scaleOptions);
              const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
              if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
                scaleOptions.position = item.dposition;
              }
              updated[id] = true;
              let scale = null;
              if (id in scales2 && scales2[id].type === scaleType) {
                scale = scales2[id];
              } else {
                const scaleClass = registry.getScale(scaleType);
                scale = new scaleClass({
                  id,
                  type: scaleType,
                  ctx: this.ctx,
                  chart: this
                });
                scales2[scale.id] = scale;
              }
              scale.init(scaleOptions, options);
            });
            each(updated, (hasUpdated, id) => {
              if (!hasUpdated) {
                delete scales2[id];
              }
            });
            each(scales2, (scale) => {
              layouts.configure(this, scale, scale.options);
              layouts.addBox(this, scale);
            });
          }
          _updateMetasets() {
            const metasets = this._metasets;
            const numData = this.data.datasets.length;
            const numMeta = metasets.length;
            metasets.sort((a, b) => a.index - b.index);
            if (numMeta > numData) {
              for (let i = numData; i < numMeta; ++i) {
                this._destroyDatasetMeta(i);
              }
              metasets.splice(numData, numMeta - numData);
            }
            this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
          }
          _removeUnreferencedMetasets() {
            const { _metasets: metasets, data: { datasets } } = this;
            if (metasets.length > datasets.length) {
              delete this._stacks;
            }
            metasets.forEach((meta, index2) => {
              if (datasets.filter((x) => x === meta._dataset).length === 0) {
                this._destroyDatasetMeta(index2);
              }
            });
          }
          buildOrUpdateControllers() {
            const newControllers = [];
            const datasets = this.data.datasets;
            let i, ilen;
            this._removeUnreferencedMetasets();
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
              const dataset = datasets[i];
              let meta = this.getDatasetMeta(i);
              const type = dataset.type || this.config.type;
              if (meta.type && meta.type !== type) {
                this._destroyDatasetMeta(i);
                meta = this.getDatasetMeta(i);
              }
              meta.type = type;
              meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
              meta.order = dataset.order || 0;
              meta.index = i;
              meta.label = "" + dataset.label;
              meta.visible = this.isDatasetVisible(i);
              if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
              } else {
                const ControllerClass = registry.getController(type);
                const { datasetElementType, dataElementType } = defaults.datasets[type];
                Object.assign(ControllerClass.prototype, {
                  dataElementType: registry.getElement(dataElementType),
                  datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                });
                meta.controller = new ControllerClass(this, i);
                newControllers.push(meta.controller);
              }
            }
            this._updateMetasets();
            return newControllers;
          }
          _resetElements() {
            each(this.data.datasets, (dataset, datasetIndex) => {
              this.getDatasetMeta(datasetIndex).controller.reset();
            }, this);
          }
          reset() {
            this._resetElements();
            this.notifyPlugins("reset");
          }
          update(mode) {
            const config = this.config;
            config.update();
            const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
            const animsDisabled = this._animationsDisabled = !options.animation;
            this._updateScales();
            this._checkEventBindings();
            this._updateHiddenIndices();
            this._plugins.invalidate();
            if (this.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
              return;
            }
            const newControllers = this.buildOrUpdateControllers();
            this.notifyPlugins("beforeElementsUpdate");
            let minPadding = 0;
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
              const { controller } = this.getDatasetMeta(i);
              const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
              controller.buildOrUpdateElements(reset);
              minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
            }
            minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
            this._updateLayout(minPadding);
            if (!animsDisabled) {
              each(newControllers, (controller) => {
                controller.reset();
              });
            }
            this._updateDatasets(mode);
            this.notifyPlugins("afterUpdate", { mode });
            this._layers.sort(compare2Level("z", "_idx"));
            const { _active, _lastEvent } = this;
            if (_lastEvent) {
              this._eventHandler(_lastEvent, true);
            } else if (_active.length) {
              this._updateHoverStyles(_active, _active, true);
            }
            this.render();
          }
          _updateScales() {
            each(this.scales, (scale) => {
              layouts.removeBox(this, scale);
            });
            this.ensureScalesHaveIDs();
            this.buildOrUpdateScales();
          }
          _checkEventBindings() {
            const options = this.options;
            const existingEvents = new Set(Object.keys(this._listeners));
            const newEvents = new Set(options.events);
            if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
              this.unbindEvents();
              this.bindEvents();
            }
          }
          _updateHiddenIndices() {
            const { _hiddenIndices } = this;
            const changes = this._getUniformDataChanges() || [];
            for (const { method, start, count } of changes) {
              const move = method === "_removeElements" ? -count : count;
              moveNumericKeys(_hiddenIndices, start, move);
            }
          }
          _getUniformDataChanges() {
            const _dataChanges = this._dataChanges;
            if (!_dataChanges || !_dataChanges.length) {
              return;
            }
            this._dataChanges = [];
            const datasetCount = this.data.datasets.length;
            const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
            const changeSet = makeSet(0);
            for (let i = 1; i < datasetCount; i++) {
              if (!setsEqual(changeSet, makeSet(i))) {
                return;
              }
            }
            return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
          }
          _updateLayout(minPadding) {
            if (this.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
              return;
            }
            layouts.update(this, this.width, this.height, minPadding);
            const area = this.chartArea;
            const noArea = area.width <= 0 || area.height <= 0;
            this._layers = [];
            each(this.boxes, (box) => {
              if (noArea && box.position === "chartArea") {
                return;
              }
              if (box.configure) {
                box.configure();
              }
              this._layers.push(...box._layers());
            }, this);
            this._layers.forEach((item, index2) => {
              item._idx = index2;
            });
            this.notifyPlugins("afterLayout");
          }
          _updateDatasets(mode) {
            if (this.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
              return;
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this.getDatasetMeta(i).controller.configure();
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this._updateDataset(i, isFunction(mode) ? mode({ datasetIndex: i }) : mode);
            }
            this.notifyPlugins("afterDatasetsUpdate", { mode });
          }
          _updateDataset(index2, mode) {
            const meta = this.getDatasetMeta(index2);
            const args = { meta, index: index2, mode, cancelable: true };
            if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
              return;
            }
            meta.controller._update(mode);
            args.cancelable = false;
            this.notifyPlugins("afterDatasetUpdate", args);
          }
          render() {
            if (this.notifyPlugins("beforeRender", { cancelable: true }) === false) {
              return;
            }
            if (animator.has(this)) {
              if (this.attached && !animator.running(this)) {
                animator.start(this);
              }
            } else {
              this.draw();
              onAnimationsComplete({ chart: this });
            }
          }
          draw() {
            let i;
            if (this._resizeBeforeDraw) {
              const { width, height } = this._resizeBeforeDraw;
              this._resize(width, height);
              this._resizeBeforeDraw = null;
            }
            this.clear();
            if (this.width <= 0 || this.height <= 0) {
              return;
            }
            if (this.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
              return;
            }
            const layers = this._layers;
            for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
              layers[i].draw(this.chartArea);
            }
            this._drawDatasets();
            for (; i < layers.length; ++i) {
              layers[i].draw(this.chartArea);
            }
            this.notifyPlugins("afterDraw");
          }
          _getSortedDatasetMetas(filterVisible) {
            const metasets = this._sortedMetasets;
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metasets.length; i < ilen; ++i) {
              const meta = metasets[i];
              if (!filterVisible || meta.visible) {
                result.push(meta);
              }
            }
            return result;
          }
          getSortedVisibleDatasetMetas() {
            return this._getSortedDatasetMetas(true);
          }
          _drawDatasets() {
            if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
              return;
            }
            const metasets = this.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
              this._drawDataset(metasets[i]);
            }
            this.notifyPlugins("afterDatasetsDraw");
          }
          _drawDataset(meta) {
            const ctx = this.ctx;
            const clip = meta._clip;
            const useClip = !clip.disabled;
            const area = this.chartArea;
            const args = {
              meta,
              index: meta.index,
              cancelable: true
            };
            if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
              return;
            }
            if (useClip) {
              clipArea(ctx, {
                left: clip.left === false ? 0 : area.left - clip.left,
                right: clip.right === false ? this.width : area.right + clip.right,
                top: clip.top === false ? 0 : area.top - clip.top,
                bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
              });
            }
            meta.controller.draw();
            if (useClip) {
              unclipArea(ctx);
            }
            args.cancelable = false;
            this.notifyPlugins("afterDatasetDraw", args);
          }
          isPointInArea(point) {
            return _isPointInArea(point, this.chartArea, this._minPadding);
          }
          getElementsAtEventForMode(e, mode, options, useFinalPosition) {
            const method = Interaction.modes[mode];
            if (typeof method === "function") {
              return method(this, e, options, useFinalPosition);
            }
            return [];
          }
          getDatasetMeta(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            const metasets = this._metasets;
            let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
            if (!meta) {
              meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset && dataset.order || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: false
              };
              metasets.push(meta);
            }
            return meta;
          }
          getContext() {
            return this.$context || (this.$context = createContext(null, { chart: this, type: "chart" }));
          }
          getVisibleDatasetCount() {
            return this.getSortedVisibleDatasetMetas().length;
          }
          isDatasetVisible(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            if (!dataset) {
              return false;
            }
            const meta = this.getDatasetMeta(datasetIndex);
            return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
          }
          setDatasetVisibility(datasetIndex, visible) {
            const meta = this.getDatasetMeta(datasetIndex);
            meta.hidden = !visible;
          }
          toggleDataVisibility(index2) {
            this._hiddenIndices[index2] = !this._hiddenIndices[index2];
          }
          getDataVisibility(index2) {
            return !this._hiddenIndices[index2];
          }
          _updateVisibility(datasetIndex, dataIndex, visible) {
            const mode = visible ? "show" : "hide";
            const meta = this.getDatasetMeta(datasetIndex);
            const anims = meta.controller._resolveAnimations(void 0, mode);
            if (defined(dataIndex)) {
              meta.data[dataIndex].hidden = !visible;
              this.update();
            } else {
              this.setDatasetVisibility(datasetIndex, visible);
              anims.update(meta, { visible });
              this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
            }
          }
          hide(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, false);
          }
          show(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, true);
          }
          _destroyDatasetMeta(datasetIndex) {
            const meta = this._metasets[datasetIndex];
            if (meta && meta.controller) {
              meta.controller._destroy();
            }
            delete this._metasets[datasetIndex];
          }
          _stop() {
            let i, ilen;
            this.stop();
            animator.remove(this);
            for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this._destroyDatasetMeta(i);
            }
          }
          destroy() {
            this.notifyPlugins("beforeDestroy");
            const { canvas, ctx } = this;
            this._stop();
            this.config.clearCache();
            if (canvas) {
              this.unbindEvents();
              clearCanvas(canvas, ctx);
              this.platform.releaseContext(ctx);
              this.canvas = null;
              this.ctx = null;
            }
            this.notifyPlugins("destroy");
            delete instances[this.id];
            this.notifyPlugins("afterDestroy");
          }
          toBase64Image(...args) {
            return this.canvas.toDataURL(...args);
          }
          bindEvents() {
            this.bindUserEvents();
            if (this.options.responsive) {
              this.bindResponsiveEvents();
            } else {
              this.attached = true;
            }
          }
          bindUserEvents() {
            const listeners = this._listeners;
            const platform = this.platform;
            const _add = (type, listener2) => {
              platform.addEventListener(this, type, listener2);
              listeners[type] = listener2;
            };
            const listener = (e, x, y) => {
              e.offsetX = x;
              e.offsetY = y;
              this._eventHandler(e);
            };
            each(this.options.events, (type) => _add(type, listener));
          }
          bindResponsiveEvents() {
            if (!this._responsiveListeners) {
              this._responsiveListeners = {};
            }
            const listeners = this._responsiveListeners;
            const platform = this.platform;
            const _add = (type, listener2) => {
              platform.addEventListener(this, type, listener2);
              listeners[type] = listener2;
            };
            const _remove = (type, listener2) => {
              if (listeners[type]) {
                platform.removeEventListener(this, type, listener2);
                delete listeners[type];
              }
            };
            const listener = (width, height) => {
              if (this.canvas) {
                this.resize(width, height);
              }
            };
            let detached;
            const attached = () => {
              _remove("attach", attached);
              this.attached = true;
              this.resize();
              _add("resize", listener);
              _add("detach", detached);
            };
            detached = () => {
              this.attached = false;
              _remove("resize", listener);
              this._stop();
              this._resize(0, 0);
              _add("attach", attached);
            };
            if (platform.isAttached(this.canvas)) {
              attached();
            } else {
              detached();
            }
          }
          unbindEvents() {
            each(this._listeners, (listener, type) => {
              this.platform.removeEventListener(this, type, listener);
            });
            this._listeners = {};
            each(this._responsiveListeners, (listener, type) => {
              this.platform.removeEventListener(this, type, listener);
            });
            this._responsiveListeners = void 0;
          }
          updateHoverStyle(items, mode, enabled) {
            const prefix = enabled ? "set" : "remove";
            let meta, item, i, ilen;
            if (mode === "dataset") {
              meta = this.getDatasetMeta(items[0].datasetIndex);
              meta.controller["_" + prefix + "DatasetHoverStyle"]();
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              item = items[i];
              const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
              if (controller) {
                controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
              }
            }
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(activeElements) {
            const lastActive = this._active || [];
            const active = activeElements.map(({ datasetIndex, index: index2 }) => {
              const meta = this.getDatasetMeta(datasetIndex);
              if (!meta) {
                throw new Error("No dataset found at index " + datasetIndex);
              }
              return {
                datasetIndex,
                element: meta.data[index2],
                index: index2
              };
            });
            const changed = !_elementsEqual(active, lastActive);
            if (changed) {
              this._active = active;
              this._lastEvent = null;
              this._updateHoverStyles(active, lastActive);
            }
          }
          notifyPlugins(hook, args, filter) {
            return this._plugins.notify(this, hook, args, filter);
          }
          _updateHoverStyles(active, lastActive, replay) {
            const hoverOptions = this.options.hover;
            const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
            const deactivated = diff(lastActive, active);
            const activated = replay ? active : diff(active, lastActive);
            if (deactivated.length) {
              this.updateHoverStyle(deactivated, hoverOptions.mode, false);
            }
            if (activated.length && hoverOptions.mode) {
              this.updateHoverStyle(activated, hoverOptions.mode, true);
            }
          }
          _eventHandler(e, replay) {
            const args = {
              event: e,
              replay,
              cancelable: true,
              inChartArea: this.isPointInArea(e)
            };
            const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
            if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
              return;
            }
            const changed = this._handleEvent(e, replay, args.inChartArea);
            args.cancelable = false;
            this.notifyPlugins("afterEvent", args, eventFilter);
            if (changed || args.changed) {
              this.render();
            }
            return this;
          }
          _handleEvent(e, replay, inChartArea) {
            const { _active: lastActive = [], options } = this;
            const useFinalPosition = replay;
            const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
            const isClick = _isClickEvent(e);
            const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
            if (inChartArea) {
              this._lastEvent = null;
              callback(options.onHover, [e, active, this], this);
              if (isClick) {
                callback(options.onClick, [e, active, this], this);
              }
            }
            const changed = !_elementsEqual(active, lastActive);
            if (changed || replay) {
              this._active = active;
              this._updateHoverStyles(active, lastActive, replay);
            }
            this._lastEvent = lastEvent;
            return changed;
          }
          _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
            if (e.type === "mouseout") {
              return [];
            }
            if (!inChartArea) {
              return lastActive;
            }
            const hoverOptions = this.options.hover;
            return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
          }
        }
        const invalidatePlugins = () => each(Chart3.instances, (chart2) => chart2._plugins.invalidate());
        const enumerable = true;
        Object.defineProperties(Chart3, {
          defaults: {
            enumerable,
            value: defaults
          },
          instances: {
            enumerable,
            value: instances
          },
          overrides: {
            enumerable,
            value: overrides
          },
          registry: {
            enumerable,
            value: registry
          },
          version: {
            enumerable,
            value: version
          },
          getChart: {
            enumerable,
            value: getChart
          },
          register: {
            enumerable,
            value: (...items) => {
              registry.add(...items);
              invalidatePlugins();
            }
          },
          unregister: {
            enumerable,
            value: (...items) => {
              registry.remove(...items);
              invalidatePlugins();
            }
          }
        });
        function abstract() {
          throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
        }
        class DateAdapter {
          constructor(options) {
            this.options = options || {};
          }
          formats() {
            return abstract();
          }
          parse(value, format) {
            return abstract();
          }
          format(timestamp, format) {
            return abstract();
          }
          add(timestamp, amount, unit) {
            return abstract();
          }
          diff(a, b, unit) {
            return abstract();
          }
          startOf(timestamp, unit, weekday) {
            return abstract();
          }
          endOf(timestamp, unit) {
            return abstract();
          }
        }
        DateAdapter.override = function(members) {
          Object.assign(DateAdapter.prototype, members);
        };
        var _adapters = {
          _date: DateAdapter
        };
        function getAllScaleValues(scale, type) {
          if (!scale._cache.$bar) {
            const visibleMetas = scale.getMatchingVisibleMetas(type);
            let values = [];
            for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
              values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
            }
            scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
          }
          return scale._cache.$bar;
        }
        function computeMinSampleSize(meta) {
          const scale = meta.iScale;
          const values = getAllScaleValues(scale, meta.type);
          let min = scale._length;
          let i, ilen, curr, prev;
          const updateMinAndPrev = () => {
            if (curr === 32767 || curr === -32768) {
              return;
            }
            if (defined(prev)) {
              min = Math.min(min, Math.abs(curr - prev) || min);
            }
            prev = curr;
          };
          for (i = 0, ilen = values.length; i < ilen; ++i) {
            curr = scale.getPixelForValue(values[i]);
            updateMinAndPrev();
          }
          prev = void 0;
          for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
            curr = scale.getPixelForTick(i);
            updateMinAndPrev();
          }
          return min;
        }
        function computeFitCategoryTraits(index2, ruler, options, stackCount) {
          const thickness = options.barThickness;
          let size, ratio;
          if (isNullOrUndef(thickness)) {
            size = ruler.min * options.categoryPercentage;
            ratio = options.barPercentage;
          } else {
            size = thickness * stackCount;
            ratio = 1;
          }
          return {
            chunk: size / stackCount,
            ratio,
            start: ruler.pixels[index2] - size / 2
          };
        }
        function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
          const pixels = ruler.pixels;
          const curr = pixels[index2];
          let prev = index2 > 0 ? pixels[index2 - 1] : null;
          let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
          const percent = options.categoryPercentage;
          if (prev === null) {
            prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
          }
          if (next === null) {
            next = curr + curr - prev;
          }
          const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
          const size = Math.abs(next - prev) / 2 * percent;
          return {
            chunk: size / stackCount,
            ratio: options.barPercentage,
            start
          };
        }
        function parseFloatBar(entry, item, vScale, i) {
          const startValue = vScale.parse(entry[0], i);
          const endValue = vScale.parse(entry[1], i);
          const min = Math.min(startValue, endValue);
          const max = Math.max(startValue, endValue);
          let barStart = min;
          let barEnd = max;
          if (Math.abs(min) > Math.abs(max)) {
            barStart = max;
            barEnd = min;
          }
          item[vScale.axis] = barEnd;
          item._custom = {
            barStart,
            barEnd,
            start: startValue,
            end: endValue,
            min,
            max
          };
        }
        function parseValue(entry, item, vScale, i) {
          if (isArray(entry)) {
            parseFloatBar(entry, item, vScale, i);
          } else {
            item[vScale.axis] = vScale.parse(entry, i);
          }
          return item;
        }
        function parseArrayOrPrimitive(meta, data, start, count) {
          const iScale = meta.iScale;
          const vScale = meta.vScale;
          const labels = iScale.getLabels();
          const singleScale = iScale === vScale;
          const parsed = [];
          let i, ilen, item, entry;
          for (i = start, ilen = start + count; i < ilen; ++i) {
            entry = data[i];
            item = {};
            item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
            parsed.push(parseValue(entry, item, vScale, i));
          }
          return parsed;
        }
        function isFloatBar(custom) {
          return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
        }
        function barSign(size, vScale, actualBase) {
          if (size !== 0) {
            return sign(size);
          }
          return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
        }
        function borderProps(properties) {
          let reverse, start, end, top, bottom;
          if (properties.horizontal) {
            reverse = properties.base > properties.x;
            start = "left";
            end = "right";
          } else {
            reverse = properties.base < properties.y;
            start = "bottom";
            end = "top";
          }
          if (reverse) {
            top = "end";
            bottom = "start";
          } else {
            top = "start";
            bottom = "end";
          }
          return { start, end, reverse, top, bottom };
        }
        function setBorderSkipped(properties, options, stack, index2) {
          let edge = options.borderSkipped;
          const res = {};
          if (!edge) {
            properties.borderSkipped = res;
            return;
          }
          const { start, end, reverse, top, bottom } = borderProps(properties);
          if (edge === "middle" && stack) {
            properties.enableBorderRadius = true;
            if ((stack._top || 0) === index2) {
              edge = top;
            } else if ((stack._bottom || 0) === index2) {
              edge = bottom;
            } else {
              res[parseEdge(bottom, start, end, reverse)] = true;
              edge = top;
            }
          }
          res[parseEdge(edge, start, end, reverse)] = true;
          properties.borderSkipped = res;
        }
        function parseEdge(edge, a, b, reverse) {
          if (reverse) {
            edge = swap(edge, a, b);
            edge = startEnd(edge, b, a);
          } else {
            edge = startEnd(edge, a, b);
          }
          return edge;
        }
        function swap(orig, v1, v2) {
          return orig === v1 ? v2 : orig === v2 ? v1 : orig;
        }
        function startEnd(v, start, end) {
          return v === "start" ? start : v === "end" ? end : v;
        }
        function setInflateAmount(properties, { inflateAmount }, ratio) {
          properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
        }
        class BarController extends DatasetController {
          parsePrimitiveData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
          }
          parseArrayData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
          }
          parseObjectData(meta, data, start, count) {
            const { iScale, vScale } = meta;
            const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
            const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
            const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
            const parsed = [];
            let i, ilen, item, obj;
            for (i = start, ilen = start + count; i < ilen; ++i) {
              obj = data[i];
              item = {};
              item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
              parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
            }
            return parsed;
          }
          updateRangeFromParsed(range2, scale, parsed, stack) {
            super.updateRangeFromParsed(range2, scale, parsed, stack);
            const custom = parsed._custom;
            if (custom && scale === this._cachedMeta.vScale) {
              range2.min = Math.min(range2.min, custom.min);
              range2.max = Math.max(range2.max, custom.max);
            }
          }
          getMaxOverflow() {
            return 0;
          }
          getLabelAndValue(index2) {
            const meta = this._cachedMeta;
            const { iScale, vScale } = meta;
            const parsed = this.getParsed(index2);
            const custom = parsed._custom;
            const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
            return {
              label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
              value
            };
          }
          initialize() {
            this.enableOptionSharing = true;
            super.initialize();
            const meta = this._cachedMeta;
            meta.stack = this.getDataset().stack;
          }
          update(mode) {
            const meta = this._cachedMeta;
            this.updateElements(meta.data, 0, meta.data.length, mode);
          }
          updateElements(bars, start, count, mode) {
            const reset = mode === "reset";
            const { index: index2, _cachedMeta: { vScale } } = this;
            const base = vScale.getBasePixel();
            const horizontal = vScale.isHorizontal();
            const ruler = this._getRuler();
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions);
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
            for (let i = start; i < start + count; i++) {
              const parsed = this.getParsed(i);
              const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base, head: base } : this._calculateBarValuePixels(i);
              const ipixels = this._calculateBarIndexPixels(i, ruler);
              const stack = (parsed._stacks || {})[vScale.axis];
              const properties = {
                horizontal,
                base: vpixels.base,
                enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index2 === stack._top || index2 === stack._bottom),
                x: horizontal ? vpixels.head : ipixels.center,
                y: horizontal ? ipixels.center : vpixels.head,
                height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                width: horizontal ? Math.abs(vpixels.size) : ipixels.size
              };
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
              }
              const options = properties.options || bars[i].options;
              setBorderSkipped(properties, options, stack, index2);
              setInflateAmount(properties, options, ruler.ratio);
              this.updateElement(bars[i], i, properties, mode);
            }
          }
          _getStacks(last, dataIndex) {
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const metasets = iScale.getMatchingVisibleMetas(this._type);
            const stacked = iScale.options.stacked;
            const ilen = metasets.length;
            const stacks = [];
            let i, item;
            for (i = 0; i < ilen; ++i) {
              item = metasets[i];
              if (!item.controller.options.grouped) {
                continue;
              }
              if (typeof dataIndex !== "undefined") {
                const val = item.controller.getParsed(dataIndex)[item.controller._cachedMeta.vScale.axis];
                if (isNullOrUndef(val) || isNaN(val)) {
                  continue;
                }
              }
              if (stacked === false || stacks.indexOf(item.stack) === -1 || stacked === void 0 && item.stack === void 0) {
                stacks.push(item.stack);
              }
              if (item.index === last) {
                break;
              }
            }
            if (!stacks.length) {
              stacks.push(void 0);
            }
            return stacks;
          }
          _getStackCount(index2) {
            return this._getStacks(void 0, index2).length;
          }
          _getStackIndex(datasetIndex, name, dataIndex) {
            const stacks = this._getStacks(datasetIndex, dataIndex);
            const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
            return index2 === -1 ? stacks.length - 1 : index2;
          }
          _getRuler() {
            const opts = this.options;
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const pixels = [];
            let i, ilen;
            for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
              pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
            }
            const barThickness = opts.barThickness;
            const min = barThickness || computeMinSampleSize(meta);
            return {
              min,
              pixels,
              start: iScale._startPixel,
              end: iScale._endPixel,
              stackCount: this._getStackCount(),
              scale: iScale,
              grouped: opts.grouped,
              ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
            };
          }
          _calculateBarValuePixels(index2) {
            const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;
            const actualBase = baseValue || 0;
            const parsed = this.getParsed(index2);
            const custom = parsed._custom;
            const floating = isFloatBar(custom);
            let value = parsed[vScale.axis];
            let start = 0;
            let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
            let head, size;
            if (length !== value) {
              start = length - value;
              length = value;
            }
            if (floating) {
              value = custom.barStart;
              length = custom.barEnd - custom.barStart;
              if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
                start = 0;
              }
              start += value;
            }
            const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
            let base = vScale.getPixelForValue(startValue);
            if (this.chart.getDataVisibility(index2)) {
              head = vScale.getPixelForValue(start + length);
            } else {
              head = base;
            }
            size = head - base;
            if (Math.abs(size) < minBarLength) {
              size = barSign(size, vScale, actualBase) * minBarLength;
              if (value === actualBase) {
                base -= size / 2;
              }
              const startPixel = vScale.getPixelForDecimal(0);
              const endPixel = vScale.getPixelForDecimal(1);
              const min = Math.min(startPixel, endPixel);
              const max = Math.max(startPixel, endPixel);
              base = Math.max(Math.min(base, max), min);
              head = base + size;
            }
            if (base === vScale.getPixelForValue(actualBase)) {
              const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
              base += halfGrid;
              size -= halfGrid;
            }
            return {
              size,
              base,
              head,
              center: head + size / 2
            };
          }
          _calculateBarIndexPixels(index2, ruler) {
            const scale = ruler.scale;
            const options = this.options;
            const skipNull = options.skipNull;
            const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
            let center, size;
            if (ruler.grouped) {
              const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
              const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
              const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
              center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
              size = Math.min(maxBarThickness, range2.chunk * range2.ratio);
            } else {
              center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
              size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
            }
            return {
              base: center - size / 2,
              head: center + size / 2,
              center,
              size
            };
          }
          draw() {
            const meta = this._cachedMeta;
            const vScale = meta.vScale;
            const rects = meta.data;
            const ilen = rects.length;
            let i = 0;
            for (; i < ilen; ++i) {
              if (this.getParsed(i)[vScale.axis] !== null) {
                rects[i].draw(this._ctx);
              }
            }
          }
        }
        BarController.id = "bar";
        BarController.defaults = {
          datasetElementType: false,
          dataElementType: "bar",
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          grouped: true,
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "base", "width", "height"]
            }
          }
        };
        BarController.overrides = {
          scales: {
            _index_: {
              type: "category",
              offset: true,
              grid: {
                offset: true
              }
            },
            _value_: {
              type: "linear",
              beginAtZero: true
            }
          }
        };
        class BubbleController extends DatasetController {
          initialize() {
            this.enableOptionSharing = true;
            super.initialize();
          }
          parsePrimitiveData(meta, data, start, count) {
            const parsed = super.parsePrimitiveData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
            }
            return parsed;
          }
          parseArrayData(meta, data, start, count) {
            const parsed = super.parseArrayData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              const item = data[start + i];
              parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
            }
            return parsed;
          }
          parseObjectData(meta, data, start, count) {
            const parsed = super.parseObjectData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              const item = data[start + i];
              parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
            }
            return parsed;
          }
          getMaxOverflow() {
            const data = this._cachedMeta.data;
            let max = 0;
            for (let i = data.length - 1; i >= 0; --i) {
              max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
            }
            return max > 0 && max;
          }
          getLabelAndValue(index2) {
            const meta = this._cachedMeta;
            const { xScale, yScale } = meta;
            const parsed = this.getParsed(index2);
            const x = xScale.getLabelForValue(parsed.x);
            const y = yScale.getLabelForValue(parsed.y);
            const r = parsed._custom;
            return {
              label: meta.label,
              value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
            };
          }
          update(mode) {
            const points = this._cachedMeta.data;
            this.updateElements(points, 0, points.length, mode);
          }
          updateElements(points, start, count, mode) {
            const reset = mode === "reset";
            const { iScale, vScale } = this._cachedMeta;
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            for (let i = start; i < start + count; i++) {
              const point = points[i];
              const parsed = !reset && this.getParsed(i);
              const properties = {};
              const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
              const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
              properties.skip = isNaN(iPixel) || isNaN(vPixel);
              if (includeOptions) {
                properties.options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
                if (reset) {
                  properties.options.radius = 0;
                }
              }
              this.updateElement(point, i, properties, mode);
            }
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
          }
          resolveDataElementOptions(index2, mode) {
            const parsed = this.getParsed(index2);
            let values = super.resolveDataElementOptions(index2, mode);
            if (values.$shared) {
              values = Object.assign({}, values, { $shared: false });
            }
            const radius = values.radius;
            if (mode !== "active") {
              values.radius = 0;
            }
            values.radius += valueOrDefault(parsed && parsed._custom, radius);
            return values;
          }
        }
        BubbleController.id = "bubble";
        BubbleController.defaults = {
          datasetElementType: false,
          dataElementType: "point",
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "borderWidth", "radius"]
            }
          }
        };
        BubbleController.overrides = {
          scales: {
            x: {
              type: "linear"
            },
            y: {
              type: "linear"
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                title() {
                  return "";
                }
              }
            }
          }
        };
        function getRatioAndOffset(rotation, circumference, cutout) {
          let ratioX = 1;
          let ratioY = 1;
          let offsetX = 0;
          let offsetY = 0;
          if (circumference < TAU) {
            const startAngle = rotation;
            const endAngle = startAngle + circumference;
            const startX = Math.cos(startAngle);
            const startY = Math.sin(startAngle);
            const endX = Math.cos(endAngle);
            const endY = Math.sin(endAngle);
            const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
            const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
            const maxX = calcMax(0, startX, endX);
            const maxY = calcMax(HALF_PI, startY, endY);
            const minX = calcMin(PI, startX, endX);
            const minY = calcMin(PI + HALF_PI, startY, endY);
            ratioX = (maxX - minX) / 2;
            ratioY = (maxY - minY) / 2;
            offsetX = -(maxX + minX) / 2;
            offsetY = -(maxY + minY) / 2;
          }
          return { ratioX, ratioY, offsetX, offsetY };
        }
        class DoughnutController extends DatasetController {
          constructor(chart2, datasetIndex) {
            super(chart2, datasetIndex);
            this.enableOptionSharing = true;
            this.innerRadius = void 0;
            this.outerRadius = void 0;
            this.offsetX = void 0;
            this.offsetY = void 0;
          }
          linkScales() {
          }
          parse(start, count) {
            const data = this.getDataset().data;
            const meta = this._cachedMeta;
            if (this._parsing === false) {
              meta._parsed = data;
            } else {
              let getter = (i2) => +data[i2];
              if (isObject2(data[start])) {
                const { key = "value" } = this._parsing;
                getter = (i2) => +resolveObjectKey(data[i2], key);
              }
              let i, ilen;
              for (i = start, ilen = start + count; i < ilen; ++i) {
                meta._parsed[i] = getter(i);
              }
            }
          }
          _getRotation() {
            return toRadians(this.options.rotation - 90);
          }
          _getCircumference() {
            return toRadians(this.options.circumference);
          }
          _getRotationExtents() {
            let min = TAU;
            let max = -TAU;
            for (let i = 0; i < this.chart.data.datasets.length; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                const controller = this.chart.getDatasetMeta(i).controller;
                const rotation = controller._getRotation();
                const circumference = controller._getCircumference();
                min = Math.min(min, rotation);
                max = Math.max(max, rotation + circumference);
              }
            }
            return {
              rotation: min,
              circumference: max - min
            };
          }
          update(mode) {
            const chart2 = this.chart;
            const { chartArea } = chart2;
            const meta = this._cachedMeta;
            const arcs = meta.data;
            const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
            const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
            const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
            const chartWeight = this._getRingWeight(this.index);
            const { circumference, rotation } = this._getRotationExtents();
            const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
            const maxWidth = (chartArea.width - spacing) / ratioX;
            const maxHeight = (chartArea.height - spacing) / ratioY;
            const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
            const outerRadius = toDimension(this.options.radius, maxRadius);
            const innerRadius = Math.max(outerRadius * cutout, 0);
            const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
            this.offsetX = offsetX * outerRadius;
            this.offsetY = offsetY * outerRadius;
            meta.total = this.calculateTotal();
            this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
            this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
            this.updateElements(arcs, 0, arcs.length, mode);
          }
          _circumference(i, reset) {
            const opts = this.options;
            const meta = this._cachedMeta;
            const circumference = this._getCircumference();
            if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
              return 0;
            }
            return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
          }
          updateElements(arcs, start, count, mode) {
            const reset = mode === "reset";
            const chart2 = this.chart;
            const chartArea = chart2.chartArea;
            const opts = chart2.options;
            const animationOpts = opts.animation;
            const centerX = (chartArea.left + chartArea.right) / 2;
            const centerY = (chartArea.top + chartArea.bottom) / 2;
            const animateScale = reset && animationOpts.animateScale;
            const innerRadius = animateScale ? 0 : this.innerRadius;
            const outerRadius = animateScale ? 0 : this.outerRadius;
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions);
            let startAngle = this._getRotation();
            let i;
            for (i = 0; i < start; ++i) {
              startAngle += this._circumference(i, reset);
            }
            for (i = start; i < start + count; ++i) {
              const circumference = this._circumference(i, reset);
              const arc = arcs[i];
              const properties = {
                x: centerX + this.offsetX,
                y: centerY + this.offsetY,
                startAngle,
                endAngle: startAngle + circumference,
                circumference,
                outerRadius,
                innerRadius
              };
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
              }
              startAngle += circumference;
              this.updateElement(arc, i, properties, mode);
            }
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
          }
          calculateTotal() {
            const meta = this._cachedMeta;
            const metaData = meta.data;
            let total = 0;
            let i;
            for (i = 0; i < metaData.length; i++) {
              const value = meta._parsed[i];
              if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
                total += Math.abs(value);
              }
            }
            return total;
          }
          calculateCircumference(value) {
            const total = this._cachedMeta.total;
            if (total > 0 && !isNaN(value)) {
              return TAU * (Math.abs(value) / total);
            }
            return 0;
          }
          getLabelAndValue(index2) {
            const meta = this._cachedMeta;
            const chart2 = this.chart;
            const labels = chart2.data.labels || [];
            const value = formatNumber(meta._parsed[index2], chart2.options.locale);
            return {
              label: labels[index2] || "",
              value
            };
          }
          getMaxBorderWidth(arcs) {
            let max = 0;
            const chart2 = this.chart;
            let i, ilen, meta, controller, options;
            if (!arcs) {
              for (i = 0, ilen = chart2.data.datasets.length; i < ilen; ++i) {
                if (chart2.isDatasetVisible(i)) {
                  meta = chart2.getDatasetMeta(i);
                  arcs = meta.data;
                  controller = meta.controller;
                  break;
                }
              }
            }
            if (!arcs) {
              return 0;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              options = controller.resolveDataElementOptions(i);
              if (options.borderAlign !== "inner") {
                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
              }
            }
            return max;
          }
          getMaxOffset(arcs) {
            let max = 0;
            for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
              const options = this.resolveDataElementOptions(i);
              max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
            }
            return max;
          }
          _getRingWeightOffset(datasetIndex) {
            let ringWeightOffset = 0;
            for (let i = 0; i < datasetIndex; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                ringWeightOffset += this._getRingWeight(i);
              }
            }
            return ringWeightOffset;
          }
          _getRingWeight(datasetIndex) {
            return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
          }
          _getVisibleDatasetWeightTotal() {
            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
          }
        }
        DoughnutController.id = "doughnut";
        DoughnutController.defaults = {
          datasetElementType: false,
          dataElementType: "arc",
          animation: {
            animateRotate: true,
            animateScale: false
          },
          animations: {
            numbers: {
              type: "number",
              properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
            }
          },
          cutout: "50%",
          rotation: 0,
          circumference: 360,
          radius: "100%",
          spacing: 0,
          indexAxis: "r"
        };
        DoughnutController.descriptors = {
          _scriptable: (name) => name !== "spacing",
          _indexable: (name) => name !== "spacing"
        };
        DoughnutController.overrides = {
          aspectRatio: 1,
          plugins: {
            legend: {
              labels: {
                generateLabels(chart2) {
                  const data = chart2.data;
                  if (data.labels.length && data.datasets.length) {
                    const { labels: { pointStyle } } = chart2.legend.options;
                    return data.labels.map((label, i) => {
                      const meta = chart2.getDatasetMeta(0);
                      const style = meta.controller.getStyle(i);
                      return {
                        text: label,
                        fillStyle: style.backgroundColor,
                        strokeStyle: style.borderColor,
                        lineWidth: style.borderWidth,
                        pointStyle,
                        hidden: !chart2.getDataVisibility(i),
                        index: i
                      };
                    });
                  }
                  return [];
                }
              },
              onClick(e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
              }
            },
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(tooltipItem) {
                  let dataLabel = tooltipItem.label;
                  const value = ": " + tooltipItem.formattedValue;
                  if (isArray(dataLabel)) {
                    dataLabel = dataLabel.slice();
                    dataLabel[0] += value;
                  } else {
                    dataLabel += value;
                  }
                  return dataLabel;
                }
              }
            }
          }
        };
        class LineController extends DatasetController {
          initialize() {
            this.enableOptionSharing = true;
            this.supportsDecimation = true;
            super.initialize();
          }
          update(mode) {
            const meta = this._cachedMeta;
            const { dataset: line, data: points = [], _dataset } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start, count } = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
            this._drawStart = start;
            this._drawCount = count;
            if (scaleRangesChanged(meta)) {
              start = 0;
              count = points.length;
            }
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
              options.borderWidth = 0;
            }
            options.segment = this.options.segment;
            this.updateElement(line, void 0, {
              animated: !animationsDisabled,
              options
            }, mode);
            this.updateElements(points, start, count, mode);
          }
          updateElements(points, start, count, mode) {
            const reset = mode === "reset";
            const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps, segment } = this.options;
            const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
            const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for (let i = start; i < start + count; ++i) {
              const point = points[i];
              const parsed = this.getParsed(i);
              const properties = directUpdate ? point : {};
              const nullData = isNullOrUndef(parsed[vAxis]);
              const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
              const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
              properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
              properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
              if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
              }
              if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
              }
              if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
              }
              prevParsed = parsed;
            }
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
          }
          getMaxOverflow() {
            const meta = this._cachedMeta;
            const dataset = meta.dataset;
            const border = dataset.options && dataset.options.borderWidth || 0;
            const data = meta.data || [];
            if (!data.length) {
              return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
            return Math.max(border, firstPoint, lastPoint) / 2;
          }
          draw() {
            const meta = this._cachedMeta;
            meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
            super.draw();
          }
        }
        LineController.id = "line";
        LineController.defaults = {
          datasetElementType: "line",
          dataElementType: "point",
          showLine: true,
          spanGaps: false
        };
        LineController.overrides = {
          scales: {
            _index_: {
              type: "category"
            },
            _value_: {
              type: "linear"
            }
          }
        };
        function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
          const pointCount = points.length;
          let start = 0;
          let count = pointCount;
          if (meta._sorted) {
            const { iScale, _parsed } = meta;
            const axis = iScale.axis;
            const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
            if (minDefined) {
              start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
            }
            if (maxDefined) {
              count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1), start, pointCount) - start;
            } else {
              count = pointCount - start;
            }
          }
          return { start, count };
        }
        function scaleRangesChanged(meta) {
          const { xScale, yScale, _scaleRanges } = meta;
          const newRanges = {
            xmin: xScale.min,
            xmax: xScale.max,
            ymin: yScale.min,
            ymax: yScale.max
          };
          if (!_scaleRanges) {
            meta._scaleRanges = newRanges;
            return true;
          }
          const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
          Object.assign(_scaleRanges, newRanges);
          return changed;
        }
        class PolarAreaController extends DatasetController {
          constructor(chart2, datasetIndex) {
            super(chart2, datasetIndex);
            this.innerRadius = void 0;
            this.outerRadius = void 0;
          }
          getLabelAndValue(index2) {
            const meta = this._cachedMeta;
            const chart2 = this.chart;
            const labels = chart2.data.labels || [];
            const value = formatNumber(meta._parsed[index2].r, chart2.options.locale);
            return {
              label: labels[index2] || "",
              value
            };
          }
          parseObjectData(meta, data, start, count) {
            return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
          }
          update(mode) {
            const arcs = this._cachedMeta.data;
            this._updateRadius();
            this.updateElements(arcs, 0, arcs.length, mode);
          }
          getMinMax() {
            const meta = this._cachedMeta;
            const range2 = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
            meta.data.forEach((element, index2) => {
              const parsed = this.getParsed(index2).r;
              if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
                if (parsed < range2.min) {
                  range2.min = parsed;
                }
                if (parsed > range2.max) {
                  range2.max = parsed;
                }
              }
            });
            return range2;
          }
          _updateRadius() {
            const chart2 = this.chart;
            const chartArea = chart2.chartArea;
            const opts = chart2.options;
            const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
            const outerRadius = Math.max(minSize / 2, 0);
            const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
            const radiusLength = (outerRadius - innerRadius) / chart2.getVisibleDatasetCount();
            this.outerRadius = outerRadius - radiusLength * this.index;
            this.innerRadius = this.outerRadius - radiusLength;
          }
          updateElements(arcs, start, count, mode) {
            const reset = mode === "reset";
            const chart2 = this.chart;
            const opts = chart2.options;
            const animationOpts = opts.animation;
            const scale = this._cachedMeta.rScale;
            const centerX = scale.xCenter;
            const centerY = scale.yCenter;
            const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
            let angle = datasetStartAngle;
            let i;
            const defaultAngle = 360 / this.countVisibleElements();
            for (i = 0; i < start; ++i) {
              angle += this._computeAngle(i, mode, defaultAngle);
            }
            for (i = start; i < start + count; i++) {
              const arc = arcs[i];
              let startAngle = angle;
              let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
              let outerRadius = chart2.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
              angle = endAngle;
              if (reset) {
                if (animationOpts.animateScale) {
                  outerRadius = 0;
                }
                if (animationOpts.animateRotate) {
                  startAngle = endAngle = datasetStartAngle;
                }
              }
              const properties = {
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius,
                startAngle,
                endAngle,
                options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
              };
              this.updateElement(arc, i, properties, mode);
            }
          }
          countVisibleElements() {
            const meta = this._cachedMeta;
            let count = 0;
            meta.data.forEach((element, index2) => {
              if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
                count++;
              }
            });
            return count;
          }
          _computeAngle(index2, mode, defaultAngle) {
            return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
          }
        }
        PolarAreaController.id = "polarArea";
        PolarAreaController.defaults = {
          dataElementType: "arc",
          animation: {
            animateRotate: true,
            animateScale: true
          },
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
            }
          },
          indexAxis: "r",
          startAngle: 0
        };
        PolarAreaController.overrides = {
          aspectRatio: 1,
          plugins: {
            legend: {
              labels: {
                generateLabels(chart2) {
                  const data = chart2.data;
                  if (data.labels.length && data.datasets.length) {
                    const { labels: { pointStyle } } = chart2.legend.options;
                    return data.labels.map((label, i) => {
                      const meta = chart2.getDatasetMeta(0);
                      const style = meta.controller.getStyle(i);
                      return {
                        text: label,
                        fillStyle: style.backgroundColor,
                        strokeStyle: style.borderColor,
                        lineWidth: style.borderWidth,
                        pointStyle,
                        hidden: !chart2.getDataVisibility(i),
                        index: i
                      };
                    });
                  }
                  return [];
                }
              },
              onClick(e, legendItem, legend) {
                legend.chart.toggleDataVisibility(legendItem.index);
                legend.chart.update();
              }
            },
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(context) {
                  return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
                }
              }
            }
          },
          scales: {
            r: {
              type: "radialLinear",
              angleLines: {
                display: false
              },
              beginAtZero: true,
              grid: {
                circular: true
              },
              pointLabels: {
                display: false
              },
              startAngle: 0
            }
          }
        };
        class PieController extends DoughnutController {
        }
        PieController.id = "pie";
        PieController.defaults = {
          cutout: 0,
          rotation: 0,
          circumference: 360,
          radius: "100%"
        };
        class RadarController extends DatasetController {
          getLabelAndValue(index2) {
            const vScale = this._cachedMeta.vScale;
            const parsed = this.getParsed(index2);
            return {
              label: vScale.getLabels()[index2],
              value: "" + vScale.getLabelForValue(parsed[vScale.axis])
            };
          }
          parseObjectData(meta, data, start, count) {
            return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
          }
          update(mode) {
            const meta = this._cachedMeta;
            const line = meta.dataset;
            const points = meta.data || [];
            const labels = meta.iScale.getLabels();
            line.points = points;
            if (mode !== "resize") {
              const options = this.resolveDatasetElementOptions(mode);
              if (!this.options.showLine) {
                options.borderWidth = 0;
              }
              const properties = {
                _loop: true,
                _fullLoop: labels.length === points.length,
                options
              };
              this.updateElement(line, void 0, properties, mode);
            }
            this.updateElements(points, 0, points.length, mode);
          }
          updateElements(points, start, count, mode) {
            const scale = this._cachedMeta.rScale;
            const reset = mode === "reset";
            for (let i = start; i < start + count; i++) {
              const point = points[i];
              const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
              const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
              const x = reset ? scale.xCenter : pointPosition.x;
              const y = reset ? scale.yCenter : pointPosition.y;
              const properties = {
                x,
                y,
                angle: pointPosition.angle,
                skip: isNaN(x) || isNaN(y),
                options
              };
              this.updateElement(point, i, properties, mode);
            }
          }
        }
        RadarController.id = "radar";
        RadarController.defaults = {
          datasetElementType: "line",
          dataElementType: "point",
          indexAxis: "r",
          showLine: true,
          elements: {
            line: {
              fill: "start"
            }
          }
        };
        RadarController.overrides = {
          aspectRatio: 1,
          scales: {
            r: {
              type: "radialLinear"
            }
          }
        };
        class ScatterController extends LineController {
        }
        ScatterController.id = "scatter";
        ScatterController.defaults = {
          showLine: false,
          fill: false
        };
        ScatterController.overrides = {
          interaction: {
            mode: "point"
          },
          plugins: {
            tooltip: {
              callbacks: {
                title() {
                  return "";
                },
                label(item) {
                  return "(" + item.label + ", " + item.formattedValue + ")";
                }
              }
            }
          },
          scales: {
            x: {
              type: "linear"
            },
            y: {
              type: "linear"
            }
          }
        };
        var controllers = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          BarController,
          BubbleController,
          DoughnutController,
          LineController,
          PolarAreaController,
          PieController,
          RadarController,
          ScatterController
        });
        function clipArc(ctx, element, endAngle) {
          const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
          let angleMargin = pixelMargin / outerRadius;
          ctx.beginPath();
          ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
          if (innerRadius > pixelMargin) {
            angleMargin = pixelMargin / innerRadius;
            ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
          } else {
            ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
          }
          ctx.closePath();
          ctx.clip();
        }
        function toRadiusCorners(value) {
          return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
        }
        function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
          const o = toRadiusCorners(arc.options.borderRadius);
          const halfThickness = (outerRadius - innerRadius) / 2;
          const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
          const computeOuterLimit = (val) => {
            const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
            return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
          };
          return {
            outerStart: computeOuterLimit(o.outerStart),
            outerEnd: computeOuterLimit(o.outerEnd),
            innerStart: _limitValue(o.innerStart, 0, innerLimit),
            innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
          };
        }
        function rThetaToXY(r, theta, x, y) {
          return {
            x: x + r * Math.cos(theta),
            y: y + r * Math.sin(theta)
          };
        }
        function pathArc(ctx, element, offset, spacing, end) {
          const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
          const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
          const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
          let spacingOffset = 0;
          const alpha2 = end - start;
          if (spacing) {
            const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
            const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
            const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
            const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
            spacingOffset = (alpha2 - adjustedAngle) / 2;
          }
          const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
          const angleOffset = (alpha2 - beta) / 2;
          const startAngle = start + angleOffset + spacingOffset;
          const endAngle = end - angleOffset - spacingOffset;
          const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
          const outerStartAdjustedRadius = outerRadius - outerStart;
          const outerEndAdjustedRadius = outerRadius - outerEnd;
          const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
          const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
          const innerStartAdjustedRadius = innerRadius + innerStart;
          const innerEndAdjustedRadius = innerRadius + innerEnd;
          const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
          const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
          ctx.beginPath();
          ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
          if (outerEnd > 0) {
            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
          }
          const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
          ctx.lineTo(p4.x, p4.y);
          if (innerEnd > 0) {
            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
          }
          ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
          if (innerStart > 0) {
            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
          }
          const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
          ctx.lineTo(p8.x, p8.y);
          if (outerStart > 0) {
            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
          }
          ctx.closePath();
        }
        function drawArc(ctx, element, offset, spacing) {
          const { fullCircles, startAngle, circumference } = element;
          let endAngle = element.endAngle;
          if (fullCircles) {
            pathArc(ctx, element, offset, spacing, startAngle + TAU);
            for (let i = 0; i < fullCircles; ++i) {
              ctx.fill();
            }
            if (!isNaN(circumference)) {
              endAngle = startAngle + circumference % TAU;
              if (circumference % TAU === 0) {
                endAngle += TAU;
              }
            }
          }
          pathArc(ctx, element, offset, spacing, endAngle);
          ctx.fill();
          return endAngle;
        }
        function drawFullCircleBorders(ctx, element, inner) {
          const { x, y, startAngle, pixelMargin, fullCircles } = element;
          const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
          const innerRadius = element.innerRadius + pixelMargin;
          let i;
          if (inner) {
            clipArc(ctx, element, startAngle + TAU);
          }
          ctx.beginPath();
          ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
          for (i = 0; i < fullCircles; ++i) {
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
          for (i = 0; i < fullCircles; ++i) {
            ctx.stroke();
          }
        }
        function drawBorder(ctx, element, offset, spacing, endAngle) {
          const { options } = element;
          const { borderWidth, borderJoinStyle } = options;
          const inner = options.borderAlign === "inner";
          if (!borderWidth) {
            return;
          }
          if (inner) {
            ctx.lineWidth = borderWidth * 2;
            ctx.lineJoin = borderJoinStyle || "round";
          } else {
            ctx.lineWidth = borderWidth;
            ctx.lineJoin = borderJoinStyle || "bevel";
          }
          if (element.fullCircles) {
            drawFullCircleBorders(ctx, element, inner);
          }
          if (inner) {
            clipArc(ctx, element, endAngle);
          }
          pathArc(ctx, element, offset, spacing, endAngle);
          ctx.stroke();
        }
        class ArcElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.circumference = void 0;
            this.startAngle = void 0;
            this.endAngle = void 0;
            this.innerRadius = void 0;
            this.outerRadius = void 0;
            this.pixelMargin = 0;
            this.fullCircles = 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          inRange(chartX, chartY, useFinalPosition) {
            const point = this.getProps(["x", "y"], useFinalPosition);
            const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
            const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
              "startAngle",
              "endAngle",
              "innerRadius",
              "outerRadius",
              "circumference"
            ], useFinalPosition);
            const rAdjust = this.options.spacing / 2;
            const _circumference = valueOrDefault(circumference, endAngle - startAngle);
            const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
            const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
            return betweenAngles && withinRadius;
          }
          getCenterPoint(useFinalPosition) {
            const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
              "x",
              "y",
              "startAngle",
              "endAngle",
              "innerRadius",
              "outerRadius",
              "circumference"
            ], useFinalPosition);
            const { offset, spacing } = this.options;
            const halfAngle = (startAngle + endAngle) / 2;
            const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
            return {
              x: x + Math.cos(halfAngle) * halfRadius,
              y: y + Math.sin(halfAngle) * halfRadius
            };
          }
          tooltipPosition(useFinalPosition) {
            return this.getCenterPoint(useFinalPosition);
          }
          draw(ctx) {
            const { options, circumference } = this;
            const offset = (options.offset || 0) / 2;
            const spacing = (options.spacing || 0) / 2;
            this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
            this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
            if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
              return;
            }
            ctx.save();
            let radiusOffset = 0;
            if (offset) {
              radiusOffset = offset / 2;
              const halfAngle = (this.startAngle + this.endAngle) / 2;
              ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
              if (this.circumference >= PI) {
                radiusOffset = offset;
              }
            }
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            const endAngle = drawArc(ctx, this, radiusOffset, spacing);
            drawBorder(ctx, this, radiusOffset, spacing, endAngle);
            ctx.restore();
          }
        }
        ArcElement.id = "arc";
        ArcElement.defaults = {
          borderAlign: "center",
          borderColor: "#fff",
          borderJoinStyle: void 0,
          borderRadius: 0,
          borderWidth: 2,
          offset: 0,
          spacing: 0,
          angle: void 0
        };
        ArcElement.defaultRoutes = {
          backgroundColor: "backgroundColor"
        };
        function setStyle(ctx, options, style = options) {
          ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
          ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
          ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
          ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
          ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
          ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
        }
        function lineTo(ctx, previous, target) {
          ctx.lineTo(target.x, target.y);
        }
        function getLineMethod(options) {
          if (options.stepped) {
            return _steppedLineTo;
          }
          if (options.tension || options.cubicInterpolationMode === "monotone") {
            return _bezierCurveTo;
          }
          return lineTo;
        }
        function pathVars(points, segment, params = {}) {
          const count = points.length;
          const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
          const { start: segmentStart, end: segmentEnd } = segment;
          const start = Math.max(paramsStart, segmentStart);
          const end = Math.min(paramsEnd, segmentEnd);
          const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
          return {
            count,
            start,
            loop: segment.loop,
            ilen: end < start && !outside ? count + end - start : end - start
          };
        }
        function pathSegment(ctx, line, segment, params) {
          const { points, options } = line;
          const { count, start, loop, ilen } = pathVars(points, segment, params);
          const lineMethod = getLineMethod(options);
          let { move = true, reverse } = params || {};
          let i, point, prev;
          for (i = 0; i <= ilen; ++i) {
            point = points[(start + (reverse ? ilen - i : i)) % count];
            if (point.skip) {
              continue;
            } else if (move) {
              ctx.moveTo(point.x, point.y);
              move = false;
            } else {
              lineMethod(ctx, prev, point, reverse, options.stepped);
            }
            prev = point;
          }
          if (loop) {
            point = points[(start + (reverse ? ilen : 0)) % count];
            lineMethod(ctx, prev, point, reverse, options.stepped);
          }
          return !!loop;
        }
        function fastPathSegment(ctx, line, segment, params) {
          const points = line.points;
          const { count, start, ilen } = pathVars(points, segment, params);
          const { move = true, reverse } = params || {};
          let avgX = 0;
          let countX = 0;
          let i, point, prevX, minY, maxY, lastY;
          const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
          const drawX = () => {
            if (minY !== maxY) {
              ctx.lineTo(avgX, maxY);
              ctx.lineTo(avgX, minY);
              ctx.lineTo(avgX, lastY);
            }
          };
          if (move) {
            point = points[pointIndex(0)];
            ctx.moveTo(point.x, point.y);
          }
          for (i = 0; i <= ilen; ++i) {
            point = points[pointIndex(i)];
            if (point.skip) {
              continue;
            }
            const x = point.x;
            const y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
              if (y < minY) {
                minY = y;
              } else if (y > maxY) {
                maxY = y;
              }
              avgX = (countX * avgX + x) / ++countX;
            } else {
              drawX();
              ctx.lineTo(x, y);
              prevX = truncX;
              countX = 0;
              minY = maxY = y;
            }
            lastY = y;
          }
          drawX();
        }
        function _getSegmentMethod(line) {
          const opts = line.options;
          const borderDash = opts.borderDash && opts.borderDash.length;
          const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
          return useFastPath ? fastPathSegment : pathSegment;
        }
        function _getInterpolationMethod(options) {
          if (options.stepped) {
            return _steppedInterpolation;
          }
          if (options.tension || options.cubicInterpolationMode === "monotone") {
            return _bezierInterpolation;
          }
          return _pointInLine;
        }
        function strokePathWithCache(ctx, line, start, count) {
          let path = line._path;
          if (!path) {
            path = line._path = new Path2D();
            if (line.path(path, start, count)) {
              path.closePath();
            }
          }
          setStyle(ctx, line.options);
          ctx.stroke(path);
        }
        function strokePathDirect(ctx, line, start, count) {
          const { segments, options } = line;
          const segmentMethod = _getSegmentMethod(line);
          for (const segment of segments) {
            setStyle(ctx, options, segment.style);
            ctx.beginPath();
            if (segmentMethod(ctx, line, segment, { start, end: start + count - 1 })) {
              ctx.closePath();
            }
            ctx.stroke();
          }
        }
        const usePath2D = typeof Path2D === "function";
        function draw(ctx, line, start, count) {
          if (usePath2D && !line.options.segment) {
            strokePathWithCache(ctx, line, start, count);
          } else {
            strokePathDirect(ctx, line, start, count);
          }
        }
        class LineElement extends Element2 {
          constructor(cfg) {
            super();
            this.animated = true;
            this.options = void 0;
            this._chart = void 0;
            this._loop = void 0;
            this._fullLoop = void 0;
            this._path = void 0;
            this._points = void 0;
            this._segments = void 0;
            this._decimated = false;
            this._pointsUpdated = false;
            this._datasetIndex = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          updateControlPoints(chartArea, indexAxis) {
            const options = this.options;
            if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
              const loop = options.spanGaps ? this._loop : this._fullLoop;
              _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
              this._pointsUpdated = true;
            }
          }
          set points(points) {
            this._points = points;
            delete this._segments;
            delete this._path;
            this._pointsUpdated = false;
          }
          get points() {
            return this._points;
          }
          get segments() {
            return this._segments || (this._segments = _computeSegments(this, this.options.segment));
          }
          first() {
            const segments = this.segments;
            const points = this.points;
            return segments.length && points[segments[0].start];
          }
          last() {
            const segments = this.segments;
            const points = this.points;
            const count = segments.length;
            return count && points[segments[count - 1].end];
          }
          interpolate(point, property) {
            const options = this.options;
            const value = point[property];
            const points = this.points;
            const segments = _boundSegments(this, { property, start: value, end: value });
            if (!segments.length) {
              return;
            }
            const result = [];
            const _interpolate = _getInterpolationMethod(options);
            let i, ilen;
            for (i = 0, ilen = segments.length; i < ilen; ++i) {
              const { start, end } = segments[i];
              const p1 = points[start];
              const p2 = points[end];
              if (p1 === p2) {
                result.push(p1);
                continue;
              }
              const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
              const interpolated = _interpolate(p1, p2, t, options.stepped);
              interpolated[property] = point[property];
              result.push(interpolated);
            }
            return result.length === 1 ? result[0] : result;
          }
          pathSegment(ctx, segment, params) {
            const segmentMethod = _getSegmentMethod(this);
            return segmentMethod(ctx, this, segment, params);
          }
          path(ctx, start, count) {
            const segments = this.segments;
            const segmentMethod = _getSegmentMethod(this);
            let loop = this._loop;
            start = start || 0;
            count = count || this.points.length - start;
            for (const segment of segments) {
              loop &= segmentMethod(ctx, this, segment, { start, end: start + count - 1 });
            }
            return !!loop;
          }
          draw(ctx, chartArea, start, count) {
            const options = this.options || {};
            const points = this.points || [];
            if (points.length && options.borderWidth) {
              ctx.save();
              draw(ctx, this, start, count);
              ctx.restore();
            }
            if (this.animated) {
              this._pointsUpdated = false;
              this._path = void 0;
            }
          }
        }
        LineElement.id = "line";
        LineElement.defaults = {
          borderCapStyle: "butt",
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: "miter",
          borderWidth: 3,
          capBezierPoints: true,
          cubicInterpolationMode: "default",
          fill: false,
          spanGaps: false,
          stepped: false,
          tension: 0
        };
        LineElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        LineElement.descriptors = {
          _scriptable: true,
          _indexable: (name) => name !== "borderDash" && name !== "fill"
        };
        function inRange$1(el, pos, axis, useFinalPosition) {
          const options = el.options;
          const { [axis]: value } = el.getProps([axis], useFinalPosition);
          return Math.abs(pos - value) < options.radius + options.hitRadius;
        }
        class PointElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.parsed = void 0;
            this.skip = void 0;
            this.stop = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          inRange(mouseX, mouseY, useFinalPosition) {
            const options = this.options;
            const { x, y } = this.getProps(["x", "y"], useFinalPosition);
            return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
          }
          inXRange(mouseX, useFinalPosition) {
            return inRange$1(this, mouseX, "x", useFinalPosition);
          }
          inYRange(mouseY, useFinalPosition) {
            return inRange$1(this, mouseY, "y", useFinalPosition);
          }
          getCenterPoint(useFinalPosition) {
            const { x, y } = this.getProps(["x", "y"], useFinalPosition);
            return { x, y };
          }
          size(options) {
            options = options || this.options || {};
            let radius = options.radius || 0;
            radius = Math.max(radius, radius && options.hoverRadius || 0);
            const borderWidth = radius && options.borderWidth || 0;
            return (radius + borderWidth) * 2;
          }
          draw(ctx, area) {
            const options = this.options;
            if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
              return;
            }
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.fillStyle = options.backgroundColor;
            drawPoint(ctx, options, this.x, this.y);
          }
          getRange() {
            const options = this.options || {};
            return options.radius + options.hitRadius;
          }
        }
        PointElement.id = "point";
        PointElement.defaults = {
          borderWidth: 1,
          hitRadius: 1,
          hoverBorderWidth: 1,
          hoverRadius: 4,
          pointStyle: "circle",
          radius: 3,
          rotation: 0
        };
        PointElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        function getBarBounds(bar, useFinalPosition) {
          const { x, y, base, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
          let left, right, top, bottom, half;
          if (bar.horizontal) {
            half = height / 2;
            left = Math.min(x, base);
            right = Math.max(x, base);
            top = y - half;
            bottom = y + half;
          } else {
            half = width / 2;
            left = x - half;
            right = x + half;
            top = Math.min(y, base);
            bottom = Math.max(y, base);
          }
          return { left, top, right, bottom };
        }
        function skipOrLimit(skip2, value, min, max) {
          return skip2 ? 0 : _limitValue(value, min, max);
        }
        function parseBorderWidth(bar, maxW, maxH) {
          const value = bar.options.borderWidth;
          const skip2 = bar.borderSkipped;
          const o = toTRBL(value);
          return {
            t: skipOrLimit(skip2.top, o.top, 0, maxH),
            r: skipOrLimit(skip2.right, o.right, 0, maxW),
            b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
            l: skipOrLimit(skip2.left, o.left, 0, maxW)
          };
        }
        function parseBorderRadius(bar, maxW, maxH) {
          const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
          const value = bar.options.borderRadius;
          const o = toTRBLCorners(value);
          const maxR = Math.min(maxW, maxH);
          const skip2 = bar.borderSkipped;
          const enableBorder = enableBorderRadius || isObject2(value);
          return {
            topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
            topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
            bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
            bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
          };
        }
        function boundingRects(bar) {
          const bounds = getBarBounds(bar);
          const width = bounds.right - bounds.left;
          const height = bounds.bottom - bounds.top;
          const border = parseBorderWidth(bar, width / 2, height / 2);
          const radius = parseBorderRadius(bar, width / 2, height / 2);
          return {
            outer: {
              x: bounds.left,
              y: bounds.top,
              w: width,
              h: height,
              radius
            },
            inner: {
              x: bounds.left + border.l,
              y: bounds.top + border.t,
              w: width - border.l - border.r,
              h: height - border.t - border.b,
              radius: {
                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
              }
            }
          };
        }
        function inRange(bar, x, y, useFinalPosition) {
          const skipX = x === null;
          const skipY = y === null;
          const skipBoth = skipX && skipY;
          const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
          return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
        }
        function hasRadius(radius) {
          return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
        }
        function addNormalRectPath(ctx, rect) {
          ctx.rect(rect.x, rect.y, rect.w, rect.h);
        }
        function inflateRect(rect, amount, refRect = {}) {
          const x = rect.x !== refRect.x ? -amount : 0;
          const y = rect.y !== refRect.y ? -amount : 0;
          const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
          const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
          return {
            x: rect.x + x,
            y: rect.y + y,
            w: rect.w + w,
            h: rect.h + h,
            radius: rect.radius
          };
        }
        class BarElement extends Element2 {
          constructor(cfg) {
            super();
            this.options = void 0;
            this.horizontal = void 0;
            this.base = void 0;
            this.width = void 0;
            this.height = void 0;
            this.inflateAmount = void 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          draw(ctx) {
            const { inflateAmount, options: { borderColor, backgroundColor } } = this;
            const { inner, outer } = boundingRects(this);
            const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
            ctx.save();
            if (outer.w !== inner.w || outer.h !== inner.h) {
              ctx.beginPath();
              addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
              ctx.clip();
              addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
              ctx.fillStyle = borderColor;
              ctx.fill("evenodd");
            }
            ctx.beginPath();
            addRectPath(ctx, inflateRect(inner, inflateAmount));
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
          }
          inRange(mouseX, mouseY, useFinalPosition) {
            return inRange(this, mouseX, mouseY, useFinalPosition);
          }
          inXRange(mouseX, useFinalPosition) {
            return inRange(this, mouseX, null, useFinalPosition);
          }
          inYRange(mouseY, useFinalPosition) {
            return inRange(this, null, mouseY, useFinalPosition);
          }
          getCenterPoint(useFinalPosition) {
            const { x, y, base, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
            return {
              x: horizontal ? (x + base) / 2 : x,
              y: horizontal ? y : (y + base) / 2
            };
          }
          getRange(axis) {
            return axis === "x" ? this.width / 2 : this.height / 2;
          }
        }
        BarElement.id = "bar";
        BarElement.defaults = {
          borderSkipped: "start",
          borderWidth: 0,
          borderRadius: 0,
          inflateAmount: "auto",
          pointStyle: void 0
        };
        BarElement.defaultRoutes = {
          backgroundColor: "backgroundColor",
          borderColor: "borderColor"
        };
        var elements = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          ArcElement,
          LineElement,
          PointElement,
          BarElement
        });
        function lttbDecimation(data, start, count, availableWidth, options) {
          const samples = options.samples || availableWidth;
          if (samples >= count) {
            return data.slice(start, start + count);
          }
          const decimated = [];
          const bucketWidth = (count - 2) / (samples - 2);
          let sampledIndex = 0;
          const endIndex = start + count - 1;
          let a = start;
          let i, maxAreaPoint, maxArea, area, nextA;
          decimated[sampledIndex++] = data[a];
          for (i = 0; i < samples - 2; i++) {
            let avgX = 0;
            let avgY = 0;
            let j;
            const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
            const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
            const avgRangeLength = avgRangeEnd - avgRangeStart;
            for (j = avgRangeStart; j < avgRangeEnd; j++) {
              avgX += data[j].x;
              avgY += data[j].y;
            }
            avgX /= avgRangeLength;
            avgY /= avgRangeLength;
            const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
            const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
            const { x: pointAx, y: pointAy } = data[a];
            maxArea = area = -1;
            for (j = rangeOffs; j < rangeTo; j++) {
              area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
              if (area > maxArea) {
                maxArea = area;
                maxAreaPoint = data[j];
                nextA = j;
              }
            }
            decimated[sampledIndex++] = maxAreaPoint;
            a = nextA;
          }
          decimated[sampledIndex++] = data[endIndex];
          return decimated;
        }
        function minMaxDecimation(data, start, count, availableWidth) {
          let avgX = 0;
          let countX = 0;
          let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
          const decimated = [];
          const endIndex = start + count - 1;
          const xMin = data[start].x;
          const xMax = data[endIndex].x;
          const dx = xMax - xMin;
          for (i = start; i < start + count; ++i) {
            point = data[i];
            x = (point.x - xMin) / dx * availableWidth;
            y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
              if (y < minY) {
                minY = y;
                minIndex = i;
              } else if (y > maxY) {
                maxY = y;
                maxIndex = i;
              }
              avgX = (countX * avgX + point.x) / ++countX;
            } else {
              const lastIndex = i - 1;
              if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
                const intermediateIndex1 = Math.min(minIndex, maxIndex);
                const intermediateIndex2 = Math.max(minIndex, maxIndex);
                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                  decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex1]), {
                    x: avgX
                  }));
                }
                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                  decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex2]), {
                    x: avgX
                  }));
                }
              }
              if (i > 0 && lastIndex !== startIndex) {
                decimated.push(data[lastIndex]);
              }
              decimated.push(point);
              prevX = truncX;
              countX = 0;
              minY = maxY = y;
              minIndex = maxIndex = startIndex = i;
            }
          }
          return decimated;
        }
        function cleanDecimatedDataset(dataset) {
          if (dataset._decimated) {
            const data = dataset._data;
            delete dataset._decimated;
            delete dataset._data;
            Object.defineProperty(dataset, "data", { value: data });
          }
        }
        function cleanDecimatedData(chart2) {
          chart2.data.datasets.forEach((dataset) => {
            cleanDecimatedDataset(dataset);
          });
        }
        function getStartAndCountOfVisiblePointsSimplified(meta, points) {
          const pointCount = points.length;
          let start = 0;
          let count;
          const { iScale } = meta;
          const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
          if (minDefined) {
            start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
          }
          if (maxDefined) {
            count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
          } else {
            count = pointCount - start;
          }
          return { start, count };
        }
        var plugin_decimation = {
          id: "decimation",
          defaults: {
            algorithm: "min-max",
            enabled: false
          },
          beforeElementsUpdate: (chart2, args, options) => {
            if (!options.enabled) {
              cleanDecimatedData(chart2);
              return;
            }
            const availableWidth = chart2.width;
            chart2.data.datasets.forEach((dataset, datasetIndex) => {
              const { _data, indexAxis } = dataset;
              const meta = chart2.getDatasetMeta(datasetIndex);
              const data = _data || dataset.data;
              if (resolve([indexAxis, chart2.options.indexAxis]) === "y") {
                return;
              }
              if (!meta.controller.supportsDecimation) {
                return;
              }
              const xAxis = chart2.scales[meta.xAxisID];
              if (xAxis.type !== "linear" && xAxis.type !== "time") {
                return;
              }
              if (chart2.options.parsing) {
                return;
              }
              let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
              const threshold = options.threshold || 4 * availableWidth;
              if (count <= threshold) {
                cleanDecimatedDataset(dataset);
                return;
              }
              if (isNullOrUndef(_data)) {
                dataset._data = data;
                delete dataset.data;
                Object.defineProperty(dataset, "data", {
                  configurable: true,
                  enumerable: true,
                  get: function() {
                    return this._decimated;
                  },
                  set: function(d) {
                    this._data = d;
                  }
                });
              }
              let decimated;
              switch (options.algorithm) {
                case "lttb":
                  decimated = lttbDecimation(data, start, count, availableWidth, options);
                  break;
                case "min-max":
                  decimated = minMaxDecimation(data, start, count, availableWidth);
                  break;
                default:
                  throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
              }
              dataset._decimated = decimated;
            });
          },
          destroy(chart2) {
            cleanDecimatedData(chart2);
          }
        };
        function _segments(line, target, property) {
          const segments = line.segments;
          const points = line.points;
          const tpoints = target.points;
          const parts = [];
          for (const segment of segments) {
            let { start, end } = segment;
            end = _findSegmentEnd(start, end, points);
            const bounds = _getBounds(property, points[start], points[end], segment.loop);
            if (!target.segments) {
              parts.push({
                source: segment,
                target: bounds,
                start: points[start],
                end: points[end]
              });
              continue;
            }
            const targetSegments = _boundSegments(target, bounds);
            for (const tgt of targetSegments) {
              const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
              const fillSources = _boundSegment(segment, points, subBounds);
              for (const fillSource of fillSources) {
                parts.push({
                  source: fillSource,
                  target: tgt,
                  start: {
                    [property]: _getEdge(bounds, subBounds, "start", Math.max)
                  },
                  end: {
                    [property]: _getEdge(bounds, subBounds, "end", Math.min)
                  }
                });
              }
            }
          }
          return parts;
        }
        function _getBounds(property, first, last, loop) {
          if (loop) {
            return;
          }
          let start = first[property];
          let end = last[property];
          if (property === "angle") {
            start = _normalizeAngle(start);
            end = _normalizeAngle(end);
          }
          return { property, start, end };
        }
        function _pointsFromSegments(boundary, line) {
          const { x = null, y = null } = boundary || {};
          const linePoints = line.points;
          const points = [];
          line.segments.forEach(({ start, end }) => {
            end = _findSegmentEnd(start, end, linePoints);
            const first = linePoints[start];
            const last = linePoints[end];
            if (y !== null) {
              points.push({ x: first.x, y });
              points.push({ x: last.x, y });
            } else if (x !== null) {
              points.push({ x, y: first.y });
              points.push({ x, y: last.y });
            }
          });
          return points;
        }
        function _findSegmentEnd(start, end, points) {
          for (; end > start; end--) {
            const point = points[end];
            if (!isNaN(point.x) && !isNaN(point.y)) {
              break;
            }
          }
          return end;
        }
        function _getEdge(a, b, prop, fn) {
          if (a && b) {
            return fn(a[prop], b[prop]);
          }
          return a ? a[prop] : b ? b[prop] : 0;
        }
        function _createBoundaryLine(boundary, line) {
          let points = [];
          let _loop = false;
          if (isArray(boundary)) {
            _loop = true;
            points = boundary;
          } else {
            points = _pointsFromSegments(boundary, line);
          }
          return points.length ? new LineElement({
            points,
            options: { tension: 0 },
            _loop,
            _fullLoop: _loop
          }) : null;
        }
        function _resolveTarget(sources, index2, propagate) {
          const source = sources[index2];
          let fill2 = source.fill;
          const visited = [index2];
          let target;
          if (!propagate) {
            return fill2;
          }
          while (fill2 !== false && visited.indexOf(fill2) === -1) {
            if (!isNumberFinite(fill2)) {
              return fill2;
            }
            target = sources[fill2];
            if (!target) {
              return false;
            }
            if (target.visible) {
              return fill2;
            }
            visited.push(fill2);
            fill2 = target.fill;
          }
          return false;
        }
        function _decodeFill(line, index2, count) {
          const fill2 = parseFillOption(line);
          if (isObject2(fill2)) {
            return isNaN(fill2.value) ? false : fill2;
          }
          let target = parseFloat(fill2);
          if (isNumberFinite(target) && Math.floor(target) === target) {
            return decodeTargetIndex(fill2[0], index2, target, count);
          }
          return ["origin", "start", "end", "stack", "shape"].indexOf(fill2) >= 0 && fill2;
        }
        function decodeTargetIndex(firstCh, index2, target, count) {
          if (firstCh === "-" || firstCh === "+") {
            target = index2 + target;
          }
          if (target === index2 || target < 0 || target >= count) {
            return false;
          }
          return target;
        }
        function _getTargetPixel(fill2, scale) {
          let pixel = null;
          if (fill2 === "start") {
            pixel = scale.bottom;
          } else if (fill2 === "end") {
            pixel = scale.top;
          } else if (isObject2(fill2)) {
            pixel = scale.getPixelForValue(fill2.value);
          } else if (scale.getBasePixel) {
            pixel = scale.getBasePixel();
          }
          return pixel;
        }
        function _getTargetValue(fill2, scale, startValue) {
          let value;
          if (fill2 === "start") {
            value = startValue;
          } else if (fill2 === "end") {
            value = scale.options.reverse ? scale.min : scale.max;
          } else if (isObject2(fill2)) {
            value = fill2.value;
          } else {
            value = scale.getBaseValue();
          }
          return value;
        }
        function parseFillOption(line) {
          const options = line.options;
          const fillOption = options.fill;
          let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
          if (fill2 === void 0) {
            fill2 = !!options.backgroundColor;
          }
          if (fill2 === false || fill2 === null) {
            return false;
          }
          if (fill2 === true) {
            return "origin";
          }
          return fill2;
        }
        function _buildStackLine(source) {
          const { scale, index: index2, line } = source;
          const points = [];
          const segments = line.segments;
          const sourcePoints = line.points;
          const linesBelow = getLinesBelow(scale, index2);
          linesBelow.push(_createBoundaryLine({ x: null, y: scale.bottom }, line));
          for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            for (let j = segment.start; j <= segment.end; j++) {
              addPointsBelow(points, sourcePoints[j], linesBelow);
            }
          }
          return new LineElement({ points, options: {} });
        }
        function getLinesBelow(scale, index2) {
          const below = [];
          const metas = scale.getMatchingVisibleMetas("line");
          for (let i = 0; i < metas.length; i++) {
            const meta = metas[i];
            if (meta.index === index2) {
              break;
            }
            if (!meta.hidden) {
              below.unshift(meta.dataset);
            }
          }
          return below;
        }
        function addPointsBelow(points, sourcePoint, linesBelow) {
          const postponed = [];
          for (let j = 0; j < linesBelow.length; j++) {
            const line = linesBelow[j];
            const { first, last, point } = findPoint(line, sourcePoint, "x");
            if (!point || first && last) {
              continue;
            }
            if (first) {
              postponed.unshift(point);
            } else {
              points.push(point);
              if (!last) {
                break;
              }
            }
          }
          points.push(...postponed);
        }
        function findPoint(line, sourcePoint, property) {
          const point = line.interpolate(sourcePoint, property);
          if (!point) {
            return {};
          }
          const pointValue = point[property];
          const segments = line.segments;
          const linePoints = line.points;
          let first = false;
          let last = false;
          for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            const firstValue = linePoints[segment.start][property];
            const lastValue = linePoints[segment.end][property];
            if (_isBetween(pointValue, firstValue, lastValue)) {
              first = pointValue === firstValue;
              last = pointValue === lastValue;
              break;
            }
          }
          return { first, last, point };
        }
        class simpleArc {
          constructor(opts) {
            this.x = opts.x;
            this.y = opts.y;
            this.radius = opts.radius;
          }
          pathSegment(ctx, bounds, opts) {
            const { x, y, radius } = this;
            bounds = bounds || { start: 0, end: TAU };
            ctx.arc(x, y, radius, bounds.end, bounds.start, true);
            return !opts.bounds;
          }
          interpolate(point) {
            const { x, y, radius } = this;
            const angle = point.angle;
            return {
              x: x + Math.cos(angle) * radius,
              y: y + Math.sin(angle) * radius,
              angle
            };
          }
        }
        function _getTarget(source) {
          const { chart: chart2, fill: fill2, line } = source;
          if (isNumberFinite(fill2)) {
            return getLineByIndex(chart2, fill2);
          }
          if (fill2 === "stack") {
            return _buildStackLine(source);
          }
          if (fill2 === "shape") {
            return true;
          }
          const boundary = computeBoundary(source);
          if (boundary instanceof simpleArc) {
            return boundary;
          }
          return _createBoundaryLine(boundary, line);
        }
        function getLineByIndex(chart2, index2) {
          const meta = chart2.getDatasetMeta(index2);
          const visible = meta && chart2.isDatasetVisible(index2);
          return visible ? meta.dataset : null;
        }
        function computeBoundary(source) {
          const scale = source.scale || {};
          if (scale.getPointPositionForValue) {
            return computeCircularBoundary(source);
          }
          return computeLinearBoundary(source);
        }
        function computeLinearBoundary(source) {
          const { scale = {}, fill: fill2 } = source;
          const pixel = _getTargetPixel(fill2, scale);
          if (isNumberFinite(pixel)) {
            const horizontal = scale.isHorizontal();
            return {
              x: horizontal ? pixel : null,
              y: horizontal ? null : pixel
            };
          }
          return null;
        }
        function computeCircularBoundary(source) {
          const { scale, fill: fill2 } = source;
          const options = scale.options;
          const length = scale.getLabels().length;
          const start = options.reverse ? scale.max : scale.min;
          const value = _getTargetValue(fill2, scale, start);
          const target = [];
          if (options.grid.circular) {
            const center = scale.getPointPositionForValue(0, start);
            return new simpleArc({
              x: center.x,
              y: center.y,
              radius: scale.getDistanceFromCenterForValue(value)
            });
          }
          for (let i = 0; i < length; ++i) {
            target.push(scale.getPointPositionForValue(i, value));
          }
          return target;
        }
        function _drawfill(ctx, source, area) {
          const target = _getTarget(source);
          const { line, scale, axis } = source;
          const lineOpts = line.options;
          const fillOption = lineOpts.fill;
          const color2 = lineOpts.backgroundColor;
          const { above = color2, below = color2 } = fillOption || {};
          if (target && line.points.length) {
            clipArea(ctx, area);
            doFill(ctx, { line, target, above, below, area, scale, axis });
            unclipArea(ctx);
          }
        }
        function doFill(ctx, cfg) {
          const { line, target, above, below, area, scale } = cfg;
          const property = line._loop ? "angle" : cfg.axis;
          ctx.save();
          if (property === "x" && below !== above) {
            clipVertical(ctx, target, area.top);
            fill(ctx, { line, target, color: above, scale, property });
            ctx.restore();
            ctx.save();
            clipVertical(ctx, target, area.bottom);
          }
          fill(ctx, { line, target, color: below, scale, property });
          ctx.restore();
        }
        function clipVertical(ctx, target, clipY) {
          const { segments, points } = target;
          let first = true;
          let lineLoop = false;
          ctx.beginPath();
          for (const segment of segments) {
            const { start, end } = segment;
            const firstPoint = points[start];
            const lastPoint = points[_findSegmentEnd(start, end, points)];
            if (first) {
              ctx.moveTo(firstPoint.x, firstPoint.y);
              first = false;
            } else {
              ctx.lineTo(firstPoint.x, clipY);
              ctx.lineTo(firstPoint.x, firstPoint.y);
            }
            lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
            if (lineLoop) {
              ctx.closePath();
            } else {
              ctx.lineTo(lastPoint.x, clipY);
            }
          }
          ctx.lineTo(target.first().x, clipY);
          ctx.closePath();
          ctx.clip();
        }
        function fill(ctx, cfg) {
          const { line, target, property, color: color2, scale } = cfg;
          const segments = _segments(line, target, property);
          for (const { source: src, target: tgt, start, end } of segments) {
            const { style: { backgroundColor = color2 } = {} } = src;
            const notShape = target !== true;
            ctx.save();
            ctx.fillStyle = backgroundColor;
            clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
            ctx.beginPath();
            const lineLoop = !!line.pathSegment(ctx, src);
            let loop;
            if (notShape) {
              if (lineLoop) {
                ctx.closePath();
              } else {
                interpolatedLineTo(ctx, target, end, property);
              }
              const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
              loop = lineLoop && targetLoop;
              if (!loop) {
                interpolatedLineTo(ctx, target, start, property);
              }
            }
            ctx.closePath();
            ctx.fill(loop ? "evenodd" : "nonzero");
            ctx.restore();
          }
        }
        function clipBounds(ctx, scale, bounds) {
          const { top, bottom } = scale.chart.chartArea;
          const { property, start, end } = bounds || {};
          if (property === "x") {
            ctx.beginPath();
            ctx.rect(start, top, end - start, bottom - top);
            ctx.clip();
          }
        }
        function interpolatedLineTo(ctx, target, point, property) {
          const interpolatedPoint = target.interpolate(point, property);
          if (interpolatedPoint) {
            ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
          }
        }
        var index = {
          id: "filler",
          afterDatasetsUpdate(chart2, _args, options) {
            const count = (chart2.data.datasets || []).length;
            const sources = [];
            let meta, i, line, source;
            for (i = 0; i < count; ++i) {
              meta = chart2.getDatasetMeta(i);
              line = meta.dataset;
              source = null;
              if (line && line.options && line instanceof LineElement) {
                source = {
                  visible: chart2.isDatasetVisible(i),
                  index: i,
                  fill: _decodeFill(line, i, count),
                  chart: chart2,
                  axis: meta.controller.options.indexAxis,
                  scale: meta.vScale,
                  line
                };
              }
              meta.$filler = source;
              sources.push(source);
            }
            for (i = 0; i < count; ++i) {
              source = sources[i];
              if (!source || source.fill === false) {
                continue;
              }
              source.fill = _resolveTarget(sources, i, options.propagate);
            }
          },
          beforeDraw(chart2, _args, options) {
            const draw2 = options.drawTime === "beforeDraw";
            const metasets = chart2.getSortedVisibleDatasetMetas();
            const area = chart2.chartArea;
            for (let i = metasets.length - 1; i >= 0; --i) {
              const source = metasets[i].$filler;
              if (!source) {
                continue;
              }
              source.line.updateControlPoints(area, source.axis);
              if (draw2) {
                _drawfill(chart2.ctx, source, area);
              }
            }
          },
          beforeDatasetsDraw(chart2, _args, options) {
            if (options.drawTime !== "beforeDatasetsDraw") {
              return;
            }
            const metasets = chart2.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
              const source = metasets[i].$filler;
              if (source) {
                _drawfill(chart2.ctx, source, chart2.chartArea);
              }
            }
          },
          beforeDatasetDraw(chart2, args, options) {
            const source = args.meta.$filler;
            if (!source || source.fill === false || options.drawTime !== "beforeDatasetDraw") {
              return;
            }
            _drawfill(chart2.ctx, source, chart2.chartArea);
          },
          defaults: {
            propagate: true,
            drawTime: "beforeDatasetDraw"
          }
        };
        const getBoxSize = (labelOpts, fontSize) => {
          let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
          if (labelOpts.usePointStyle) {
            boxHeight = Math.min(boxHeight, fontSize);
            boxWidth = Math.min(boxWidth, fontSize);
          }
          return {
            boxWidth,
            boxHeight,
            itemHeight: Math.max(fontSize, boxHeight)
          };
        };
        const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
        class Legend extends Element2 {
          constructor(config) {
            super();
            this._added = false;
            this.legendHitBoxes = [];
            this._hoveredItem = null;
            this.doughnutMode = false;
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this.legendItems = void 0;
            this.columnSizes = void 0;
            this.lineWidths = void 0;
            this.maxHeight = void 0;
            this.maxWidth = void 0;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.height = void 0;
            this.width = void 0;
            this._margins = void 0;
            this.position = void 0;
            this.weight = void 0;
            this.fullSize = void 0;
          }
          update(maxWidth, maxHeight, margins) {
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins;
            this.setDimensions();
            this.buildLabels();
            this.fit();
          }
          setDimensions() {
            if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = this._margins.left;
              this.right = this.width;
            } else {
              this.height = this.maxHeight;
              this.top = this._margins.top;
              this.bottom = this.height;
            }
          }
          buildLabels() {
            const labelOpts = this.options.labels || {};
            let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];
            if (labelOpts.filter) {
              legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
            }
            if (labelOpts.sort) {
              legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
            }
            if (this.options.reverse) {
              legendItems.reverse();
            }
            this.legendItems = legendItems;
          }
          fit() {
            const { options, ctx } = this;
            if (!options.display) {
              this.width = this.height = 0;
              return;
            }
            const labelOpts = options.labels;
            const labelFont = toFont(labelOpts.font);
            const fontSize = labelFont.size;
            const titleHeight = this._computeTitleHeight();
            const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
            let width, height;
            ctx.font = labelFont.string;
            if (this.isHorizontal()) {
              width = this.maxWidth;
              height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
            } else {
              height = this.maxHeight;
              width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
            }
            this.width = Math.min(width, options.maxWidth || this.maxWidth);
            this.height = Math.min(height, options.maxHeight || this.maxHeight);
          }
          _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
            const { ctx, maxWidth, options: { labels: { padding } } } = this;
            const hitboxes = this.legendHitBoxes = [];
            const lineWidths = this.lineWidths = [0];
            const lineHeight = itemHeight + padding;
            let totalHeight = titleHeight;
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            let row = -1;
            let top = -lineHeight;
            this.legendItems.forEach((legendItem, i) => {
              const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
              if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                totalHeight += lineHeight;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                top += lineHeight;
                row++;
              }
              hitboxes[i] = { left: 0, top, row, width: itemWidth, height: itemHeight };
              lineWidths[lineWidths.length - 1] += itemWidth + padding;
            });
            return totalHeight;
          }
          _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
            const { ctx, maxHeight, options: { labels: { padding } } } = this;
            const hitboxes = this.legendHitBoxes = [];
            const columnSizes = this.columnSizes = [];
            const heightLimit = maxHeight - titleHeight;
            let totalWidth = padding;
            let currentColWidth = 0;
            let currentColHeight = 0;
            let left = 0;
            let col = 0;
            this.legendItems.forEach((legendItem, i) => {
              const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
              if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                totalWidth += currentColWidth + padding;
                columnSizes.push({ width: currentColWidth, height: currentColHeight });
                left += currentColWidth + padding;
                col++;
                currentColWidth = currentColHeight = 0;
              }
              hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
              currentColWidth = Math.max(currentColWidth, itemWidth);
              currentColHeight += itemHeight + padding;
            });
            totalWidth += currentColWidth;
            columnSizes.push({ width: currentColWidth, height: currentColHeight });
            return totalWidth;
          }
          adjustHitBoxes() {
            if (!this.options.display) {
              return;
            }
            const titleHeight = this._computeTitleHeight();
            const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
            const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
            if (this.isHorizontal()) {
              let row = 0;
              let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
              for (const hitbox of hitboxes) {
                if (row !== hitbox.row) {
                  row = hitbox.row;
                  left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                }
                hitbox.top += this.top + titleHeight + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                left += hitbox.width + padding;
              }
            } else {
              let col = 0;
              let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
              for (const hitbox of hitboxes) {
                if (hitbox.col !== col) {
                  col = hitbox.col;
                  top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                }
                hitbox.top = top;
                hitbox.left += this.left + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                top += hitbox.height + padding;
              }
            }
          }
          isHorizontal() {
            return this.options.position === "top" || this.options.position === "bottom";
          }
          draw() {
            if (this.options.display) {
              const ctx = this.ctx;
              clipArea(ctx, this);
              this._draw();
              unclipArea(ctx);
            }
          }
          _draw() {
            const { options: opts, columnSizes, lineWidths, ctx } = this;
            const { align, labels: labelOpts } = opts;
            const defaultColor = defaults.color;
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const labelFont = toFont(labelOpts.font);
            const { color: fontColor, padding } = labelOpts;
            const fontSize = labelFont.size;
            const halfFontSize = fontSize / 2;
            let cursor;
            this.drawTitle();
            ctx.textAlign = rtlHelper.textAlign("left");
            ctx.textBaseline = "middle";
            ctx.lineWidth = 0.5;
            ctx.font = labelFont.string;
            const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
            const drawLegendBox = function(x, y, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
                return;
              }
              ctx.save();
              const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
              ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
              ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
              ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
              ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
              ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
              if (labelOpts.usePointStyle) {
                const drawOptions = {
                  radius: boxWidth * Math.SQRT2 / 2,
                  pointStyle: legendItem.pointStyle,
                  rotation: legendItem.rotation,
                  borderWidth: lineWidth
                };
                const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                const centerY = y + halfFontSize;
                drawPoint(ctx, drawOptions, centerX, centerY);
              } else {
                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                const borderRadius = toTRBLCorners(legendItem.borderRadius);
                ctx.beginPath();
                if (Object.values(borderRadius).some((v) => v !== 0)) {
                  addRoundedRectPath(ctx, {
                    x: xBoxLeft,
                    y: yBoxTop,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius
                  });
                } else {
                  ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                }
                ctx.fill();
                if (lineWidth !== 0) {
                  ctx.stroke();
                }
              }
              ctx.restore();
            };
            const fillText = function(x, y, legendItem) {
              renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                strikethrough: legendItem.hidden,
                textAlign: rtlHelper.textAlign(legendItem.textAlign)
              });
            };
            const isHorizontal = this.isHorizontal();
            const titleHeight = this._computeTitleHeight();
            if (isHorizontal) {
              cursor = {
                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
                y: this.top + padding + titleHeight,
                line: 0
              };
            } else {
              cursor = {
                x: this.left + padding,
                y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
                line: 0
              };
            }
            overrideTextDirection(this.ctx, opts.textDirection);
            const lineHeight = itemHeight + padding;
            this.legendItems.forEach((legendItem, i) => {
              ctx.strokeStyle = legendItem.fontColor || fontColor;
              ctx.fillStyle = legendItem.fontColor || fontColor;
              const textWidth = ctx.measureText(legendItem.text).width;
              const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
              const width = boxWidth + halfFontSize + textWidth;
              let x = cursor.x;
              let y = cursor.y;
              rtlHelper.setWidth(this.width);
              if (isHorizontal) {
                if (i > 0 && x + width + padding > this.right) {
                  y = cursor.y += lineHeight;
                  cursor.line++;
                  x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
                }
              } else if (i > 0 && y + lineHeight > this.bottom) {
                x = cursor.x = x + columnSizes[cursor.line].width + padding;
                cursor.line++;
                y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
              }
              const realX = rtlHelper.x(x);
              drawLegendBox(realX, y, legendItem);
              x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
              fillText(rtlHelper.x(x), y, legendItem);
              if (isHorizontal) {
                cursor.x += width + padding;
              } else {
                cursor.y += lineHeight;
              }
            });
            restoreTextDirection(this.ctx, opts.textDirection);
          }
          drawTitle() {
            const opts = this.options;
            const titleOpts = opts.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            if (!titleOpts.display) {
              return;
            }
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const ctx = this.ctx;
            const position = titleOpts.position;
            const halfFontSize = titleFont.size / 2;
            const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
            let y;
            let left = this.left;
            let maxWidth = this.width;
            if (this.isHorizontal()) {
              maxWidth = Math.max(...this.lineWidths);
              y = this.top + topPaddingPlusHalfFontSize;
              left = _alignStartEnd(opts.align, left, this.right - maxWidth);
            } else {
              const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
              y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
            }
            const x = _alignStartEnd(position, left, left + maxWidth);
            ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
            ctx.textBaseline = "middle";
            ctx.strokeStyle = titleOpts.color;
            ctx.fillStyle = titleOpts.color;
            ctx.font = titleFont.string;
            renderText(ctx, titleOpts.text, x, y, titleFont);
          }
          _computeTitleHeight() {
            const titleOpts = this.options.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
          }
          _getLegendItemAt(x, y) {
            let i, hitBox, lh;
            if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
              lh = this.legendHitBoxes;
              for (i = 0; i < lh.length; ++i) {
                hitBox = lh[i];
                if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
                  return this.legendItems[i];
                }
              }
            }
            return null;
          }
          handleEvent(e) {
            const opts = this.options;
            if (!isListened(e.type, opts)) {
              return;
            }
            const hoveredItem = this._getLegendItemAt(e.x, e.y);
            if (e.type === "mousemove" || e.type === "mouseout") {
              const previous = this._hoveredItem;
              const sameItem = itemsEqual(previous, hoveredItem);
              if (previous && !sameItem) {
                callback(opts.onLeave, [e, previous, this], this);
              }
              this._hoveredItem = hoveredItem;
              if (hoveredItem && !sameItem) {
                callback(opts.onHover, [e, hoveredItem, this], this);
              }
            } else if (hoveredItem) {
              callback(opts.onClick, [e, hoveredItem, this], this);
            }
          }
        }
        function isListened(type, opts) {
          if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
            return true;
          }
          if (opts.onClick && (type === "click" || type === "mouseup")) {
            return true;
          }
          return false;
        }
        var plugin_legend = {
          id: "legend",
          _element: Legend,
          start(chart2, _args, options) {
            const legend = chart2.legend = new Legend({ ctx: chart2.ctx, options, chart: chart2 });
            layouts.configure(chart2, legend, options);
            layouts.addBox(chart2, legend);
          },
          stop(chart2) {
            layouts.removeBox(chart2, chart2.legend);
            delete chart2.legend;
          },
          beforeUpdate(chart2, _args, options) {
            const legend = chart2.legend;
            layouts.configure(chart2, legend, options);
            legend.options = options;
          },
          afterUpdate(chart2) {
            const legend = chart2.legend;
            legend.buildLabels();
            legend.adjustHitBoxes();
          },
          afterEvent(chart2, args) {
            if (!args.replay) {
              chart2.legend.handleEvent(args.event);
            }
          },
          defaults: {
            display: true,
            position: "top",
            align: "center",
            fullSize: true,
            reverse: false,
            weight: 1e3,
            onClick(e, legendItem, legend) {
              const index2 = legendItem.datasetIndex;
              const ci = legend.chart;
              if (ci.isDatasetVisible(index2)) {
                ci.hide(index2);
                legendItem.hidden = true;
              } else {
                ci.show(index2);
                legendItem.hidden = false;
              }
            },
            onHover: null,
            onLeave: null,
            labels: {
              color: (ctx) => ctx.chart.options.color,
              boxWidth: 40,
              padding: 10,
              generateLabels(chart2) {
                const datasets = chart2.data.datasets;
                const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart2.legend.options;
                return chart2._getSortedDatasetMetas().map((meta) => {
                  const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                  const borderWidth = toPadding(style.borderWidth);
                  return {
                    text: datasets[meta.index].label,
                    fillStyle: style.backgroundColor,
                    fontColor: color2,
                    hidden: !meta.visible,
                    lineCap: style.borderCapStyle,
                    lineDash: style.borderDash,
                    lineDashOffset: style.borderDashOffset,
                    lineJoin: style.borderJoinStyle,
                    lineWidth: (borderWidth.width + borderWidth.height) / 4,
                    strokeStyle: style.borderColor,
                    pointStyle: pointStyle || style.pointStyle,
                    rotation: style.rotation,
                    textAlign: textAlign || style.textAlign,
                    borderRadius: 0,
                    datasetIndex: meta.index
                  };
                }, this);
              }
            },
            title: {
              color: (ctx) => ctx.chart.options.color,
              display: false,
              position: "center",
              text: ""
            }
          },
          descriptors: {
            _scriptable: (name) => !name.startsWith("on"),
            labels: {
              _scriptable: (name) => !["generateLabels", "filter", "sort"].includes(name)
            }
          }
        };
        class Title extends Element2 {
          constructor(config) {
            super();
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this._padding = void 0;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.width = void 0;
            this.height = void 0;
            this.position = void 0;
            this.weight = void 0;
            this.fullSize = void 0;
          }
          update(maxWidth, maxHeight) {
            const opts = this.options;
            this.left = 0;
            this.top = 0;
            if (!opts.display) {
              this.width = this.height = this.right = this.bottom = 0;
              return;
            }
            this.width = this.right = maxWidth;
            this.height = this.bottom = maxHeight;
            const lineCount = isArray(opts.text) ? opts.text.length : 1;
            this._padding = toPadding(opts.padding);
            const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
            if (this.isHorizontal()) {
              this.height = textSize;
            } else {
              this.width = textSize;
            }
          }
          isHorizontal() {
            const pos = this.options.position;
            return pos === "top" || pos === "bottom";
          }
          _drawArgs(offset) {
            const { top, left, bottom, right, options } = this;
            const align = options.align;
            let rotation = 0;
            let maxWidth, titleX, titleY;
            if (this.isHorizontal()) {
              titleX = _alignStartEnd(align, left, right);
              titleY = top + offset;
              maxWidth = right - left;
            } else {
              if (options.position === "left") {
                titleX = left + offset;
                titleY = _alignStartEnd(align, bottom, top);
                rotation = PI * -0.5;
              } else {
                titleX = right - offset;
                titleY = _alignStartEnd(align, top, bottom);
                rotation = PI * 0.5;
              }
              maxWidth = bottom - top;
            }
            return { titleX, titleY, maxWidth, rotation };
          }
          draw() {
            const ctx = this.ctx;
            const opts = this.options;
            if (!opts.display) {
              return;
            }
            const fontOpts = toFont(opts.font);
            const lineHeight = fontOpts.lineHeight;
            const offset = lineHeight / 2 + this._padding.top;
            const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
            renderText(ctx, opts.text, 0, 0, fontOpts, {
              color: opts.color,
              maxWidth,
              rotation,
              textAlign: _toLeftRightCenter(opts.align),
              textBaseline: "middle",
              translation: [titleX, titleY]
            });
          }
        }
        function createTitle(chart2, titleOpts) {
          const title = new Title({
            ctx: chart2.ctx,
            options: titleOpts,
            chart: chart2
          });
          layouts.configure(chart2, title, titleOpts);
          layouts.addBox(chart2, title);
          chart2.titleBlock = title;
        }
        var plugin_title = {
          id: "title",
          _element: Title,
          start(chart2, _args, options) {
            createTitle(chart2, options);
          },
          stop(chart2) {
            const titleBlock = chart2.titleBlock;
            layouts.removeBox(chart2, titleBlock);
            delete chart2.titleBlock;
          },
          beforeUpdate(chart2, _args, options) {
            const title = chart2.titleBlock;
            layouts.configure(chart2, title, options);
            title.options = options;
          },
          defaults: {
            align: "center",
            display: false,
            font: {
              weight: "bold"
            },
            fullSize: true,
            padding: 10,
            position: "top",
            text: "",
            weight: 2e3
          },
          defaultRoutes: {
            color: "color"
          },
          descriptors: {
            _scriptable: true,
            _indexable: false
          }
        };
        const map = new WeakMap();
        var plugin_subtitle = {
          id: "subtitle",
          start(chart2, _args, options) {
            const title = new Title({
              ctx: chart2.ctx,
              options,
              chart: chart2
            });
            layouts.configure(chart2, title, options);
            layouts.addBox(chart2, title);
            map.set(chart2, title);
          },
          stop(chart2) {
            layouts.removeBox(chart2, map.get(chart2));
            map.delete(chart2);
          },
          beforeUpdate(chart2, _args, options) {
            const title = map.get(chart2);
            layouts.configure(chart2, title, options);
            title.options = options;
          },
          defaults: {
            align: "center",
            display: false,
            font: {
              weight: "normal"
            },
            fullSize: true,
            padding: 0,
            position: "top",
            text: "",
            weight: 1500
          },
          defaultRoutes: {
            color: "color"
          },
          descriptors: {
            _scriptable: true,
            _indexable: false
          }
        };
        const positioners = {
          average(items) {
            if (!items.length) {
              return false;
            }
            let i, len;
            let x = 0;
            let y = 0;
            let count = 0;
            for (i = 0, len = items.length; i < len; ++i) {
              const el = items[i].element;
              if (el && el.hasValue()) {
                const pos = el.tooltipPosition();
                x += pos.x;
                y += pos.y;
                ++count;
              }
            }
            return {
              x: x / count,
              y: y / count
            };
          },
          nearest(items, eventPosition) {
            if (!items.length) {
              return false;
            }
            let x = eventPosition.x;
            let y = eventPosition.y;
            let minDistance = Number.POSITIVE_INFINITY;
            let i, len, nearestElement;
            for (i = 0, len = items.length; i < len; ++i) {
              const el = items[i].element;
              if (el && el.hasValue()) {
                const center = el.getCenterPoint();
                const d = distanceBetweenPoints(eventPosition, center);
                if (d < minDistance) {
                  minDistance = d;
                  nearestElement = el;
                }
              }
            }
            if (nearestElement) {
              const tp = nearestElement.tooltipPosition();
              x = tp.x;
              y = tp.y;
            }
            return {
              x,
              y
            };
          }
        };
        function pushOrConcat(base, toPush) {
          if (toPush) {
            if (isArray(toPush)) {
              Array.prototype.push.apply(base, toPush);
            } else {
              base.push(toPush);
            }
          }
          return base;
        }
        function splitNewlines(str) {
          if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
            return str.split("\n");
          }
          return str;
        }
        function createTooltipItem(chart2, item) {
          const { element, datasetIndex, index: index2 } = item;
          const controller = chart2.getDatasetMeta(datasetIndex).controller;
          const { label, value } = controller.getLabelAndValue(index2);
          return {
            chart: chart2,
            label,
            parsed: controller.getParsed(index2),
            raw: chart2.data.datasets[datasetIndex].data[index2],
            formattedValue: value,
            dataset: controller.getDataset(),
            dataIndex: index2,
            datasetIndex,
            element
          };
        }
        function getTooltipSize(tooltip, options) {
          const ctx = tooltip.chart.ctx;
          const { body, footer, title } = tooltip;
          const { boxWidth, boxHeight } = options;
          const bodyFont = toFont(options.bodyFont);
          const titleFont = toFont(options.titleFont);
          const footerFont = toFont(options.footerFont);
          const titleLineCount = title.length;
          const footerLineCount = footer.length;
          const bodyLineItemCount = body.length;
          const padding = toPadding(options.padding);
          let height = padding.height;
          let width = 0;
          let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
          combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
          if (titleLineCount) {
            height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
          }
          if (combinedBodyLength) {
            const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
            height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
          }
          if (footerLineCount) {
            height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
          }
          let widthPadding = 0;
          const maxLineWidth = function(line) {
            width = Math.max(width, ctx.measureText(line).width + widthPadding);
          };
          ctx.save();
          ctx.font = titleFont.string;
          each(tooltip.title, maxLineWidth);
          ctx.font = bodyFont.string;
          each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
          widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
          each(body, (bodyItem) => {
            each(bodyItem.before, maxLineWidth);
            each(bodyItem.lines, maxLineWidth);
            each(bodyItem.after, maxLineWidth);
          });
          widthPadding = 0;
          ctx.font = footerFont.string;
          each(tooltip.footer, maxLineWidth);
          ctx.restore();
          width += padding.width;
          return { width, height };
        }
        function determineYAlign(chart2, size) {
          const { y, height } = size;
          if (y < height / 2) {
            return "top";
          } else if (y > chart2.height - height / 2) {
            return "bottom";
          }
          return "center";
        }
        function doesNotFitWithAlign(xAlign, chart2, options, size) {
          const { x, width } = size;
          const caret = options.caretSize + options.caretPadding;
          if (xAlign === "left" && x + width + caret > chart2.width) {
            return true;
          }
          if (xAlign === "right" && x - width - caret < 0) {
            return true;
          }
        }
        function determineXAlign(chart2, options, size, yAlign) {
          const { x, width } = size;
          const { width: chartWidth, chartArea: { left, right } } = chart2;
          let xAlign = "center";
          if (yAlign === "center") {
            xAlign = x <= (left + right) / 2 ? "left" : "right";
          } else if (x <= width / 2) {
            xAlign = "left";
          } else if (x >= chartWidth - width / 2) {
            xAlign = "right";
          }
          if (doesNotFitWithAlign(xAlign, chart2, options, size)) {
            xAlign = "center";
          }
          return xAlign;
        }
        function determineAlignment(chart2, options, size) {
          const yAlign = size.yAlign || options.yAlign || determineYAlign(chart2, size);
          return {
            xAlign: size.xAlign || options.xAlign || determineXAlign(chart2, options, size, yAlign),
            yAlign
          };
        }
        function alignX(size, xAlign) {
          let { x, width } = size;
          if (xAlign === "right") {
            x -= width;
          } else if (xAlign === "center") {
            x -= width / 2;
          }
          return x;
        }
        function alignY(size, yAlign, paddingAndSize) {
          let { y, height } = size;
          if (yAlign === "top") {
            y += paddingAndSize;
          } else if (yAlign === "bottom") {
            y -= height + paddingAndSize;
          } else {
            y -= height / 2;
          }
          return y;
        }
        function getBackgroundPoint(options, size, alignment, chart2) {
          const { caretSize, caretPadding, cornerRadius } = options;
          const { xAlign, yAlign } = alignment;
          const paddingAndSize = caretSize + caretPadding;
          const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
          let x = alignX(size, xAlign);
          const y = alignY(size, yAlign, paddingAndSize);
          if (yAlign === "center") {
            if (xAlign === "left") {
              x += paddingAndSize;
            } else if (xAlign === "right") {
              x -= paddingAndSize;
            }
          } else if (xAlign === "left") {
            x -= Math.max(topLeft, bottomLeft) + caretSize;
          } else if (xAlign === "right") {
            x += Math.max(topRight, bottomRight) + caretSize;
          }
          return {
            x: _limitValue(x, 0, chart2.width - size.width),
            y: _limitValue(y, 0, chart2.height - size.height)
          };
        }
        function getAlignedX(tooltip, align, options) {
          const padding = toPadding(options.padding);
          return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
        }
        function getBeforeAfterBodyLines(callback2) {
          return pushOrConcat([], splitNewlines(callback2));
        }
        function createTooltipContext(parent, tooltip, tooltipItems) {
          return createContext(parent, {
            tooltip,
            tooltipItems,
            type: "tooltip"
          });
        }
        function overrideCallbacks(callbacks, context) {
          const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
          return override ? callbacks.override(override) : callbacks;
        }
        class Tooltip extends Element2 {
          constructor(config) {
            super();
            this.opacity = 0;
            this._active = [];
            this._eventPosition = void 0;
            this._size = void 0;
            this._cachedAnimations = void 0;
            this._tooltipItems = [];
            this.$animations = void 0;
            this.$context = void 0;
            this.chart = config.chart || config._chart;
            this._chart = this.chart;
            this.options = config.options;
            this.dataPoints = void 0;
            this.title = void 0;
            this.beforeBody = void 0;
            this.body = void 0;
            this.afterBody = void 0;
            this.footer = void 0;
            this.xAlign = void 0;
            this.yAlign = void 0;
            this.x = void 0;
            this.y = void 0;
            this.height = void 0;
            this.width = void 0;
            this.caretX = void 0;
            this.caretY = void 0;
            this.labelColors = void 0;
            this.labelPointStyles = void 0;
            this.labelTextColors = void 0;
          }
          initialize(options) {
            this.options = options;
            this._cachedAnimations = void 0;
            this.$context = void 0;
          }
          _resolveAnimations() {
            const cached = this._cachedAnimations;
            if (cached) {
              return cached;
            }
            const chart2 = this.chart;
            const options = this.options.setContext(this.getContext());
            const opts = options.enabled && chart2.options.animation && options.animations;
            const animations = new Animations(this.chart, opts);
            if (opts._cacheable) {
              this._cachedAnimations = Object.freeze(animations);
            }
            return animations;
          }
          getContext() {
            return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
          }
          getTitle(context, options) {
            const { callbacks } = options;
            const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
            const title = callbacks.title.apply(this, [context]);
            const afterTitle = callbacks.afterTitle.apply(this, [context]);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
            lines = pushOrConcat(lines, splitNewlines(title));
            lines = pushOrConcat(lines, splitNewlines(afterTitle));
            return lines;
          }
          getBeforeBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
          }
          getBody(tooltipItems, options) {
            const { callbacks } = options;
            const bodyItems = [];
            each(tooltipItems, (context) => {
              const bodyItem = {
                before: [],
                lines: [],
                after: []
              };
              const scoped = overrideCallbacks(callbacks, context);
              pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));
              pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
              pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));
              bodyItems.push(bodyItem);
            });
            return bodyItems;
          }
          getAfterBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
          }
          getFooter(tooltipItems, options) {
            const { callbacks } = options;
            const beforeFooter = callbacks.beforeFooter.apply(this, [tooltipItems]);
            const footer = callbacks.footer.apply(this, [tooltipItems]);
            const afterFooter = callbacks.afterFooter.apply(this, [tooltipItems]);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
            lines = pushOrConcat(lines, splitNewlines(footer));
            lines = pushOrConcat(lines, splitNewlines(afterFooter));
            return lines;
          }
          _createItems(options) {
            const active = this._active;
            const data = this.chart.data;
            const labelColors = [];
            const labelPointStyles = [];
            const labelTextColors = [];
            let tooltipItems = [];
            let i, len;
            for (i = 0, len = active.length; i < len; ++i) {
              tooltipItems.push(createTooltipItem(this.chart, active[i]));
            }
            if (options.filter) {
              tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
            }
            if (options.itemSort) {
              tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
            }
            each(tooltipItems, (context) => {
              const scoped = overrideCallbacks(options.callbacks, context);
              labelColors.push(scoped.labelColor.call(this, context));
              labelPointStyles.push(scoped.labelPointStyle.call(this, context));
              labelTextColors.push(scoped.labelTextColor.call(this, context));
            });
            this.labelColors = labelColors;
            this.labelPointStyles = labelPointStyles;
            this.labelTextColors = labelTextColors;
            this.dataPoints = tooltipItems;
            return tooltipItems;
          }
          update(changed, replay) {
            const options = this.options.setContext(this.getContext());
            const active = this._active;
            let properties;
            let tooltipItems = [];
            if (!active.length) {
              if (this.opacity !== 0) {
                properties = {
                  opacity: 0
                };
              }
            } else {
              const position = positioners[options.position].call(this, active, this._eventPosition);
              tooltipItems = this._createItems(options);
              this.title = this.getTitle(tooltipItems, options);
              this.beforeBody = this.getBeforeBody(tooltipItems, options);
              this.body = this.getBody(tooltipItems, options);
              this.afterBody = this.getAfterBody(tooltipItems, options);
              this.footer = this.getFooter(tooltipItems, options);
              const size = this._size = getTooltipSize(this, options);
              const positionAndSize = Object.assign({}, position, size);
              const alignment = determineAlignment(this.chart, options, positionAndSize);
              const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
              this.xAlign = alignment.xAlign;
              this.yAlign = alignment.yAlign;
              properties = {
                opacity: 1,
                x: backgroundPoint.x,
                y: backgroundPoint.y,
                width: size.width,
                height: size.height,
                caretX: position.x,
                caretY: position.y
              };
            }
            this._tooltipItems = tooltipItems;
            this.$context = void 0;
            if (properties) {
              this._resolveAnimations().update(this, properties);
            }
            if (changed && options.external) {
              options.external.call(this, { chart: this.chart, tooltip: this, replay });
            }
          }
          drawCaret(tooltipPoint, ctx, size, options) {
            const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
          }
          getCaretPosition(tooltipPoint, size, options) {
            const { xAlign, yAlign } = this;
            const { caretSize, cornerRadius } = options;
            const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
            const { x: ptX, y: ptY } = tooltipPoint;
            const { width, height } = size;
            let x1, x2, x3, y1, y2, y3;
            if (yAlign === "center") {
              y2 = ptY + height / 2;
              if (xAlign === "left") {
                x1 = ptX;
                x2 = x1 - caretSize;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
              } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
              }
              x3 = x1;
            } else {
              if (xAlign === "left") {
                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
              } else if (xAlign === "right") {
                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
              } else {
                x2 = this.caretX;
              }
              if (yAlign === "top") {
                y1 = ptY;
                y2 = y1 - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                x1 = x2 + caretSize;
                x3 = x2 - caretSize;
              }
              y3 = y1;
            }
            return { x1, x2, x3, y1, y2, y3 };
          }
          drawTitle(pt, ctx, options) {
            const title = this.title;
            const length = title.length;
            let titleFont, titleSpacing, i;
            if (length) {
              const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
              pt.x = getAlignedX(this, options.titleAlign, options);
              ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
              ctx.textBaseline = "middle";
              titleFont = toFont(options.titleFont);
              titleSpacing = options.titleSpacing;
              ctx.fillStyle = options.titleColor;
              ctx.font = titleFont.string;
              for (i = 0; i < length; ++i) {
                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                pt.y += titleFont.lineHeight + titleSpacing;
                if (i + 1 === length) {
                  pt.y += options.titleMarginBottom - titleSpacing;
                }
              }
            }
          }
          _drawColorBox(ctx, pt, i, rtlHelper, options) {
            const labelColors = this.labelColors[i];
            const labelPointStyle = this.labelPointStyles[i];
            const { boxHeight, boxWidth, boxPadding } = options;
            const bodyFont = toFont(options.bodyFont);
            const colorX = getAlignedX(this, "left", options);
            const rtlColorX = rtlHelper.x(colorX);
            const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
            const colorY = pt.y + yOffSet;
            if (options.usePointStyle) {
              const drawOptions = {
                radius: Math.min(boxWidth, boxHeight) / 2,
                pointStyle: labelPointStyle.pointStyle,
                rotation: labelPointStyle.rotation,
                borderWidth: 1
              };
              const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
              const centerY = colorY + boxHeight / 2;
              ctx.strokeStyle = options.multiKeyBackground;
              ctx.fillStyle = options.multiKeyBackground;
              drawPoint(ctx, drawOptions, centerX, centerY);
              ctx.strokeStyle = labelColors.borderColor;
              ctx.fillStyle = labelColors.backgroundColor;
              drawPoint(ctx, drawOptions, centerX, centerY);
            } else {
              ctx.lineWidth = labelColors.borderWidth || 1;
              ctx.strokeStyle = labelColors.borderColor;
              ctx.setLineDash(labelColors.borderDash || []);
              ctx.lineDashOffset = labelColors.borderDashOffset || 0;
              const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);
              const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);
              const borderRadius = toTRBLCorners(labelColors.borderRadius);
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                ctx.beginPath();
                ctx.fillStyle = options.multiKeyBackground;
                addRoundedRectPath(ctx, {
                  x: outerX,
                  y: colorY,
                  w: boxWidth,
                  h: boxHeight,
                  radius: borderRadius
                });
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = labelColors.backgroundColor;
                ctx.beginPath();
                addRoundedRectPath(ctx, {
                  x: innerX,
                  y: colorY + 1,
                  w: boxWidth - 2,
                  h: boxHeight - 2,
                  radius: borderRadius
                });
                ctx.fill();
              } else {
                ctx.fillStyle = options.multiKeyBackground;
                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                ctx.fillStyle = labelColors.backgroundColor;
                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
              }
            }
            ctx.fillStyle = this.labelTextColors[i];
          }
          drawBody(pt, ctx, options) {
            const { body } = this;
            const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
            const bodyFont = toFont(options.bodyFont);
            let bodyLineHeight = bodyFont.lineHeight;
            let xLinePadding = 0;
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            const fillLineOfText = function(line) {
              ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
              pt.y += bodyLineHeight + bodySpacing;
            };
            const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            let bodyItem, textColor, lines, i, j, ilen, jlen;
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = "middle";
            ctx.font = bodyFont.string;
            pt.x = getAlignedX(this, bodyAlignForCalculation, options);
            ctx.fillStyle = options.bodyColor;
            each(this.beforeBody, fillLineOfText);
            xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
            for (i = 0, ilen = body.length; i < ilen; ++i) {
              bodyItem = body[i];
              textColor = this.labelTextColors[i];
              ctx.fillStyle = textColor;
              each(bodyItem.before, fillLineOfText);
              lines = bodyItem.lines;
              if (displayColors && lines.length) {
                this._drawColorBox(ctx, pt, i, rtlHelper, options);
                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
              }
              for (j = 0, jlen = lines.length; j < jlen; ++j) {
                fillLineOfText(lines[j]);
                bodyLineHeight = bodyFont.lineHeight;
              }
              each(bodyItem.after, fillLineOfText);
            }
            xLinePadding = 0;
            bodyLineHeight = bodyFont.lineHeight;
            each(this.afterBody, fillLineOfText);
            pt.y -= bodySpacing;
          }
          drawFooter(pt, ctx, options) {
            const footer = this.footer;
            const length = footer.length;
            let footerFont, i;
            if (length) {
              const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
              pt.x = getAlignedX(this, options.footerAlign, options);
              pt.y += options.footerMarginTop;
              ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
              ctx.textBaseline = "middle";
              footerFont = toFont(options.footerFont);
              ctx.fillStyle = options.footerColor;
              ctx.font = footerFont.string;
              for (i = 0; i < length; ++i) {
                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                pt.y += footerFont.lineHeight + options.footerSpacing;
              }
            }
          }
          drawBackground(pt, ctx, tooltipSize, options) {
            const { xAlign, yAlign } = this;
            const { x, y } = pt;
            const { width, height } = tooltipSize;
            const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.beginPath();
            ctx.moveTo(x + topLeft, y);
            if (yAlign === "top") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width - topRight, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
            if (yAlign === "center" && xAlign === "right") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width, y + height - bottomRight);
            ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
            if (yAlign === "bottom") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + bottomLeft, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
            if (yAlign === "center" && xAlign === "left") {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x, y + topLeft);
            ctx.quadraticCurveTo(x, y, x + topLeft, y);
            ctx.closePath();
            ctx.fill();
            if (options.borderWidth > 0) {
              ctx.stroke();
            }
          }
          _updateAnimationTarget(options) {
            const chart2 = this.chart;
            const anims = this.$animations;
            const animX = anims && anims.x;
            const animY = anims && anims.y;
            if (animX || animY) {
              const position = positioners[options.position].call(this, this._active, this._eventPosition);
              if (!position) {
                return;
              }
              const size = this._size = getTooltipSize(this, options);
              const positionAndSize = Object.assign({}, position, this._size);
              const alignment = determineAlignment(chart2, options, positionAndSize);
              const point = getBackgroundPoint(options, positionAndSize, alignment, chart2);
              if (animX._to !== point.x || animY._to !== point.y) {
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                this.width = size.width;
                this.height = size.height;
                this.caretX = position.x;
                this.caretY = position.y;
                this._resolveAnimations().update(this, point);
              }
            }
          }
          _willRender() {
            return !!this.opacity;
          }
          draw(ctx) {
            const options = this.options.setContext(this.getContext());
            let opacity = this.opacity;
            if (!opacity) {
              return;
            }
            this._updateAnimationTarget(options);
            const tooltipSize = {
              width: this.width,
              height: this.height
            };
            const pt = {
              x: this.x,
              y: this.y
            };
            opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
            const padding = toPadding(options.padding);
            const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
            if (options.enabled && hasTooltipContent) {
              ctx.save();
              ctx.globalAlpha = opacity;
              this.drawBackground(pt, ctx, tooltipSize, options);
              overrideTextDirection(ctx, options.textDirection);
              pt.y += padding.top;
              this.drawTitle(pt, ctx, options);
              this.drawBody(pt, ctx, options);
              this.drawFooter(pt, ctx, options);
              restoreTextDirection(ctx, options.textDirection);
              ctx.restore();
            }
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(activeElements, eventPosition) {
            const lastActive = this._active;
            const active = activeElements.map(({ datasetIndex, index: index2 }) => {
              const meta = this.chart.getDatasetMeta(datasetIndex);
              if (!meta) {
                throw new Error("Cannot find a dataset at index " + datasetIndex);
              }
              return {
                datasetIndex,
                element: meta.data[index2],
                index: index2
              };
            });
            const changed = !_elementsEqual(lastActive, active);
            const positionChanged = this._positionChanged(active, eventPosition);
            if (changed || positionChanged) {
              this._active = active;
              this._eventPosition = eventPosition;
              this._ignoreReplayEvents = true;
              this.update(true);
            }
          }
          handleEvent(e, replay, inChartArea = true) {
            if (replay && this._ignoreReplayEvents) {
              return false;
            }
            this._ignoreReplayEvents = false;
            const options = this.options;
            const lastActive = this._active || [];
            const active = this._getActiveElements(e, lastActive, replay, inChartArea);
            const positionChanged = this._positionChanged(active, e);
            const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
            if (changed) {
              this._active = active;
              if (options.enabled || options.external) {
                this._eventPosition = {
                  x: e.x,
                  y: e.y
                };
                this.update(true, replay);
              }
            }
            return changed;
          }
          _getActiveElements(e, lastActive, replay, inChartArea) {
            const options = this.options;
            if (e.type === "mouseout") {
              return [];
            }
            if (!inChartArea) {
              return lastActive;
            }
            const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
            if (options.reverse) {
              active.reverse();
            }
            return active;
          }
          _positionChanged(active, e) {
            const { caretX, caretY, options } = this;
            const position = positioners[options.position].call(this, active, e);
            return position !== false && (caretX !== position.x || caretY !== position.y);
          }
        }
        Tooltip.positioners = positioners;
        var plugin_tooltip = {
          id: "tooltip",
          _element: Tooltip,
          positioners,
          afterInit(chart2, _args, options) {
            if (options) {
              chart2.tooltip = new Tooltip({ chart: chart2, options });
            }
          },
          beforeUpdate(chart2, _args, options) {
            if (chart2.tooltip) {
              chart2.tooltip.initialize(options);
            }
          },
          reset(chart2, _args, options) {
            if (chart2.tooltip) {
              chart2.tooltip.initialize(options);
            }
          },
          afterDraw(chart2) {
            const tooltip = chart2.tooltip;
            if (tooltip && tooltip._willRender()) {
              const args = {
                tooltip
              };
              if (chart2.notifyPlugins("beforeTooltipDraw", args) === false) {
                return;
              }
              tooltip.draw(chart2.ctx);
              chart2.notifyPlugins("afterTooltipDraw", args);
            }
          },
          afterEvent(chart2, args) {
            if (chart2.tooltip) {
              const useFinalPosition = args.replay;
              if (chart2.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
                args.changed = true;
              }
            }
          },
          defaults: {
            enabled: true,
            external: null,
            position: "average",
            backgroundColor: "rgba(0,0,0,0.8)",
            titleColor: "#fff",
            titleFont: {
              weight: "bold"
            },
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleAlign: "left",
            bodyColor: "#fff",
            bodySpacing: 2,
            bodyFont: {},
            bodyAlign: "left",
            footerColor: "#fff",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFont: {
              weight: "bold"
            },
            footerAlign: "left",
            padding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            boxHeight: (ctx, opts) => opts.bodyFont.size,
            boxWidth: (ctx, opts) => opts.bodyFont.size,
            multiKeyBackground: "#fff",
            displayColors: true,
            boxPadding: 0,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            animation: {
              duration: 400,
              easing: "easeOutQuart"
            },
            animations: {
              numbers: {
                type: "number",
                properties: ["x", "y", "width", "height", "caretX", "caretY"]
              },
              opacity: {
                easing: "linear",
                duration: 200
              }
            },
            callbacks: {
              beforeTitle: noop2,
              title(tooltipItems) {
                if (tooltipItems.length > 0) {
                  const item = tooltipItems[0];
                  const labels = item.chart.data.labels;
                  const labelCount = labels ? labels.length : 0;
                  if (this && this.options && this.options.mode === "dataset") {
                    return item.dataset.label || "";
                  } else if (item.label) {
                    return item.label;
                  } else if (labelCount > 0 && item.dataIndex < labelCount) {
                    return labels[item.dataIndex];
                  }
                }
                return "";
              },
              afterTitle: noop2,
              beforeBody: noop2,
              beforeLabel: noop2,
              label(tooltipItem) {
                if (this && this.options && this.options.mode === "dataset") {
                  return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
                }
                let label = tooltipItem.dataset.label || "";
                if (label) {
                  label += ": ";
                }
                const value = tooltipItem.formattedValue;
                if (!isNullOrUndef(value)) {
                  label += value;
                }
                return label;
              },
              labelColor(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                  borderColor: options.borderColor,
                  backgroundColor: options.backgroundColor,
                  borderWidth: options.borderWidth,
                  borderDash: options.borderDash,
                  borderDashOffset: options.borderDashOffset,
                  borderRadius: 0
                };
              },
              labelTextColor() {
                return this.options.bodyColor;
              },
              labelPointStyle(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                  pointStyle: options.pointStyle,
                  rotation: options.rotation
                };
              },
              afterLabel: noop2,
              afterBody: noop2,
              beforeFooter: noop2,
              footer: noop2,
              afterFooter: noop2
            }
          },
          defaultRoutes: {
            bodyFont: "font",
            footerFont: "font",
            titleFont: "font"
          },
          descriptors: {
            _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
            _indexable: false,
            callbacks: {
              _scriptable: false,
              _indexable: false
            },
            animation: {
              _fallback: false
            },
            animations: {
              _fallback: "animation"
            }
          },
          additionalOptionScopes: ["interaction"]
        };
        var plugins = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          Decimation: plugin_decimation,
          Filler: index,
          Legend: plugin_legend,
          SubTitle: plugin_subtitle,
          Title: plugin_title,
          Tooltip: plugin_tooltip
        });
        const addIfString = (labels, raw, index2, addedLabels) => {
          if (typeof raw === "string") {
            index2 = labels.push(raw) - 1;
            addedLabels.unshift({ index: index2, label: raw });
          } else if (isNaN(raw)) {
            index2 = null;
          }
          return index2;
        };
        function findOrAddLabel(labels, raw, index2, addedLabels) {
          const first = labels.indexOf(raw);
          if (first === -1) {
            return addIfString(labels, raw, index2, addedLabels);
          }
          const last = labels.lastIndexOf(raw);
          return first !== last ? index2 : first;
        }
        const validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
        class CategoryScale extends Scale {
          constructor(cfg) {
            super(cfg);
            this._startValue = void 0;
            this._valueRange = 0;
            this._addedLabels = [];
          }
          init(scaleOptions) {
            const added = this._addedLabels;
            if (added.length) {
              const labels = this.getLabels();
              for (const { index: index2, label } of added) {
                if (labels[index2] === label) {
                  labels.splice(index2, 1);
                }
              }
              this._addedLabels = [];
            }
            super.init(scaleOptions);
          }
          parse(raw, index2) {
            if (isNullOrUndef(raw)) {
              return null;
            }
            const labels = this.getLabels();
            index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
            return validIndex(index2, labels.length - 1);
          }
          determineDataLimits() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min, max } = this.getMinMax(true);
            if (this.options.bounds === "ticks") {
              if (!minDefined) {
                min = 0;
              }
              if (!maxDefined) {
                max = this.getLabels().length - 1;
              }
            }
            this.min = min;
            this.max = max;
          }
          buildTicks() {
            const min = this.min;
            const max = this.max;
            const offset = this.options.offset;
            const ticks = [];
            let labels = this.getLabels();
            labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
            this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
            this._startValue = this.min - (offset ? 0.5 : 0);
            for (let value = min; value <= max; value++) {
              ticks.push({ value });
            }
            return ticks;
          }
          getLabelForValue(value) {
            const labels = this.getLabels();
            if (value >= 0 && value < labels.length) {
              return labels[value];
            }
            return value;
          }
          configure() {
            super.configure();
            if (!this.isHorizontal()) {
              this._reversePixels = !this._reversePixels;
            }
          }
          getPixelForValue(value) {
            if (typeof value !== "number") {
              value = this.parse(value);
            }
            return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
          }
          getPixelForTick(index2) {
            const ticks = this.ticks;
            if (index2 < 0 || index2 > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index2].value);
          }
          getValueForPixel(pixel) {
            return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
          }
          getBasePixel() {
            return this.bottom;
          }
        }
        CategoryScale.id = "category";
        CategoryScale.defaults = {
          ticks: {
            callback: CategoryScale.prototype.getLabelForValue
          }
        };
        function generateTicks$1(generationOptions, dataRange) {
          const ticks = [];
          const MIN_SPACING = 1e-14;
          const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
          const unit = step || 1;
          const maxSpaces = maxTicks - 1;
          const { min: rmin, max: rmax } = dataRange;
          const minDefined = !isNullOrUndef(min);
          const maxDefined = !isNullOrUndef(max);
          const countDefined = !isNullOrUndef(count);
          const minSpacing = (rmax - rmin) / (maxDigits + 1);
          let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
          let factor, niceMin, niceMax, numSpaces;
          if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
            return [{ value: rmin }, { value: rmax }];
          }
          numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
          if (numSpaces > maxSpaces) {
            spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
          }
          if (!isNullOrUndef(precision)) {
            factor = Math.pow(10, precision);
            spacing = Math.ceil(spacing * factor) / factor;
          }
          if (bounds === "ticks") {
            niceMin = Math.floor(rmin / spacing) * spacing;
            niceMax = Math.ceil(rmax / spacing) * spacing;
          } else {
            niceMin = rmin;
            niceMax = rmax;
          }
          if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
            numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
            spacing = (max - min) / numSpaces;
            niceMin = min;
            niceMax = max;
          } else if (countDefined) {
            niceMin = minDefined ? min : niceMin;
            niceMax = maxDefined ? max : niceMax;
            numSpaces = count - 1;
            spacing = (niceMax - niceMin) / numSpaces;
          } else {
            numSpaces = (niceMax - niceMin) / spacing;
            if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
              numSpaces = Math.round(numSpaces);
            } else {
              numSpaces = Math.ceil(numSpaces);
            }
          }
          const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
          factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
          niceMin = Math.round(niceMin * factor) / factor;
          niceMax = Math.round(niceMax * factor) / factor;
          let j = 0;
          if (minDefined) {
            if (includeBounds && niceMin !== min) {
              ticks.push({ value: min });
              if (niceMin < min) {
                j++;
              }
              if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
                j++;
              }
            } else if (niceMin < min) {
              j++;
            }
          }
          for (; j < numSpaces; ++j) {
            ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
          }
          if (maxDefined && includeBounds && niceMax !== max) {
            if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
              ticks[ticks.length - 1].value = max;
            } else {
              ticks.push({ value: max });
            }
          } else if (!maxDefined || niceMax === max) {
            ticks.push({ value: niceMax });
          }
          return ticks;
        }
        function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
          const rad = toRadians(minRotation);
          const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
          const length = 0.75 * minSpacing * ("" + value).length;
          return Math.min(minSpacing / ratio, length);
        }
        class LinearScaleBase extends Scale {
          constructor(cfg) {
            super(cfg);
            this.start = void 0;
            this.end = void 0;
            this._startValue = void 0;
            this._endValue = void 0;
            this._valueRange = 0;
          }
          parse(raw, index2) {
            if (isNullOrUndef(raw)) {
              return null;
            }
            if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
              return null;
            }
            return +raw;
          }
          handleTickRangeOptions() {
            const { beginAtZero } = this.options;
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min, max } = this;
            const setMin = (v) => min = minDefined ? min : v;
            const setMax = (v) => max = maxDefined ? max : v;
            if (beginAtZero) {
              const minSign = sign(min);
              const maxSign = sign(max);
              if (minSign < 0 && maxSign < 0) {
                setMax(0);
              } else if (minSign > 0 && maxSign > 0) {
                setMin(0);
              }
            }
            if (min === max) {
              let offset = 1;
              if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
                offset = Math.abs(max * 0.05);
              }
              setMax(max + offset);
              if (!beginAtZero) {
                setMin(min - offset);
              }
            }
            this.min = min;
            this.max = max;
          }
          getTickLimit() {
            const tickOpts = this.options.ticks;
            let { maxTicksLimit, stepSize } = tickOpts;
            let maxTicks;
            if (stepSize) {
              maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
              if (maxTicks > 1e3) {
                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                maxTicks = 1e3;
              }
            } else {
              maxTicks = this.computeTickLimit();
              maxTicksLimit = maxTicksLimit || 11;
            }
            if (maxTicksLimit) {
              maxTicks = Math.min(maxTicksLimit, maxTicks);
            }
            return maxTicks;
          }
          computeTickLimit() {
            return Number.POSITIVE_INFINITY;
          }
          buildTicks() {
            const opts = this.options;
            const tickOpts = opts.ticks;
            let maxTicks = this.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            const numericGeneratorOptions = {
              maxTicks,
              bounds: opts.bounds,
              min: opts.min,
              max: opts.max,
              precision: tickOpts.precision,
              step: tickOpts.stepSize,
              count: tickOpts.count,
              maxDigits: this._maxDigits(),
              horizontal: this.isHorizontal(),
              minRotation: tickOpts.minRotation || 0,
              includeBounds: tickOpts.includeBounds !== false
            };
            const dataRange = this._range || this;
            const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
            if (opts.bounds === "ticks") {
              _setMinAndMaxByKey(ticks, this, "value");
            }
            if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
            } else {
              this.start = this.min;
              this.end = this.max;
            }
            return ticks;
          }
          configure() {
            const ticks = this.ticks;
            let start = this.min;
            let end = this.max;
            super.configure();
            if (this.options.offset && ticks.length) {
              const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
              start -= offset;
              end += offset;
            }
            this._startValue = start;
            this._endValue = end;
            this._valueRange = end - start;
          }
          getLabelForValue(value) {
            return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
          }
        }
        class LinearScale extends LinearScaleBase {
          determineDataLimits() {
            const { min, max } = this.getMinMax(true);
            this.min = isNumberFinite(min) ? min : 0;
            this.max = isNumberFinite(max) ? max : 1;
            this.handleTickRangeOptions();
          }
          computeTickLimit() {
            const horizontal = this.isHorizontal();
            const length = horizontal ? this.width : this.height;
            const minRotation = toRadians(this.options.ticks.minRotation);
            const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
            const tickFont = this._resolveTickFontOptions(0);
            return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
          }
          getPixelForValue(value) {
            return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
          }
          getValueForPixel(pixel) {
            return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
          }
        }
        LinearScale.id = "linear";
        LinearScale.defaults = {
          ticks: {
            callback: Ticks.formatters.numeric
          }
        };
        function isMajor(tickVal) {
          const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
          return remain === 1;
        }
        function generateTicks(generationOptions, dataRange) {
          const endExp = Math.floor(log10(dataRange.max));
          const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
          const ticks = [];
          let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
          let exp = Math.floor(log10(tickVal));
          let significand = Math.floor(tickVal / Math.pow(10, exp));
          let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
          do {
            ticks.push({ value: tickVal, major: isMajor(tickVal) });
            ++significand;
            if (significand === 10) {
              significand = 1;
              ++exp;
              precision = exp >= 0 ? 1 : precision;
            }
            tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
          } while (exp < endExp || exp === endExp && significand < endSignificand);
          const lastTick = finiteOrDefault(generationOptions.max, tickVal);
          ticks.push({ value: lastTick, major: isMajor(tickVal) });
          return ticks;
        }
        class LogarithmicScale extends Scale {
          constructor(cfg) {
            super(cfg);
            this.start = void 0;
            this.end = void 0;
            this._startValue = void 0;
            this._valueRange = 0;
          }
          parse(raw, index2) {
            const value = LinearScaleBase.prototype.parse.apply(this, [raw, index2]);
            if (value === 0) {
              this._zero = true;
              return void 0;
            }
            return isNumberFinite(value) && value > 0 ? value : null;
          }
          determineDataLimits() {
            const { min, max } = this.getMinMax(true);
            this.min = isNumberFinite(min) ? Math.max(0, min) : null;
            this.max = isNumberFinite(max) ? Math.max(0, max) : null;
            if (this.options.beginAtZero) {
              this._zero = true;
            }
            this.handleTickRangeOptions();
          }
          handleTickRangeOptions() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let min = this.min;
            let max = this.max;
            const setMin = (v) => min = minDefined ? min : v;
            const setMax = (v) => max = maxDefined ? max : v;
            const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
            if (min === max) {
              if (min <= 0) {
                setMin(1);
                setMax(10);
              } else {
                setMin(exp(min, -1));
                setMax(exp(max, 1));
              }
            }
            if (min <= 0) {
              setMin(exp(max, -1));
            }
            if (max <= 0) {
              setMax(exp(min, 1));
            }
            if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {
              setMin(exp(min, -1));
            }
            this.min = min;
            this.max = max;
          }
          buildTicks() {
            const opts = this.options;
            const generationOptions = {
              min: this._userMin,
              max: this._userMax
            };
            const ticks = generateTicks(generationOptions, this);
            if (opts.bounds === "ticks") {
              _setMinAndMaxByKey(ticks, this, "value");
            }
            if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
            } else {
              this.start = this.min;
              this.end = this.max;
            }
            return ticks;
          }
          getLabelForValue(value) {
            return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
          }
          configure() {
            const start = this.min;
            super.configure();
            this._startValue = log10(start);
            this._valueRange = log10(this.max) - log10(start);
          }
          getPixelForValue(value) {
            if (value === void 0 || value === 0) {
              value = this.min;
            }
            if (value === null || isNaN(value)) {
              return NaN;
            }
            return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
          }
          getValueForPixel(pixel) {
            const decimal = this.getDecimalForPixel(pixel);
            return Math.pow(10, this._startValue + decimal * this._valueRange);
          }
        }
        LogarithmicScale.id = "logarithmic";
        LogarithmicScale.defaults = {
          ticks: {
            callback: Ticks.formatters.logarithmic,
            major: {
              enabled: true
            }
          }
        };
        function getTickBackdropHeight(opts) {
          const tickOpts = opts.ticks;
          if (tickOpts.display && opts.display) {
            const padding = toPadding(tickOpts.backdropPadding);
            return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
          }
          return 0;
        }
        function measureLabelSize(ctx, font, label) {
          label = isArray(label) ? label : [label];
          return {
            w: _longestText(ctx, font.string, label),
            h: label.length * font.lineHeight
          };
        }
        function determineLimits(angle, pos, size, min, max) {
          if (angle === min || angle === max) {
            return {
              start: pos - size / 2,
              end: pos + size / 2
            };
          } else if (angle < min || angle > max) {
            return {
              start: pos - size,
              end: pos
            };
          }
          return {
            start: pos,
            end: pos + size
          };
        }
        function fitWithPointLabels(scale) {
          const orig = {
            l: scale.left + scale._padding.left,
            r: scale.right - scale._padding.right,
            t: scale.top + scale._padding.top,
            b: scale.bottom - scale._padding.bottom
          };
          const limits = Object.assign({}, orig);
          const labelSizes = [];
          const padding = [];
          const valueCount = scale._pointLabels.length;
          const pointLabelOpts = scale.options.pointLabels;
          const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
          for (let i = 0; i < valueCount; i++) {
            const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
            padding[i] = opts.padding;
            const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
            const plFont = toFont(opts.font);
            const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
            labelSizes[i] = textSize;
            const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
            const angle = Math.round(toDegrees(angleRadians));
            const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
            const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
            updateLimits(limits, orig, angleRadians, hLimits, vLimits);
          }
          scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
          scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
        }
        function updateLimits(limits, orig, angle, hLimits, vLimits) {
          const sin = Math.abs(Math.sin(angle));
          const cos = Math.abs(Math.cos(angle));
          let x = 0;
          let y = 0;
          if (hLimits.start < orig.l) {
            x = (orig.l - hLimits.start) / sin;
            limits.l = Math.min(limits.l, orig.l - x);
          } else if (hLimits.end > orig.r) {
            x = (hLimits.end - orig.r) / sin;
            limits.r = Math.max(limits.r, orig.r + x);
          }
          if (vLimits.start < orig.t) {
            y = (orig.t - vLimits.start) / cos;
            limits.t = Math.min(limits.t, orig.t - y);
          } else if (vLimits.end > orig.b) {
            y = (vLimits.end - orig.b) / cos;
            limits.b = Math.max(limits.b, orig.b + y);
          }
        }
        function buildPointLabelItems(scale, labelSizes, padding) {
          const items = [];
          const valueCount = scale._pointLabels.length;
          const opts = scale.options;
          const extra = getTickBackdropHeight(opts) / 2;
          const outerDistance = scale.drawingArea;
          const additionalAngle = opts.pointLabels.centerPointLabels ? PI / valueCount : 0;
          for (let i = 0; i < valueCount; i++) {
            const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);
            const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
            const size = labelSizes[i];
            const y = yForAngle(pointLabelPosition.y, size.h, angle);
            const textAlign = getTextAlignForAngle(angle);
            const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
            items.push({
              x: pointLabelPosition.x,
              y,
              textAlign,
              left,
              top: y,
              right: left + size.w,
              bottom: y + size.h
            });
          }
          return items;
        }
        function getTextAlignForAngle(angle) {
          if (angle === 0 || angle === 180) {
            return "center";
          } else if (angle < 180) {
            return "left";
          }
          return "right";
        }
        function leftForTextAlign(x, w, align) {
          if (align === "right") {
            x -= w;
          } else if (align === "center") {
            x -= w / 2;
          }
          return x;
        }
        function yForAngle(y, h, angle) {
          if (angle === 90 || angle === 270) {
            y -= h / 2;
          } else if (angle > 270 || angle < 90) {
            y -= h;
          }
          return y;
        }
        function drawPointLabels(scale, labelCount) {
          const { ctx, options: { pointLabels } } = scale;
          for (let i = labelCount - 1; i >= 0; i--) {
            const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
            const plFont = toFont(optsAtIndex.font);
            const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
            const { backdropColor } = optsAtIndex;
            if (!isNullOrUndef(backdropColor)) {
              const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
              const padding = toPadding(optsAtIndex.backdropPadding);
              ctx.fillStyle = backdropColor;
              const backdropLeft = left - padding.left;
              const backdropTop = top - padding.top;
              const backdropWidth = right - left + padding.width;
              const backdropHeight = bottom - top + padding.height;
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                ctx.beginPath();
                addRoundedRectPath(ctx, {
                  x: backdropLeft,
                  y: backdropTop,
                  w: backdropWidth,
                  h: backdropHeight,
                  radius: borderRadius
                });
                ctx.fill();
              } else {
                ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
              }
            }
            renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
              color: optsAtIndex.color,
              textAlign,
              textBaseline: "middle"
            });
          }
        }
        function pathRadiusLine(scale, radius, circular, labelCount) {
          const { ctx } = scale;
          if (circular) {
            ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
          } else {
            let pointPosition = scale.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (let i = 1; i < labelCount; i++) {
              pointPosition = scale.getPointPosition(i, radius);
              ctx.lineTo(pointPosition.x, pointPosition.y);
            }
          }
        }
        function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
          const ctx = scale.ctx;
          const circular = gridLineOpts.circular;
          const { color: color2, lineWidth } = gridLineOpts;
          if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
            return;
          }
          ctx.save();
          ctx.strokeStyle = color2;
          ctx.lineWidth = lineWidth;
          ctx.setLineDash(gridLineOpts.borderDash);
          ctx.lineDashOffset = gridLineOpts.borderDashOffset;
          ctx.beginPath();
          pathRadiusLine(scale, radius, circular, labelCount);
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
        function createPointLabelContext(parent, index2, label) {
          return createContext(parent, {
            label,
            index: index2,
            type: "pointLabel"
          });
        }
        class RadialLinearScale extends LinearScaleBase {
          constructor(cfg) {
            super(cfg);
            this.xCenter = void 0;
            this.yCenter = void 0;
            this.drawingArea = void 0;
            this._pointLabels = [];
            this._pointLabelItems = [];
          }
          setDimensions() {
            const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
            const w = this.width = this.maxWidth - padding.width;
            const h = this.height = this.maxHeight - padding.height;
            this.xCenter = Math.floor(this.left + w / 2 + padding.left);
            this.yCenter = Math.floor(this.top + h / 2 + padding.top);
            this.drawingArea = Math.floor(Math.min(w, h) / 2);
          }
          determineDataLimits() {
            const { min, max } = this.getMinMax(false);
            this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
            this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
            this.handleTickRangeOptions();
          }
          computeTickLimit() {
            return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
          }
          generateTickLabels(ticks) {
            LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
            this._pointLabels = this.getLabels().map((value, index2) => {
              const label = callback(this.options.pointLabels.callback, [value, index2], this);
              return label || label === 0 ? label : "";
            }).filter((v, i) => this.chart.getDataVisibility(i));
          }
          fit() {
            const opts = this.options;
            if (opts.display && opts.pointLabels.display) {
              fitWithPointLabels(this);
            } else {
              this.setCenterPoint(0, 0, 0, 0);
            }
          }
          setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
            this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
            this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
            this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
          }
          getIndexAngle(index2) {
            const angleMultiplier = TAU / (this._pointLabels.length || 1);
            const startAngle = this.options.startAngle || 0;
            return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
          }
          getDistanceFromCenterForValue(value) {
            if (isNullOrUndef(value)) {
              return NaN;
            }
            const scalingFactor = this.drawingArea / (this.max - this.min);
            if (this.options.reverse) {
              return (this.max - value) * scalingFactor;
            }
            return (value - this.min) * scalingFactor;
          }
          getValueForDistanceFromCenter(distance) {
            if (isNullOrUndef(distance)) {
              return NaN;
            }
            const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
            return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
          }
          getPointLabelContext(index2) {
            const pointLabels = this._pointLabels || [];
            if (index2 >= 0 && index2 < pointLabels.length) {
              const pointLabel = pointLabels[index2];
              return createPointLabelContext(this.getContext(), index2, pointLabel);
            }
          }
          getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
            const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
            return {
              x: Math.cos(angle) * distanceFromCenter + this.xCenter,
              y: Math.sin(angle) * distanceFromCenter + this.yCenter,
              angle
            };
          }
          getPointPositionForValue(index2, value) {
            return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
          }
          getBasePosition(index2) {
            return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
          }
          getPointLabelPosition(index2) {
            const { left, top, right, bottom } = this._pointLabelItems[index2];
            return {
              left,
              top,
              right,
              bottom
            };
          }
          drawBackground() {
            const { backgroundColor, grid: { circular } } = this.options;
            if (backgroundColor) {
              const ctx = this.ctx;
              ctx.save();
              ctx.beginPath();
              pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
              ctx.closePath();
              ctx.fillStyle = backgroundColor;
              ctx.fill();
              ctx.restore();
            }
          }
          drawGrid() {
            const ctx = this.ctx;
            const opts = this.options;
            const { angleLines, grid } = opts;
            const labelCount = this._pointLabels.length;
            let i, offset, position;
            if (opts.pointLabels.display) {
              drawPointLabels(this, labelCount);
            }
            if (grid.display) {
              this.ticks.forEach((tick, index2) => {
                if (index2 !== 0) {
                  offset = this.getDistanceFromCenterForValue(tick.value);
                  const optsAtIndex = grid.setContext(this.getContext(index2 - 1));
                  drawRadiusLine(this, optsAtIndex, offset, labelCount);
                }
              });
            }
            if (angleLines.display) {
              ctx.save();
              for (i = labelCount - 1; i >= 0; i--) {
                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                const { color: color2, lineWidth } = optsAtIndex;
                if (!lineWidth || !color2) {
                  continue;
                }
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color2;
                ctx.setLineDash(optsAtIndex.borderDash);
                ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
                position = this.getPointPosition(i, offset);
                ctx.beginPath();
                ctx.moveTo(this.xCenter, this.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
              }
              ctx.restore();
            }
          }
          drawBorder() {
          }
          drawLabels() {
            const ctx = this.ctx;
            const opts = this.options;
            const tickOpts = opts.ticks;
            if (!tickOpts.display) {
              return;
            }
            const startAngle = this.getIndexAngle(0);
            let offset, width;
            ctx.save();
            ctx.translate(this.xCenter, this.yCenter);
            ctx.rotate(startAngle);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            this.ticks.forEach((tick, index2) => {
              if (index2 === 0 && !opts.reverse) {
                return;
              }
              const optsAtIndex = tickOpts.setContext(this.getContext(index2));
              const tickFont = toFont(optsAtIndex.font);
              offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
              if (optsAtIndex.showLabelBackdrop) {
                ctx.font = tickFont.string;
                width = ctx.measureText(tick.label).width;
                ctx.fillStyle = optsAtIndex.backdropColor;
                const padding = toPadding(optsAtIndex.backdropPadding);
                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
              }
              renderText(ctx, tick.label, 0, -offset, tickFont, {
                color: optsAtIndex.color
              });
            });
            ctx.restore();
          }
          drawTitle() {
          }
        }
        RadialLinearScale.id = "radialLinear";
        RadialLinearScale.defaults = {
          display: true,
          animate: true,
          position: "chartArea",
          angleLines: {
            display: true,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0
          },
          grid: {
            circular: false
          },
          startAngle: 0,
          ticks: {
            showLabelBackdrop: true,
            callback: Ticks.formatters.numeric
          },
          pointLabels: {
            backdropColor: void 0,
            backdropPadding: 2,
            display: true,
            font: {
              size: 10
            },
            callback(label) {
              return label;
            },
            padding: 5,
            centerPointLabels: false
          }
        };
        RadialLinearScale.defaultRoutes = {
          "angleLines.color": "borderColor",
          "pointLabels.color": "color",
          "ticks.color": "color"
        };
        RadialLinearScale.descriptors = {
          angleLines: {
            _fallback: "grid"
          }
        };
        const INTERVALS = {
          millisecond: { common: true, size: 1, steps: 1e3 },
          second: { common: true, size: 1e3, steps: 60 },
          minute: { common: true, size: 6e4, steps: 60 },
          hour: { common: true, size: 36e5, steps: 24 },
          day: { common: true, size: 864e5, steps: 30 },
          week: { common: false, size: 6048e5, steps: 4 },
          month: { common: true, size: 2628e6, steps: 12 },
          quarter: { common: false, size: 7884e6, steps: 4 },
          year: { common: true, size: 3154e7 }
        };
        const UNITS = Object.keys(INTERVALS);
        function sorter(a, b) {
          return a - b;
        }
        function parse(scale, input) {
          if (isNullOrUndef(input)) {
            return null;
          }
          const adapter = scale._adapter;
          const { parser, round: round2, isoWeekday } = scale._parseOpts;
          let value = input;
          if (typeof parser === "function") {
            value = parser(value);
          }
          if (!isNumberFinite(value)) {
            value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
          }
          if (value === null) {
            return null;
          }
          if (round2) {
            value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
          }
          return +value;
        }
        function determineUnitForAutoTicks(minUnit, min, max, capacity) {
          const ilen = UNITS.length;
          for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
            const interval = INTERVALS[UNITS[i]];
            const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
            if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
              return UNITS[i];
            }
          }
          return UNITS[ilen - 1];
        }
        function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
          for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
            const unit = UNITS[i];
            if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
              return unit;
            }
          }
          return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
        }
        function determineMajorUnit(unit) {
          for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
            if (INTERVALS[UNITS[i]].common) {
              return UNITS[i];
            }
          }
        }
        function addTick(ticks, time, timestamps) {
          if (!timestamps) {
            ticks[time] = true;
          } else if (timestamps.length) {
            const { lo, hi } = _lookup(timestamps, time);
            const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
            ticks[timestamp] = true;
          }
        }
        function setMajorTicks(scale, ticks, map2, majorUnit) {
          const adapter = scale._adapter;
          const first = +adapter.startOf(ticks[0].value, majorUnit);
          const last = ticks[ticks.length - 1].value;
          let major, index2;
          for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
            index2 = map2[major];
            if (index2 >= 0) {
              ticks[index2].major = true;
            }
          }
          return ticks;
        }
        function ticksFromTimestamps(scale, values, majorUnit) {
          const ticks = [];
          const map2 = {};
          const ilen = values.length;
          let i, value;
          for (i = 0; i < ilen; ++i) {
            value = values[i];
            map2[value] = i;
            ticks.push({
              value,
              major: false
            });
          }
          return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
        }
        class TimeScale extends Scale {
          constructor(props) {
            super(props);
            this._cache = {
              data: [],
              labels: [],
              all: []
            };
            this._unit = "day";
            this._majorUnit = void 0;
            this._offsets = {};
            this._normalized = false;
            this._parseOpts = void 0;
          }
          init(scaleOpts, opts) {
            const time = scaleOpts.time || (scaleOpts.time = {});
            const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);
            mergeIf(time.displayFormats, adapter.formats());
            this._parseOpts = {
              parser: time.parser,
              round: time.round,
              isoWeekday: time.isoWeekday
            };
            super.init(scaleOpts);
            this._normalized = opts.normalized;
          }
          parse(raw, index2) {
            if (raw === void 0) {
              return null;
            }
            return parse(this, raw);
          }
          beforeLayout() {
            super.beforeLayout();
            this._cache = {
              data: [],
              labels: [],
              all: []
            };
          }
          determineDataLimits() {
            const options = this.options;
            const adapter = this._adapter;
            const unit = options.time.unit || "day";
            let { min, max, minDefined, maxDefined } = this.getUserBounds();
            function _applyBounds(bounds) {
              if (!minDefined && !isNaN(bounds.min)) {
                min = Math.min(min, bounds.min);
              }
              if (!maxDefined && !isNaN(bounds.max)) {
                max = Math.max(max, bounds.max);
              }
            }
            if (!minDefined || !maxDefined) {
              _applyBounds(this._getLabelBounds());
              if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
                _applyBounds(this.getMinMax(false));
              }
            }
            min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
            max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
            this.min = Math.min(min, max - 1);
            this.max = Math.max(min + 1, max);
          }
          _getLabelBounds() {
            const arr = this.getLabelTimestamps();
            let min = Number.POSITIVE_INFINITY;
            let max = Number.NEGATIVE_INFINITY;
            if (arr.length) {
              min = arr[0];
              max = arr[arr.length - 1];
            }
            return { min, max };
          }
          buildTicks() {
            const options = this.options;
            const timeOpts = options.time;
            const tickOpts = options.ticks;
            const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
            if (options.bounds === "ticks" && timestamps.length) {
              this.min = this._userMin || timestamps[0];
              this.max = this._userMax || timestamps[timestamps.length - 1];
            }
            const min = this.min;
            const max = this.max;
            const ticks = _filterBetween(timestamps, min, max);
            this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
            this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
            this.initOffsets(timestamps);
            if (options.reverse) {
              ticks.reverse();
            }
            return ticksFromTimestamps(this, ticks, this._majorUnit);
          }
          afterAutoSkip() {
            if (this.options.offsetAfterAutoskip) {
              this.initOffsets(this.ticks.map((tick) => +tick.value));
            }
          }
          initOffsets(timestamps) {
            let start = 0;
            let end = 0;
            let first, last;
            if (this.options.offset && timestamps.length) {
              first = this.getDecimalForValue(timestamps[0]);
              if (timestamps.length === 1) {
                start = 1 - first;
              } else {
                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
              }
              last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
              if (timestamps.length === 1) {
                end = last;
              } else {
                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
              }
            }
            const limit = timestamps.length < 3 ? 0.5 : 0.25;
            start = _limitValue(start, 0, limit);
            end = _limitValue(end, 0, limit);
            this._offsets = { start, end, factor: 1 / (start + 1 + end) };
          }
          _generate() {
            const adapter = this._adapter;
            const min = this.min;
            const max = this.max;
            const options = this.options;
            const timeOpts = options.time;
            const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
            const stepSize = valueOrDefault(timeOpts.stepSize, 1);
            const weekday = minor === "week" ? timeOpts.isoWeekday : false;
            const hasWeekday = isNumber(weekday) || weekday === true;
            const ticks = {};
            let first = min;
            let time, count;
            if (hasWeekday) {
              first = +adapter.startOf(first, "isoWeek", weekday);
            }
            first = +adapter.startOf(first, hasWeekday ? "day" : minor);
            if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
              throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
            }
            const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
            for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
              addTick(ticks, time, timestamps);
            }
            if (time === max || options.bounds === "ticks" || count === 1) {
              addTick(ticks, time, timestamps);
            }
            return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
          }
          getLabelForValue(value) {
            const adapter = this._adapter;
            const timeOpts = this.options.time;
            if (timeOpts.tooltipFormat) {
              return adapter.format(value, timeOpts.tooltipFormat);
            }
            return adapter.format(value, timeOpts.displayFormats.datetime);
          }
          _tickFormatFunction(time, index2, ticks, format) {
            const options = this.options;
            const formats = options.time.displayFormats;
            const unit = this._unit;
            const majorUnit = this._majorUnit;
            const minorFormat = unit && formats[unit];
            const majorFormat = majorUnit && formats[majorUnit];
            const tick = ticks[index2];
            const major = majorUnit && majorFormat && tick && tick.major;
            const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));
            const formatter = options.ticks.callback;
            return formatter ? callback(formatter, [label, index2, ticks], this) : label;
          }
          generateTickLabels(ticks) {
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              tick.label = this._tickFormatFunction(tick.value, i, ticks);
            }
          }
          getDecimalForValue(value) {
            return value === null ? NaN : (value - this.min) / (this.max - this.min);
          }
          getPixelForValue(value) {
            const offsets = this._offsets;
            const pos = this.getDecimalForValue(value);
            return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
          }
          getValueForPixel(pixel) {
            const offsets = this._offsets;
            const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return this.min + pos * (this.max - this.min);
          }
          _getLabelSize(label) {
            const ticksOpts = this.options.ticks;
            const tickLabelWidth = this.ctx.measureText(label).width;
            const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
            const cosRotation = Math.cos(angle);
            const sinRotation = Math.sin(angle);
            const tickFontSize = this._resolveTickFontOptions(0).size;
            return {
              w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
              h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
            };
          }
          _getLabelCapacity(exampleTime) {
            const timeOpts = this.options.time;
            const displayFormats = timeOpts.displayFormats;
            const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
            const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);
            const size = this._getLabelSize(exampleLabel);
            const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
            return capacity > 0 ? capacity : 1;
          }
          getDataTimestamps() {
            let timestamps = this._cache.data || [];
            let i, ilen;
            if (timestamps.length) {
              return timestamps;
            }
            const metas = this.getMatchingVisibleMetas();
            if (this._normalized && metas.length) {
              return this._cache.data = metas[0].controller.getAllParsedValues(this);
            }
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
              timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
            }
            return this._cache.data = this.normalize(timestamps);
          }
          getLabelTimestamps() {
            const timestamps = this._cache.labels || [];
            let i, ilen;
            if (timestamps.length) {
              return timestamps;
            }
            const labels = this.getLabels();
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              timestamps.push(parse(this, labels[i]));
            }
            return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
          }
          normalize(values) {
            return _arrayUnique(values.sort(sorter));
          }
        }
        TimeScale.id = "time";
        TimeScale.defaults = {
          bounds: "data",
          adapters: {},
          time: {
            parser: false,
            unit: false,
            round: false,
            isoWeekday: false,
            minUnit: "millisecond",
            displayFormats: {}
          },
          ticks: {
            source: "auto",
            major: {
              enabled: false
            }
          }
        };
        function interpolate(table, val, reverse) {
          let lo = 0;
          let hi = table.length - 1;
          let prevSource, nextSource, prevTarget, nextTarget;
          if (reverse) {
            if (val >= table[lo].pos && val <= table[hi].pos) {
              ({ lo, hi } = _lookupByKey(table, "pos", val));
            }
            ({ pos: prevSource, time: prevTarget } = table[lo]);
            ({ pos: nextSource, time: nextTarget } = table[hi]);
          } else {
            if (val >= table[lo].time && val <= table[hi].time) {
              ({ lo, hi } = _lookupByKey(table, "time", val));
            }
            ({ time: prevSource, pos: prevTarget } = table[lo]);
            ({ time: nextSource, pos: nextTarget } = table[hi]);
          }
          const span = nextSource - prevSource;
          return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
        }
        class TimeSeriesScale extends TimeScale {
          constructor(props) {
            super(props);
            this._table = [];
            this._minPos = void 0;
            this._tableRange = void 0;
          }
          initOffsets() {
            const timestamps = this._getTimestampsForTable();
            const table = this._table = this.buildLookupTable(timestamps);
            this._minPos = interpolate(table, this.min);
            this._tableRange = interpolate(table, this.max) - this._minPos;
            super.initOffsets(timestamps);
          }
          buildLookupTable(timestamps) {
            const { min, max } = this;
            const items = [];
            const table = [];
            let i, ilen, prev, curr, next;
            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
              curr = timestamps[i];
              if (curr >= min && curr <= max) {
                items.push(curr);
              }
            }
            if (items.length < 2) {
              return [
                { time: min, pos: 0 },
                { time: max, pos: 1 }
              ];
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              next = items[i + 1];
              prev = items[i - 1];
              curr = items[i];
              if (Math.round((next + prev) / 2) !== curr) {
                table.push({ time: curr, pos: i / (ilen - 1) });
              }
            }
            return table;
          }
          _getTimestampsForTable() {
            let timestamps = this._cache.all || [];
            if (timestamps.length) {
              return timestamps;
            }
            const data = this.getDataTimestamps();
            const label = this.getLabelTimestamps();
            if (data.length && label.length) {
              timestamps = this.normalize(data.concat(label));
            } else {
              timestamps = data.length ? data : label;
            }
            timestamps = this._cache.all = timestamps;
            return timestamps;
          }
          getDecimalForValue(value) {
            return (interpolate(this._table, value) - this._minPos) / this._tableRange;
          }
          getValueForPixel(pixel) {
            const offsets = this._offsets;
            const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
          }
        }
        TimeSeriesScale.id = "timeseries";
        TimeSeriesScale.defaults = TimeScale.defaults;
        var scales = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          CategoryScale,
          LinearScale,
          LogarithmicScale,
          RadialLinearScale,
          TimeScale,
          TimeSeriesScale
        });
        Chart3.register(controllers, scales, elements, plugins);
        Chart3.helpers = __spreadValues({}, helpers);
        Chart3._adapters = _adapters;
        Chart3.Animation = Animation;
        Chart3.Animations = Animations;
        Chart3.animator = animator;
        Chart3.controllers = registry.controllers.items;
        Chart3.DatasetController = DatasetController;
        Chart3.Element = Element2;
        Chart3.elements = elements;
        Chart3.Interaction = Interaction;
        Chart3.layouts = layouts;
        Chart3.platforms = platforms;
        Chart3.Scale = Scale;
        Chart3.Ticks = Ticks;
        Object.assign(Chart3, controllers, scales, elements, plugins, platforms);
        Chart3.Chart = Chart3;
        if (typeof window !== "undefined") {
          window.Chart = Chart3;
        }
        return Chart3;
      });
    }
  });

  // node_modules/chart.js/helpers/helpers.js
  var require_helpers = __commonJS({
    "node_modules/chart.js/helpers/helpers.js"(exports, module) {
      module.exports = require_chart().helpers;
    }
  });

  // node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.js
  var require_chartjs_plugin_datalabels = __commonJS({
    "node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require_helpers(), require_chart()) : typeof define === "function" && define.amd ? define(["chart.js/helpers", "chart.js"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.ChartDataLabels = factory(global2.Chart.helpers, global2.Chart));
      })(exports, function(helpers, chart_js) {
        "use strict";
        var devicePixelRatio = function() {
          if (typeof window !== "undefined") {
            if (window.devicePixelRatio) {
              return window.devicePixelRatio;
            }
            var screen = window.screen;
            if (screen) {
              return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);
            }
          }
          return 1;
        }();
        var utils = {
          toTextLines: function(inputs) {
            var lines = [];
            var input;
            inputs = [].concat(inputs);
            while (inputs.length) {
              input = inputs.pop();
              if (typeof input === "string") {
                lines.unshift.apply(lines, input.split("\n"));
              } else if (Array.isArray(input)) {
                inputs.push.apply(inputs, input);
              } else if (!helpers.isNullOrUndef(inputs)) {
                lines.unshift("" + input);
              }
            }
            return lines;
          },
          textSize: function(ctx, lines, font) {
            var items = [].concat(lines);
            var ilen = items.length;
            var prev = ctx.font;
            var width = 0;
            var i;
            ctx.font = font.string;
            for (i = 0; i < ilen; ++i) {
              width = Math.max(ctx.measureText(items[i]).width, width);
            }
            ctx.font = prev;
            return {
              height: ilen * font.lineHeight,
              width
            };
          },
          bound: function(min, value, max) {
            return Math.max(min, Math.min(value, max));
          },
          arrayDiff: function(a0, a1) {
            var prev = a0.slice();
            var updates = [];
            var i, j, ilen, v;
            for (i = 0, ilen = a1.length; i < ilen; ++i) {
              v = a1[i];
              j = prev.indexOf(v);
              if (j === -1) {
                updates.push([v, 1]);
              } else {
                prev.splice(j, 1);
              }
            }
            for (i = 0, ilen = prev.length; i < ilen; ++i) {
              updates.push([prev[i], -1]);
            }
            return updates;
          },
          rasterize: function(v) {
            return Math.round(v * devicePixelRatio) / devicePixelRatio;
          }
        };
        function orient(point, origin) {
          var x0 = origin.x;
          var y0 = origin.y;
          if (x0 === null) {
            return { x: 0, y: -1 };
          }
          if (y0 === null) {
            return { x: 1, y: 0 };
          }
          var dx = point.x - x0;
          var dy = point.y - y0;
          var ln = Math.sqrt(dx * dx + dy * dy);
          return {
            x: ln ? dx / ln : 0,
            y: ln ? dy / ln : -1
          };
        }
        function aligned(x, y, vx, vy, align) {
          switch (align) {
            case "center":
              vx = vy = 0;
              break;
            case "bottom":
              vx = 0;
              vy = 1;
              break;
            case "right":
              vx = 1;
              vy = 0;
              break;
            case "left":
              vx = -1;
              vy = 0;
              break;
            case "top":
              vx = 0;
              vy = -1;
              break;
            case "start":
              vx = -vx;
              vy = -vy;
              break;
            case "end":
              break;
            default:
              align *= Math.PI / 180;
              vx = Math.cos(align);
              vy = Math.sin(align);
              break;
          }
          return {
            x,
            y,
            vx,
            vy
          };
        }
        var R_INSIDE = 0;
        var R_LEFT = 1;
        var R_RIGHT = 2;
        var R_BOTTOM = 4;
        var R_TOP = 8;
        function region(x, y, rect) {
          var res = R_INSIDE;
          if (x < rect.left) {
            res |= R_LEFT;
          } else if (x > rect.right) {
            res |= R_RIGHT;
          }
          if (y < rect.top) {
            res |= R_TOP;
          } else if (y > rect.bottom) {
            res |= R_BOTTOM;
          }
          return res;
        }
        function clipped(segment, area) {
          var x0 = segment.x0;
          var y0 = segment.y0;
          var x1 = segment.x1;
          var y1 = segment.y1;
          var r0 = region(x0, y0, area);
          var r1 = region(x1, y1, area);
          var r, x, y;
          while (true) {
            if (!(r0 | r1) || r0 & r1) {
              break;
            }
            r = r0 || r1;
            if (r & R_TOP) {
              x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);
              y = area.top;
            } else if (r & R_BOTTOM) {
              x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);
              y = area.bottom;
            } else if (r & R_RIGHT) {
              y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);
              x = area.right;
            } else if (r & R_LEFT) {
              y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);
              x = area.left;
            }
            if (r === r0) {
              x0 = x;
              y0 = y;
              r0 = region(x0, y0, area);
            } else {
              x1 = x;
              y1 = y;
              r1 = region(x1, y1, area);
            }
          }
          return {
            x0,
            x1,
            y0,
            y1
          };
        }
        function compute$1(range2, config) {
          var anchor = config.anchor;
          var segment = range2;
          var x, y;
          if (config.clamp) {
            segment = clipped(segment, config.area);
          }
          if (anchor === "start") {
            x = segment.x0;
            y = segment.y0;
          } else if (anchor === "end") {
            x = segment.x1;
            y = segment.y1;
          } else {
            x = (segment.x0 + segment.x1) / 2;
            y = (segment.y0 + segment.y1) / 2;
          }
          return aligned(x, y, range2.vx, range2.vy, config.align);
        }
        var positioners = {
          arc: function(el, config) {
            var angle = (el.startAngle + el.endAngle) / 2;
            var vx = Math.cos(angle);
            var vy = Math.sin(angle);
            var r0 = el.innerRadius;
            var r1 = el.outerRadius;
            return compute$1({
              x0: el.x + vx * r0,
              y0: el.y + vy * r0,
              x1: el.x + vx * r1,
              y1: el.y + vy * r1,
              vx,
              vy
            }, config);
          },
          point: function(el, config) {
            var v = orient(el, config.origin);
            var rx = v.x * el.options.radius;
            var ry = v.y * el.options.radius;
            return compute$1({
              x0: el.x - rx,
              y0: el.y - ry,
              x1: el.x + rx,
              y1: el.y + ry,
              vx: v.x,
              vy: v.y
            }, config);
          },
          bar: function(el, config) {
            var v = orient(el, config.origin);
            var x = el.x;
            var y = el.y;
            var sx = 0;
            var sy = 0;
            if (el.horizontal) {
              x = Math.min(el.x, el.base);
              sx = Math.abs(el.base - el.x);
            } else {
              y = Math.min(el.y, el.base);
              sy = Math.abs(el.base - el.y);
            }
            return compute$1({
              x0: x,
              y0: y + sy,
              x1: x + sx,
              y1: y,
              vx: v.x,
              vy: v.y
            }, config);
          },
          fallback: function(el, config) {
            var v = orient(el, config.origin);
            return compute$1({
              x0: el.x,
              y0: el.y,
              x1: el.x,
              y1: el.y,
              vx: v.x,
              vy: v.y
            }, config);
          }
        };
        var rasterize = utils.rasterize;
        function boundingRects(model) {
          var borderWidth = model.borderWidth || 0;
          var padding = model.padding;
          var th = model.size.height;
          var tw = model.size.width;
          var tx = -tw / 2;
          var ty = -th / 2;
          return {
            frame: {
              x: tx - padding.left - borderWidth,
              y: ty - padding.top - borderWidth,
              w: tw + padding.width + borderWidth * 2,
              h: th + padding.height + borderWidth * 2
            },
            text: {
              x: tx,
              y: ty,
              w: tw,
              h: th
            }
          };
        }
        function getScaleOrigin(el, context) {
          var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;
          if (!scale) {
            return null;
          }
          if (scale.xCenter !== void 0 && scale.yCenter !== void 0) {
            return { x: scale.xCenter, y: scale.yCenter };
          }
          var pixel = scale.getBasePixel();
          return el.horizontal ? { x: pixel, y: null } : { x: null, y: pixel };
        }
        function getPositioner(el) {
          if (el instanceof chart_js.ArcElement) {
            return positioners.arc;
          }
          if (el instanceof chart_js.PointElement) {
            return positioners.point;
          }
          if (el instanceof chart_js.BarElement) {
            return positioners.bar;
          }
          return positioners.fallback;
        }
        function drawRoundedRect(ctx, x, y, w, h, radius) {
          var HALF_PI = Math.PI / 2;
          if (radius) {
            var r = Math.min(radius, h / 2, w / 2);
            var left = x + r;
            var top = y + r;
            var right = x + w - r;
            var bottom = y + h - r;
            ctx.moveTo(x, top);
            if (left < right && top < bottom) {
              ctx.arc(left, top, r, -Math.PI, -HALF_PI);
              ctx.arc(right, top, r, -HALF_PI, 0);
              ctx.arc(right, bottom, r, 0, HALF_PI);
              ctx.arc(left, bottom, r, HALF_PI, Math.PI);
            } else if (left < right) {
              ctx.moveTo(left, y);
              ctx.arc(right, top, r, -HALF_PI, HALF_PI);
              ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);
            } else if (top < bottom) {
              ctx.arc(left, top, r, -Math.PI, 0);
              ctx.arc(left, bottom, r, 0, Math.PI);
            } else {
              ctx.arc(left, top, r, -Math.PI, Math.PI);
            }
            ctx.closePath();
            ctx.moveTo(x, y);
          } else {
            ctx.rect(x, y, w, h);
          }
        }
        function drawFrame(ctx, rect, model) {
          var bgColor = model.backgroundColor;
          var borderColor = model.borderColor;
          var borderWidth = model.borderWidth;
          if (!bgColor && (!borderColor || !borderWidth)) {
            return;
          }
          ctx.beginPath();
          drawRoundedRect(ctx, rasterize(rect.x) + borderWidth / 2, rasterize(rect.y) + borderWidth / 2, rasterize(rect.w) - borderWidth, rasterize(rect.h) - borderWidth, model.borderRadius);
          ctx.closePath();
          if (bgColor) {
            ctx.fillStyle = bgColor;
            ctx.fill();
          }
          if (borderColor && borderWidth) {
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = borderWidth;
            ctx.lineJoin = "miter";
            ctx.stroke();
          }
        }
        function textGeometry(rect, align, font) {
          var h = font.lineHeight;
          var w = rect.w;
          var x = rect.x;
          var y = rect.y + h / 2;
          if (align === "center") {
            x += w / 2;
          } else if (align === "end" || align === "right") {
            x += w;
          }
          return {
            h,
            w,
            x,
            y
          };
        }
        function drawTextLine(ctx, text, cfg) {
          var shadow = ctx.shadowBlur;
          var stroked = cfg.stroked;
          var x = rasterize(cfg.x);
          var y = rasterize(cfg.y);
          var w = rasterize(cfg.w);
          if (stroked) {
            ctx.strokeText(text, x, y, w);
          }
          if (cfg.filled) {
            if (shadow && stroked) {
              ctx.shadowBlur = 0;
            }
            ctx.fillText(text, x, y, w);
            if (shadow && stroked) {
              ctx.shadowBlur = shadow;
            }
          }
        }
        function drawText(ctx, lines, rect, model) {
          var align = model.textAlign;
          var color = model.color;
          var filled = !!color;
          var font = model.font;
          var ilen = lines.length;
          var strokeColor = model.textStrokeColor;
          var strokeWidth = model.textStrokeWidth;
          var stroked = strokeColor && strokeWidth;
          var i;
          if (!ilen || !filled && !stroked) {
            return;
          }
          rect = textGeometry(rect, align, font);
          ctx.font = font.string;
          ctx.textAlign = align;
          ctx.textBaseline = "middle";
          ctx.shadowBlur = model.textShadowBlur;
          ctx.shadowColor = model.textShadowColor;
          if (filled) {
            ctx.fillStyle = color;
          }
          if (stroked) {
            ctx.lineJoin = "round";
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
          }
          for (i = 0, ilen = lines.length; i < ilen; ++i) {
            drawTextLine(ctx, lines[i], {
              stroked,
              filled,
              w: rect.w,
              x: rect.x,
              y: rect.y + rect.h * i
            });
          }
        }
        var Label = function(config, ctx, el, index) {
          var me = this;
          me._config = config;
          me._index = index;
          me._model = null;
          me._rects = null;
          me._ctx = ctx;
          me._el = el;
        };
        helpers.merge(Label.prototype, {
          _modelize: function(display, lines, config, context) {
            var me = this;
            var index = me._index;
            var font = helpers.toFont(helpers.resolve([config.font, {}], context, index));
            var color = helpers.resolve([config.color, chart_js.defaults.color], context, index);
            return {
              align: helpers.resolve([config.align, "center"], context, index),
              anchor: helpers.resolve([config.anchor, "center"], context, index),
              area: context.chart.chartArea,
              backgroundColor: helpers.resolve([config.backgroundColor, null], context, index),
              borderColor: helpers.resolve([config.borderColor, null], context, index),
              borderRadius: helpers.resolve([config.borderRadius, 0], context, index),
              borderWidth: helpers.resolve([config.borderWidth, 0], context, index),
              clamp: helpers.resolve([config.clamp, false], context, index),
              clip: helpers.resolve([config.clip, false], context, index),
              color,
              display,
              font,
              lines,
              offset: helpers.resolve([config.offset, 0], context, index),
              opacity: helpers.resolve([config.opacity, 1], context, index),
              origin: getScaleOrigin(me._el, context),
              padding: helpers.toPadding(helpers.resolve([config.padding, 0], context, index)),
              positioner: getPositioner(me._el),
              rotation: helpers.resolve([config.rotation, 0], context, index) * (Math.PI / 180),
              size: utils.textSize(me._ctx, lines, font),
              textAlign: helpers.resolve([config.textAlign, "start"], context, index),
              textShadowBlur: helpers.resolve([config.textShadowBlur, 0], context, index),
              textShadowColor: helpers.resolve([config.textShadowColor, color], context, index),
              textStrokeColor: helpers.resolve([config.textStrokeColor, color], context, index),
              textStrokeWidth: helpers.resolve([config.textStrokeWidth, 0], context, index)
            };
          },
          update: function(context) {
            var me = this;
            var model = null;
            var rects = null;
            var index = me._index;
            var config = me._config;
            var value, label, lines;
            var display = helpers.resolve([config.display, true], context, index);
            if (display) {
              value = context.dataset.data[index];
              label = helpers.valueOrDefault(helpers.callback(config.formatter, [value, context]), value);
              lines = helpers.isNullOrUndef(label) ? [] : utils.toTextLines(label);
              if (lines.length) {
                model = me._modelize(display, lines, config, context);
                rects = boundingRects(model);
              }
            }
            me._model = model;
            me._rects = rects;
          },
          geometry: function() {
            return this._rects ? this._rects.frame : {};
          },
          rotation: function() {
            return this._model ? this._model.rotation : 0;
          },
          visible: function() {
            return this._model && this._model.opacity;
          },
          model: function() {
            return this._model;
          },
          draw: function(chart2, center) {
            var me = this;
            var ctx = chart2.ctx;
            var model = me._model;
            var rects = me._rects;
            var area;
            if (!this.visible()) {
              return;
            }
            ctx.save();
            if (model.clip) {
              area = model.area;
              ctx.beginPath();
              ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
              ctx.clip();
            }
            ctx.globalAlpha = utils.bound(0, model.opacity, 1);
            ctx.translate(rasterize(center.x), rasterize(center.y));
            ctx.rotate(model.rotation);
            drawFrame(ctx, rects.frame, model);
            drawText(ctx, model.lines, rects.text, model);
            ctx.restore();
          }
        });
        var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
        var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        function rotated(point, center, angle) {
          var cos = Math.cos(angle);
          var sin = Math.sin(angle);
          var cx = center.x;
          var cy = center.y;
          return {
            x: cx + cos * (point.x - cx) - sin * (point.y - cy),
            y: cy + sin * (point.x - cx) + cos * (point.y - cy)
          };
        }
        function projected(points, axis) {
          var min = MAX_INTEGER;
          var max = MIN_INTEGER;
          var origin = axis.origin;
          var i, pt, vx, vy, dp;
          for (i = 0; i < points.length; ++i) {
            pt = points[i];
            vx = pt.x - origin.x;
            vy = pt.y - origin.y;
            dp = axis.vx * vx + axis.vy * vy;
            min = Math.min(min, dp);
            max = Math.max(max, dp);
          }
          return {
            min,
            max
          };
        }
        function toAxis(p0, p1) {
          var vx = p1.x - p0.x;
          var vy = p1.y - p0.y;
          var ln = Math.sqrt(vx * vx + vy * vy);
          return {
            vx: (p1.x - p0.x) / ln,
            vy: (p1.y - p0.y) / ln,
            origin: p0,
            ln
          };
        }
        var HitBox = function() {
          this._rotation = 0;
          this._rect = {
            x: 0,
            y: 0,
            w: 0,
            h: 0
          };
        };
        helpers.merge(HitBox.prototype, {
          center: function() {
            var r = this._rect;
            return {
              x: r.x + r.w / 2,
              y: r.y + r.h / 2
            };
          },
          update: function(center, rect, rotation) {
            this._rotation = rotation;
            this._rect = {
              x: rect.x + center.x,
              y: rect.y + center.y,
              w: rect.w,
              h: rect.h
            };
          },
          contains: function(point) {
            var me = this;
            var margin = 1;
            var rect = me._rect;
            point = rotated(point, me.center(), -me._rotation);
            return !(point.x < rect.x - margin || point.y < rect.y - margin || point.x > rect.x + rect.w + margin * 2 || point.y > rect.y + rect.h + margin * 2);
          },
          intersects: function(other) {
            var r0 = this._points();
            var r1 = other._points();
            var axes = [
              toAxis(r0[0], r0[1]),
              toAxis(r0[0], r0[3])
            ];
            var i, pr0, pr1;
            if (this._rotation !== other._rotation) {
              axes.push(toAxis(r1[0], r1[1]), toAxis(r1[0], r1[3]));
            }
            for (i = 0; i < axes.length; ++i) {
              pr0 = projected(r0, axes[i]);
              pr1 = projected(r1, axes[i]);
              if (pr0.max < pr1.min || pr1.max < pr0.min) {
                return false;
              }
            }
            return true;
          },
          _points: function() {
            var me = this;
            var rect = me._rect;
            var angle = me._rotation;
            var center = me.center();
            return [
              rotated({ x: rect.x, y: rect.y }, center, angle),
              rotated({ x: rect.x + rect.w, y: rect.y }, center, angle),
              rotated({ x: rect.x + rect.w, y: rect.y + rect.h }, center, angle),
              rotated({ x: rect.x, y: rect.y + rect.h }, center, angle)
            ];
          }
        });
        function coordinates(el, model, geometry) {
          var point = model.positioner(el, model);
          var vx = point.vx;
          var vy = point.vy;
          if (!vx && !vy) {
            return { x: point.x, y: point.y };
          }
          var w = geometry.w;
          var h = geometry.h;
          var rotation = model.rotation;
          var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));
          var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));
          var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));
          dx *= vx * vs;
          dy *= vy * vs;
          dx += model.offset * vx;
          dy += model.offset * vy;
          return {
            x: point.x + dx,
            y: point.y + dy
          };
        }
        function collide(labels, collider) {
          var i, j, s0, s1;
          for (i = labels.length - 1; i >= 0; --i) {
            s0 = labels[i].$layout;
            for (j = i - 1; j >= 0 && s0._visible; --j) {
              s1 = labels[j].$layout;
              if (s1._visible && s0._box.intersects(s1._box)) {
                collider(s0, s1);
              }
            }
          }
          return labels;
        }
        function compute(labels) {
          var i, ilen, label, state, geometry, center, proxy;
          for (i = 0, ilen = labels.length; i < ilen; ++i) {
            label = labels[i];
            state = label.$layout;
            if (state._visible) {
              proxy = new Proxy(label._el, { get: (el, p) => el.getProps([p], true)[p] });
              geometry = label.geometry();
              center = coordinates(proxy, label.model(), geometry);
              state._box.update(center, geometry, label.rotation());
            }
          }
          return collide(labels, function(s0, s1) {
            var h0 = s0._hidable;
            var h1 = s1._hidable;
            if (h0 && h1 || h1) {
              s1._visible = false;
            } else if (h0) {
              s0._visible = false;
            }
          });
        }
        var layout = {
          prepare: function(datasets) {
            var labels = [];
            var i, j, ilen, jlen, label;
            for (i = 0, ilen = datasets.length; i < ilen; ++i) {
              for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {
                label = datasets[i][j];
                labels.push(label);
                label.$layout = {
                  _box: new HitBox(),
                  _hidable: false,
                  _visible: true,
                  _set: i,
                  _idx: j
                };
              }
            }
            labels.sort(function(a, b) {
              var sa = a.$layout;
              var sb = b.$layout;
              return sa._idx === sb._idx ? sb._set - sa._set : sb._idx - sa._idx;
            });
            this.update(labels);
            return labels;
          },
          update: function(labels) {
            var dirty = false;
            var i, ilen, label, model, state;
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              label = labels[i];
              model = label.model();
              state = label.$layout;
              state._hidable = model && model.display === "auto";
              state._visible = label.visible();
              dirty |= state._hidable;
            }
            if (dirty) {
              compute(labels);
            }
          },
          lookup: function(labels, point) {
            var i, state;
            for (i = labels.length - 1; i >= 0; --i) {
              state = labels[i].$layout;
              if (state && state._visible && state._box.contains(point)) {
                return labels[i];
              }
            }
            return null;
          },
          draw: function(chart2, labels) {
            var i, ilen, label, state, geometry, center;
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              label = labels[i];
              state = label.$layout;
              if (state._visible) {
                geometry = label.geometry();
                center = coordinates(label._el, label.model(), geometry);
                state._box.update(center, geometry, label.rotation());
                label.draw(chart2, center);
              }
            }
          }
        };
        var formatter = function(value) {
          if (helpers.isNullOrUndef(value)) {
            return null;
          }
          var label = value;
          var keys, klen, k;
          if (helpers.isObject(value)) {
            if (!helpers.isNullOrUndef(value.label)) {
              label = value.label;
            } else if (!helpers.isNullOrUndef(value.r)) {
              label = value.r;
            } else {
              label = "";
              keys = Object.keys(value);
              for (k = 0, klen = keys.length; k < klen; ++k) {
                label += (k !== 0 ? ", " : "") + keys[k] + ": " + value[keys[k]];
              }
            }
          }
          return "" + label;
        };
        var defaults = {
          align: "center",
          anchor: "center",
          backgroundColor: null,
          borderColor: null,
          borderRadius: 0,
          borderWidth: 0,
          clamp: false,
          clip: false,
          color: void 0,
          display: true,
          font: {
            family: void 0,
            lineHeight: 1.2,
            size: void 0,
            style: void 0,
            weight: null
          },
          formatter,
          labels: void 0,
          listeners: {},
          offset: 4,
          opacity: 1,
          padding: {
            top: 4,
            right: 4,
            bottom: 4,
            left: 4
          },
          rotation: 0,
          textAlign: "start",
          textStrokeColor: void 0,
          textStrokeWidth: 0,
          textShadowBlur: 0,
          textShadowColor: void 0
        };
        var EXPANDO_KEY = "$datalabels";
        var DEFAULT_KEY = "$default";
        function configure(dataset, options) {
          var override = dataset.datalabels;
          var listeners = {};
          var configs = [];
          var labels, keys;
          if (override === false) {
            return null;
          }
          if (override === true) {
            override = {};
          }
          options = helpers.merge({}, [options, override]);
          labels = options.labels || {};
          keys = Object.keys(labels);
          delete options.labels;
          if (keys.length) {
            keys.forEach(function(key) {
              if (labels[key]) {
                configs.push(helpers.merge({}, [
                  options,
                  labels[key],
                  { _key: key }
                ]));
              }
            });
          } else {
            configs.push(options);
          }
          listeners = configs.reduce(function(target, config) {
            helpers.each(config.listeners || {}, function(fn, event) {
              target[event] = target[event] || {};
              target[event][config._key || DEFAULT_KEY] = fn;
            });
            delete config.listeners;
            return target;
          }, {});
          return {
            labels: configs,
            listeners
          };
        }
        function dispatchEvent(chart2, listeners, label) {
          if (!listeners) {
            return;
          }
          var context = label.$context;
          var groups = label.$groups;
          var callback;
          if (!listeners[groups._set]) {
            return;
          }
          callback = listeners[groups._set][groups._key];
          if (!callback) {
            return;
          }
          if (helpers.callback(callback, [context]) === true) {
            chart2[EXPANDO_KEY]._dirty = true;
            label.update(context);
          }
        }
        function dispatchMoveEvents(chart2, listeners, previous, label) {
          var enter, leave;
          if (!previous && !label) {
            return;
          }
          if (!previous) {
            enter = true;
          } else if (!label) {
            leave = true;
          } else if (previous !== label) {
            leave = enter = true;
          }
          if (leave) {
            dispatchEvent(chart2, listeners.leave, previous);
          }
          if (enter) {
            dispatchEvent(chart2, listeners.enter, label);
          }
        }
        function handleMoveEvents(chart2, event) {
          var expando = chart2[EXPANDO_KEY];
          var listeners = expando._listeners;
          var previous, label;
          if (!listeners.enter && !listeners.leave) {
            return;
          }
          if (event.type === "mousemove") {
            label = layout.lookup(expando._labels, event);
          } else if (event.type !== "mouseout") {
            return;
          }
          previous = expando._hovered;
          expando._hovered = label;
          dispatchMoveEvents(chart2, listeners, previous, label);
        }
        function handleClickEvents(chart2, event) {
          var expando = chart2[EXPANDO_KEY];
          var handlers = expando._listeners.click;
          var label = handlers && layout.lookup(expando._labels, event);
          if (label) {
            dispatchEvent(chart2, handlers, label);
          }
        }
        var plugin = {
          id: "datalabels",
          defaults,
          beforeInit: function(chart2) {
            chart2[EXPANDO_KEY] = {
              _actives: []
            };
          },
          beforeUpdate: function(chart2) {
            var expando = chart2[EXPANDO_KEY];
            expando._listened = false;
            expando._listeners = {};
            expando._datasets = [];
            expando._labels = [];
          },
          afterDatasetUpdate: function(chart2, args, options) {
            var datasetIndex = args.index;
            var expando = chart2[EXPANDO_KEY];
            var labels = expando._datasets[datasetIndex] = [];
            var visible = chart2.isDatasetVisible(datasetIndex);
            var dataset = chart2.data.datasets[datasetIndex];
            var config = configure(dataset, options);
            var elements = args.meta.data || [];
            var ctx = chart2.ctx;
            var i, j, ilen, jlen, cfg, key, el, label;
            ctx.save();
            for (i = 0, ilen = elements.length; i < ilen; ++i) {
              el = elements[i];
              el[EXPANDO_KEY] = [];
              if (visible && el && chart2.getDataVisibility(i) && !el.skip) {
                for (j = 0, jlen = config.labels.length; j < jlen; ++j) {
                  cfg = config.labels[j];
                  key = cfg._key;
                  label = new Label(cfg, ctx, el, i);
                  label.$groups = {
                    _set: datasetIndex,
                    _key: key || DEFAULT_KEY
                  };
                  label.$context = {
                    active: false,
                    chart: chart2,
                    dataIndex: i,
                    dataset,
                    datasetIndex
                  };
                  label.update(label.$context);
                  el[EXPANDO_KEY].push(label);
                  labels.push(label);
                }
              }
            }
            ctx.restore();
            helpers.merge(expando._listeners, config.listeners, {
              merger: function(event, target, source) {
                target[event] = target[event] || {};
                target[event][args.index] = source[event];
                expando._listened = true;
              }
            });
          },
          afterUpdate: function(chart2, options) {
            chart2[EXPANDO_KEY]._labels = layout.prepare(chart2[EXPANDO_KEY]._datasets, options);
          },
          afterDatasetsDraw: function(chart2) {
            layout.draw(chart2, chart2[EXPANDO_KEY]._labels);
          },
          beforeEvent: function(chart2, args) {
            if (chart2[EXPANDO_KEY]._listened) {
              var event = args.event;
              switch (event.type) {
                case "mousemove":
                case "mouseout":
                  handleMoveEvents(chart2, event);
                  break;
                case "click":
                  handleClickEvents(chart2, event);
                  break;
              }
            }
          },
          afterEvent: function(chart2) {
            var expando = chart2[EXPANDO_KEY];
            var previous = expando._actives;
            var actives = expando._actives = chart2.getActiveElements();
            var updates = utils.arrayDiff(previous, actives);
            var i, ilen, j, jlen, update, label, labels;
            for (i = 0, ilen = updates.length; i < ilen; ++i) {
              update = updates[i];
              if (update[1]) {
                labels = update[0].element[EXPANDO_KEY] || [];
                for (j = 0, jlen = labels.length; j < jlen; ++j) {
                  label = labels[j];
                  label.$context.active = update[1] === 1;
                  label.update(label.$context);
                }
              }
            }
            if (expando._dirty || updates.length) {
              layout.update(expando._labels);
              chart2.render();
            }
            delete expando._dirty;
          }
        };
        return plugin;
      });
    }
  });

  // node_modules/bootstrap-icons/font/bootstrap-icons.css
  var require_ = __commonJS({
    "node_modules/bootstrap-icons/font/bootstrap-icons.css"(exports, module) {
      module.exports = {};
    }
  });

  // node_modules/material-icons/iconfont/material-icons.css
  var require_2 = __commonJS({
    "node_modules/material-icons/iconfont/material-icons.css"(exports, module) {
      module.exports = {};
    }
  });

  // ../deps/phoenix_html/priv/static/phoenix_html.js
  "use strict";
  (function() {
    var PolyfillEvent = eventConstructor();
    function eventConstructor() {
      if (typeof window.CustomEvent === "function")
        return window.CustomEvent;
      function CustomEvent2(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: void 0 };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
      CustomEvent2.prototype = window.Event.prototype;
      return CustomEvent2;
    }
    function buildHiddenInput(name, value) {
      var input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      input.value = value;
      return input;
    }
    function handleClick(element, targetModifierKey) {
      var to = element.getAttribute("data-to"), method = buildHiddenInput("_method", element.getAttribute("data-method")), csrf = buildHiddenInput("_csrf_token", element.getAttribute("data-csrf")), form = document.createElement("form"), target = element.getAttribute("target");
      form.method = element.getAttribute("data-method") === "get" ? "get" : "post";
      form.action = to;
      form.style.display = "hidden";
      if (target)
        form.target = target;
      else if (targetModifierKey)
        form.target = "_blank";
      form.appendChild(csrf);
      form.appendChild(method);
      document.body.appendChild(form);
      form.submit();
    }
    window.addEventListener("click", function(e) {
      var element = e.target;
      if (e.defaultPrevented)
        return;
      while (element && element.getAttribute) {
        var phoenixLinkEvent = new PolyfillEvent("phoenix.link.click", {
          "bubbles": true,
          "cancelable": true
        });
        if (!element.dispatchEvent(phoenixLinkEvent)) {
          e.preventDefault();
          e.stopImmediatePropagation();
          return false;
        }
        if (element.getAttribute("data-method")) {
          handleClick(element, e.metaKey || e.shiftKey);
          e.preventDefault();
          return false;
        } else {
          element = element.parentNode;
        }
      }
    }, false);
    window.addEventListener("phoenix.link.click", function(e) {
      var message = e.target.getAttribute("data-confirm");
      if (message && !window.confirm(message)) {
        e.preventDefault();
      }
    }, false);
  })();

  // ../deps/phoenix/priv/static/phoenix.esm.js
  var closure = (value) => {
    if (typeof value === "function") {
      return value;
    } else {
      let closure22 = function() {
        return value;
      };
      return closure22;
    }
  };
  var globalSelf = typeof self !== "undefined" ? self : null;
  var phxWindow = typeof window !== "undefined" ? window : null;
  var global = globalSelf || phxWindow || void 0;
  var DEFAULT_VSN = "2.0.0";
  var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
  var DEFAULT_TIMEOUT = 1e4;
  var WS_CLOSE_NORMAL = 1e3;
  var CHANNEL_STATES = {
    closed: "closed",
    errored: "errored",
    joined: "joined",
    joining: "joining",
    leaving: "leaving"
  };
  var CHANNEL_EVENTS = {
    close: "phx_close",
    error: "phx_error",
    join: "phx_join",
    reply: "phx_reply",
    leave: "phx_leave"
  };
  var TRANSPORTS = {
    longpoll: "longpoll",
    websocket: "websocket"
  };
  var XHR_STATES = {
    complete: 4
  };
  var Push = class {
    constructor(channel, event, payload, timeout) {
      this.channel = channel;
      this.event = event;
      this.payload = payload || function() {
        return {};
      };
      this.receivedResp = null;
      this.timeout = timeout;
      this.timeoutTimer = null;
      this.recHooks = [];
      this.sent = false;
    }
    resend(timeout) {
      this.timeout = timeout;
      this.reset();
      this.send();
    }
    send() {
      if (this.hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload(),
        ref: this.ref,
        join_ref: this.channel.joinRef()
      });
    }
    receive(status, callback) {
      if (this.hasReceived(status)) {
        callback(this.receivedResp.response);
      }
      this.recHooks.push({ status, callback });
      return this;
    }
    reset() {
      this.cancelRefEvent();
      this.ref = null;
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
    }
    matchReceive({ status, response, _ref }) {
      this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
    }
    cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel.off(this.refEvent);
    }
    cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
    startTimeout() {
      if (this.timeoutTimer) {
        this.cancelTimeout();
      }
      this.ref = this.channel.socket.makeRef();
      this.refEvent = this.channel.replyEventName(this.ref);
      this.channel.on(this.refEvent, (payload) => {
        this.cancelRefEvent();
        this.cancelTimeout();
        this.receivedResp = payload;
        this.matchReceive(payload);
      });
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
    trigger(status, response) {
      this.channel.trigger(this.refEvent, { status, response });
    }
  };
  var Timer = class {
    constructor(callback, timerCalc) {
      this.callback = callback;
      this.timerCalc = timerCalc;
      this.timer = null;
      this.tries = 0;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
    }
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  };
  var Channel = class {
    constructor(topic, params, socket) {
      this.state = CHANNEL_STATES.closed;
      this.topic = topic;
      this.params = closure(params || {});
      this.socket = socket;
      this.bindings = [];
      this.bindingRef = 0;
      this.timeout = this.socket.timeout;
      this.joinedOnce = false;
      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
      this.pushBuffer = [];
      this.stateChangeRefs = [];
      this.rejoinTimer = new Timer(() => {
        if (this.socket.isConnected()) {
          this.rejoin();
        }
      }, this.socket.rejoinAfterMs);
      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
      this.stateChangeRefs.push(this.socket.onOpen(() => {
        this.rejoinTimer.reset();
        if (this.isErrored()) {
          this.rejoin();
        }
      }));
      this.joinPush.receive("ok", () => {
        this.state = CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this.joinPush.receive("error", () => {
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.onClose(() => {
        this.rejoinTimer.reset();
        if (this.socket.hasLogger())
          this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
        this.state = CHANNEL_STATES.closed;
        this.socket.remove(this);
      });
      this.onError((reason) => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `error ${this.topic}`, reason);
        if (this.isJoining()) {
          this.joinPush.reset();
        }
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.joinPush.receive("timeout", () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
        leavePush.send();
        this.state = CHANNEL_STATES.errored;
        this.joinPush.reset();
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
        this.trigger(this.replyEventName(ref), payload);
      });
    }
    join(timeout = this.timeout) {
      if (this.joinedOnce) {
        throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
      } else {
        this.timeout = timeout;
        this.joinedOnce = true;
        this.rejoin();
        return this.joinPush;
      }
    }
    onClose(callback) {
      this.on(CHANNEL_EVENTS.close, callback);
    }
    onError(callback) {
      return this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));
    }
    on(event, callback) {
      let ref = this.bindingRef++;
      this.bindings.push({ event, ref, callback });
      return ref;
    }
    off(event, ref) {
      this.bindings = this.bindings.filter((bind) => {
        return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));
      });
    }
    canPush() {
      return this.socket.isConnected() && this.isJoined();
    }
    push(event, payload, timeout = this.timeout) {
      payload = payload || {};
      if (!this.joinedOnce) {
        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
      }
      let pushEvent = new Push(this, event, function() {
        return payload;
      }, timeout);
      if (this.canPush()) {
        pushEvent.send();
      } else {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
      }
      return pushEvent;
    }
    leave(timeout = this.timeout) {
      this.rejoinTimer.reset();
      this.joinPush.cancelTimeout();
      this.state = CHANNEL_STATES.leaving;
      let onClose = () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `leave ${this.topic}`);
        this.trigger(CHANNEL_EVENTS.close, "leave");
      };
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
      leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
      leavePush.send();
      if (!this.canPush()) {
        leavePush.trigger("ok", {});
      }
      return leavePush;
    }
    onMessage(_event, payload, _ref) {
      return payload;
    }
    isMember(topic, event, payload, joinRef) {
      if (this.topic !== topic) {
        return false;
      }
      if (joinRef && joinRef !== this.joinRef()) {
        if (this.socket.hasLogger())
          this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
        return false;
      } else {
        return true;
      }
    }
    joinRef() {
      return this.joinPush.ref;
    }
    rejoin(timeout = this.timeout) {
      if (this.isLeaving()) {
        return;
      }
      this.socket.leaveOpenTopic(this.topic);
      this.state = CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    trigger(event, payload, ref, joinRef) {
      let handledPayload = this.onMessage(event, payload, ref, joinRef);
      if (payload && !handledPayload) {
        throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
      }
      let eventBindings = this.bindings.filter((bind) => bind.event === event);
      for (let i = 0; i < eventBindings.length; i++) {
        let bind = eventBindings[i];
        bind.callback(handledPayload, ref, joinRef || this.joinRef());
      }
    }
    replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    isClosed() {
      return this.state === CHANNEL_STATES.closed;
    }
    isErrored() {
      return this.state === CHANNEL_STATES.errored;
    }
    isJoined() {
      return this.state === CHANNEL_STATES.joined;
    }
    isJoining() {
      return this.state === CHANNEL_STATES.joining;
    }
    isLeaving() {
      return this.state === CHANNEL_STATES.leaving;
    }
  };
  var Ajax = class {
    static request(method, endPoint, accept, body, timeout, ontimeout, callback) {
      if (global.XDomainRequest) {
        let req = new global.XDomainRequest();
        this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
      } else {
        let req = new global.XMLHttpRequest();
        this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);
      }
    }
    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
      req.timeout = timeout;
      req.open(method, endPoint);
      req.onload = () => {
        let response = this.parseJSON(req.responseText);
        callback && callback(response);
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.onprogress = () => {
      };
      req.send(body);
    }
    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {
      req.open(method, endPoint, true);
      req.timeout = timeout;
      req.setRequestHeader("Content-Type", accept);
      req.onerror = () => {
        callback && callback(null);
      };
      req.onreadystatechange = () => {
        if (req.readyState === XHR_STATES.complete && callback) {
          let response = this.parseJSON(req.responseText);
          callback(response);
        }
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.send(body);
    }
    static parseJSON(resp) {
      if (!resp || resp === "") {
        return null;
      }
      try {
        return JSON.parse(resp);
      } catch (e) {
        console && console.log("failed to parse JSON response", resp);
        return null;
      }
    }
    static serialize(obj, parentKey) {
      let queryStr = [];
      for (var key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        let paramKey = parentKey ? `${parentKey}[${key}]` : key;
        let paramVal = obj[key];
        if (typeof paramVal === "object") {
          queryStr.push(this.serialize(paramVal, paramKey));
        } else {
          queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
        }
      }
      return queryStr.join("&");
    }
    static appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      let prefix = url.match(/\?/) ? "&" : "?";
      return `${url}${prefix}${this.serialize(params)}`;
    }
  };
  var LongPoll = class {
    constructor(endPoint) {
      this.endPoint = null;
      this.token = null;
      this.skipHeartbeat = true;
      this.onopen = function() {
      };
      this.onerror = function() {
      };
      this.onmessage = function() {
      };
      this.onclose = function() {
      };
      this.pollEndpoint = this.normalizeEndpoint(endPoint);
      this.readyState = SOCKET_STATES.connecting;
      this.poll();
    }
    normalizeEndpoint(endPoint) {
      return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
    }
    endpointURL() {
      return Ajax.appendParams(this.pollEndpoint, { token: this.token });
    }
    closeAndRetry() {
      this.close();
      this.readyState = SOCKET_STATES.connecting;
    }
    ontimeout() {
      this.onerror("timeout");
      this.closeAndRetry();
    }
    poll() {
      if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {
        return;
      }
      Ajax.request("GET", this.endpointURL(), "application/json", null, this.timeout, this.ontimeout.bind(this), (resp) => {
        if (resp) {
          var { status, token, messages } = resp;
          this.token = token;
        } else {
          status = 0;
        }
        switch (status) {
          case 200:
            messages.forEach((msg) => {
              setTimeout(() => {
                this.onmessage({ data: msg });
              }, 0);
            });
            this.poll();
            break;
          case 204:
            this.poll();
            break;
          case 410:
            this.readyState = SOCKET_STATES.open;
            this.onopen();
            this.poll();
            break;
          case 403:
            this.onerror();
            this.close();
            break;
          case 0:
          case 500:
            this.onerror();
            this.closeAndRetry();
            break;
          default:
            throw new Error(`unhandled poll status ${status}`);
        }
      });
    }
    send(body) {
      Ajax.request("POST", this.endpointURL(), "application/json", body, this.timeout, this.onerror.bind(this, "timeout"), (resp) => {
        if (!resp || resp.status !== 200) {
          this.onerror(resp && resp.status);
          this.closeAndRetry();
        }
      });
    }
    close(_code, _reason) {
      this.readyState = SOCKET_STATES.closed;
      this.onclose();
    }
  };
  var serializer_default = {
    HEADER_LENGTH: 1,
    META_LENGTH: 4,
    KINDS: { push: 0, reply: 1, broadcast: 2 },
    encode(msg, callback) {
      if (msg.payload.constructor === ArrayBuffer) {
        return callback(this.binaryEncode(msg));
      } else {
        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback(JSON.stringify(payload));
      }
    },
    decode(rawPayload, callback) {
      if (rawPayload.constructor === ArrayBuffer) {
        return callback(this.binaryDecode(rawPayload));
      } else {
        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
        return callback({ join_ref, ref, topic, event, payload });
      }
    },
    binaryEncode(message) {
      let { join_ref, ref, event, topic, payload } = message;
      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.push);
      view.setUint8(offset++, join_ref.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, event.length);
      Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + payload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(payload), header.byteLength);
      return combined.buffer;
    },
    binaryDecode(buffer) {
      let view = new DataView(buffer);
      let kind = view.getUint8(0);
      let decoder = new TextDecoder();
      switch (kind) {
        case this.KINDS.push:
          return this.decodePush(buffer, view, decoder);
        case this.KINDS.reply:
          return this.decodeReply(buffer, view, decoder);
        case this.KINDS.broadcast:
          return this.decodeBroadcast(buffer, view, decoder);
      }
    },
    decodePush(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let topicSize = view.getUint8(2);
      let eventSize = view.getUint8(3);
      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: joinRef, ref: null, topic, event, payload: data };
    },
    decodeReply(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let refSize = view.getUint8(2);
      let topicSize = view.getUint8(3);
      let eventSize = view.getUint8(4);
      let offset = this.HEADER_LENGTH + this.META_LENGTH;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let ref = decoder.decode(buffer.slice(offset, offset + refSize));
      offset = offset + refSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      let payload = { status: event, response: data };
      return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
    },
    decodeBroadcast(buffer, view, decoder) {
      let topicSize = view.getUint8(1);
      let eventSize = view.getUint8(2);
      let offset = this.HEADER_LENGTH + 2;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: null, ref: null, topic, event, payload: data };
    }
  };
  var Socket = class {
    constructor(endPoint, opts = {}) {
      this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
      this.channels = [];
      this.sendBuffer = [];
      this.ref = 0;
      this.timeout = opts.timeout || DEFAULT_TIMEOUT;
      this.transport = opts.transport || global.WebSocket || LongPoll;
      this.establishedConnections = 0;
      this.defaultEncoder = serializer_default.encode.bind(serializer_default);
      this.defaultDecoder = serializer_default.decode.bind(serializer_default);
      this.closeWasClean = false;
      this.binaryType = opts.binaryType || "arraybuffer";
      this.connectClock = 1;
      if (this.transport !== LongPoll) {
        this.encode = opts.encode || this.defaultEncoder;
        this.decode = opts.decode || this.defaultDecoder;
      } else {
        this.encode = this.defaultEncoder;
        this.decode = this.defaultDecoder;
      }
      let awaitingConnectionOnPageShow = null;
      if (phxWindow && phxWindow.addEventListener) {
        phxWindow.addEventListener("pagehide", (_e) => {
          if (this.conn) {
            this.disconnect();
            awaitingConnectionOnPageShow = this.connectClock;
          }
        });
        phxWindow.addEventListener("pageshow", (_e) => {
          if (awaitingConnectionOnPageShow === this.connectClock) {
            awaitingConnectionOnPageShow = null;
            this.connect();
          }
        });
      }
      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
      this.rejoinAfterMs = (tries) => {
        if (opts.rejoinAfterMs) {
          return opts.rejoinAfterMs(tries);
        } else {
          return [1e3, 2e3, 5e3][tries - 1] || 1e4;
        }
      };
      this.reconnectAfterMs = (tries) => {
        if (opts.reconnectAfterMs) {
          return opts.reconnectAfterMs(tries);
        } else {
          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
        }
      };
      this.logger = opts.logger || null;
      this.longpollerTimeout = opts.longpollerTimeout || 2e4;
      this.params = closure(opts.params || {});
      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
      this.vsn = opts.vsn || DEFAULT_VSN;
      this.heartbeatTimer = null;
      this.pendingHeartbeatRef = null;
      this.reconnectTimer = new Timer(() => {
        this.teardown(() => this.connect());
      }, this.reconnectAfterMs);
    }
    replaceTransport(newTransport) {
      this.disconnect();
      this.transport = newTransport;
    }
    protocol() {
      return location.protocol.match(/^https/) ? "wss" : "ws";
    }
    endPointURL() {
      let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), { vsn: this.vsn });
      if (uri.charAt(0) !== "/") {
        return uri;
      }
      if (uri.charAt(1) === "/") {
        return `${this.protocol()}:${uri}`;
      }
      return `${this.protocol()}://${location.host}${uri}`;
    }
    disconnect(callback, code, reason) {
      this.connectClock++;
      this.closeWasClean = true;
      this.reconnectTimer.reset();
      this.teardown(callback, code, reason);
    }
    connect(params) {
      this.connectClock++;
      if (params) {
        console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
        this.params = closure(params);
      }
      if (this.conn) {
        return;
      }
      this.closeWasClean = false;
      this.conn = new this.transport(this.endPointURL());
      this.conn.binaryType = this.binaryType;
      this.conn.timeout = this.longpollerTimeout;
      this.conn.onopen = () => this.onConnOpen();
      this.conn.onerror = (error) => this.onConnError(error);
      this.conn.onmessage = (event) => this.onConnMessage(event);
      this.conn.onclose = (event) => this.onConnClose(event);
    }
    log(kind, msg, data) {
      this.logger(kind, msg, data);
    }
    hasLogger() {
      return this.logger !== null;
    }
    onOpen(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.open.push([ref, callback]);
      return ref;
    }
    onClose(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.close.push([ref, callback]);
      return ref;
    }
    onError(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.error.push([ref, callback]);
      return ref;
    }
    onMessage(callback) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.message.push([ref, callback]);
      return ref;
    }
    onConnOpen() {
      if (this.hasLogger())
        this.log("transport", `connected to ${this.endPointURL()}`);
      this.closeWasClean = false;
      this.establishedConnections++;
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      this.resetHeartbeat();
      this.stateChangeCallbacks.open.forEach(([, callback]) => callback());
    }
    heartbeatTimeout() {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        if (this.hasLogger()) {
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        }
        this.abnormalClose("heartbeat timeout");
      }
    }
    resetHeartbeat() {
      if (this.conn && this.conn.skipHeartbeat) {
        return;
      }
      this.pendingHeartbeatRef = null;
      clearTimeout(this.heartbeatTimer);
      setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    teardown(callback, code, reason) {
      if (!this.conn) {
        return callback && callback();
      }
      this.waitForBufferDone(() => {
        if (this.conn) {
          if (code) {
            this.conn.close(code, reason || "");
          } else {
            this.conn.close();
          }
        }
        this.waitForSocketClosed(() => {
          if (this.conn) {
            this.conn.onclose = function() {
            };
            this.conn = null;
          }
          callback && callback();
        });
      });
    }
    waitForBufferDone(callback, tries = 1) {
      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForBufferDone(callback, tries + 1);
      }, 150 * tries);
    }
    waitForSocketClosed(callback, tries = 1) {
      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
        callback();
        return;
      }
      setTimeout(() => {
        this.waitForSocketClosed(callback, tries + 1);
      }, 150 * tries);
    }
    onConnClose(event) {
      let closeCode = event && event.code;
      if (this.hasLogger())
        this.log("transport", "close", event);
      this.triggerChanError();
      clearTimeout(this.heartbeatTimer);
      if (!this.closeWasClean && closeCode !== 1e3) {
        this.reconnectTimer.scheduleTimeout();
      }
      this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));
    }
    onConnError(error) {
      if (this.hasLogger())
        this.log("transport", error);
      let transportBefore = this.transport;
      let establishedBefore = this.establishedConnections;
      this.stateChangeCallbacks.error.forEach(([, callback]) => {
        callback(error, transportBefore, establishedBefore);
      });
      if (transportBefore === this.transport || establishedBefore > 0) {
        this.triggerChanError();
      }
    }
    triggerChanError() {
      this.channels.forEach((channel) => {
        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
          channel.trigger(CHANNEL_EVENTS.error);
        }
      });
    }
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case SOCKET_STATES.connecting:
          return "connecting";
        case SOCKET_STATES.open:
          return "open";
        case SOCKET_STATES.closing:
          return "closing";
        default:
          return "closed";
      }
    }
    isConnected() {
      return this.connectionState() === "open";
    }
    remove(channel) {
      this.off(channel.stateChangeRefs);
      this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());
    }
    off(refs) {
      for (let key in this.stateChangeCallbacks) {
        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
          return refs.indexOf(ref) === -1;
        });
      }
    }
    channel(topic, chanParams = {}) {
      let chan = new Channel(topic, chanParams, this);
      this.channels.push(chan);
      return chan;
    }
    push(data) {
      if (this.hasLogger()) {
        let { topic, event, payload, ref, join_ref } = data;
        this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
      }
      if (this.isConnected()) {
        this.encode(data, (result) => this.conn.send(result));
      } else {
        this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
      }
    }
    makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    sendHeartbeat() {
      if (this.pendingHeartbeatRef && !this.isConnected()) {
        return;
      }
      this.pendingHeartbeatRef = this.makeRef();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
      this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
    }
    abnormalClose(reason) {
      this.closeWasClean = false;
      if (this.isConnected()) {
        this.conn.close(WS_CLOSE_NORMAL, reason);
      }
    }
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback) => callback());
        this.sendBuffer = [];
      }
    }
    onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        let { topic, event, payload, ref, join_ref } = msg;
        if (ref && ref === this.pendingHeartbeatRef) {
          clearTimeout(this.heartbeatTimer);
          this.pendingHeartbeatRef = null;
          setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
        }
        if (this.hasLogger())
          this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
        for (let i = 0; i < this.channels.length; i++) {
          const channel = this.channels[i];
          if (!channel.isMember(topic, event, payload, join_ref)) {
            continue;
          }
          channel.trigger(event, payload, ref, join_ref);
        }
        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
          let [, callback] = this.stateChangeCallbacks.message[i];
          callback(msg);
        }
      });
    }
    leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
      if (dupChannel) {
        if (this.hasLogger())
          this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.leave();
      }
    }
  };

  // ../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js
  var CONSECUTIVE_RELOADS = "consecutive-reloads";
  var MAX_RELOADS = 10;
  var RELOAD_JITTER_MIN = 1e3;
  var RELOAD_JITTER_MAX = 3e3;
  var FAILSAFE_JITTER = 3e4;
  var PHX_EVENT_CLASSES = [
    "phx-click-loading",
    "phx-change-loading",
    "phx-submit-loading",
    "phx-keydown-loading",
    "phx-keyup-loading",
    "phx-blur-loading",
    "phx-focus-loading"
  ];
  var PHX_COMPONENT = "data-phx-component";
  var PHX_LIVE_LINK = "data-phx-link";
  var PHX_TRACK_STATIC = "track-static";
  var PHX_LINK_STATE = "data-phx-link-state";
  var PHX_REF = "data-phx-ref";
  var PHX_REF_SRC = "data-phx-ref-src";
  var PHX_TRACK_UPLOADS = "track-uploads";
  var PHX_UPLOAD_REF = "data-phx-upload-ref";
  var PHX_PREFLIGHTED_REFS = "data-phx-preflighted-refs";
  var PHX_DONE_REFS = "data-phx-done-refs";
  var PHX_DROP_TARGET = "drop-target";
  var PHX_ACTIVE_ENTRY_REFS = "data-phx-active-refs";
  var PHX_LIVE_FILE_UPDATED = "phx:live-file:updated";
  var PHX_SKIP = "data-phx-skip";
  var PHX_PRUNE = "data-phx-prune";
  var PHX_PAGE_LOADING = "page-loading";
  var PHX_CONNECTED_CLASS = "phx-connected";
  var PHX_DISCONNECTED_CLASS = "phx-loading";
  var PHX_NO_FEEDBACK_CLASS = "phx-no-feedback";
  var PHX_ERROR_CLASS = "phx-error";
  var PHX_PARENT_ID = "data-phx-parent-id";
  var PHX_MAIN = "data-phx-main";
  var PHX_ROOT_ID = "data-phx-root-id";
  var PHX_TRIGGER_ACTION = "trigger-action";
  var PHX_FEEDBACK_FOR = "feedback-for";
  var PHX_HAS_FOCUSED = "phx-has-focused";
  var FOCUSABLE_INPUTS = ["text", "textarea", "number", "email", "password", "search", "tel", "url", "date", "time", "datetime-local", "color", "range"];
  var CHECKABLE_INPUTS = ["checkbox", "radio"];
  var PHX_HAS_SUBMITTED = "phx-has-submitted";
  var PHX_SESSION = "data-phx-session";
  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;
  var PHX_STICKY = "data-phx-sticky";
  var PHX_STATIC = "data-phx-static";
  var PHX_READONLY = "data-phx-readonly";
  var PHX_DISABLED = "data-phx-disabled";
  var PHX_DISABLE_WITH = "disable-with";
  var PHX_DISABLE_WITH_RESTORE = "data-phx-disable-with-restore";
  var PHX_HOOK = "hook";
  var PHX_DEBOUNCE = "debounce";
  var PHX_THROTTLE = "throttle";
  var PHX_UPDATE = "update";
  var PHX_KEY = "key";
  var PHX_PRIVATE = "phxPrivate";
  var PHX_AUTO_RECOVER = "auto-recover";
  var PHX_LV_DEBUG = "phx:live-socket:debug";
  var PHX_LV_PROFILE = "phx:live-socket:profiling";
  var PHX_LV_LATENCY_SIM = "phx:live-socket:latency-sim";
  var PHX_PROGRESS = "progress";
  var LOADER_TIMEOUT = 1;
  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;
  var BINDING_PREFIX = "phx-";
  var PUSH_TIMEOUT = 3e4;
  var DEBOUNCE_TRIGGER = "debounce-trigger";
  var THROTTLED = "throttled";
  var DEBOUNCE_PREV_KEY = "debounce-prev-key";
  var DEFAULTS = {
    debounce: 300,
    throttle: 300
  };
  var DYNAMICS = "d";
  var STATIC = "s";
  var COMPONENTS = "c";
  var EVENTS = "e";
  var REPLY = "r";
  var TITLE = "t";
  var TEMPLATES = "p";
  var EntryUploader = class {
    constructor(entry, chunkSize, liveSocket2) {
      this.liveSocket = liveSocket2;
      this.entry = entry;
      this.offset = 0;
      this.chunkSize = chunkSize;
      this.chunkTimer = null;
      this.uploadChannel = liveSocket2.channel(`lvu:${entry.ref}`, { token: entry.metadata() });
    }
    error(reason) {
      clearTimeout(this.chunkTimer);
      this.uploadChannel.leave();
      this.entry.error(reason);
    }
    upload() {
      this.uploadChannel.onError((reason) => this.error(reason));
      this.uploadChannel.join().receive("ok", (_data) => this.readNextChunk()).receive("error", (reason) => this.error(reason));
    }
    isDone() {
      return this.offset >= this.entry.file.size;
    }
    readNextChunk() {
      let reader = new window.FileReader();
      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);
      reader.onload = (e) => {
        if (e.target.error === null) {
          this.offset += e.target.result.byteLength;
          this.pushChunk(e.target.result);
        } else {
          return logError("Read error: " + e.target.error);
        }
      };
      reader.readAsArrayBuffer(blob);
    }
    pushChunk(chunk) {
      if (!this.uploadChannel.isJoined()) {
        return;
      }
      this.uploadChannel.push("chunk", chunk).receive("ok", () => {
        this.entry.progress(this.offset / this.entry.file.size * 100);
        if (!this.isDone()) {
          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);
        }
      });
    }
  };
  var logError = (msg, obj) => console.error && console.error(msg, obj);
  var isCid = (cid) => {
    let type = typeof cid;
    return type === "number" || type === "string" && /^(0|[1-9]\d*)$/.test(cid);
  };
  function detectDuplicateIds() {
    let ids = /* @__PURE__ */ new Set();
    let elems = document.querySelectorAll("*[id]");
    for (let i = 0, len = elems.length; i < len; i++) {
      if (ids.has(elems[i].id)) {
        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);
      } else {
        ids.add(elems[i].id);
      }
    }
  }
  var debug = (view, kind, msg, obj) => {
    if (view.liveSocket.isDebugEnabled()) {
      console.log(`${view.id} ${kind}: ${msg} - `, obj);
    }
  };
  var closure2 = (val) => typeof val === "function" ? val : function() {
    return val;
  };
  var clone = (obj) => {
    return JSON.parse(JSON.stringify(obj));
  };
  var closestPhxBinding = (el, binding, borderEl) => {
    do {
      if (el.matches(`[${binding}]`)) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));
    return null;
  };
  var isObject = (obj) => {
    return obj !== null && typeof obj === "object" && !(obj instanceof Array);
  };
  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);
  var isEmpty = (obj) => {
    for (let x in obj) {
      return false;
    }
    return true;
  };
  var maybe = (el, callback) => el && callback(el);
  var channelUploader = function(entries, onError, resp, liveSocket2) {
    entries.forEach((entry) => {
      let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket2);
      entryUploader.upload();
    });
  };
  var Browser = {
    canPushState() {
      return typeof history.pushState !== "undefined";
    },
    dropLocal(localStorage, namespace, subkey) {
      return localStorage.removeItem(this.localKey(namespace, subkey));
    },
    updateLocal(localStorage, namespace, subkey, initial, func) {
      let current = this.getLocal(localStorage, namespace, subkey);
      let key = this.localKey(namespace, subkey);
      let newVal = current === null ? initial : func(current);
      localStorage.setItem(key, JSON.stringify(newVal));
      return newVal;
    },
    getLocal(localStorage, namespace, subkey) {
      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));
    },
    updateCurrentState(callback) {
      if (!this.canPushState()) {
        return;
      }
      history.replaceState(callback(history.state || {}), "", window.location.href);
    },
    pushState(kind, meta, to) {
      if (this.canPushState()) {
        if (to !== window.location.href) {
          if (meta.type == "redirect" && meta.scroll) {
            let currentState = history.state || {};
            currentState.scroll = meta.scroll;
            history.replaceState(currentState, "", window.location.href);
          }
          delete meta.scroll;
          history[kind + "State"](meta, "", to || null);
          let hashEl = this.getHashTargetEl(window.location.hash);
          if (hashEl) {
            hashEl.scrollIntoView();
          } else if (meta.type === "redirect") {
            window.scroll(0, 0);
          }
        }
      } else {
        this.redirect(to);
      }
    },
    setCookie(name, value) {
      document.cookie = `${name}=${value}`;
    },
    getCookie(name) {
      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), "$1");
    },
    redirect(toURL, flash) {
      if (flash) {
        Browser.setCookie("__phoenix_flash__", flash + "; max-age=60000; path=/");
      }
      window.location = toURL;
    },
    localKey(namespace, subkey) {
      return `${namespace}-${subkey}`;
    },
    getHashTargetEl(maybeHash) {
      let hash = maybeHash.toString().substring(1);
      if (hash === "") {
        return;
      }
      return document.getElementById(hash) || document.querySelector(`a[name="${hash}"]`);
    }
  };
  var browser_default = Browser;
  var DOM = {
    byId(id) {
      return document.getElementById(id) || logError(`no id found for ${id}`);
    },
    removeClass(el, className) {
      el.classList.remove(className);
      if (el.classList.length === 0) {
        el.removeAttribute("class");
      }
    },
    all(node, query, callback) {
      if (!node) {
        return [];
      }
      let array = Array.from(node.querySelectorAll(query));
      return callback ? array.forEach(callback) : array;
    },
    childNodeLength(html) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return template.content.childElementCount;
    },
    isUploadInput(el) {
      return el.type === "file" && el.getAttribute(PHX_UPLOAD_REF) !== null;
    },
    findUploadInputs(node) {
      return this.all(node, `input[type="file"][${PHX_UPLOAD_REF}]`);
    },
    findComponentNodeList(node, cid) {
      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node);
    },
    isPhxDestroyed(node) {
      return node.id && DOM.private(node, "destroyed") ? true : false;
    },
    markPhxChildDestroyed(el) {
      if (this.isPhxChild(el)) {
        el.setAttribute(PHX_SESSION, "");
      }
      this.putPrivate(el, "destroyed", true);
    },
    findPhxChildrenInFragment(html, parentId) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return this.findPhxChildren(template.content, parentId);
    },
    isIgnored(el, phxUpdate) {
      return (el.getAttribute(phxUpdate) || el.getAttribute("data-phx-update")) === "ignore";
    },
    isPhxUpdate(el, phxUpdate, updateTypes) {
      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;
    },
    findPhxSticky(el) {
      return this.all(el, `[${PHX_STICKY}]`);
    },
    findPhxChildren(el, parentId) {
      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}="${parentId}"]`);
    },
    findParentCIDs(node, cids) {
      let initial = new Set(cids);
      return cids.reduce((acc, cid) => {
        let selector = `[${PHX_COMPONENT}="${cid}"] [${PHX_COMPONENT}]`;
        this.filterWithinSameLiveView(this.all(node, selector), node).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => acc.delete(childCID));
        return acc;
      }, initial);
    },
    filterWithinSameLiveView(nodes, parent) {
      if (parent.querySelector(PHX_VIEW_SELECTOR)) {
        return nodes.filter((el) => this.withinSameLiveView(el, parent));
      } else {
        return nodes;
      }
    },
    withinSameLiveView(node, parent) {
      while (node = node.parentNode) {
        if (node.isSameNode(parent)) {
          return true;
        }
        if (node.getAttribute(PHX_SESSION) !== null) {
          return false;
        }
      }
    },
    private(el, key) {
      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];
    },
    deletePrivate(el, key) {
      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];
    },
    putPrivate(el, key, value) {
      if (!el[PHX_PRIVATE]) {
        el[PHX_PRIVATE] = {};
      }
      el[PHX_PRIVATE][key] = value;
    },
    updatePrivate(el, key, defaultVal, updateFunc) {
      let existing = this.private(el, key);
      if (existing === void 0) {
        this.putPrivate(el, key, updateFunc(defaultVal));
      } else {
        this.putPrivate(el, key, updateFunc(existing));
      }
    },
    copyPrivates(target, source) {
      if (source[PHX_PRIVATE]) {
        target[PHX_PRIVATE] = source[PHX_PRIVATE];
      }
    },
    putTitle(str) {
      let titleEl = document.querySelector("title");
      let { prefix, suffix } = titleEl.dataset;
      document.title = `${prefix || ""}${str}${suffix || ""}`;
    },
    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback) {
      let debounce = el.getAttribute(phxDebounce);
      let throttle = el.getAttribute(phxThrottle);
      if (debounce === "") {
        debounce = defaultDebounce;
      }
      if (throttle === "") {
        throttle = defaultThrottle;
      }
      let value = debounce || throttle;
      switch (value) {
        case null:
          return callback();
        case "blur":
          if (this.once(el, "debounce-blur")) {
            el.addEventListener("blur", () => callback());
          }
          return;
        default:
          let timeout = parseInt(value);
          let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback();
          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);
          if (isNaN(timeout)) {
            return logError(`invalid throttle/debounce value: ${value}`);
          }
          if (throttle) {
            let newKeyDown = false;
            if (event.type === "keydown") {
              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);
              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);
              newKeyDown = prevKey !== event.key;
            }
            if (!newKeyDown && this.private(el, THROTTLED)) {
              return false;
            } else {
              callback();
              this.putPrivate(el, THROTTLED, true);
              setTimeout(() => this.triggerCycle(el, DEBOUNCE_TRIGGER), timeout);
            }
          } else {
            setTimeout(() => this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle), timeout);
          }
          let form = el.form;
          if (form && this.once(form, "bind-debounce")) {
            form.addEventListener("submit", () => {
              Array.from(new FormData(form).entries(), ([name]) => {
                let input = form.querySelector(`[name="${name}"]`);
                this.incCycle(input, DEBOUNCE_TRIGGER);
                this.deletePrivate(input, THROTTLED);
              });
            });
          }
          if (this.once(el, "bind-debounce")) {
            el.addEventListener("blur", () => this.triggerCycle(el, DEBOUNCE_TRIGGER));
          }
      }
    },
    triggerCycle(el, key, currentCycle) {
      let [cycle, trigger] = this.private(el, key);
      if (!currentCycle) {
        currentCycle = cycle;
      }
      if (currentCycle === cycle) {
        this.incCycle(el, key);
        trigger();
      }
    },
    once(el, key) {
      if (this.private(el, key) === true) {
        return false;
      }
      this.putPrivate(el, key, true);
      return true;
    },
    incCycle(el, key, trigger = function() {
    }) {
      let [currentCycle] = this.private(el, key) || [0, trigger];
      currentCycle++;
      this.putPrivate(el, key, [currentCycle, trigger]);
      return currentCycle;
    },
    discardError(container, el, phxFeedbackFor) {
      let field = el.getAttribute && el.getAttribute(phxFeedbackFor);
      let input = field && container.querySelector(`[id="${field}"], [name="${field}"]`);
      if (!input) {
        return;
      }
      if (!(this.private(input, PHX_HAS_FOCUSED) || this.private(input.form, PHX_HAS_SUBMITTED))) {
        el.classList.add(PHX_NO_FEEDBACK_CLASS);
      }
    },
    showError(inputEl, phxFeedbackFor) {
      if (inputEl.id || inputEl.name) {
        this.all(inputEl.form, `[${phxFeedbackFor}="${inputEl.id}"], [${phxFeedbackFor}="${inputEl.name}"]`, (el) => {
          this.removeClass(el, PHX_NO_FEEDBACK_CLASS);
        });
      }
    },
    isPhxChild(node) {
      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);
    },
    isPhxSticky(node) {
      return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;
    },
    firstPhxChild(el) {
      return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];
    },
    dispatchEvent(target, eventString, detail = {}) {
      let event = new CustomEvent(eventString, { bubbles: true, cancelable: true, detail });
      target.dispatchEvent(event);
    },
    cloneNode(node, html) {
      if (typeof html === "undefined") {
        return node.cloneNode(true);
      } else {
        let cloned = node.cloneNode(false);
        cloned.innerHTML = html;
        return cloned;
      }
    },
    mergeAttrs(target, source, opts = {}) {
      let exclude = opts.exclude || [];
      let isIgnored = opts.isIgnored;
      let sourceAttrs = source.attributes;
      for (let i = sourceAttrs.length - 1; i >= 0; i--) {
        let name = sourceAttrs[i].name;
        if (exclude.indexOf(name) < 0) {
          target.setAttribute(name, source.getAttribute(name));
        }
      }
      let targetAttrs = target.attributes;
      for (let i = targetAttrs.length - 1; i >= 0; i--) {
        let name = targetAttrs[i].name;
        if (isIgnored) {
          if (name.startsWith("data-") && !source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        } else {
          if (!source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        }
      }
    },
    mergeFocusedInput(target, source) {
      if (!(target instanceof HTMLSelectElement)) {
        DOM.mergeAttrs(target, source, { except: ["value"] });
      }
      if (source.readOnly) {
        target.setAttribute("readonly", true);
      } else {
        target.removeAttribute("readonly");
      }
    },
    hasSelectionRange(el) {
      return el.setSelectionRange && (el.type === "text" || el.type === "textarea");
    },
    restoreFocus(focused, selectionStart, selectionEnd) {
      if (!DOM.isTextualInput(focused)) {
        return;
      }
      let wasFocused = focused.matches(":focus");
      if (focused.readOnly) {
        focused.blur();
      }
      if (!wasFocused) {
        focused.focus();
      }
      if (this.hasSelectionRange(focused)) {
        focused.setSelectionRange(selectionStart, selectionEnd);
      }
    },
    isFormInput(el) {
      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== "button";
    },
    syncAttrsToProps(el) {
      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {
        el.checked = el.getAttribute("checked") !== null;
      }
    },
    isTextualInput(el) {
      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;
    },
    isNowTriggerFormExternal(el, phxTriggerExternal) {
      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;
    },
    syncPendingRef(fromEl, toEl, disableWith) {
      let ref = fromEl.getAttribute(PHX_REF);
      if (ref === null) {
        return true;
      }
      let refSrc = fromEl.getAttribute(PHX_REF_SRC);
      if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {
        if (DOM.isUploadInput(fromEl)) {
          DOM.mergeAttrs(fromEl, toEl, { isIgnored: true });
        }
        DOM.putPrivate(fromEl, PHX_REF, toEl);
        return false;
      } else {
        PHX_EVENT_CLASSES.forEach((className) => {
          fromEl.classList.contains(className) && toEl.classList.add(className);
        });
        toEl.setAttribute(PHX_REF, ref);
        toEl.setAttribute(PHX_REF_SRC, refSrc);
        return true;
      }
    },
    cleanChildNodes(container, phxUpdate) {
      if (DOM.isPhxUpdate(container, phxUpdate, ["append", "prepend"])) {
        let toRemove = [];
        container.childNodes.forEach((childNode) => {
          if (!childNode.id) {
            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === "";
            if (!isEmptyTextNode) {
              logError(`only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(childNode.outerHTML || childNode.nodeValue).trim()}"

`);
            }
            toRemove.push(childNode);
          }
        });
        toRemove.forEach((childNode) => childNode.remove());
      }
    },
    replaceRootContainer(container, tagName, attrs) {
      let retainedAttrs = /* @__PURE__ */ new Set(["id", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);
      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {
        Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));
        Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));
        return container;
      } else {
        let newContainer = document.createElement(tagName);
        Object.keys(attrs).forEach((attr) => newContainer.setAttribute(attr, attrs[attr]));
        retainedAttrs.forEach((attr) => newContainer.setAttribute(attr, container.getAttribute(attr)));
        newContainer.innerHTML = container.innerHTML;
        container.replaceWith(newContainer);
        return newContainer;
      }
    },
    getSticky(el, name, defaultVal) {
      let op = (DOM.private(el, "sticky") || []).find(([existingName]) => name === existingName);
      if (op) {
        let [_name, _op, stashedResult] = op;
        return stashedResult;
      } else {
        return typeof defaultVal === "function" ? defaultVal() : defaultVal;
      }
    },
    deleteSticky(el, name) {
      this.updatePrivate(el, "sticky", [], (ops) => {
        return ops.filter(([existingName, _]) => existingName !== name);
      });
    },
    putSticky(el, name, op) {
      let stashedResult = op(el);
      this.updatePrivate(el, "sticky", [], (ops) => {
        let existingIndex = ops.findIndex(([existingName]) => name === existingName);
        if (existingIndex >= 0) {
          ops[existingIndex] = [name, op, stashedResult];
        } else {
          ops.push([name, op, stashedResult]);
        }
        return ops;
      });
    },
    applyStickyOperations(el) {
      let ops = DOM.private(el, "sticky");
      if (!ops) {
        return;
      }
      ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));
    }
  };
  var dom_default = DOM;
  var UploadEntry = class {
    static isActive(fileEl, file) {
      let isNew = file._phxRef === void 0;
      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return file.size > 0 && (isNew || isActive);
    }
    static isPreflighted(fileEl, file) {
      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(",");
      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return isPreflighted && this.isActive(fileEl, file);
    }
    constructor(fileEl, file, view) {
      this.ref = LiveUploader.genFileRef(file);
      this.fileEl = fileEl;
      this.file = file;
      this.view = view;
      this.meta = null;
      this._isCancelled = false;
      this._isDone = false;
      this._progress = 0;
      this._lastProgressSent = -1;
      this._onDone = function() {
      };
      this._onElUpdated = this.onElUpdated.bind(this);
      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
    }
    metadata() {
      return this.meta;
    }
    progress(progress) {
      this._progress = Math.floor(progress);
      if (this._progress > this._lastProgressSent) {
        if (this._progress >= 100) {
          this._progress = 100;
          this._lastProgressSent = 100;
          this._isDone = true;
          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
            LiveUploader.untrackFile(this.fileEl, this.file);
            this._onDone();
          });
        } else {
          this._lastProgressSent = this._progress;
          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);
        }
      }
    }
    cancel() {
      this._isCancelled = true;
      this._isDone = true;
      this._onDone();
    }
    isDone() {
      return this._isDone;
    }
    error(reason = "failed") {
      this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });
      LiveUploader.clearFiles(this.fileEl);
    }
    onDone(callback) {
      this._onDone = () => {
        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
        callback();
      };
    }
    onElUpdated() {
      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      if (activeRefs.indexOf(this.ref) === -1) {
        this.cancel();
      }
    }
    toPreflightPayload() {
      return {
        last_modified: this.file.lastModified,
        name: this.file.name,
        size: this.file.size,
        type: this.file.type,
        ref: this.ref
      };
    }
    uploader(uploaders) {
      if (this.meta.uploader) {
        let callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);
        return { name: this.meta.uploader, callback };
      } else {
        return { name: "channel", callback: channelUploader };
      }
    }
    zipPostFlight(resp) {
      this.meta = resp.entries[this.ref];
      if (!this.meta) {
        logError(`no preflight upload response returned with ref ${this.ref}`, { input: this.fileEl, response: resp });
      }
    }
  };
  var liveUploaderFileRef = 0;
  var LiveUploader = class {
    static genFileRef(file) {
      let ref = file._phxRef;
      if (ref !== void 0) {
        return ref;
      } else {
        file._phxRef = (liveUploaderFileRef++).toString();
        return file._phxRef;
      }
    }
    static getEntryDataURL(inputEl, ref, callback) {
      let file = this.activeFiles(inputEl).find((file2) => this.genFileRef(file2) === ref);
      callback(URL.createObjectURL(file));
    }
    static hasUploadsInProgress(formEl) {
      let active = 0;
      dom_default.findUploadInputs(formEl).forEach((input) => {
        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {
          active++;
        }
      });
      return active > 0;
    }
    static serializeUploads(inputEl) {
      let files = this.activeFiles(inputEl);
      let fileData = {};
      files.forEach((file) => {
        let entry = { path: inputEl.name };
        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);
        fileData[uploadRef] = fileData[uploadRef] || [];
        entry.ref = this.genFileRef(file);
        entry.name = file.name || entry.ref;
        entry.type = file.type;
        entry.size = file.size;
        fileData[uploadRef].push(entry);
      });
      return fileData;
    }
    static clearFiles(inputEl) {
      inputEl.value = null;
      inputEl.removeAttribute(PHX_UPLOAD_REF);
      dom_default.putPrivate(inputEl, "files", []);
    }
    static untrackFile(inputEl, file) {
      dom_default.putPrivate(inputEl, "files", dom_default.private(inputEl, "files").filter((f) => !Object.is(f, file)));
    }
    static trackFiles(inputEl, files) {
      if (inputEl.getAttribute("multiple") !== null) {
        let newFiles = files.filter((file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)));
        dom_default.putPrivate(inputEl, "files", this.activeFiles(inputEl).concat(newFiles));
        inputEl.value = null;
      } else {
        dom_default.putPrivate(inputEl, "files", files);
      }
    }
    static activeFileInputs(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((el) => el.files && this.activeFiles(el).length > 0);
    }
    static activeFiles(input) {
      return (dom_default.private(input, "files") || []).filter((f) => UploadEntry.isActive(input, f));
    }
    static inputsAwaitingPreflight(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((input) => this.filesAwaitingPreflight(input).length > 0);
    }
    static filesAwaitingPreflight(input) {
      return this.activeFiles(input).filter((f) => !UploadEntry.isPreflighted(input, f));
    }
    constructor(inputEl, view, onComplete) {
      this.view = view;
      this.onComplete = onComplete;
      this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map((file) => new UploadEntry(inputEl, file, view));
      this.numEntriesInProgress = this._entries.length;
    }
    entries() {
      return this._entries;
    }
    initAdapterUpload(resp, onError, liveSocket2) {
      this._entries = this._entries.map((entry) => {
        entry.zipPostFlight(resp);
        entry.onDone(() => {
          this.numEntriesInProgress--;
          if (this.numEntriesInProgress === 0) {
            this.onComplete();
          }
        });
        return entry;
      });
      let groupedEntries = this._entries.reduce((acc, entry) => {
        let { name, callback } = entry.uploader(liveSocket2.uploaders);
        acc[name] = acc[name] || { callback, entries: [] };
        acc[name].entries.push(entry);
        return acc;
      }, {});
      for (let name in groupedEntries) {
        let { callback, entries } = groupedEntries[name];
        callback(entries, onError, resp, liveSocket2);
      }
    }
  };
  var Hooks = {
    LiveFileUpload: {
      activeRefs() {
        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);
      },
      preflightedRefs() {
        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);
      },
      mounted() {
        this.preflightedWas = this.preflightedRefs();
      },
      updated() {
        let newPreflights = this.preflightedRefs();
        if (this.preflightedWas !== newPreflights) {
          this.preflightedWas = newPreflights;
          if (newPreflights === "") {
            this.__view.cancelSubmit(this.el.form);
          }
        }
        if (this.activeRefs() === "") {
          this.el.value = null;
        }
        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));
      }
    },
    LiveImgPreview: {
      mounted() {
        this.ref = this.el.getAttribute("data-phx-entry-ref");
        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));
        LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {
          this.url = url;
          this.el.src = url;
        });
      },
      destroyed() {
        URL.revokeObjectURL(this.url);
      }
    }
  };
  var hooks_default = Hooks;
  var DOMPostMorphRestorer = class {
    constructor(containerBefore, containerAfter, updateType) {
      let idsBefore = /* @__PURE__ */ new Set();
      let idsAfter = new Set([...containerAfter.children].map((child) => child.id));
      let elementsToModify = [];
      Array.from(containerBefore.children).forEach((child) => {
        if (child.id) {
          idsBefore.add(child.id);
          if (idsAfter.has(child.id)) {
            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;
            elementsToModify.push({ elementId: child.id, previousElementId });
          }
        }
      });
      this.containerId = containerAfter.id;
      this.updateType = updateType;
      this.elementsToModify = elementsToModify;
      this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));
    }
    perform() {
      let container = dom_default.byId(this.containerId);
      this.elementsToModify.forEach((elementToModify) => {
        if (elementToModify.previousElementId) {
          maybe(document.getElementById(elementToModify.previousElementId), (previousElem) => {
            maybe(document.getElementById(elementToModify.elementId), (elem) => {
              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;
              if (!isInRightPlace) {
                previousElem.insertAdjacentElement("afterend", elem);
              }
            });
          });
        } else {
          maybe(document.getElementById(elementToModify.elementId), (elem) => {
            let isInRightPlace = elem.previousElementSibling == null;
            if (!isInRightPlace) {
              container.insertAdjacentElement("afterbegin", elem);
            }
          });
        }
      });
      if (this.updateType == "prepend") {
        this.elementIdsToAdd.reverse().forEach((elemId) => {
          maybe(document.getElementById(elemId), (elem) => container.insertAdjacentElement("afterbegin", elem));
        });
      }
    }
  };
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
      attr = fromNodeAttrs[d];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(curFromNodeChild, fromEl, true);
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          if (onBeforeElUpdated(fromEl, toEl) === false) {
            return;
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(curFromNodeChild, fromEl, true);
                          }
                          curFromNodeChild = matchingFromEl;
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(curFromNodeChild, fromEl, true);
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              fromEl.appendChild(matchingFromEl);
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                fromEl.appendChild(curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;
  var DOMPatch = class {
    static patchEl(fromEl, toEl, activeElement) {
      morphdom_esm_default(fromEl, toEl, {
        childrenOnly: false,
        onBeforeElUpdated: (fromEl2, toEl2) => {
          if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {
            dom_default.mergeFocusedInput(fromEl2, toEl2);
            return false;
          }
        }
      });
    }
    constructor(view, container, id, html, targetCID) {
      this.view = view;
      this.liveSocket = view.liveSocket;
      this.container = container;
      this.id = id;
      this.rootID = view.root.id;
      this.html = html;
      this.targetCID = targetCID;
      this.cidPatch = isCid(this.targetCID);
      this.callbacks = {
        beforeadded: [],
        beforeupdated: [],
        beforephxChildAdded: [],
        afteradded: [],
        afterupdated: [],
        afterdiscarded: [],
        afterphxChildAdded: [],
        aftertransitionsDiscarded: []
      };
    }
    before(kind, callback) {
      this.callbacks[`before${kind}`].push(callback);
    }
    after(kind, callback) {
      this.callbacks[`after${kind}`].push(callback);
    }
    trackBefore(kind, ...args) {
      this.callbacks[`before${kind}`].forEach((callback) => callback(...args));
    }
    trackAfter(kind, ...args) {
      this.callbacks[`after${kind}`].forEach((callback) => callback(...args));
    }
    markPrunableContentForRemoval() {
      dom_default.all(this.container, "[phx-update=append] > *, [phx-update=prepend] > *", (el) => {
        el.setAttribute(PHX_PRUNE, "");
      });
    }
    perform() {
      let { view, liveSocket: liveSocket2, container, html } = this;
      let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;
      if (this.isCIDPatch() && !targetContainer) {
        return;
      }
      let focused = liveSocket2.getActiveElement();
      let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
      let phxUpdate = liveSocket2.binding(PHX_UPDATE);
      let phxFeedbackFor = liveSocket2.binding(PHX_FEEDBACK_FOR);
      let disableWith = liveSocket2.binding(PHX_DISABLE_WITH);
      let phxTriggerExternal = liveSocket2.binding(PHX_TRIGGER_ACTION);
      let phxRemove = liveSocket2.binding("remove");
      let added = [];
      let updates = [];
      let appendPrependUpdates = [];
      let pendingRemoves = [];
      let externalFormTriggered = null;
      let diffHTML = liveSocket2.time("premorph container prep", () => {
        return this.buildDiffHTML(container, html, phxUpdate, targetContainer);
      });
      this.trackBefore("added", container);
      this.trackBefore("updated", container, container);
      liveSocket2.time("morphdom", () => {
        morphdom_esm_default(targetContainer, diffHTML, {
          childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,
          getNodeKey: (node) => {
            return dom_default.isPhxDestroyed(node) ? null : node.id;
          },
          onBeforeNodeAdded: (el) => {
            this.trackBefore("added", el);
            return el;
          },
          onNodeAdded: (el) => {
            if (el instanceof HTMLImageElement && el.srcset) {
              el.srcset = el.srcset;
            } else if (el instanceof HTMLVideoElement && el.autoplay) {
              el.play();
            }
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            dom_default.discardError(targetContainer, el, phxFeedbackFor);
            if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {
              this.trackAfter("phxChildAdded", el);
            }
            added.push(el);
          },
          onNodeDiscarded: (el) => {
            if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {
              liveSocket2.destroyViewByEl(el);
            }
            this.trackAfter("discarded", el);
          },
          onBeforeNodeDiscarded: (el) => {
            if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {
              return true;
            }
            if (el.parentNode !== null && dom_default.isPhxUpdate(el.parentNode, phxUpdate, ["append", "prepend"]) && el.id) {
              return false;
            }
            if (el.getAttribute && el.getAttribute(phxRemove)) {
              pendingRemoves.push(el);
              return false;
            }
            if (this.skipCIDSibling(el)) {
              return false;
            }
            return true;
          },
          onElUpdated: (el) => {
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            updates.push(el);
          },
          onBeforeElUpdated: (fromEl, toEl) => {
            dom_default.cleanChildNodes(toEl, phxUpdate);
            if (this.skipCIDSibling(toEl)) {
              return false;
            }
            if (dom_default.isPhxSticky(fromEl)) {
              return false;
            }
            if (dom_default.isIgnored(fromEl, phxUpdate)) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (fromEl.type === "number" && (fromEl.validity && fromEl.validity.badInput)) {
              return false;
            }
            if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {
              if (dom_default.isUploadInput(fromEl)) {
                this.trackBefore("updated", fromEl, toEl);
                updates.push(fromEl);
              }
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (dom_default.isPhxChild(toEl)) {
              let prevSession = fromEl.getAttribute(PHX_SESSION);
              dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });
              if (prevSession !== "") {
                fromEl.setAttribute(PHX_SESSION, prevSession);
              }
              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            dom_default.copyPrivates(toEl, fromEl);
            dom_default.discardError(targetContainer, toEl, phxFeedbackFor);
            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);
            if (isFocusedFormEl) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeFocusedInput(fromEl, toEl);
              dom_default.syncAttrsToProps(fromEl);
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            } else {
              if (dom_default.isPhxUpdate(toEl, phxUpdate, ["append", "prepend"])) {
                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));
              }
              dom_default.syncAttrsToProps(toEl);
              dom_default.applyStickyOperations(toEl);
              this.trackBefore("updated", fromEl, toEl);
              return true;
            }
          }
        });
      });
      if (liveSocket2.isDebugEnabled()) {
        detectDuplicateIds();
      }
      if (appendPrependUpdates.length > 0) {
        liveSocket2.time("post-morph append/prepend restoration", () => {
          appendPrependUpdates.forEach((update) => update.perform());
        });
      }
      liveSocket2.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));
      dom_default.dispatchEvent(document, "phx:update");
      added.forEach((el) => this.trackAfter("added", el));
      updates.forEach((el) => this.trackAfter("updated", el));
      if (pendingRemoves.length > 0) {
        liveSocket2.transitionRemoves(pendingRemoves);
        liveSocket2.requestDOMUpdate(() => {
          pendingRemoves.forEach((el) => {
            let child = dom_default.firstPhxChild(el);
            if (child) {
              liveSocket2.destroyViewByEl(child);
            }
            el.remove();
          });
          this.trackAfter("transitionsDiscarded", pendingRemoves);
        });
      }
      if (externalFormTriggered) {
        liveSocket2.disconnect();
        externalFormTriggered.submit();
      }
      return true;
    }
    isCIDPatch() {
      return this.cidPatch;
    }
    skipCIDSibling(el) {
      return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;
    }
    targetCIDContainer(html) {
      if (!this.isCIDPatch()) {
        return;
      }
      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);
      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {
        return first;
      } else {
        return first && first.parentNode;
      }
    }
    buildDiffHTML(container, html, phxUpdate, targetContainer) {
      let isCIDPatch = this.isCIDPatch();
      let isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();
      if (!isCIDPatch || isCIDWithSingleRoot) {
        return html;
      } else {
        let diffContainer = null;
        let template = document.createElement("template");
        diffContainer = dom_default.cloneNode(targetContainer);
        let [firstComponent, ...rest] = dom_default.findComponentNodeList(diffContainer, this.targetCID);
        template.innerHTML = html;
        rest.forEach((el) => el.remove());
        Array.from(diffContainer.childNodes).forEach((child) => {
          if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== this.targetCID.toString()) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
        });
        Array.from(template.content.childNodes).forEach((el) => diffContainer.insertBefore(el, firstComponent));
        firstComponent.remove();
        return diffContainer.outerHTML;
      }
    }
  };
  var Rendered = class {
    static extract(diff) {
      let { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;
      delete diff[REPLY];
      delete diff[EVENTS];
      delete diff[TITLE];
      return { diff, title, reply: reply || null, events: events || [] };
    }
    constructor(viewId, rendered) {
      this.viewId = viewId;
      this.rendered = {};
      this.mergeDiff(rendered);
    }
    parentViewId() {
      return this.viewId;
    }
    toString(onlyCids) {
      return this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);
    }
    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids) {
      onlyCids = onlyCids ? new Set(onlyCids) : null;
      let output = { buffer: "", components, onlyCids };
      this.toOutputBuffer(rendered, null, output);
      return output.buffer;
    }
    componentCIDs(diff) {
      return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));
    }
    isComponentOnlyDiff(diff) {
      if (!diff[COMPONENTS]) {
        return false;
      }
      return Object.keys(diff).length === 1;
    }
    getComponent(diff, cid) {
      return diff[COMPONENTS][cid];
    }
    mergeDiff(diff) {
      let newc = diff[COMPONENTS];
      let cache = {};
      delete diff[COMPONENTS];
      this.rendered = this.mutableMerge(this.rendered, diff);
      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};
      if (newc) {
        let oldc = this.rendered[COMPONENTS];
        for (let cid in newc) {
          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);
        }
        for (let cid in newc) {
          oldc[cid] = newc[cid];
        }
        diff[COMPONENTS] = newc;
      }
    }
    cachedFindComponent(cid, cdiff, oldc, newc, cache) {
      if (cache[cid]) {
        return cache[cid];
      } else {
        let ndiff, stat, scid = cdiff[STATIC];
        if (isCid(scid)) {
          let tdiff;
          if (scid > 0) {
            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);
          } else {
            tdiff = oldc[-scid];
          }
          stat = tdiff[STATIC];
          ndiff = this.cloneMerge(tdiff, cdiff);
          ndiff[STATIC] = stat;
        } else {
          ndiff = cdiff[STATIC] !== void 0 ? cdiff : this.cloneMerge(oldc[cid] || {}, cdiff);
        }
        cache[cid] = ndiff;
        return ndiff;
      }
    }
    mutableMerge(target, source) {
      if (source[STATIC] !== void 0) {
        return source;
      } else {
        this.doMutableMerge(target, source);
        return target;
      }
    }
    doMutableMerge(target, source) {
      for (let key in source) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          this.doMutableMerge(targetVal, val);
        } else {
          target[key] = val;
        }
      }
    }
    cloneMerge(target, source) {
      let merged = __spreadValues(__spreadValues({}, target), source);
      for (let key in merged) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, val);
        }
      }
      return merged;
    }
    componentToString(cid) {
      return this.recursiveCIDToString(this.rendered[COMPONENTS], cid);
    }
    pruneCIDs(cids) {
      cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);
    }
    get() {
      return this.rendered;
    }
    isNewFingerprint(diff = {}) {
      return !!diff[STATIC];
    }
    templateStatic(part, templates) {
      if (typeof part === "number") {
        return templates[part];
      } else {
        return part;
      }
    }
    toOutputBuffer(rendered, templates, output) {
      if (rendered[DYNAMICS]) {
        return this.comprehensionToBuffer(rendered, templates, output);
      }
      let { [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      output.buffer += statics[0];
      for (let i = 1; i < statics.length; i++) {
        this.dynamicToBuffer(rendered[i - 1], templates, output);
        output.buffer += statics[i];
      }
    }
    comprehensionToBuffer(rendered, templates, output) {
      let { [DYNAMICS]: dynamics, [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      let compTemplates = templates || rendered[TEMPLATES];
      for (let d = 0; d < dynamics.length; d++) {
        let dynamic = dynamics[d];
        output.buffer += statics[0];
        for (let i = 1; i < statics.length; i++) {
          this.dynamicToBuffer(dynamic[i - 1], compTemplates, output);
          output.buffer += statics[i];
        }
      }
    }
    dynamicToBuffer(rendered, templates, output) {
      if (typeof rendered === "number") {
        output.buffer += this.recursiveCIDToString(output.components, rendered, output.onlyCids);
      } else if (isObject(rendered)) {
        this.toOutputBuffer(rendered, templates, output);
      } else {
        output.buffer += rendered;
      }
    }
    recursiveCIDToString(components, cid, onlyCids) {
      let component = components[cid] || logError(`no component for CID ${cid}`, components);
      let template = document.createElement("template");
      template.innerHTML = this.recursiveToString(component, components, onlyCids);
      let container = template.content;
      let skip = onlyCids && !onlyCids.has(cid);
      let [hasChildNodes, hasChildComponents] = Array.from(container.childNodes).reduce(([hasNodes, hasComponents], child, i) => {
        if (child.nodeType === Node.ELEMENT_NODE) {
          if (child.getAttribute(PHX_COMPONENT)) {
            return [hasNodes, true];
          }
          child.setAttribute(PHX_COMPONENT, cid);
          if (!child.id) {
            child.id = `${this.parentViewId()}-${cid}-${i}`;
          }
          if (skip) {
            child.setAttribute(PHX_SKIP, "");
            child.innerHTML = "";
          }
          return [true, hasComponents];
        } else {
          if (child.nodeValue.trim() !== "") {
            logError(`only HTML element tags are allowed at the root of components.

got: "${child.nodeValue.trim()}"

within:
`, template.innerHTML.trim());
            child.replaceWith(this.createSpan(child.nodeValue, cid));
            return [true, hasComponents];
          } else {
            child.remove();
            return [hasNodes, hasComponents];
          }
        }
      }, [false, false]);
      if (!hasChildNodes && !hasChildComponents) {
        logError("expected at least one HTML element tag inside a component, but the component is empty:\n", template.innerHTML.trim());
        return this.createSpan("", cid).outerHTML;
      } else if (!hasChildNodes && hasChildComponents) {
        logError("expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.", template.innerHTML.trim());
        return template.innerHTML;
      } else {
        return template.innerHTML;
      }
    }
    createSpan(text, cid) {
      let span = document.createElement("span");
      span.innerText = text;
      span.setAttribute(PHX_COMPONENT, cid);
      return span;
    }
  };
  var viewHookID = 1;
  var ViewHook = class {
    static makeID() {
      return viewHookID++;
    }
    static elementID(el) {
      return el.phxHookId;
    }
    constructor(view, el, callbacks) {
      this.__view = view;
      this.__liveSocket = view.liveSocket;
      this.__callbacks = callbacks;
      this.__listeners = /* @__PURE__ */ new Set();
      this.__isDisconnected = false;
      this.el = el;
      this.el.phxHookId = this.constructor.makeID();
      for (let key in this.__callbacks) {
        this[key] = this.__callbacks[key];
      }
    }
    __mounted() {
      this.mounted && this.mounted();
    }
    __updated() {
      this.updated && this.updated();
    }
    __beforeUpdate() {
      this.beforeUpdate && this.beforeUpdate();
    }
    __destroyed() {
      this.destroyed && this.destroyed();
    }
    __reconnected() {
      if (this.__isDisconnected) {
        this.__isDisconnected = false;
        this.reconnected && this.reconnected();
      }
    }
    __disconnected() {
      this.__isDisconnected = true;
      this.disconnected && this.disconnected();
    }
    pushEvent(event, payload = {}, onReply = function() {
    }) {
      return this.__view.pushHookEvent(null, event, payload, onReply);
    }
    pushEventTo(phxTarget, event, payload = {}, onReply = function() {
    }) {
      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {
        return view.pushHookEvent(targetCtx, event, payload, onReply);
      });
    }
    handleEvent(event, callback) {
      let callbackRef = (customEvent, bypass) => bypass ? event : callback(customEvent.detail);
      window.addEventListener(`phx:${event}`, callbackRef);
      this.__listeners.add(callbackRef);
      return callbackRef;
    }
    removeHandleEvent(callbackRef) {
      let event = callbackRef(null, true);
      window.removeEventListener(`phx:${event}`, callbackRef);
      this.__listeners.delete(callbackRef);
    }
    upload(name, files) {
      return this.__view.dispatchUploads(name, files);
    }
    uploadTo(phxTarget, name, files) {
      return this.__view.withinTargets(phxTarget, (view) => view.dispatchUploads(name, files));
    }
    __cleanup__() {
      this.__listeners.forEach((callbackRef) => this.removeHandleEvent(callbackRef));
    }
  };
  var JS = {
    exec(eventType, phxEvent, view, sourceEl, defaults) {
      let [defaultKind, defaultArgs] = defaults || [null, {}];
      let commands = phxEvent.charAt(0) === "[" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];
      commands.forEach(([kind, args]) => {
        if (kind === defaultKind && defaultArgs.data) {
          args.data = Object.assign(args.data || {}, defaultArgs.data);
        }
        this.filterToEls(sourceEl, args).forEach((el) => {
          this[`exec_${kind}`](eventType, phxEvent, view, sourceEl, el, args);
        });
      });
    },
    isVisible(el) {
      return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);
    },
    exec_dispatch(eventType, phxEvent, view, sourceEl, el, { to, event, detail }) {
      dom_default.dispatchEvent(el, event, detail);
    },
    exec_push(eventType, phxEvent, view, sourceEl, el, args) {
      let { event, data, target, page_loading, loading, value } = args;
      let pushOpts = { loading, value, target, page_loading: !!page_loading };
      let targetSrc = eventType === "change" ? sourceEl.form : sourceEl;
      let phxTarget = target || targetSrc.getAttribute(view.binding("target")) || targetSrc;
      view.withinTargets(phxTarget, (targetView, targetCtx) => {
        if (eventType === "change") {
          let { newCid, _target, callback } = args;
          if (_target) {
            pushOpts._target = _target;
          }
          targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback);
        } else if (eventType === "submit") {
          targetView.submitForm(sourceEl, targetCtx, event || phxEvent, pushOpts);
        } else {
          targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data, pushOpts);
        }
      });
    },
    exec_add_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {
      this.addOrRemoveClasses(el, names, [], transition, time, view);
    },
    exec_remove_class(eventType, phxEvent, view, sourceEl, el, { names, transition, time }) {
      this.addOrRemoveClasses(el, [], names, transition, time, view);
    },
    exec_transition(eventType, phxEvent, view, sourceEl, el, { time, transition }) {
      let [transition_start, running, transition_end] = transition;
      let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(running), []);
      let onDone = () => this.addOrRemoveClasses(el, transition_end, transition_start.concat(running));
      view.transition(time, onStart, onDone);
    },
    exec_toggle(eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time }) {
      this.toggle(eventType, view, el, display, ins, outs, time);
    },
    exec_show(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.show(eventType, view, el, display, transition, time);
    },
    exec_hide(eventType, phxEvent, view, sourceEl, el, { display, transition, time }) {
      this.hide(eventType, view, el, display, transition, time);
    },
    exec_set_attr(eventType, phxEvent, view, sourceEl, el, { attr: [attr, val] }) {
      this.setOrRemoveAttrs(el, [[attr, val]], []);
    },
    exec_remove_attr(eventType, phxEvent, view, sourceEl, el, { attr }) {
      this.setOrRemoveAttrs(el, [], [attr]);
    },
    show(eventType, view, el, display, transition, time) {
      if (!this.isVisible(el)) {
        this.toggle(eventType, view, el, display, transition, null, time);
      }
    },
    hide(eventType, view, el, display, transition, time) {
      if (this.isVisible(el)) {
        this.toggle(eventType, view, el, display, null, transition, time);
      }
    },
    toggle(eventType, view, el, display, ins, outs, time) {
      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];
      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];
      if (inClasses.length > 0 || outClasses.length > 0) {
        if (this.isVisible(el)) {
          let onStart = () => {
            this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, outClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:hide-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          if (eventType === "remove") {
            return;
          }
          let onStart = () => {
            this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, inClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, inEndClasses, inStartClasses));
            });
          };
          el.dispatchEvent(new Event("phx:show-start"));
          view.transition(time, onStart, () => {
            this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      } else {
        if (this.isVisible(el)) {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:hide-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:show-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = display || "block");
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      }
    },
    addOrRemoveClasses(el, adds, removes, transition, time, view) {
      let [transition_run, transition_start, transition_end] = transition || [[], [], []];
      if (transition_run.length > 0) {
        let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(transition_run), []);
        let onDone = () => this.addOrRemoveClasses(el, adds.concat(transition_end), removes.concat(transition_run).concat(transition_start));
        return view.transition(time, onStart, onDone);
      }
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let keepAdds = adds.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let keepRemoves = removes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        let newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);
        let newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);
        dom_default.putSticky(el, "classes", (currentEl) => {
          currentEl.classList.remove(...newRemoves);
          currentEl.classList.add(...newAdds);
          return [newAdds, newRemoves];
        });
      });
    },
    setOrRemoveAttrs(el, sets, removes) {
      let [prevSets, prevRemoves] = dom_default.getSticky(el, "attrs", [[], []]);
      let keepSets = sets.filter(([attr, _val]) => !this.hasSet(prevSets, attr) && !el.attributes.getNamedItem(attr));
      let keepRemoves = removes.filter((attr) => prevRemoves.indexOf(attr) < 0 && el.attributes.getNamedItem(attr));
      let newSets = prevSets.filter(([attr, _val]) => removes.indexOf(attr) < 0).concat(keepSets);
      let newRemoves = prevRemoves.filter((attr) => !this.hasSet(sets, attr)).concat(keepRemoves);
      dom_default.putSticky(el, "attrs", (currentEl) => {
        newRemoves.forEach((attr) => currentEl.removeAttribute(attr));
        newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));
        return [newSets, newRemoves];
      });
    },
    hasSet(sets, nameSearch) {
      return sets.find(([name, val]) => name === nameSearch);
    },
    hasAllClasses(el, classes) {
      return classes.every((name) => el.classList.contains(name));
    },
    isToggledOut(el, outClasses) {
      return !this.isVisible(el) || this.hasAllClasses(el, outClasses);
    },
    filterToEls(sourceEl, { to }) {
      return to ? dom_default.all(document, to) : [sourceEl];
    }
  };
  var js_default = JS;
  var serializeForm = (form, meta = {}) => {
    let formData = new FormData(form);
    let toRemove = [];
    formData.forEach((val, key, _index) => {
      if (val instanceof File) {
        toRemove.push(key);
      }
    });
    toRemove.forEach((key) => formData.delete(key));
    let params = new URLSearchParams();
    for (let [key, val] of formData.entries()) {
      params.append(key, val);
    }
    for (let metaKey in meta) {
      params.append(metaKey, meta[metaKey]);
    }
    return params.toString();
  };
  var View = class {
    constructor(el, liveSocket2, parentView, flash) {
      this.liveSocket = liveSocket2;
      this.flash = flash;
      this.parent = parentView;
      this.root = parentView ? parentView.root : this;
      this.el = el;
      this.id = this.el.id;
      this.ref = 0;
      this.childJoins = 0;
      this.loaderTimer = null;
      this.pendingDiffs = [];
      this.pruningCIDs = [];
      this.redirect = false;
      this.href = null;
      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;
      this.joinPending = true;
      this.destroyed = false;
      this.joinCallback = function(onDone) {
        onDone && onDone();
      };
      this.stopCallback = function() {
      };
      this.pendingJoinOps = this.parent ? null : [];
      this.viewHooks = {};
      this.uploaders = {};
      this.formSubmits = [];
      this.children = this.parent ? null : {};
      this.root.children[this.id] = {};
      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {
        return {
          redirect: this.redirect ? this.href : void 0,
          url: this.redirect ? void 0 : this.href || void 0,
          params: this.connectParams(),
          session: this.getSession(),
          static: this.getStatic(),
          flash: this.flash
        };
      });
      this.showLoader(this.liveSocket.loaderTimeout);
      this.bindChannel();
    }
    setHref(href) {
      this.href = href;
    }
    setRedirect(href) {
      this.redirect = true;
      this.href = href;
    }
    isMain() {
      return this.el.getAttribute(PHX_MAIN) !== null;
    }
    connectParams() {
      let params = this.liveSocket.params(this.el);
      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === "string");
      if (manifest.length > 0) {
        params["_track_static"] = manifest;
      }
      params["_mounts"] = this.joinCount;
      return params;
    }
    isConnected() {
      return this.channel.canPush();
    }
    getSession() {
      return this.el.getAttribute(PHX_SESSION);
    }
    getStatic() {
      let val = this.el.getAttribute(PHX_STATIC);
      return val === "" ? null : val;
    }
    destroy(callback = function() {
    }) {
      this.destroyAllChildren();
      this.destroyed = true;
      delete this.root.children[this.id];
      if (this.parent) {
        delete this.root.children[this.parent.id][this.id];
      }
      clearTimeout(this.loaderTimer);
      let onFinished = () => {
        callback();
        for (let id in this.viewHooks) {
          this.destroyHook(this.viewHooks[id]);
        }
      };
      dom_default.markPhxChildDestroyed(this.el);
      this.log("destroyed", () => ["the child has been removed from the parent"]);
      this.channel.leave().receive("ok", onFinished).receive("error", onFinished).receive("timeout", onFinished);
    }
    setContainerClasses(...classes) {
      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
      this.el.classList.add(...classes);
    }
    showLoader(timeout) {
      clearTimeout(this.loaderTimer);
      if (timeout) {
        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);
      } else {
        for (let id in this.viewHooks) {
          this.viewHooks[id].__disconnected();
        }
        this.setContainerClasses(PHX_DISCONNECTED_CLASS);
      }
    }
    hideLoader() {
      clearTimeout(this.loaderTimer);
      this.setContainerClasses(PHX_CONNECTED_CLASS);
    }
    triggerReconnected() {
      for (let id in this.viewHooks) {
        this.viewHooks[id].__reconnected();
      }
    }
    log(kind, msgCallback) {
      this.liveSocket.log(this, kind, msgCallback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.liveSocket.transition(time, onStart, onDone);
    }
    withinTargets(phxTarget, callback) {
      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {
        return this.liveSocket.owner(phxTarget, (view) => callback(view, phxTarget));
      }
      if (isCid(phxTarget)) {
        let targets = dom_default.findComponentNodeList(this.el, phxTarget);
        if (targets.length === 0) {
          logError(`no component found matching phx-target of ${phxTarget}`);
        } else {
          callback(this, parseInt(phxTarget));
        }
      } else {
        let targets = Array.from(document.querySelectorAll(phxTarget));
        if (targets.length === 0) {
          logError(`nothing found matching the phx-target selector "${phxTarget}"`);
        }
        targets.forEach((target) => this.liveSocket.owner(target, (view) => callback(view, target)));
      }
    }
    applyDiff(type, rawDiff, callback) {
      this.log(type, () => ["", clone(rawDiff)]);
      let { diff, reply, events, title } = Rendered.extract(rawDiff);
      if (title) {
        dom_default.putTitle(title);
      }
      callback({ diff, reply, events });
      return reply;
    }
    onJoin(resp) {
      let { rendered, container } = resp;
      if (container) {
        let [tag, attrs] = container;
        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);
      }
      this.childJoins = 0;
      this.joinPending = true;
      this.flash = null;
      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);
      this.applyDiff("mount", rendered, ({ diff, events }) => {
        this.rendered = new Rendered(this.id, diff);
        let html = this.renderContainer(null, "join");
        this.dropPendingRefs();
        let forms = this.formsForRecovery(html);
        this.joinCount++;
        if (forms.length > 0) {
          forms.forEach(([form, newForm, newCid], i) => {
            this.pushFormRecovery(form, newCid, (resp2) => {
              if (i === forms.length - 1) {
                this.onJoinComplete(resp2, html, events);
              }
            });
          });
        } else {
          this.onJoinComplete(resp, html, events);
        }
      });
    }
    dropPendingRefs() {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}]`, (el) => {
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
      });
    }
    onJoinComplete({ live_patch }, html, events) {
      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {
        return this.applyJoinPatch(live_patch, html, events);
      }
      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter((toEl) => {
        let fromEl = toEl.id && this.el.querySelector(`[id="${toEl.id}"]`);
        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);
        if (phxStatic) {
          toEl.setAttribute(PHX_STATIC, phxStatic);
        }
        return this.joinChild(toEl);
      });
      if (newChildren.length === 0) {
        if (this.parent) {
          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
          this.applyJoinPatch(live_patch, html, events);
        }
      } else {
        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);
      }
    }
    attachTrueDocEl() {
      this.el = dom_default.byId(this.id);
      this.el.setAttribute(PHX_ROOT_ID, this.root.id);
    }
    applyJoinPatch(live_patch, html, events) {
      this.attachTrueDocEl();
      let patch = new DOMPatch(this, this.el, this.id, html, null);
      patch.markPrunableContentForRemoval();
      this.performPatch(patch, false);
      this.joinNewChildren();
      dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, (hookEl) => {
        let hook = this.addHook(hookEl);
        if (hook) {
          hook.__mounted();
        }
      });
      this.joinPending = false;
      this.liveSocket.dispatchEvents(events);
      this.applyPendingUpdates();
      if (live_patch) {
        let { kind, to } = live_patch;
        this.liveSocket.historyPatch(to, kind);
      }
      this.hideLoader();
      if (this.joinCount > 1) {
        this.triggerReconnected();
      }
      this.stopCallback();
    }
    triggerBeforeUpdateHook(fromEl, toEl) {
      this.liveSocket.triggerDOM("onBeforeElUpdated", [fromEl, toEl]);
      let hook = this.getHook(fromEl);
      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));
      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {
        hook.__beforeUpdate();
        return hook;
      }
    }
    performPatch(patch, pruneCids) {
      let removedEls = [];
      let phxChildrenAdded = false;
      let updatedHookIds = /* @__PURE__ */ new Set();
      patch.after("added", (el) => {
        this.liveSocket.triggerDOM("onNodeAdded", [el]);
        let newHook = this.addHook(el);
        if (newHook) {
          newHook.__mounted();
        }
      });
      patch.after("phxChildAdded", (el) => {
        if (dom_default.isPhxSticky(el)) {
          this.liveSocket.joinRootViews();
        } else {
          phxChildrenAdded = true;
        }
      });
      patch.before("updated", (fromEl, toEl) => {
        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);
        if (hook) {
          updatedHookIds.add(fromEl.id);
        }
      });
      patch.after("updated", (el) => {
        if (updatedHookIds.has(el.id)) {
          this.getHook(el).__updated();
        }
      });
      patch.after("discarded", (el) => {
        if (el.nodeType === Node.ELEMENT_NODE) {
          removedEls.push(el);
        }
      });
      patch.after("transitionsDiscarded", (els) => this.afterElementsRemoved(els, pruneCids));
      patch.perform();
      this.afterElementsRemoved(removedEls, pruneCids);
      return phxChildrenAdded;
    }
    afterElementsRemoved(elements, pruneCids) {
      let destroyedCIDs = [];
      elements.forEach((parent) => {
        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);
        components.concat(parent).forEach((el) => {
          let cid = this.componentID(el);
          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {
            destroyedCIDs.push(cid);
          }
          let hook = this.getHook(el);
          hook && this.destroyHook(hook);
        });
      });
      if (pruneCids) {
        this.maybePushComponentsDestroyed(destroyedCIDs);
      }
    }
    joinNewChildren() {
      dom_default.findPhxChildren(this.el, this.id).forEach((el) => this.joinChild(el));
    }
    getChildById(id) {
      return this.root.children[this.id][id];
    }
    getDescendentByEl(el) {
      if (el.id === this.id) {
        return this;
      } else {
        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];
      }
    }
    destroyDescendent(id) {
      for (let parentId in this.root.children) {
        for (let childId in this.root.children[parentId]) {
          if (childId === id) {
            return this.root.children[parentId][childId].destroy();
          }
        }
      }
    }
    joinChild(el) {
      let child = this.getChildById(el.id);
      if (!child) {
        let view = new View(el, this.liveSocket, this);
        this.root.children[this.id][view.id] = view;
        view.join();
        this.childJoins++;
        return true;
      }
    }
    isJoinPending() {
      return this.joinPending;
    }
    ackJoin(_child) {
      this.childJoins--;
      if (this.childJoins === 0) {
        if (this.parent) {
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
        }
      }
    }
    onAllChildJoinsComplete() {
      this.joinCallback(() => {
        this.pendingJoinOps.forEach(([view, op]) => {
          if (!view.isDestroyed()) {
            op();
          }
        });
        this.pendingJoinOps = [];
      });
    }
    update(diff, events) {
      if (this.isJoinPending() || this.liveSocket.hasPendingLink()) {
        return this.pendingDiffs.push({ diff, events });
      }
      this.rendered.mergeDiff(diff);
      let phxChildrenAdded = false;
      if (this.rendered.isComponentOnlyDiff(diff)) {
        this.liveSocket.time("component patch complete", () => {
          let parentCids = dom_default.findParentCIDs(this.el, this.rendered.componentCIDs(diff));
          parentCids.forEach((parentCID) => {
            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {
              phxChildrenAdded = true;
            }
          });
        });
      } else if (!isEmpty(diff)) {
        this.liveSocket.time("full patch complete", () => {
          let html = this.renderContainer(diff, "update");
          let patch = new DOMPatch(this, this.el, this.id, html, null);
          phxChildrenAdded = this.performPatch(patch, true);
        });
      }
      this.liveSocket.dispatchEvents(events);
      if (phxChildrenAdded) {
        this.joinNewChildren();
      }
    }
    renderContainer(diff, kind) {
      return this.liveSocket.time(`toString diff (${kind})`, () => {
        let tag = this.el.tagName;
        let cids = diff ? this.rendered.componentCIDs(diff).concat(this.pruningCIDs) : null;
        let html = this.rendered.toString(cids);
        return `<${tag}>${html}</${tag}>`;
      });
    }
    componentPatch(diff, cid) {
      if (isEmpty(diff))
        return false;
      let html = this.rendered.componentToString(cid);
      let patch = new DOMPatch(this, this.el, this.id, html, cid);
      let childrenAdded = this.performPatch(patch, true);
      return childrenAdded;
    }
    getHook(el) {
      return this.viewHooks[ViewHook.elementID(el)];
    }
    addHook(el) {
      if (ViewHook.elementID(el) || !el.getAttribute) {
        return;
      }
      let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));
      if (hookName && !this.ownsElement(el)) {
        return;
      }
      let callbacks = this.liveSocket.getHookCallbacks(hookName);
      if (callbacks) {
        if (!el.id) {
          logError(`no DOM ID for hook "${hookName}". Hooks require a unique ID on each element.`, el);
        }
        let hook = new ViewHook(this, el, callbacks);
        this.viewHooks[ViewHook.elementID(hook.el)] = hook;
        return hook;
      } else if (hookName !== null) {
        logError(`unknown hook found for "${hookName}"`, el);
      }
    }
    destroyHook(hook) {
      hook.__destroyed();
      hook.__cleanup__();
      delete this.viewHooks[ViewHook.elementID(hook.el)];
    }
    applyPendingUpdates() {
      this.pendingDiffs.forEach(({ diff, events }) => this.update(diff, events));
      this.pendingDiffs = [];
    }
    onChannel(event, cb) {
      this.liveSocket.onChannel(this.channel, event, (resp) => {
        if (this.isJoinPending()) {
          this.root.pendingJoinOps.push([this, () => cb(resp)]);
        } else {
          this.liveSocket.requestDOMUpdate(() => cb(resp));
        }
      });
    }
    bindChannel() {
      this.liveSocket.onChannel(this.channel, "diff", (rawDiff) => {
        this.liveSocket.requestDOMUpdate(() => {
          this.applyDiff("update", rawDiff, ({ diff, events }) => this.update(diff, events));
        });
      });
      this.onChannel("redirect", ({ to, flash }) => this.onRedirect({ to, flash }));
      this.onChannel("live_patch", (redir) => this.onLivePatch(redir));
      this.onChannel("live_redirect", (redir) => this.onLiveRedirect(redir));
      this.channel.onError((reason) => this.onError(reason));
      this.channel.onClose((reason) => this.onClose(reason));
    }
    destroyAllChildren() {
      for (let id in this.root.children[this.id]) {
        this.getChildById(id).destroy();
      }
    }
    onLiveRedirect(redir) {
      let { to, kind, flash } = redir;
      let url = this.expandURL(to);
      this.liveSocket.historyRedirect(url, kind, flash);
    }
    onLivePatch(redir) {
      let { to, kind } = redir;
      this.href = this.expandURL(to);
      this.liveSocket.historyPatch(to, kind);
    }
    expandURL(to) {
      return to.startsWith("/") ? `${window.location.protocol}//${window.location.host}${to}` : to;
    }
    onRedirect({ to, flash }) {
      this.liveSocket.redirect(to, flash);
    }
    isDestroyed() {
      return this.destroyed;
    }
    join(callback) {
      if (this.isMain()) {
        this.stopCallback = this.liveSocket.withPageLoading({ to: this.href, kind: "initial" });
      }
      this.joinCallback = (onDone) => {
        onDone = onDone || function() {
        };
        callback ? callback(this.joinCount, onDone) : onDone();
      };
      this.liveSocket.wrapPush(this, { timeout: false }, () => {
        return this.channel.join().receive("ok", (data) => {
          if (!this.isDestroyed()) {
            this.liveSocket.requestDOMUpdate(() => this.onJoin(data));
          }
        }).receive("error", (resp) => !this.isDestroyed() && this.onJoinError(resp)).receive("timeout", () => !this.isDestroyed() && this.onJoinError({ reason: "timeout" }));
      });
    }
    onJoinError(resp) {
      if (resp.reason === "unauthorized" || resp.reason === "stale") {
        this.log("error", () => ["unauthorized live_redirect. Falling back to page request", resp]);
        return this.onRedirect({ to: this.href });
      }
      if (resp.redirect || resp.live_redirect) {
        this.joinPending = false;
        this.channel.leave();
      }
      if (resp.redirect) {
        return this.onRedirect(resp.redirect);
      }
      if (resp.live_redirect) {
        return this.onLiveRedirect(resp.live_redirect);
      }
      this.log("error", () => ["unable to join", resp]);
      return this.liveSocket.reloadWithJitter(this);
    }
    onClose(reason) {
      if (this.isDestroyed()) {
        return;
      }
      if (this.isJoinPending() && document.visibilityState !== "hidden" || this.liveSocket.hasPendingLink() && reason !== "leave") {
        return this.liveSocket.reloadWithJitter(this);
      }
      this.destroyAllChildren();
      this.liveSocket.dropActiveElement(this);
      if (document.activeElement) {
        document.activeElement.blur();
      }
      if (this.liveSocket.isUnloaded()) {
        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);
      }
    }
    onError(reason) {
      this.onClose(reason);
      this.log("error", () => ["view crashed", reason]);
      if (!this.liveSocket.isUnloaded()) {
        this.displayError();
      }
    }
    displayError() {
      if (this.isMain()) {
        dom_default.dispatchEvent(window, "phx:page-loading-start", { to: this.href, kind: "error" });
      }
      this.showLoader();
      this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);
    }
    pushWithReply(refGenerator, event, payload, onReply = function() {
    }) {
      if (!this.isConnected()) {
        return;
      }
      let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];
      let onLoadingDone = function() {
      };
      if (opts.page_loading || el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {
        onLoadingDone = this.liveSocket.withPageLoading({ kind: "element", target: el });
      }
      if (typeof payload.cid !== "number") {
        delete payload.cid;
      }
      return this.liveSocket.wrapPush(this, { timeout: true }, () => {
        return this.channel.push(event, payload, PUSH_TIMEOUT).receive("ok", (resp) => {
          if (ref !== null) {
            this.undoRefs(ref);
          }
          let finish = (hookReply) => {
            if (resp.redirect) {
              this.onRedirect(resp.redirect);
            }
            if (resp.live_patch) {
              this.onLivePatch(resp.live_patch);
            }
            if (resp.live_redirect) {
              this.onLiveRedirect(resp.live_redirect);
            }
            onLoadingDone();
            onReply(resp, hookReply);
          };
          if (resp.diff) {
            this.liveSocket.requestDOMUpdate(() => {
              let hookReply = this.applyDiff("update", resp.diff, ({ diff, events }) => {
                this.update(diff, events);
              });
              finish(hookReply);
            });
          } else {
            finish(null);
          }
        });
      });
    }
    undoRefs(ref) {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.id}"][${PHX_REF}="${ref}"]`, (el) => {
        let disabledVal = el.getAttribute(PHX_DISABLED);
        el.removeAttribute(PHX_REF);
        el.removeAttribute(PHX_REF_SRC);
        if (el.getAttribute(PHX_READONLY) !== null) {
          el.readOnly = false;
          el.removeAttribute(PHX_READONLY);
        }
        if (disabledVal !== null) {
          el.disabled = disabledVal === "true" ? true : false;
          el.removeAttribute(PHX_DISABLED);
        }
        PHX_EVENT_CLASSES.forEach((className) => dom_default.removeClass(el, className));
        let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);
        if (disableRestore !== null) {
          el.innerText = disableRestore;
          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);
        }
        let toEl = dom_default.private(el, PHX_REF);
        if (toEl) {
          let hook = this.triggerBeforeUpdateHook(el, toEl);
          DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());
          if (hook) {
            hook.__updated();
          }
          dom_default.deletePrivate(el, PHX_REF);
        }
      });
    }
    putRef(elements, event, opts = {}) {
      let newRef = this.ref++;
      let disableWith = this.binding(PHX_DISABLE_WITH);
      if (opts.loading) {
        elements = elements.concat(dom_default.all(document, opts.loading));
      }
      elements.forEach((el) => {
        el.classList.add(`phx-${event}-loading`);
        el.setAttribute(PHX_REF, newRef);
        el.setAttribute(PHX_REF_SRC, this.el.id);
        let disableText = el.getAttribute(disableWith);
        if (disableText !== null) {
          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {
            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);
          }
          if (disableText !== "") {
            el.innerText = disableText;
          }
          el.setAttribute("disabled", "");
        }
      });
      return [newRef, elements, opts];
    }
    componentID(el) {
      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);
      return cid ? parseInt(cid) : null;
    }
    targetComponentID(target, targetCtx, opts = {}) {
      if (isCid(targetCtx)) {
        return targetCtx;
      }
      let cidOrSelector = target.getAttribute(this.binding("target"));
      if (isCid(cidOrSelector)) {
        return parseInt(cidOrSelector);
      } else if (targetCtx && (cidOrSelector !== null || opts.target)) {
        return this.closestComponentID(targetCtx);
      } else {
        return null;
      }
    }
    closestComponentID(targetCtx) {
      if (isCid(targetCtx)) {
        return targetCtx;
      } else if (targetCtx) {
        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), (el) => this.ownsElement(el) && this.componentID(el));
      } else {
        return null;
      }
    }
    pushHookEvent(targetCtx, event, payload, onReply) {
      if (!this.isConnected()) {
        this.log("hook", () => ["unable to push hook event. LiveView not connected", event, payload]);
        return false;
      }
      let [ref, els, opts] = this.putRef([], "hook");
      this.pushWithReply(() => [ref, els, opts], "event", {
        type: "hook",
        event,
        value: payload,
        cid: this.closestComponentID(targetCtx)
      }, (resp, reply) => onReply(reply, ref));
      return ref;
    }
    extractMeta(el, meta, value) {
      let prefix = this.binding("value-");
      for (let i = 0; i < el.attributes.length; i++) {
        if (!meta) {
          meta = {};
        }
        let name = el.attributes[i].name;
        if (name.startsWith(prefix)) {
          meta[name.replace(prefix, "")] = el.getAttribute(name);
        }
      }
      if (el.value !== void 0) {
        if (!meta) {
          meta = {};
        }
        meta.value = el.value;
        if (el.tagName === "INPUT" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {
          delete meta.value;
        }
      }
      if (value) {
        if (!meta) {
          meta = {};
        }
        for (let key in value) {
          meta[key] = value[key];
        }
      }
      return meta;
    }
    pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}) {
      this.pushWithReply(() => this.putRef([el], type, opts), "event", {
        type,
        event: phxEvent,
        value: this.extractMeta(el, meta, opts.value),
        cid: this.targetComponentID(el, targetCtx, opts)
      });
    }
    pushFileProgress(fileEl, entryRef, progress, onReply = function() {
    }) {
      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {
        view.pushWithReply(null, "progress", {
          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),
          ref: fileEl.getAttribute(PHX_UPLOAD_REF),
          entry_ref: entryRef,
          progress,
          cid: view.targetComponentID(fileEl.form, targetCtx)
        }, onReply);
      });
    }
    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {
      let uploads;
      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx);
      let refGenerator = () => this.putRef([inputEl, inputEl.form], "change", opts);
      let formData = serializeForm(inputEl.form, { _target: opts._target });
      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {
        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));
      }
      uploads = LiveUploader.serializeUploads(inputEl);
      let event = {
        type: "form",
        event: phxEvent,
        value: formData,
        uploads,
        cid
      };
      this.pushWithReply(refGenerator, "event", event, (resp) => {
        dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR));
        if (dom_default.isUploadInput(inputEl) && inputEl.getAttribute("data-phx-auto-upload") !== null) {
          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {
            let [ref, _els] = refGenerator();
            this.uploadFiles(inputEl.form, targetCtx, ref, cid, (_uploads) => {
              callback && callback(resp);
              this.triggerAwaitingSubmit(inputEl.form);
            });
          }
        } else {
          callback && callback(resp);
        }
      });
    }
    triggerAwaitingSubmit(formEl) {
      let awaitingSubmit = this.getScheduledSubmit(formEl);
      if (awaitingSubmit) {
        let [_el, _ref, _opts, callback] = awaitingSubmit;
        this.cancelSubmit(formEl);
        callback();
      }
    }
    getScheduledSubmit(formEl) {
      return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));
    }
    scheduleSubmit(formEl, ref, opts, callback) {
      if (this.getScheduledSubmit(formEl)) {
        return true;
      }
      this.formSubmits.push([formEl, ref, opts, callback]);
    }
    cancelSubmit(formEl) {
      this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {
        if (el.isSameNode(formEl)) {
          this.undoRefs(ref);
          return false;
        } else {
          return true;
        }
      });
    }
    pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply) {
      let filterIgnored = (el) => {
        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);
        return !(userIgnored || closestPhxBinding(el, "data-phx-update=ignore", el.form));
      };
      let filterDisables = (el) => {
        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));
      };
      let filterButton = (el) => el.tagName == "BUTTON";
      let filterInput = (el) => ["INPUT", "TEXTAREA", "SELECT"].includes(el.tagName);
      let refGenerator = () => {
        let formElements = Array.from(formEl.elements);
        let disables = formElements.filter(filterDisables);
        let buttons = formElements.filter(filterButton).filter(filterIgnored);
        let inputs = formElements.filter(filterInput).filter(filterIgnored);
        buttons.forEach((button) => {
          button.setAttribute(PHX_DISABLED, button.disabled);
          button.disabled = true;
        });
        inputs.forEach((input) => {
          input.setAttribute(PHX_READONLY, input.readOnly);
          input.readOnly = true;
          if (input.files) {
            input.setAttribute(PHX_DISABLED, input.disabled);
            input.disabled = true;
          }
        });
        formEl.setAttribute(this.binding(PHX_PAGE_LOADING), "");
        return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), "submit", opts);
      };
      let cid = this.targetComponentID(formEl, targetCtx);
      if (LiveUploader.hasUploadsInProgress(formEl)) {
        let [ref, _els] = refGenerator();
        let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply);
        return this.scheduleSubmit(formEl, ref, opts, push);
      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
        let [ref, els] = refGenerator();
        let proxyRefGen = () => [ref, els, opts];
        this.uploadFiles(formEl, targetCtx, ref, cid, (_uploads) => {
          let formData = serializeForm(formEl, {});
          this.pushWithReply(proxyRefGen, "event", {
            type: "form",
            event: phxEvent,
            value: formData,
            cid
          }, onReply);
        });
      } else {
        let formData = serializeForm(formEl);
        this.pushWithReply(refGenerator, "event", {
          type: "form",
          event: phxEvent,
          value: formData,
          cid
        }, onReply);
      }
    }
    uploadFiles(formEl, targetCtx, ref, cid, onComplete) {
      let joinCountAtUpload = this.joinCount;
      let inputEls = LiveUploader.activeFileInputs(formEl);
      let numFileInputsInProgress = inputEls.length;
      inputEls.forEach((inputEl) => {
        let uploader = new LiveUploader(inputEl, this, () => {
          numFileInputsInProgress--;
          if (numFileInputsInProgress === 0) {
            onComplete();
          }
        });
        this.uploaders[inputEl] = uploader;
        let entries = uploader.entries().map((entry) => entry.toPreflightPayload());
        let payload = {
          ref: inputEl.getAttribute(PHX_UPLOAD_REF),
          entries,
          cid: this.targetComponentID(inputEl.form, targetCtx)
        };
        this.log("upload", () => ["sending preflight request", payload]);
        this.pushWithReply(null, "allow_upload", payload, (resp) => {
          this.log("upload", () => ["got preflight response", resp]);
          if (resp.error) {
            this.undoRefs(ref);
            let [entry_ref, reason] = resp.error;
            this.log("upload", () => [`error for entry ${entry_ref}`, reason]);
          } else {
            let onError = (callback) => {
              this.channel.onError(() => {
                if (this.joinCount === joinCountAtUpload) {
                  callback();
                }
              });
            };
            uploader.initAdapterUpload(resp, onError, this.liveSocket);
          }
        });
      });
    }
    dispatchUploads(name, filesOrBlobs) {
      let inputs = dom_default.findUploadInputs(this.el).filter((el) => el.name === name);
      if (inputs.length === 0) {
        logError(`no live file inputs found matching the name "${name}"`);
      } else if (inputs.length > 1) {
        logError(`duplicate live file inputs found matching the name "${name}"`);
      } else {
        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, { files: filesOrBlobs });
      }
    }
    pushFormRecovery(form, newCid, callback) {
      this.liveSocket.withinOwners(form, (view, targetCtx) => {
        let input = form.elements[0];
        let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding("change"));
        js_default.exec("change", phxEvent, view, input, ["push", { _target: input.name, newCid, callback }]);
      });
    }
    pushLinkPatch(href, targetEl, callback) {
      let linkRef = this.liveSocket.setPendingLink(href);
      let refGen = targetEl ? () => this.putRef([targetEl], "click") : null;
      let fallback = () => this.liveSocket.redirect(window.location.href);
      let push = this.pushWithReply(refGen, "live_patch", { url: href }, (resp) => {
        this.liveSocket.requestDOMUpdate(() => {
          if (resp.link_redirect) {
            this.liveSocket.replaceMain(href, null, callback, linkRef);
          } else {
            if (this.liveSocket.commitPendingLink(linkRef)) {
              this.href = href;
            }
            this.applyPendingUpdates();
            callback && callback(linkRef);
          }
        });
      });
      if (push) {
        push.receive("timeout", fallback);
      } else {
        fallback();
      }
    }
    formsForRecovery(html) {
      if (this.joinCount === 0) {
        return [];
      }
      let phxChange = this.binding("change");
      let template = document.createElement("template");
      template.innerHTML = html;
      return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id && this.ownsElement(form)).filter((form) => form.elements.length > 0).filter((form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== "ignore").map((form) => {
        let newForm = template.content.querySelector(`form[id="${form.id}"][${phxChange}="${form.getAttribute(phxChange)}"]`);
        if (newForm) {
          return [form, newForm, this.targetComponentID(newForm)];
        } else {
          return [form, null, null];
        }
      }).filter(([form, newForm, newCid]) => newForm);
    }
    maybePushComponentsDestroyed(destroyedCIDs) {
      let willDestroyCIDs = destroyedCIDs.filter((cid) => {
        return dom_default.findComponentNodeList(this.el, cid).length === 0;
      });
      if (willDestroyCIDs.length > 0) {
        this.pruningCIDs.push(...willDestroyCIDs);
        this.pushWithReply(null, "cids_will_destroy", { cids: willDestroyCIDs }, () => {
          this.pruningCIDs = this.pruningCIDs.filter((cid) => willDestroyCIDs.indexOf(cid) !== -1);
          let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {
            return dom_default.findComponentNodeList(this.el, cid).length === 0;
          });
          if (completelyDestroyCIDs.length > 0) {
            this.pushWithReply(null, "cids_destroyed", { cids: completelyDestroyCIDs }, (resp) => {
              this.rendered.pruneCIDs(resp.cids);
            });
          }
        });
      }
    }
    ownsElement(el) {
      return el.getAttribute(PHX_PARENT_ID) === this.id || maybe(el.closest(PHX_VIEW_SELECTOR), (node) => node.id) === this.id;
    }
    submitForm(form, targetCtx, phxEvent, opts = {}) {
      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);
      let phxFeedback = this.liveSocket.binding(PHX_FEEDBACK_FOR);
      let inputs = Array.from(form.elements);
      this.liveSocket.blurActiveElement(this);
      this.pushFormSubmit(form, targetCtx, phxEvent, opts, () => {
        inputs.forEach((input) => dom_default.showError(input, phxFeedback));
        this.liveSocket.restorePreviouslyActiveFocus();
      });
    }
    binding(kind) {
      return this.liveSocket.binding(kind);
    }
  };
  var LiveSocket = class {
    constructor(url, phxSocket, opts = {}) {
      this.unloaded = false;
      if (!phxSocket || phxSocket.constructor.name === "Object") {
        throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
      }
      this.socket = new phxSocket(url, opts);
      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;
      this.opts = opts;
      this.params = closure2(opts.params || {});
      this.viewLogger = opts.viewLogger;
      this.metadataCallbacks = opts.metadata || {};
      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});
      this.activeElement = null;
      this.prevActive = null;
      this.silenced = false;
      this.main = null;
      this.linkRef = 1;
      this.clickRef = 1;
      this.roots = {};
      this.href = window.location.href;
      this.pendingLink = null;
      this.currentLocation = clone(window.location);
      this.hooks = opts.hooks || {};
      this.uploaders = opts.uploaders || {};
      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;
      this.maxReloads = opts.maxReloads || MAX_RELOADS;
      this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;
      this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;
      this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;
      this.localStorage = opts.localStorage || window.localStorage;
      this.sessionStorage = opts.sessionStorage || window.sessionStorage;
      this.boundTopLevelEvents = false;
      this.domCallbacks = Object.assign({ onNodeAdded: closure2(), onBeforeElUpdated: closure2() }, opts.dom || {});
      this.transitions = new TransitionSet();
      window.addEventListener("pagehide", (_e) => {
        this.unloaded = true;
      });
      this.socket.onOpen(() => {
        if (this.isUnloaded()) {
          window.location.reload();
        }
      });
    }
    isProfileEnabled() {
      return this.sessionStorage.getItem(PHX_LV_PROFILE) === "true";
    }
    isDebugEnabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "true";
    }
    enableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "true");
    }
    enableProfiling() {
      this.sessionStorage.setItem(PHX_LV_PROFILE, "true");
    }
    disableDebug() {
      this.sessionStorage.removeItem(PHX_LV_DEBUG);
    }
    disableProfiling() {
      this.sessionStorage.removeItem(PHX_LV_PROFILE);
    }
    enableLatencySim(upperBoundMs) {
      this.enableDebug();
      console.log("latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable");
      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);
    }
    disableLatencySim() {
      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);
    }
    getLatencySim() {
      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);
      return str ? parseInt(str) : null;
    }
    getSocket() {
      return this.socket;
    }
    connect() {
      let doConnect = () => {
        if (this.joinRootViews()) {
          this.bindTopLevelEvents();
          this.socket.connect();
        }
      };
      if (["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0) {
        doConnect();
      } else {
        document.addEventListener("DOMContentLoaded", () => doConnect());
      }
    }
    disconnect(callback) {
      this.socket.disconnect(callback);
    }
    execJS(el, encodedJS, eventType = null) {
      this.owner(el, (view) => js_default.exec(eventType, encodedJS, view, el));
    }
    triggerDOM(kind, args) {
      this.domCallbacks[kind](...args);
    }
    time(name, func) {
      if (!this.isProfileEnabled() || !console.time) {
        return func();
      }
      console.time(name);
      let result = func();
      console.timeEnd(name);
      return result;
    }
    log(view, kind, msgCallback) {
      if (this.viewLogger) {
        let [msg, obj] = msgCallback();
        this.viewLogger(view, kind, msg, obj);
      } else if (this.isDebugEnabled()) {
        let [msg, obj] = msgCallback();
        debug(view, kind, msg, obj);
      }
    }
    requestDOMUpdate(callback) {
      this.transitions.after(callback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.transitions.addTransition(time, onStart, onDone);
    }
    onChannel(channel, event, cb) {
      channel.on(event, (data) => {
        let latency = this.getLatencySim();
        if (!latency) {
          cb(data);
        } else {
          console.log(`simulating ${latency}ms of latency from server to client`);
          setTimeout(() => cb(data), latency);
        }
      });
    }
    wrapPush(view, opts, push) {
      let latency = this.getLatencySim();
      let oldJoinCount = view.joinCount;
      if (!latency) {
        if (opts.timeout) {
          return push().receive("timeout", () => {
            if (view.joinCount === oldJoinCount && !view.isDestroyed()) {
              this.reloadWithJitter(view, () => {
                this.log(view, "timeout", () => ["received timeout while communicating with server. Falling back to hard refresh for recovery"]);
              });
            }
          });
        } else {
          return push();
        }
      }
      console.log(`simulating ${latency}ms of latency from client to server`);
      let fakePush = {
        receives: [],
        receive(kind, cb) {
          this.receives.push([kind, cb]);
        }
      };
      setTimeout(() => {
        if (view.isDestroyed()) {
          return;
        }
        fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());
      }, latency);
      return fakePush;
    }
    reloadWithJitter(view, log) {
      view.destroy();
      this.disconnect();
      let minMs = this.reloadJitterMin;
      let maxMs = this.reloadJitterMax;
      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, (count) => count + 1);
      log ? log() : this.log(view, "join", () => [`encountered ${tries} consecutive reloads`]);
      if (tries > this.maxReloads) {
        this.log(view, "join", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);
        afterMs = this.failsafeJitter;
      }
      setTimeout(() => {
        if (this.hasPendingLink()) {
          window.location = this.pendingLink;
        } else {
          window.location.reload();
        }
      }, afterMs);
    }
    getHookCallbacks(name) {
      return name && name.startsWith("Phoenix.") ? hooks_default[name.split(".")[1]] : this.hooks[name];
    }
    isUnloaded() {
      return this.unloaded;
    }
    isConnected() {
      return this.socket.isConnected();
    }
    getBindingPrefix() {
      return this.bindingPrefix;
    }
    binding(kind) {
      return `${this.getBindingPrefix()}${kind}`;
    }
    channel(topic, params) {
      return this.socket.channel(topic, params);
    }
    joinRootViews() {
      let rootsFound = false;
      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, (rootEl) => {
        if (!this.getRootById(rootEl.id)) {
          let view = this.newRootView(rootEl);
          view.setHref(this.getHref());
          view.join();
          if (rootEl.getAttribute(PHX_MAIN)) {
            this.main = view;
          }
        }
        rootsFound = true;
      });
      return rootsFound;
    }
    redirect(to, flash) {
      this.disconnect();
      browser_default.redirect(to, flash);
    }
    replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {
      let oldMainEl = this.main.el;
      let newMainEl = dom_default.cloneNode(oldMainEl, "");
      this.main.showLoader(this.loaderTimeout);
      this.main.destroy();
      this.main = this.newRootView(newMainEl, flash);
      this.main.setRedirect(href);
      this.transitionRemoves();
      this.main.join((joinCount, onDone) => {
        if (joinCount === 1 && this.commitPendingLink(linkRef)) {
          this.requestDOMUpdate(() => {
            dom_default.findPhxSticky(document).forEach((el) => newMainEl.appendChild(el));
            oldMainEl.replaceWith(newMainEl);
            callback && callback();
            onDone();
          });
        }
      });
    }
    transitionRemoves(elements) {
      let removeAttr = this.binding("remove");
      elements = elements || dom_default.all(document, `[${removeAttr}]`);
      elements.forEach((el) => {
        if (document.body.contains(el)) {
          this.execJS(el, el.getAttribute(removeAttr), "remove");
        }
      });
    }
    isPhxView(el) {
      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;
    }
    newRootView(el, flash) {
      let view = new View(el, this, null, flash);
      this.roots[view.id] = view;
      return view;
    }
    owner(childEl, callback) {
      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), (el) => this.getViewByEl(el)) || this.main;
      if (view) {
        callback(view);
      }
    }
    withinOwners(childEl, callback) {
      this.owner(childEl, (view) => callback(view, childEl));
    }
    getViewByEl(el) {
      let rootId = el.getAttribute(PHX_ROOT_ID);
      return maybe(this.getRootById(rootId), (root) => root.getDescendentByEl(el));
    }
    getRootById(id) {
      return this.roots[id];
    }
    destroyAllViews() {
      for (let id in this.roots) {
        this.roots[id].destroy();
        delete this.roots[id];
      }
    }
    destroyViewByEl(el) {
      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));
      if (root && root.id === el.id) {
        root.destroy();
        delete this.roots[root.id];
      } else if (root) {
        root.destroyDescendent(el.id);
      }
    }
    setActiveElement(target) {
      if (this.activeElement === target) {
        return;
      }
      this.activeElement = target;
      let cancel = () => {
        if (target === this.activeElement) {
          this.activeElement = null;
        }
        target.removeEventListener("mouseup", this);
        target.removeEventListener("touchend", this);
      };
      target.addEventListener("mouseup", cancel);
      target.addEventListener("touchend", cancel);
    }
    getActiveElement() {
      if (document.activeElement === document.body) {
        return this.activeElement || document.activeElement;
      } else {
        return document.activeElement || document.body;
      }
    }
    dropActiveElement(view) {
      if (this.prevActive && view.ownsElement(this.prevActive)) {
        this.prevActive = null;
      }
    }
    restorePreviouslyActiveFocus() {
      if (this.prevActive && this.prevActive !== document.body) {
        this.prevActive.focus();
      }
    }
    blurActiveElement() {
      this.prevActive = this.getActiveElement();
      if (this.prevActive !== document.body) {
        this.prevActive.blur();
      }
    }
    bindTopLevelEvents() {
      if (this.boundTopLevelEvents) {
        return;
      }
      this.boundTopLevelEvents = true;
      this.socket.onClose((event) => {
        if (event.code === 1e3 && this.main) {
          this.reloadWithJitter(this.main);
        }
      });
      document.body.addEventListener("click", function() {
      });
      window.addEventListener("pageshow", (e) => {
        if (e.persisted) {
          this.getSocket().disconnect();
          this.withPageLoading({ to: window.location.href, kind: "redirect" });
          window.location.reload();
        }
      }, true);
      this.bindNav();
      this.bindClicks();
      this.bindForms();
      this.bind({ keyup: "keyup", keydown: "keydown" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));
        let pressedKey = e.key && e.key.toLowerCase();
        if (matchKey && matchKey.toLowerCase() !== pressedKey) {
          return;
        }
        let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
        js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
      });
      this.bind({ blur: "focusout", focus: "focusin" }, (e, type, view, targetEl, phxEvent, eventTarget) => {
        if (!eventTarget) {
          let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      this.bind({ blur: "blur", focus: "focus" }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {
        if (phxTarget === "window") {
          let data = this.eventMeta(type, e, targetEl);
          js_default.exec(type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      window.addEventListener("dragover", (e) => e.preventDefault());
      window.addEventListener("drop", (e) => {
        e.preventDefault();
        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), (trueTarget) => {
          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));
        });
        let dropTarget = dropTargetId && document.getElementById(dropTargetId);
        let files = Array.from(e.dataTransfer.files || []);
        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {
          return;
        }
        LiveUploader.trackFiles(dropTarget, files);
        dropTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
      this.on(PHX_TRACK_UPLOADS, (e) => {
        let uploadTarget = e.target;
        if (!dom_default.isUploadInput(uploadTarget)) {
          return;
        }
        let files = Array.from(e.detail.files || []).filter((f) => f instanceof File || f instanceof Blob);
        LiveUploader.trackFiles(uploadTarget, files);
        uploadTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
    }
    eventMeta(eventName, e, targetEl) {
      let callback = this.metadataCallbacks[eventName];
      return callback ? callback(e, targetEl) : {};
    }
    setPendingLink(href) {
      this.linkRef++;
      this.pendingLink = href;
      return this.linkRef;
    }
    commitPendingLink(linkRef) {
      if (this.linkRef !== linkRef) {
        return false;
      } else {
        this.href = this.pendingLink;
        this.pendingLink = null;
        return true;
      }
    }
    getHref() {
      return this.href;
    }
    hasPendingLink() {
      return !!this.pendingLink;
    }
    bind(events, callback) {
      for (let event in events) {
        let browserEventName = events[event];
        this.on(browserEventName, (e) => {
          let binding = this.binding(event);
          let windowBinding = this.binding(`window-${event}`);
          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);
          if (targetPhxEvent) {
            this.debounce(e.target, e, () => {
              this.withinOwners(e.target, (view) => {
                callback(e, event, view, e.target, targetPhxEvent, null);
              });
            });
          } else {
            dom_default.all(document, `[${windowBinding}]`, (el) => {
              let phxEvent = el.getAttribute(windowBinding);
              this.debounce(el, e, () => {
                this.withinOwners(el, (view) => {
                  callback(e, event, view, el, phxEvent, "window");
                });
              });
            });
          }
        });
      }
    }
    bindClicks() {
      this.bindClick("click", "click", false);
      this.bindClick("mousedown", "capture-click", true);
    }
    bindClick(eventName, bindingName, capture) {
      let click = this.binding(bindingName);
      window.addEventListener(eventName, (e) => {
        if (!this.isConnected()) {
          return;
        }
        this.clickRef++;
        let clickRefWas = this.clickRef;
        let target = null;
        if (capture) {
          target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);
        } else {
          target = closestPhxBinding(e.target, click);
          this.dispatchClickAway(e, clickRefWas);
        }
        let phxEvent = target && target.getAttribute(click);
        if (!phxEvent) {
          return;
        }
        if (target.getAttribute("href") === "#") {
          e.preventDefault();
        }
        this.debounce(target, e, () => {
          this.withinOwners(target, (view) => {
            js_default.exec("click", phxEvent, view, target, ["push", { data: this.eventMeta("click", e, target) }]);
          });
        });
      }, capture);
    }
    dispatchClickAway(e, clickRefWas) {
      let phxClickAway = this.binding("click-away");
      let phxClick = this.binding("click");
      dom_default.all(document, `[${phxClickAway}]`, (el) => {
        if (!(el.isSameNode(e.target) || el.contains(e.target))) {
          this.withinOwners(e.target, (view) => {
            let phxEvent = el.getAttribute(phxClickAway);
            if (js_default.isVisible(el)) {
              let target = e.target.closest(`[${phxClick}]`) || e.target;
              js_default.exec("click", phxEvent, view, el, ["push", { data: this.eventMeta("click", e, e.target) }]);
            }
          });
        }
      });
    }
    bindNav() {
      if (!browser_default.canPushState()) {
        return;
      }
      if (history.scrollRestoration) {
        history.scrollRestoration = "manual";
      }
      let scrollTimer = null;
      window.addEventListener("scroll", (_e) => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          browser_default.updateCurrentState((state) => Object.assign(state, { scroll: window.scrollY }));
        }, 100);
      });
      window.addEventListener("popstate", (event) => {
        if (!this.registerNewLocation(window.location)) {
          return;
        }
        let { type, id, root, scroll } = event.state || {};
        let href = window.location.href;
        this.requestDOMUpdate(() => {
          if (this.main.isConnected() && (type === "patch" && id === this.main.id)) {
            this.main.pushLinkPatch(href, null);
          } else {
            this.replaceMain(href, null, () => {
              if (root) {
                this.replaceRootHistory();
              }
              if (typeof scroll === "number") {
                setTimeout(() => {
                  window.scrollTo(0, scroll);
                }, 0);
              }
            });
          }
        });
      }, false);
      window.addEventListener("click", (e) => {
        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);
        let type = target && target.getAttribute(PHX_LIVE_LINK);
        let wantsNewTab = e.metaKey || e.ctrlKey || e.button === 1;
        if (!type || !this.isConnected() || !this.main || wantsNewTab) {
          return;
        }
        let href = target.href;
        let linkState = target.getAttribute(PHX_LINK_STATE);
        e.preventDefault();
        if (this.pendingLink === href) {
          return;
        }
        this.requestDOMUpdate(() => {
          if (type === "patch") {
            this.pushHistoryPatch(href, linkState, target);
          } else if (type === "redirect") {
            this.historyRedirect(href, linkState);
          } else {
            throw new Error(`expected ${PHX_LIVE_LINK} to be "patch" or "redirect", got: ${type}`);
          }
        });
      }, false);
    }
    dispatchEvent(event, payload = {}) {
      dom_default.dispatchEvent(window, `phx:${event}`, payload);
    }
    dispatchEvents(events) {
      events.forEach(([event, payload]) => this.dispatchEvent(event, payload));
    }
    withPageLoading(info, callback) {
      dom_default.dispatchEvent(window, "phx:page-loading-start", info);
      let done = () => dom_default.dispatchEvent(window, "phx:page-loading-stop", info);
      return callback ? callback(done) : done;
    }
    pushHistoryPatch(href, linkState, targetEl) {
      this.withPageLoading({ to: href, kind: "patch" }, (done) => {
        this.main.pushLinkPatch(href, targetEl, (linkRef) => {
          this.historyPatch(href, linkState, linkRef);
          done();
        });
      });
    }
    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {
      if (!this.commitPendingLink(linkRef)) {
        return;
      }
      browser_default.pushState(linkState, { type: "patch", id: this.main.id }, href);
      this.registerNewLocation(window.location);
    }
    historyRedirect(href, linkState, flash) {
      let scroll = window.scrollY;
      this.withPageLoading({ to: href, kind: "redirect" }, (done) => {
        this.replaceMain(href, flash, () => {
          browser_default.pushState(linkState, { type: "redirect", id: this.main.id, scroll }, href);
          this.registerNewLocation(window.location);
          done();
        });
      });
    }
    replaceRootHistory() {
      browser_default.pushState("replace", { root: true, type: "patch", id: this.main.id });
    }
    registerNewLocation(newLocation) {
      let { pathname, search } = this.currentLocation;
      if (pathname + search === newLocation.pathname + newLocation.search) {
        return false;
      } else {
        this.currentLocation = clone(newLocation);
        return true;
      }
    }
    bindForms() {
      let iterations = 0;
      this.on("submit", (e) => {
        let phxEvent = e.target.getAttribute(this.binding("submit"));
        if (!phxEvent) {
          return;
        }
        e.preventDefault();
        e.target.disabled = true;
        this.withinOwners(e.target, (view) => {
          js_default.exec("submit", phxEvent, view, e.target, ["push", {}]);
        });
      }, false);
      for (let type of ["change", "input"]) {
        this.on(type, (e) => {
          let input = e.target;
          let phxEvent = input.form && input.form.getAttribute(this.binding("change"));
          if (!phxEvent) {
            return;
          }
          if (input.type === "number" && input.validity && input.validity.badInput) {
            return;
          }
          let currentIterations = iterations;
          iterations++;
          let { at, type: lastType } = dom_default.private(input, "prev-iteration") || {};
          if (at === currentIterations - 1 && type !== lastType) {
            return;
          }
          dom_default.putPrivate(input, "prev-iteration", { at: currentIterations, type });
          this.debounce(input, e, () => {
            this.withinOwners(input.form, (view) => {
              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);
              if (!dom_default.isTextualInput(input)) {
                this.setActiveElement(input);
              }
              js_default.exec("change", phxEvent, view, input, ["push", { _target: e.target.name }]);
            });
          });
        }, false);
      }
    }
    debounce(el, event, callback) {
      let phxDebounce = this.binding(PHX_DEBOUNCE);
      let phxThrottle = this.binding(PHX_THROTTLE);
      let defaultDebounce = this.defaults.debounce.toString();
      let defaultThrottle = this.defaults.throttle.toString();
      dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback);
    }
    silenceEvents(callback) {
      this.silenced = true;
      callback();
      this.silenced = false;
    }
    on(event, callback) {
      window.addEventListener(event, (e) => {
        if (!this.silenced) {
          callback(e);
        }
      });
    }
  };
  var TransitionSet = class {
    constructor() {
      this.transitions = /* @__PURE__ */ new Set();
      this.pendingOps = [];
      this.reset();
    }
    reset() {
      this.transitions.forEach((timer) => {
        cancelTimeout(timer);
        this.transitions.delete(timer);
      });
      this.flushPendingOps();
    }
    after(callback) {
      if (this.size() === 0) {
        callback();
      } else {
        this.pushPendingOp(callback);
      }
    }
    addTransition(time, onStart, onDone) {
      onStart();
      let timer = setTimeout(() => {
        this.transitions.delete(timer);
        onDone();
        if (this.size() === 0) {
          this.flushPendingOps();
        }
      }, time);
      this.transitions.add(timer);
    }
    pushPendingOp(op) {
      this.pendingOps.push(op);
    }
    size() {
      return this.transitions.size;
    }
    flushPendingOps() {
      this.pendingOps.forEach((op) => op());
      this.pendingOps = [];
    }
  };

  // js/app.js
  var import_draggable = __toModule(require_draggable_bundle());
  var import_topbar = __toModule(require_topbar());

  // js/chart.js
  var import_chart = __toModule(require_chart());
  var import_chartjs_plugin_datalabels = __toModule(require_chartjs_plugin_datalabels());

  // node_modules/chart.js-plugin-labels-dv/dist/chartjs-plugin-labels.min.js
  !function(t) {
    typeof define == "function" && define.amd ? define(t) : t();
  }(function() {
    "use strict";
    !function() {
      if (typeof Chart == "undefined")
        return void console.error("Cannot find Chart object.");
      const t = Chart.helpers;
      typeof Object.assign != "function" && (Object.assign = function(t2) {
        if (!t2)
          throw new TypeError("Cannot convert undefined or null to object");
        const e2 = Object(t2);
        for (let t3 = 1; t3 < arguments.length; t3++) {
          const o2 = arguments[t3];
          if (o2)
            for (const t4 in o2)
              Object.prototype.hasOwnProperty.call(o2, t4) && (e2[t4] = o2[t4]);
        }
        return e2;
      });
      const e = {};
      function o() {
        this.renderToDataset = this.renderToDataset.bind(this);
      }
      ["pie", "doughnut", "polarArea", "bar"].forEach(function(t2) {
        e[t2] = true;
      }), o.prototype.setup = function(t2, e2) {
        this.chart = t2, this.ctx = t2.ctx, this.args = {}, this.barTotal = {};
        const o2 = t2.config.options;
        this.options = Object.assign({ position: "default", precision: 0, fontSize: o2.font ? o2.font.size : 12, fontColor: o2.color || "#333333", fontStyle: o2.font ? o2.font.style : "normal", fontFamily: o2.font ? o2.font.family : "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", shadowOffsetX: 3, shadowOffsetY: 3, shadowColor: "rgba(0,0,0,0.3)", shadowBlur: 6, images: [], outsidePadding: 2, textMargin: 2, overlap: true }, e2), t2.config.type === "bar" && (this.options.position = "default", this.options.arc = false, this.options.overlap = true);
      }, o.prototype.render = function() {
        this.labelBounds = [], this.chart.data.datasets.forEach(this.renderToDataset);
      }, o.prototype.renderToDataset = function(t2, e2) {
        this.totalPercentage = 0, this.total = null;
        const o2 = this.args[e2];
        o2.meta.data.forEach(function(e3, n) {
          this.renderToElement(t2, o2, e3, n);
        }.bind(this));
      }, o.prototype.renderToElement = function(e2, o2, n, i) {
        if (!this.shouldRenderToElement(o2.meta, n))
          return;
        this.percentage = null;
        const s = this.getLabel(e2, n, i);
        if (!s)
          return;
        const r = this.ctx;
        r.save(), r.font = t.fontString(this.options.fontSize, this.options.fontStyle, this.options.fontFamily);
        const a = this.getRenderInfo(n, s);
        this.drawable(n, s, a) ? (r.beginPath(), r.fillStyle = this.getFontColor(e2, n, i), this.renderLabel(s, a), r.restore()) : r.restore();
      }, o.prototype.renderLabel = function(t2, e2) {
        return this.options.arc ? this.renderArcLabel(t2, e2) : this.renderBaseLabel(t2, e2);
      }, o.prototype.renderBaseLabel = function(t2, e2) {
        const o2 = this.ctx;
        if (typeof t2 == "object")
          o2.drawImage(t2, e2.x - t2.width / 2, e2.y - t2.height / 2, t2.width, t2.height);
        else {
          o2.save(), o2.textBaseline = "top", o2.textAlign = "center", this.options.textShadow && (o2.shadowOffsetX = this.options.shadowOffsetX, o2.shadowOffsetY = this.options.shadowOffsetY, o2.shadowColor = this.options.shadowColor, o2.shadowBlur = this.options.shadowBlur);
          const n = t2.split("\n");
          for (let t3 = 0; t3 < n.length; t3++) {
            const i = e2.y - this.options.fontSize / 2 * n.length + this.options.fontSize * t3;
            o2.fillText(n[t3], e2.x, i);
          }
          o2.restore();
        }
      }, o.prototype.renderArcLabel = function(t2, e2) {
        const o2 = this.ctx, n = e2.radius, i = e2.view;
        if (o2.save(), o2.translate(i.x, i.y), typeof t2 == "string") {
          o2.rotate(e2.startAngle), o2.textBaseline = "middle", o2.textAlign = "left";
          const i2 = t2.split("\n");
          let s = 0;
          const r = [];
          let a, h = 0;
          this.options.position === "border" && (h = (i2.length - 1) * this.options.fontSize / 2);
          for (let t3 = 0; t3 < i2.length; ++t3)
            a = o2.measureText(i2[t3]), a.width > s && (s = a.width), r.push(a.width);
          for (let t3 = 0; t3 < i2.length; ++t3) {
            const e3 = i2[t3], l = (i2.length - 1 - t3) * -this.options.fontSize + h;
            o2.save();
            const c = (s - r[t3]) / 2;
            o2.rotate(c / n);
            for (let t4 = 0; t4 < e3.length; t4++) {
              const i3 = e3.charAt(t4);
              a = o2.measureText(i3), o2.save(), o2.translate(0, -1 * n), o2.fillText(i3, 0, l), o2.restore(), o2.rotate(a.width / n);
            }
            o2.restore();
          }
        } else
          o2.rotate((i.startAngle + Math.PI / 2 + e2.endAngle) / 2), o2.translate(0, -1 * n), this.renderLabel(t2, { x: 0, y: 0 });
        o2.restore();
      }, o.prototype.shouldRenderToElement = function(t2, e2) {
        return !t2.hidden && (this.options.showZero || this.chart.config.type === "polarArea" ? e2.outerRadius !== 0 : e2.circumference !== 0);
      }, o.prototype.getLabel = function(t2, e2, o2) {
        let n;
        if (typeof this.options.render == "function")
          n = this.options.render({ label: this.chart.config.data.labels[o2], value: t2.data[o2], percentage: this.getPercentage(t2, e2, o2), dataset: t2, index: o2 });
        else
          switch (this.options.render) {
            case "value":
              n = t2.data[o2];
              break;
            case "label":
              n = this.chart.config.data.labels[o2];
              break;
            case "image":
              n = this.options.images[o2] ? this.loadImage(this.options.images[o2]) : "";
              break;
            case "percentage":
            default:
              n = this.getPercentage(t2, e2, o2) + "%";
          }
        return typeof n == "object" ? n = this.loadImage(n) : n && (n = n.toString()), n;
      }, o.prototype.getFontColor = function(t2, e2, o2) {
        let n = this.options.fontColor;
        return typeof n == "function" ? n = n({ label: this.chart.config.data.labels[o2], value: t2.data[o2], percentage: this.getPercentage(t2, e2, o2), backgroundColor: t2.backgroundColor[o2], dataset: t2, index: o2 }) : typeof n != "string" && (n = n[o2] || this.chart.config.options.color), n;
      }, o.prototype.getPercentage = function(t2, e2, o2) {
        if (this.percentage)
          return this.percentage;
        let n;
        if (this.chart.config.type === "polarArea" || this.chart.config.type === "doughnut" || this.chart.config.type === "pie") {
          if (!this.total) {
            this.total = 0;
            for (let e3 = 0; e3 < t2.data.length; ++e3)
              this.total += t2.data[e3];
          }
          n = t2.data[o2] / this.total * 100;
        } else if (this.chart.config.type === "bar") {
          if (!this.barTotal[o2]) {
            this.barTotal[o2] = 0;
            for (let t3 = 0; t3 < this.chart.data.datasets.length; ++t3)
              this.barTotal[o2] += this.chart.data.datasets[t3].data[o2];
          }
          n = t2.data[o2] / this.barTotal[o2] * 100;
        } else
          n = e2.circumference / this.chart.config.options.circumference * 100;
        return n = parseFloat(n.toFixed(this.options.precision)), this.options.showActualPercentages || (this.chart.config.type === "bar" && (this.totalPercentage = this.barTotalPercentage[o2] || 0), this.totalPercentage += n, this.totalPercentage > 100 && (n -= this.totalPercentage - 100, n = parseFloat(n.toFixed(this.options.precision))), this.chart.config.type === "bar" && (this.barTotalPercentage[o2] = this.totalPercentage)), this.percentage = n, n;
      }, o.prototype.getRenderInfo = function(t2, e2) {
        return this.chart.config.type === "bar" ? this.getBarRenderInfo(t2, e2) : this.options.arc ? this.getArcRenderInfo(t2, e2) : this.getBaseRenderInfo(t2, e2);
      }, o.prototype.getBaseRenderInfo = function(t2, e2) {
        if (this.options.position === "outside" || this.options.position === "border") {
          let o2, n = {};
          const i = t2, s = i.startAngle + (i.endAngle - i.startAngle) / 2, r = i.outerRadius / 2;
          if (this.options.position === "border" ? o2 = (i.outerRadius - r) / 2 + r : this.options.position === "outside" && (o2 = i.outerRadius - r + r + this.options.textMargin), n = { x: i.x + Math.cos(s) * o2, y: i.y + Math.sin(s) * o2 }, this.options.position === "outside") {
            const t3 = this.options.textMargin + this.measureLabel(e2).width / 2;
            n.x += n.x < i.x ? -t3 : t3;
          }
          return n;
        }
        return t2.tooltipPosition();
      }, o.prototype.getArcRenderInfo = function(t2, e2) {
        let o2;
        const n = t2;
        o2 = this.options.position === "outside" ? n.outerRadius + this.options.fontSize + this.options.textMargin : this.options.position === "border" ? (n.outerRadius / 2 + n.outerRadius) / 2 : (n.innerRadius + n.outerRadius) / 2;
        let i = n.startAngle, s = n.endAngle;
        const r = s - i;
        i += Math.PI / 2, s += Math.PI / 2;
        return i += (s - (this.measureLabel(e2).width / o2 + i)) / 2, { radius: o2, startAngle: i, endAngle: s, totalAngle: r, view: n };
      }, o.prototype.getBarRenderInfo = function(t2, e2) {
        const o2 = t2.tooltipPosition();
        return o2.y -= this.measureLabel(e2).height / 2 + this.options.textMargin, o2;
      }, o.prototype.drawable = function(t2, e2, o2) {
        if (this.options.overlap)
          return true;
        if (this.options.arc)
          return o2.endAngle - o2.startAngle <= o2.totalAngle;
        {
          const n = this.measureLabel(e2), i = o2.x - n.width / 2, s = o2.x + n.width / 2, r = o2.y - n.height / 2, a = o2.y + n.height / 2;
          return this.options.position === "outside" ? this.outsideInRange(i, s, r, a) : t2.inRange(i, r) && t2.inRange(i, a) && t2.inRange(s, r) && t2.inRange(s, a);
        }
      }, o.prototype.outsideInRange = function(t2, e2, o2, n) {
        const i = this.labelBounds;
        for (let s = 0; s < i.length; ++s) {
          const r = i[s];
          let a = [[t2, o2], [t2, n], [e2, o2], [e2, n]];
          for (let t3 = 0; t3 < a.length; ++t3) {
            const e3 = a[t3][0], o3 = a[t3][1];
            if (e3 >= r.left && e3 <= r.right && o3 >= r.top && o3 <= r.bottom)
              return false;
          }
          a = [[r.left, r.top], [r.left, r.bottom], [r.right, r.top], [r.right, r.bottom]];
          for (let i2 = 0; i2 < a.length; ++i2) {
            const s2 = a[i2][0], r2 = a[i2][1];
            if (s2 >= t2 && s2 <= e2 && r2 >= o2 && r2 <= n)
              return false;
          }
        }
        return i.push({ left: t2, right: e2, top: o2, bottom: n }), true;
      }, o.prototype.measureLabel = function(t2) {
        if (typeof t2 == "object")
          return { width: t2.width, height: t2.height };
        {
          let e2 = 0;
          const o2 = t2.split("\n");
          for (let t3 = 0; t3 < o2.length; ++t3) {
            const n = this.ctx.measureText(o2[t3]);
            n.width > e2 && (e2 = n.width);
          }
          return { width: e2, height: this.options.fontSize * o2.length };
        }
      }, o.prototype.loadImage = function(t2) {
        const e2 = new Image();
        return e2.src = t2.src, e2.width = t2.width, e2.height = t2.height, e2;
      }, Chart.register({ id: "labels", beforeDatasetsUpdate: function(t2, n, i) {
        if (!e[t2.config.type])
          return;
        i.length || (i = [i]);
        const s = i.length;
        t2._labels && s === t2._labels.length || (t2._labels = i.map(function() {
          return new o();
        }));
        let r = false, a = 0;
        for (let e2 = 0; e2 < s; ++e2) {
          const o2 = t2._labels[e2];
          if (o2.setup(t2, i[e2]), o2.options.position === "outside") {
            r = true;
            const t3 = 1.5 * o2.options.fontSize + o2.options.outsidePadding;
            t3 > a && (a = t3);
          }
        }
        r && (t2.chartArea.top += a, t2.chartArea.bottom -= a);
      }, afterDatasetUpdate: function(t2, o2) {
        e[t2.config.type] && t2._labels.forEach(function(t3) {
          t3.args[o2.index] = o2;
        });
      }, beforeDraw: function(t2) {
        e[t2.config.type] && t2._labels.forEach(function(t3) {
          t3.barTotalPercentage = {};
        });
      }, afterDatasetsDraw: function(t2) {
        e[t2.config.type] && t2._labels.forEach(function(t3) {
          t3.render();
        });
      } });
    }();
  });

  // js/chart.js
  var colors = ["#36a2eb"];
  var month = [
    "Janvier",
    "F\xE9vrier",
    "Mars",
    "Avril",
    "Mai",
    "Juin",
    "Juillet",
    "Ao\xFBt",
    "Septembre",
    "Octobre",
    "Novembre",
    "D\xE9cembre"
  ];
  var SURVEY = [
    "Qualit\xE9 du travail effectu\xE9",
    "Gain de temps du client",
    "Respect du d\xE9lai de livraison",
    "Qualit\xE9 de la communication"
  ];
  var HorizontalBarChart = class {
    constructor(ctx, labels, values) {
      this.chart = new import_chart.default(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [
            {
              axis: "x",
              label: "Liste des t\xE2ches",
              data: values,
              fill: false,
              borderColor: colors,
              backgroundColor: colors,
              borderWidth: 1,
              color: "#fff"
            }
          ]
        },
        options: {
          indexAxis: "x",
          responsive: true,
          plugins: {
            labels: {
              render: "value",
              fontColor: "#5c5c5c",
              position: "outside"
            },
            legend: {
              position: "bottom"
            },
            title: {
              display: true,
              text: "Liste des t\xE2ches par contributeurs"
            },
            datalabels: {
              color: "#fff"
            }
          }
        }
      });
    }
  };
  var StackedBarChart = class {
    constructor(ctx, todo_tasks, blocked_tasks, tasks_in_progress, tasks_in_control, achieved_tasks) {
      this.chart = new import_chart.default(ctx, {
        type: "bar",
        data: {
          labels: month,
          datasets: [
            {
              label: "T\xE2ches \xE0 faire",
              data: todo_tasks,
              backgroundColor: "#36a2eb"
            },
            {
              label: "T\xE2ches en blocage",
              data: blocked_tasks,
              backgroundColor: "#e67e22"
            },
            {
              label: "T\xE2ches en cours",
              data: tasks_in_progress,
              backgroundColor: "#27ae60"
            },
            {
              label: "T\xE2ches en contr\xF4le",
              data: tasks_in_control,
              backgroundColor: "#8e44ad"
            },
            {
              label: "T\xE2ches achev\xE9es",
              data: achieved_tasks,
              backgroundColor: "#ff6384"
            }
          ]
        },
        options: {
          plugins: {
            labels: {
              render: "value",
              fontColor: "#5c5c5c",
              position: "outside"
            },
            legend: {
              position: "bottom"
            },
            title: {
              display: true,
              text: "T\xE2ches par mois"
            }
          },
          responsive: true
        }
      });
    }
  };
  var SurveyChart = class {
    constructor(ctx, values) {
      this.chart = new import_chart.default(ctx, {
        type: "bar",
        data: {
          labels: SURVEY,
          datasets: [
            {
              axis: "x",
              label: "Pourcentage de satisfaction en %",
              data: values,
              fill: false,
              borderColor: colors,
              backgroundColor: colors,
              borderWidth: 2,
              color: "#fff"
            }
          ]
        },
        options: {
          maintainAspectRatio: false,
          indexAxis: "y",
          responsive: true,
          plugins: {
            labels: {
              render: "value",
              fontColor: "#5c5c5c",
              position: "outside"
            },
            legend: {
              position: "bottom"
            },
            title: {
              display: true,
              text: "Taux de satisfaction du client"
            },
            datalabels: {
              color: "#fff"
            }
          }
        }
      });
    }
  };

  // js/app.js
  var import_chart3 = __toModule(require_chart());
  require_();
  require_2();
  var Hooks2 = {};
  Hooks2.HorizontalBarChart = {
    mounted() {
      const { labels_tasks_by_contributors, values_tasks_by_contributors } = JSON.parse(this.el.dataset.chartData);
      this.chart = new HorizontalBarChart(this.el, labels_tasks_by_contributors, values_tasks_by_contributors);
    }
  };
  Hooks2.StackedBarChart = {
    mounted() {
      const {
        values_tasks_todo_by_month,
        values_blocking_tasks_by_month,
        values_tasks_in_progress_by_month,
        values_tasks_in_control_by_month,
        values_tasks_achieved_by_month
      } = JSON.parse(this.el.dataset.chartData);
      this.chart = new StackedBarChart(this.el, values_tasks_todo_by_month, values_blocking_tasks_by_month, values_tasks_in_progress_by_month, values_tasks_in_control_by_month, values_tasks_achieved_by_month);
    }
  };
  Hooks2.SurveyChart = {
    mounted() {
      console.log("is mounted");
      const { values } = JSON.parse(this.el.dataset.chartData);
      this.mychart = new SurveyChart(this.el, values);
    }
  };
  Hooks2.Board = {
    mounted() {
      this.initDraggables();
    },
    updated() {
      this.sortableCard.destroy();
      this.sortableStage.destroy();
      this.initDraggables();
    },
    initDraggables() {
      this.sortableCard = new import_draggable.Sortable(document.querySelectorAll(".stage__cards"), {
        draggable: ".card",
        mirror: {
          constrainDimensions: true
        },
        swapAnimation: {
          duration: 200,
          easingFunction: "ease-in-out"
        },
        plugins: [import_draggable.Plugins.SwapAnimation]
      });
      this.sortableCard.on("sortable:stop", (event) => {
        const source = event.data.dragEvent.data.source;
        const cardId = parseInt(source.getAttribute("data-card-id"));
        const newStageId = parseInt(event.data.newContainer.getAttribute("data-stage-id"));
        const newIndex = parseInt(event.data.newIndex);
        const cardPayload = {
          card: {
            id: cardId,
            stage_id: newStageId,
            position: newIndex
          }
        };
        this.pushEvent("update_card", cardPayload);
      });
      this.sortableStage = new import_draggable.Sortable(document.querySelectorAll(".board"), {
        draggable: ".stage",
        handle: ".draggable-handle",
        mirror: {
          constrainDimensions: true,
          yAxis: false
        }
      });
      this.sortableStage.on("sortable:stop", (event) => {
        const source = event.data.dragEvent.data.source;
        const stageId = parseInt(source.getAttribute("data-stage-id"));
        const newIndex = parseInt(event.data.newIndex);
        const stagePayload = {
          stage: {
            id: stageId,
            position: newIndex
          }
        };
        this.pushEvent("update_stage", stagePayload);
      });
    }
  };
  Hooks2.AnimateAlert = {
    mounted() {
      this.handleEvent("AnimateAlert", ({}) => this.reset_opacity());
    },
    updated() {
    },
    reset_opacity() {
      var alert = document.querySelector("#alert_anim");
      alert.style.opacity = 1;
      window.setTimeout(function() {
        alert.style.display = "none";
      }, 2e3);
    },
    anim_onload() {
      var alerts2 = document.querySelectorAll(".alert");
      alerts2.forEach((item) => {
        item.style.opacity = 1;
        item.onload = window.setTimeout(function() {
          item.style.opacity = 0;
        }, 2e3);
      });
      for (var i = 0; i < alerts2.length; i++) {
        alerts2[i].style.opacity = 1;
        alerts2[i].onload = window.setTimeout(function() {
          alerts2[i].style.opacity = 0;
        }, 2e3);
      }
    }
  };
  Hooks2.blurHook = {
    mounted() {
      this.handleEvent("blurBody", ({ param1, param2 }) => this.blurBody());
    },
    blurBody() {
      var body = document.body;
      var request_form = document.querySelector("#the_request_form");
      body.style.opacity = 0.5;
      request_form.style.opacity = 1;
    }
  };
  Hooks2.MessageBody = {
    mounted() {
      var messageBody = document.querySelector("#messageBody");
      this.handleEvent("updateScroll", ({}) => messageBody.scrollTop = messageBody.scrollHeight - messageBody.clientHeight);
    }
  };
  Hooks2.urlProcess = {
    mounted() {
      let main = document.querySelector("#main");
      var url = window.location.href;
      url.includes("/logs") ? main.classList.remove("container") : main.classList.add("container");
    }
  };
  Hooks2.SpinTest = {
    mounted() {
      this.handleEvent("SpinTest", ({}) => this.spin_icon());
      this.handleEvent("SpinComment", ({}) => this.spin_comment_icon());
    },
    spin_icon() {
      var spins = document.querySelectorAll(".notif__load");
      spins.forEach((item) => {
        item.classList.add("new__rotate__icon");
      });
      spins.forEach((item) => {
        window.setTimeout(function() {
          item.classList.remove("new__rotate__icon");
        }, 500);
      });
    },
    spin_comment_icon() {
      var clock_comment = document.getElementById("clock_comment");
      clock_comment.classList.add("rotate__icon");
      window.setTimeout(function() {
        clock_comment.classList.remove("rotate__icon");
      }, 500);
    }
  };
  var navToggle = document.querySelector(".nav__toggle");
  var navWrapper = document.querySelector(".nav__wrapper");
  navToggle.addEventListener("click", function() {
    if (navWrapper.classList.contains("active")) {
      this.setAttribute("aria-expanded", "false");
      this.setAttribute("aria-label", "menu");
      navWrapper.classList.remove("active");
    } else {
      navWrapper.classList.add("active");
      this.setAttribute("aria-label", "close menu");
      this.setAttribute("aria-expanded", "true");
    }
  });
  var menuBtn = document.querySelector(".menu-btn");
  var menuOpen = false;
  menuBtn.addEventListener("click", () => {
    if (!menuOpen) {
      menuBtn.classList.add("open");
      menuOpen = true;
    } else {
      menuBtn.classList.remove("open");
      menuOpen = false;
    }
  });
  var alerts = document.querySelectorAll(".alert");
  alerts.forEach((item) => {
    item.style.opacity = 1;
    item.onload = window.setTimeout(function() {
      item.style.opacity = 0;
    }, 2e3);
  });
  var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
  var liveSocket = new LiveSocket("/live", Socket, {
    params: { _csrf_token: csrfToken },
    hooks: Hooks2
  });
  import_topbar.default.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
  window.addEventListener("phx:page-loading-start", (info) => import_topbar.default.show());
  window.addEventListener("phx:page-loading-stop", (info) => import_topbar.default.hide());
  liveSocket.connect();
  window.liveSocket = liveSocket;
})();
/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.8.0
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
/*!
 * chartjs-plugin-datalabels v2.0.0
 * https://chartjs-plugin-datalabels.netlify.app
 * (c) 2017-2021 chartjs-plugin-datalabels contributors
 * Released under the MIT license
 */
/**
   * [chartjs-plugin-labels]{@link https://github.com/DavideViolante/chartjs-plugin-labels}
   *
   * @version 3.1.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com], Davide Violante
   * @copyright Chen, Yi-Cyuan 2017-2018
   * @license MIT
   */
/**
 * @license MIT
 * topbar 1.0.0, 2021-01-06
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Ac2hvcGlmeS9kcmFnZ2FibGUvbGliL2RyYWdnYWJsZS5idW5kbGUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL3ZlbmRvci90b3BiYXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NoYXJ0LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvaGVscGVycy9oZWxwZXJzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9kaXN0L2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC91dGlscy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9wdXNoLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC90aW1lci5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY2hhbm5lbC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvYWpheC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvbG9uZ3BvbGwuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zZXJpYWxpemVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zb2NrZXQuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2VudHJ5X3VwbG9hZGVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3V0aWxzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2Jyb3dzZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3VwbG9hZF9lbnRyeS5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3VwbG9hZGVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2hvb2tzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2RvbV9wb3N0X21vcnBoX3Jlc3RvcmVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL25vZGVfbW9kdWxlcy9tb3JwaGRvbS9kaXN0L21vcnBoZG9tLWVzbS5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9kb21fcGF0Y2guanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvcmVuZGVyZWQuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvdmlld19ob29rLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2pzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3ZpZXcuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvbGl2ZV9zb2NrZXQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL2pzL2FwcC5qcyIsICIuLi8uLi8uLi9hc3NldHMvanMvY2hhcnQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy1wbHVnaW4tbGFiZWxzLWR2L2Rpc3QvY2hhcnRqcy1wbHVnaW4tbGFiZWxzLm1pbi5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShcIkRyYWdnYWJsZVwiLCBbXSwgZmFjdG9yeSk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcblx0XHRleHBvcnRzW1wiRHJhZ2dhYmxlXCJdID0gZmFjdG9yeSgpO1xyXG5cdGVsc2VcclxuXHRcdHJvb3RbXCJEcmFnZ2FibGVcIl0gPSBmYWN0b3J5KCk7XHJcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XHJcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXHJcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XHJcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcclxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcclxuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXHJcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxyXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxyXG4vKioqKioqLyBcdFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXHJcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4vKioqKioqLyBcdH1cclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xyXG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XHJcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcclxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XHJcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xyXG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XHJcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcclxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA2Nik7XHJcbi8qKioqKiovIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKioqKiovIChbXHJcbi8qIDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2Nsb3Nlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY2xvc2VzdCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nsb3Nlc3QpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xyXG5cclxuT2JqZWN0LmtleXMoX1NlbnNvckV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1NlbnNvckV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xyXG5cclxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfU2Vuc29yMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0RyYWdFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG5cclxuT2JqZWN0LmtleXMoX0RyYWdFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9EcmFnRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX0RyYWdnYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblxyXG5PYmplY3Qua2V5cyhfRHJhZ2dhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfRHJhZ2dhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX1BsdWdpbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuXHJcbk9iamVjdC5rZXlzKF9QbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1BsdWdpbnNba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX1NlbnNvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cclxuT2JqZWN0LmtleXMoX1NlbnNvcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU2Vuc29yc1trZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbnZhciBfRHJhZ2dhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XHJcblxyXG52YXIgX0RyYWdnYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnZ2FibGUpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9EcmFnZ2FibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU2Vuc29yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX01vdXNlU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ01vdXNlU2Vuc29yJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTW91c2VTZW5zb3IpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfVG91Y2hTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVG91Y2hTZW5zb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Ub3VjaFNlbnNvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9EcmFnU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0RyYWdTZW5zb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnU2Vuc29yKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX0ZvcmNlVG91Y2hTZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRm9yY2VUb3VjaFNlbnNvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZvcmNlVG91Y2hTZW5zb3IpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxuT2JqZWN0LmtleXMoX1NlbnNvckV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1NlbnNvckV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TbmFwcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG5cclxuT2JqZWN0LmtleXMoX1NuYXBwYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1NuYXBwYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0NvbGxpZGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG5cclxuT2JqZWN0LmtleXMoX0NvbGxpZGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Db2xsaWRhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU29ydGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xyXG5cclxuT2JqZWN0LmtleXMoX1NvcnRhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU29ydGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU3dhcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcclxuXHJcbk9iamVjdC5rZXlzKF9Td2FwcGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Td2FwcGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRHJvcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcclxuXHJcbk9iamVjdC5rZXlzKF9Ecm9wcGFibGVFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9Ecm9wcGFibGVFdmVudFtrZXldO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQW5ub3VuY2VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Fubm91bmNlbWVudCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fubm91bmNlbWVudCkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRBbm5vdW5jZW1lbnRPcHRpb25zJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX0Fubm91bmNlbWVudC5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Gb2N1c2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRm9jdXNhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9jdXNhYmxlKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX01pcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdNaXJyb3InLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NaXJyb3IpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0TWlycm9yT3B0aW9ucycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9NaXJyb3IuZGVmYXVsdE9wdGlvbnM7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfU2Nyb2xsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdTY3JvbGxhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Nyb2xsYWJsZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRTY3JvbGxhYmxlT3B0aW9ucycsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9TY3JvbGxhYmxlLmRlZmF1bHRPcHRpb25zO1xyXG4gIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9EcmFnZ2FibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpO1xyXG5cclxuT2JqZWN0LmtleXMoX0RyYWdnYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0RyYWdnYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9EcmFnRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcclxuXHJcbk9iamVjdC5rZXlzKF9EcmFnRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfRHJhZ0V2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Tb3J0YWJsZVNvcnRlZCA9IFN5bWJvbCgnb25Tb3J0YWJsZVNvcnRlZCcpO1xyXG5cclxuLyoqXHJcbiAqIFN3YXBBbmltYXRpb24gZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuZHVyYXRpb25cclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRlZmF1bHRPcHRpb25zLmVhc2luZ0Z1bmN0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVmYXVsdE9wdGlvbnMuaG9yaXpvbnRhbFxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIGR1cmF0aW9uOiAxNTAsXHJcbiAgZWFzaW5nRnVuY3Rpb246ICdlYXNlLWluLW91dCcsXHJcbiAgaG9yaXpvbnRhbDogZmFsc2VcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTd2FwQW5pbWF0aW9uIHBsdWdpbiBhZGRzIHN3YXAgYW5pbWF0aW9ucyBmb3Igc29ydGFibGVcclxuICogQGNsYXNzIFN3YXBBbmltYXRpb25cclxuICogQG1vZHVsZSBTd2FwQW5pbWF0aW9uXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBTd2FwQW5pbWF0aW9uIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTd2FwQW5pbWF0aW9uIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFN3YXBBbmltYXRpb25cclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3dhcEFuaW1hdGlvbiBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLmR1cmF0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gZGVmYXVsdE9wdGlvbnMuZWFzaW5nRnVuY3Rpb25cclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0T3B0aW9ucywgdGhpcy5nZXRPcHRpb25zKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGFzdCBhbmltYXRpb24gZnJhbWVcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsYXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uU29ydGFibGVTb3J0ZWRdID0gdGhpc1tvblNvcnRhYmxlU29ydGVkXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignc29ydGFibGU6c29ydGVkJywgdGhpc1tvblNvcnRhYmxlU29ydGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignc29ydGFibGU6c29ydGVkJywgdGhpc1tvblNvcnRhYmxlU29ydGVkXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5zd2FwQW5pbWF0aW9uIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU29ydGFibGUgc29ydGVkIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge1NvcnRhYmxlU29ydGVkRXZlbnR9IHNvcnRhYmxlRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvblNvcnRhYmxlU29ydGVkXSh7IG9sZEluZGV4LCBuZXdJbmRleCwgZHJhZ0V2ZW50IH0pIHtcclxuICAgIGNvbnN0IHsgc291cmNlLCBvdmVyIH0gPSBkcmFnRXZlbnQ7XHJcblxyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXN0QW5pbWF0aW9uRnJhbWUpO1xyXG5cclxuICAgIC8vIENhbiBiZSBkb25lIGluIGEgc2VwYXJhdGUgZnJhbWVcclxuICAgIHRoaXMubGFzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgaWYgKG9sZEluZGV4ID49IG5ld0luZGV4KSB7XHJcbiAgICAgICAgYW5pbWF0ZShzb3VyY2UsIG92ZXIsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYW5pbWF0ZShvdmVyLCBzb3VyY2UsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gU3dhcEFuaW1hdGlvbjsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFuaW1hdGVzIHR3byBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmVhc2luZ0Z1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmhvcml6b250YWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5mdW5jdGlvbiBhbmltYXRlKGZyb20sIHRvLCB7IGR1cmF0aW9uLCBlYXNpbmdGdW5jdGlvbiwgaG9yaXpvbnRhbCB9KSB7XHJcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtmcm9tLCB0b10pIHtcclxuICAgIGVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuICB9XHJcblxyXG4gIGlmIChob3Jpem9udGFsKSB7XHJcbiAgICBjb25zdCB3aWR0aCA9IGZyb20ub2Zmc2V0V2lkdGg7XHJcbiAgICBmcm9tLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3dpZHRofXB4LCAwLCAwKWA7XHJcbiAgICB0by5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoLSR7d2lkdGh9cHgsIDAsIDApYDtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc3QgaGVpZ2h0ID0gZnJvbS5vZmZzZXRIZWlnaHQ7XHJcbiAgICBmcm9tLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgwLCAke2hlaWdodH1weCwgMClgO1xyXG4gICAgdG8uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDAsIC0ke2hlaWdodH1weCwgMClgO1xyXG4gIH1cclxuXHJcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbZnJvbSwgdG9dKSB7XHJcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZCk7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbiA9IGB0cmFuc2Zvcm0gJHtkdXJhdGlvbn1tcyAke2Vhc2luZ0Z1bmN0aW9ufWA7XHJcbiAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNldHMgYW5pbWF0aW9uIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgYW5pbWF0aW9uIGhhcyBjb21wbGV0ZWRcclxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZChldmVudCkge1xyXG4gIGV2ZW50LnRhcmdldC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XHJcbiAgZXZlbnQudGFyZ2V0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcclxuICBldmVudC50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHJlc2V0RWxlbWVudE9uVHJhbnNpdGlvbkVuZCk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfU3dhcEFuaW1hdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG5cclxudmFyIF9Td2FwQW5pbWF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N3YXBBbmltYXRpb24pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Td2FwQW5pbWF0aW9uMi5kZWZhdWx0O1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX1N3YXBBbmltYXRpb24uZGVmYXVsdE9wdGlvbnM7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxudmFyIF9TbmFwcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBTeW1ib2woJ29uRHJhZ1N0YXJ0Jyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xyXG5jb25zdCBvbkRyYWdPdXQgPSBTeW1ib2woJ29uRHJhZ091dCcpO1xyXG5jb25zdCBvbk1pcnJvckNyZWF0ZWQgPSBTeW1ib2woJ29uTWlycm9yQ3JlYXRlZCcpO1xyXG5jb25zdCBvbk1pcnJvckRlc3Ryb3kgPSBTeW1ib2woJ29uTWlycm9yRGVzdHJveScpO1xyXG5cclxuLyoqXHJcbiAqIFNuYXBwYWJsZSBwbHVnaW4gd2hpY2ggc25hcHMgZHJhZ2dhYmxlIGVsZW1lbnRzIGludG8gcGxhY2VcclxuICogQGNsYXNzIFNuYXBwYWJsZVxyXG4gKiBAbW9kdWxlIFNuYXBwYWJsZVxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgU25hcHBhYmxlIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBTbmFwcGFibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgU25hcHBhYmxlXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBmaXJzdCBzb3VyY2UgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxudWxsfSBmaXJzdFNvdXJjZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpcnN0U291cmNlID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBtaXJyb3IgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gbWlycm9yXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWlycm9yID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdPdmVyXSA9IHRoaXNbb25EcmFnT3Zlcl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnT3V0XSA9IHRoaXNbb25EcmFnT3V0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1pcnJvckNyZWF0ZWRdID0gdGhpc1tvbk1pcnJvckNyZWF0ZWRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTWlycm9yRGVzdHJveV0gPSB0aGlzW29uTWlycm9yRGVzdHJveV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9uKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vbignZHJhZzpvdXQnLCB0aGlzW29uRHJhZ091dF0pLm9uKCdkcm9wcGFibGU6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcm9wcGFibGU6b3V0JywgdGhpc1tvbkRyYWdPdXRdKS5vbignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9uKCdtaXJyb3I6ZGVzdHJveScsIHRoaXNbb25NaXJyb3JEZXN0cm95XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9mZignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub2ZmKCdkcmFnOm91dCcsIHRoaXNbb25EcmFnT3V0XSkub2ZmKCdkcm9wcGFibGU6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9mZignZHJvcHBhYmxlOm91dCcsIHRoaXNbb25EcmFnT3V0XSkub2ZmKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub2ZmKCdtaXJyb3I6ZGVzdHJveScsIHRoaXNbb25NaXJyb3JEZXN0cm95XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0YXJ0RXZlbnR9IGV2ZW50IC0gRHJhZyBzdGFydCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmZpcnN0U291cmNlID0gZXZlbnQuc291cmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdG9wIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0b3BFdmVudH0gZXZlbnQgLSBEcmFnIHN0b3AgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RvcF0oKSB7XHJcbiAgICB0aGlzLmZpcnN0U291cmNlID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgb3ZlciBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnR8RHJvcHBhYmxlT3ZlckV2ZW50fSBldmVudCAtIERyYWcgb3ZlciBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdmVyXShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCBldmVudC5kcmFnRXZlbnQuc291cmNlO1xyXG5cclxuICAgIGlmIChzb3VyY2UgPT09IHRoaXMuZmlyc3RTb3VyY2UpIHtcclxuICAgICAgdGhpcy5maXJzdFNvdXJjZSA9IG51bGw7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzbmFwSW5FdmVudCA9IG5ldyBfU25hcHBhYmxlRXZlbnQuU25hcEluRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKHNuYXBJbkV2ZW50KTtcclxuXHJcbiAgICBpZiAoc25hcEluRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMubWlycm9yKSB7XHJcbiAgICAgIHRoaXMubWlycm9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICB9XHJcblxyXG4gICAgc291cmNlLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lRm9yKCdzb3VyY2U6ZHJhZ2dpbmcnKSk7XHJcbiAgICBzb3VyY2UuY2xhc3NMaXN0LmFkZCh0aGlzLmRyYWdnYWJsZS5nZXRDbGFzc05hbWVGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XHJcblxyXG4gICAgLy8gTmVlZCB0byBjYW5jZWwgdGhpcyBpbiBkcmFnIG91dFxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZHJhZ2dhYmxlLmdldENsYXNzTmFtZUZvcignc291cmNlOnBsYWNlZCcpKTtcclxuICAgIH0sIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMucGxhY2VkVGltZW91dCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG91dCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdPdXRFdmVudHxEcm9wcGFibGVPdXRFdmVudH0gZXZlbnQgLSBEcmFnIG91dCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdPdXRdKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc291cmNlID0gZXZlbnQuc291cmNlIHx8IGV2ZW50LmRyYWdFdmVudC5zb3VyY2U7XHJcblxyXG4gICAgY29uc3Qgc25hcE91dEV2ZW50ID0gbmV3IF9TbmFwcGFibGVFdmVudC5TbmFwT3V0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBzbmFwcGFibGU6IGV2ZW50Lm92ZXIgfHwgZXZlbnQuZHJvcHBhYmxlXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKHNuYXBPdXRFdmVudCk7XHJcblxyXG4gICAgaWYgKHNuYXBPdXRFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5taXJyb3IpIHtcclxuICAgICAgdGhpcy5taXJyb3Iuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHNvdXJjZS5jbGFzc0xpc3QuYWRkKHRoaXMuZHJhZ2dhYmxlLmdldENsYXNzTmFtZUZvcignc291cmNlOmRyYWdnaW5nJykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlycm9yIGNyZWF0ZWQgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7TWlycm9yQ3JlYXRlZEV2ZW50fSBtaXJyb3JFdmVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uTWlycm9yQ3JlYXRlZF0oeyBtaXJyb3IgfSkge1xyXG4gICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNaXJyb3IgZGVzdHJveSBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtNaXJyb3JEZXN0cm95RXZlbnR9IG1pcnJvckV2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25NaXJyb3JEZXN0cm95XSgpIHtcclxuICAgIHRoaXMubWlycm9yID0gbnVsbDtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gU25hcHBhYmxlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLlNuYXBPdXRFdmVudCA9IGV4cG9ydHMuU25hcEluRXZlbnQgPSBleHBvcnRzLlNuYXBFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2Ugc25hcCBldmVudFxyXG4gKiBAY2xhc3MgU25hcEV2ZW50XHJcbiAqIEBtb2R1bGUgU25hcEV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIFNuYXBFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIHNuYXAgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgZHJhZ0V2ZW50XHJcbiAgICogQHR5cGUge0RyYWdFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ0V2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTbmFwcGFibGUgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBzbmFwcGFibGVcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNuYXBwYWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc25hcHBhYmxlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5TbmFwRXZlbnQgPSBTbmFwRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU25hcCBpbiBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNuYXBJbkV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNuYXBJbkV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTbmFwRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU25hcEV2ZW50LnR5cGUgPSAnc25hcCc7XHJcbmNsYXNzIFNuYXBJbkV2ZW50IGV4dGVuZHMgU25hcEV2ZW50IHt9XHJcblxyXG5leHBvcnRzLlNuYXBJbkV2ZW50ID0gU25hcEluRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNuYXAgb3V0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNuYXBPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU25hcE91dEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU25hcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5TbmFwSW5FdmVudC50eXBlID0gJ3NuYXA6aW4nO1xyXG5TbmFwSW5FdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgU25hcE91dEV2ZW50IGV4dGVuZHMgU25hcEV2ZW50IHt9XHJcbmV4cG9ydHMuU25hcE91dEV2ZW50ID0gU25hcE91dEV2ZW50O1xyXG5TbmFwT3V0RXZlbnQudHlwZSA9ICdzbmFwOm91dCc7XHJcblNuYXBPdXRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfU25hcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5cclxuT2JqZWN0LmtleXMoX1NuYXBwYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1NuYXBwYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9TbmFwcGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxuXHJcbnZhciBfU25hcHBhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NuYXBwYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX1NuYXBwYWJsZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25NaXJyb3JDcmVhdGVkID0gU3ltYm9sKCdvbk1pcnJvckNyZWF0ZWQnKTtcclxuY29uc3Qgb25NaXJyb3JEZXN0cm95ID0gU3ltYm9sKCdvbk1pcnJvckRlc3Ryb3knKTtcclxuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xyXG5jb25zdCByZXNpemUgPSBTeW1ib2woJ3Jlc2l6ZScpO1xyXG5cclxuLyoqXHJcbiAqIFJlc2l6ZU1pcnJvciBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgUmVzaXplTWlycm9yIHBsdWdpbiByZXNpemVzIHRoZSBtaXJyb3IgZWxlbWVudCB0byB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgdGhhdCB0aGUgbWlycm9yIGlzIGhvdmVyaW5nIG92ZXJcclxuICogQGNsYXNzIFJlc2l6ZU1pcnJvclxyXG4gKiBAbW9kdWxlIFJlc2l6ZU1pcnJvclxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgUmVzaXplTWlycm9yIGV4dGVuZHMgX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBSZXNpemVNaXJyb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgUmVzaXplTWlycm9yXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZU1pcnJvciBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVNaXJyb3IgcmVtZW1iZXJzIHRoZSBsYXN0IHdpZHRoIHdoZW4gcmVzaXppbmcgdGhlIG1pcnJvclxyXG4gICAgICogdG8gYXZvaWQgYWRkaXRpb25hbCB3cml0ZXMgdG8gdGhlIERPTVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxhc3RXaWR0aFxyXG4gICAgICovXHJcbiAgICB0aGlzLmxhc3RXaWR0aCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVNaXJyb3IgcmVtZW1iZXJzIHRoZSBsYXN0IGhlaWdodCB3aGVuIHJlc2l6aW5nIHRoZSBtaXJyb3JcclxuICAgICAqIHRvIGF2b2lkIGFkZGl0aW9uYWwgd3JpdGVzIHRvIHRoZSBET01cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsYXN0SGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdEhlaWdodCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgbWlycm9yIGVsZW1lbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IG1pcnJvclxyXG4gICAgICovXHJcbiAgICB0aGlzLm1pcnJvciA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvbk1pcnJvckNyZWF0ZWRdID0gdGhpc1tvbk1pcnJvckNyZWF0ZWRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTWlycm9yRGVzdHJveV0gPSB0aGlzW29uTWlycm9yRGVzdHJveV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnT3Zlcl0gPSB0aGlzW29uRHJhZ092ZXJdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdtaXJyb3I6Y3JlYXRlZCcsIHRoaXNbb25NaXJyb3JDcmVhdGVkXSkub24oJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9uKCdkcmFnOm92ZXI6Y29udGFpbmVyJywgdGhpc1tvbkRyYWdPdmVyXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9mZignbWlycm9yOmRlc3Ryb3knLCB0aGlzW29uTWlycm9yRGVzdHJveV0pLm9mZignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub2ZmKCdkcmFnOm92ZXI6Y29udGFpbmVyJywgdGhpc1tvbkRyYWdPdmVyXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldE9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5yZXNpemVNaXJyb3IgfHwge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNaXJyb3IgY3JlYXRlZCBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtNaXJyb3JDcmVhdGVkRXZlbnR9IG1pcnJvckV2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25NaXJyb3JDcmVhdGVkXSh7IG1pcnJvciB9KSB7XHJcbiAgICB0aGlzLm1pcnJvciA9IG1pcnJvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1pcnJvciBkZXN0cm95IGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge01pcnJvckRlc3Ryb3lFdmVudH0gbWlycm9yRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbk1pcnJvckRlc3Ryb3ldKCkge1xyXG4gICAgdGhpcy5taXJyb3IgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBvdmVyIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnQgfCBEcmFnT3ZlckNvbnRhaW5lcn0gZHJhZ0V2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25EcmFnT3Zlcl0oZHJhZ0V2ZW50KSB7XHJcbiAgICB0aGlzW3Jlc2l6ZV0oZHJhZ0V2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2l6ZSBmdW5jdGlvbiBmb3JcclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnQgfCBEcmFnT3ZlckNvbnRhaW5lcn0gZHJhZ0V2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbcmVzaXplXSh7IG92ZXJDb250YWluZXIsIG92ZXIgfSkge1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgaWYgKHRoaXMubWlycm9yLnBhcmVudE5vZGUgIT09IG92ZXJDb250YWluZXIpIHtcclxuICAgICAgICBvdmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubWlycm9yKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3Qgb3ZlckVsZW1lbnQgPSBvdmVyIHx8IHRoaXMuZHJhZ2dhYmxlLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpWzBdO1xyXG5cclxuICAgICAgaWYgKCFvdmVyRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgKDAsIF91dGlscy5yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lKSgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb3ZlclJlY3QgPSBvdmVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubGFzdEhlaWdodCA9PT0gb3ZlclJlY3QuaGVpZ2h0ICYmIHRoaXMubGFzdFdpZHRoID09PSBvdmVyUmVjdC53aWR0aCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5taXJyb3Iuc3R5bGUud2lkdGggPSBgJHtvdmVyUmVjdC53aWR0aH1weGA7XHJcbiAgICAgICAgdGhpcy5taXJyb3Iuc3R5bGUuaGVpZ2h0ID0gYCR7b3ZlclJlY3QuaGVpZ2h0fXB4YDtcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0V2lkdGggPSBvdmVyUmVjdC53aWR0aDtcclxuICAgICAgICB0aGlzLmxhc3RIZWlnaHQgPSBvdmVyUmVjdC5oZWlnaHQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJlc2l6ZU1pcnJvcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfUmVzaXplTWlycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcblxyXG52YXIgX1Jlc2l6ZU1pcnJvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZXNpemVNaXJyb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9SZXNpemVNaXJyb3IyLmRlZmF1bHQ7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBfUmVzaXplTWlycm9yLmRlZmF1bHRPcHRpb25zO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0UGx1Z2luKTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxudmFyIF9Db2xsaWRhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uRHJhZ01vdmUgPSBTeW1ib2woJ29uRHJhZ01vdmUnKTtcclxuY29uc3Qgb25EcmFnU3RvcCA9IFN5bWJvbCgnb25EcmFnU3RvcCcpO1xyXG5jb25zdCBvblJlcXVlc3RBbmltYXRpb25GcmFtZSA9IFN5bWJvbCgnb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKTtcclxuXHJcbi8qKlxyXG4gKiBDb2xsaWRhYmxlIHBsdWdpbiB3aGljaCBkZXRlY3RzIGNvbGxpZGluZyBlbGVtZW50cyB3aGlsZSBkcmFnZ2luZ1xyXG4gKiBAY2xhc3MgQ29sbGlkYWJsZVxyXG4gKiBAbW9kdWxlIENvbGxpZGFibGVcclxuICogQGV4dGVuZHMgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIENvbGxpZGFibGUgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIENvbGxpZGFibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgQ29sbGlkYWJsZVxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIHN1cGVyKGRyYWdnYWJsZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZWVwcyB0cmFjayBvZiBjdXJyZW50bHkgY29sbGlkaW5nIGVsZW1lbnRzXHJcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fG51bGx9IGN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnRcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2VlcHMgdHJhY2sgb2YgY3VycmVudGx5IGNvbGxpZGluZyBlbGVtZW50c1xyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxudWxsfSBsYXN0Q29sbGlkaW5nRWxlbWVudFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW5pbWF0aW9uIGZyYW1lIGZvciBmaW5kaW5nIGNvbGxpZGluZyBlbGVtZW50c1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8bnVsbH0gY3VycmVudEFuaW1hdGlvbkZyYW1lXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25SZXF1ZXN0QW5pbWF0aW9uRnJhbWVdID0gdGhpc1tvblJlcXVlc3RBbmltYXRpb25GcmFtZV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHBsdWdpbnMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjdXJyZW50IGNvbGxpZGFibGVzIGJhc2VkIG9uIGBjb2xsaWRhYmxlc2Agb3B0aW9uXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnRbXX1cclxuICAgKi9cclxuICBnZXRDb2xsaWRhYmxlcygpIHtcclxuICAgIGNvbnN0IGNvbGxpZGFibGVzID0gdGhpcy5kcmFnZ2FibGUub3B0aW9ucy5jb2xsaWRhYmxlcztcclxuXHJcbiAgICBpZiAodHlwZW9mIGNvbGxpZGFibGVzID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChjb2xsaWRhYmxlcykpO1xyXG4gICAgfSBlbHNlIGlmIChjb2xsaWRhYmxlcyBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGNvbGxpZGFibGVzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbGxpZGFibGVzKTtcclxuICAgIH0gZWxzZSBpZiAoY29sbGlkYWJsZXMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gW2NvbGxpZGFibGVzXTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbGxpZGFibGVzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHJldHVybiBjb2xsaWRhYmxlcygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ01vdmVFdmVudH0gZXZlbnQgLSBEcmFnIG1vdmUgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnTW92ZV0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnNlbnNvckV2ZW50LnRhcmdldDtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzW29uUmVxdWVzdEFuaW1hdGlvbkZyYW1lXSh0YXJnZXQpKTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50KSB7XHJcbiAgICAgIGV2ZW50LmNhbmNlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbGxpZGFibGVJbkV2ZW50ID0gbmV3IF9Db2xsaWRhYmxlRXZlbnQuQ29sbGlkYWJsZUluRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBjb2xsaWRpbmdFbGVtZW50OiB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnRcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGNvbGxpZGFibGVPdXRFdmVudCA9IG5ldyBfQ29sbGlkYWJsZUV2ZW50LkNvbGxpZGFibGVPdXRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGNvbGxpZGluZ0VsZW1lbnQ6IHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnRcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGVudGVyaW5nQ29sbGlkYWJsZSA9IEJvb2xlYW4odGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ICYmIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgIT09IHRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCk7XHJcbiAgICBjb25zdCBsZWF2aW5nQ29sbGlkYWJsZSA9IEJvb2xlYW4oIXRoaXMuY3VycmVudGx5Q29sbGlkaW5nRWxlbWVudCAmJiB0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50KTtcclxuXHJcbiAgICBpZiAoZW50ZXJpbmdDb2xsaWRhYmxlKSB7XHJcbiAgICAgIGlmICh0aGlzLmxhc3RDb2xsaWRpbmdFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKGNvbGxpZGFibGVJbkV2ZW50KTtcclxuICAgIH0gZWxzZSBpZiAobGVhdmluZ0NvbGxpZGFibGUpIHtcclxuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgPSB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0b3AgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RvcEV2ZW50fSBldmVudCAtIERyYWcgc3RvcCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdG9wXShldmVudCkge1xyXG4gICAgY29uc3QgbGFzdENvbGxpZGluZ0VsZW1lbnQgPSB0aGlzLmN1cnJlbnRseUNvbGxpZGluZ0VsZW1lbnQgfHwgdGhpcy5sYXN0Q29sbGlkaW5nRWxlbWVudDtcclxuICAgIGNvbnN0IGNvbGxpZGFibGVPdXRFdmVudCA9IG5ldyBfQ29sbGlkYWJsZUV2ZW50LkNvbGxpZGFibGVPdXRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGNvbGxpZGluZ0VsZW1lbnQ6IGxhc3RDb2xsaWRpbmdFbGVtZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAobGFzdENvbGxpZGluZ0VsZW1lbnQpIHtcclxuICAgICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihjb2xsaWRhYmxlT3V0RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGFzdENvbGxpZGluZ0VsZW1lbnQgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuaW1hdGlvbiBmcmFtZSBmdW5jdGlvblxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gQ3VycmVudCBtb3ZlIHRhcmdldFxyXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxyXG4gICAqL1xyXG4gIFtvblJlcXVlc3RBbmltYXRpb25GcmFtZV0odGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBjb2xsaWRhYmxlcyA9IHRoaXMuZ2V0Q29sbGlkYWJsZXMoKTtcclxuICAgICAgdGhpcy5jdXJyZW50bHlDb2xsaWRpbmdFbGVtZW50ID0gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIGVsZW1lbnQgPT4gY29sbGlkYWJsZXMuaW5jbHVkZXMoZWxlbWVudCkpO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29sbGlkYWJsZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5Db2xsaWRhYmxlT3V0RXZlbnQgPSBleHBvcnRzLkNvbGxpZGFibGVJbkV2ZW50ID0gZXhwb3J0cy5Db2xsaWRhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIGNvbGxpZGFibGUgZXZlbnRcclxuICogQGNsYXNzIENvbGxpZGFibGVFdmVudFxyXG4gKiBAbW9kdWxlIENvbGxpZGFibGVFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBDb2xsaWRhYmxlRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjb2xsaWFibGUgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgZHJhZ0V2ZW50XHJcbiAgICogQHR5cGUge0RyYWdFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ0V2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkNvbGxpZGFibGVFdmVudCA9IENvbGxpZGFibGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb2xsaWRhYmxlIGluIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgQ29sbGlkYWJsZUluRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgQ29sbGlkYWJsZUluRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIENvbGxpZGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Db2xsaWRhYmxlRXZlbnQudHlwZSA9ICdjb2xsaWRhYmxlJztcclxuY2xhc3MgQ29sbGlkYWJsZUluRXZlbnQgZXh0ZW5kcyBDb2xsaWRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBFbGVtZW50IHlvdSBhcmUgY3VycmVudGx5IGNvbGxpZGluZyB3aXRoXHJcbiAgICogQHByb3BlcnR5IGNvbGxpZGluZ0VsZW1lbnRcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGNvbGxpZGluZ0VsZW1lbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNvbGxpZGluZ0VsZW1lbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkNvbGxpZGFibGVJbkV2ZW50ID0gQ29sbGlkYWJsZUluRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbGxpZGFibGUgb3V0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIENvbGxpZGFibGVPdXRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgQ29sbGlkYWJsZU91dEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgQ29sbGlkYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Db2xsaWRhYmxlSW5FdmVudC50eXBlID0gJ2NvbGxpZGFibGU6aW4nO1xyXG5jbGFzcyBDb2xsaWRhYmxlT3V0RXZlbnQgZXh0ZW5kcyBDb2xsaWRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBFbGVtZW50IHlvdSB3ZXJlIHByZXZpb3VzbHkgY29sbGlkaW5nIHdpdGhcclxuICAgKiBAcHJvcGVydHkgY29sbGlkaW5nRWxlbWVudFxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgY29sbGlkaW5nRWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuY29sbGlkaW5nRWxlbWVudDtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5Db2xsaWRhYmxlT3V0RXZlbnQgPSBDb2xsaWRhYmxlT3V0RXZlbnQ7XHJcbkNvbGxpZGFibGVPdXRFdmVudC50eXBlID0gJ2NvbGxpZGFibGU6b3V0JztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfQ29sbGlkYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHJcbk9iamVjdC5rZXlzKF9Db2xsaWRhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfQ29sbGlkYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9Db2xsaWRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcblxyXG52YXIgX0NvbGxpZGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29sbGlkYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0NvbGxpZGFibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0NvbGxpZGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQ29sbGlkYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbGxpZGFibGUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfUmVzaXplTWlycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1Jlc2l6ZU1pcnJvcicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Jlc2l6ZU1pcnJvcikuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2RlZmF1bHRSZXNpemVNaXJyb3JPcHRpb25zJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX1Jlc2l6ZU1pcnJvci5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9TbmFwcGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU25hcHBhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU25hcHBhYmxlKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1N3YXBBbmltYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU3dhcEFuaW1hdGlvbicsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N3YXBBbmltYXRpb24pLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdkZWZhdWx0U3dhcEFuaW1hdGlvbk9wdGlvbnMnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfU3dhcEFuaW1hdGlvbi5kZWZhdWx0T3B0aW9ucztcclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0RyYWdnYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG52YXIgX0RyYWdnYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnZ2FibGUpO1xyXG5cclxudmFyIF9Tb3J0YWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnT3ZlckNvbnRhaW5lciA9IFN5bWJvbCgnb25EcmFnT3ZlckNvbnRhaW5lcicpO1xyXG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFubm91bmNlbWVudCBtZXNzYWdlIHdoZW4gYSBEcmFnZ2FibGUgZWxlbWVudCBoYXMgYmVlbiBzb3J0ZWQgd2l0aCBhbm90aGVyIERyYWdnYWJsZSBlbGVtZW50XHJcbiAqIG9yIG1vdmVkIGludG8gYSBuZXcgY29udGFpbmVyXHJcbiAqIEBwYXJhbSB7U29ydGFibGVTb3J0ZWRFdmVudH0gc29ydGFibGVFdmVudFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBvblNvcnRhYmxlU29ydGVkRGVmYXVsdEFubm91bmNlbWVudCh7IGRyYWdFdmVudCB9KSB7XHJcbiAgY29uc3Qgc291cmNlVGV4dCA9IGRyYWdFdmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyYWdFdmVudC5zb3VyY2UuaWQgfHwgJ3NvcnRhYmxlIGVsZW1lbnQnO1xyXG5cclxuICBpZiAoZHJhZ0V2ZW50Lm92ZXIpIHtcclxuICAgIGNvbnN0IG92ZXJUZXh0ID0gZHJhZ0V2ZW50Lm92ZXIudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyYWdFdmVudC5vdmVyLmlkIHx8ICdzb3J0YWJsZSBlbGVtZW50JztcclxuICAgIGNvbnN0IGlzRm9sbG93aW5nID0gZHJhZ0V2ZW50LnNvdXJjZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihkcmFnRXZlbnQub3ZlcikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcclxuXHJcbiAgICBpZiAoaXNGb2xsb3dpbmcpIHtcclxuICAgICAgcmV0dXJuIGBQbGFjZWQgJHtzb3VyY2VUZXh0fSBhZnRlciAke292ZXJUZXh0fWA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gYFBsYWNlZCAke3NvdXJjZVRleHR9IGJlZm9yZSAke292ZXJUZXh0fWA7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIG5lZWQgdG8gZmlndXJlIG91dCBob3cgdG8gY29tcHV0ZSBjb250YWluZXIgbmFtZVxyXG4gICAgcmV0dXJuIGBQbGFjZWQgJHtzb3VyY2VUZXh0fSBpbnRvIGEgZGlmZmVyZW50IGNvbnRhaW5lcmA7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtPYmplY3R9IGRlZmF1bHRBbm5vdW5jZW1lbnRzXHJcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydzb3J0YWJsZTpzb3J0ZWQnXVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XHJcbiAgJ3NvcnRhYmxlOnNvcnRlZCc6IG9uU29ydGFibGVTb3J0ZWREZWZhdWx0QW5ub3VuY2VtZW50XHJcbn07XHJcblxyXG4vKipcclxuICogU29ydGFibGUgaXMgYnVpbHQgb24gdG9wIG9mIERyYWdnYWJsZSBhbmQgYWxsb3dzIHNvcnRpbmcgb2YgZHJhZ2dhYmxlIGVsZW1lbnRzLiBTb3J0YWJsZSB3aWxsIGtlZXBcclxuICogdHJhY2sgb2YgdGhlIG9yaWdpbmFsIGluZGV4IGFuZCBlbWl0cyB0aGUgbmV3IGluZGV4IGFzIHlvdSBkcmFnIG92ZXIgZHJhZ2dhYmxlIGVsZW1lbnRzLlxyXG4gKiBAY2xhc3MgU29ydGFibGVcclxuICogQG1vZHVsZSBTb3J0YWJsZVxyXG4gKiBAZXh0ZW5kcyBEcmFnZ2FibGVcclxuICovXHJcbmNsYXNzIFNvcnRhYmxlIGV4dGVuZHMgX0RyYWdnYWJsZTIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogU29ydGFibGUgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgU29ydGFibGVcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBTb3J0YWJsZSBjb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciBTb3J0YWJsZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihjb250YWluZXJzLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xyXG4gICAgICBhbm5vdW5jZW1lbnRzOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdEFubm91bmNlbWVudHMsIG9wdGlvbnMuYW5ub3VuY2VtZW50cyB8fCB7fSlcclxuICAgIH0pKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHN0YXJ0IGluZGV4IG9mIHNvdXJjZSBvbiBkcmFnIHN0YXJ0XHJcbiAgICAgKiBAcHJvcGVydHkgc3RhcnRJbmRleFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGFydEluZGV4ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHN0YXJ0IGNvbnRhaW5lciBvbiBkcmFnIHN0YXJ0XHJcbiAgICAgKiBAcHJvcGVydHkgc3RhcnRDb250YWluZXJcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGFydENvbnRhaW5lciA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdPdmVyQ29udGFpbmVyXSA9IHRoaXNbb25EcmFnT3ZlckNvbnRhaW5lcl0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnT3Zlcl0gPSB0aGlzW29uRHJhZ092ZXJdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6b3Zlcjpjb250YWluZXInLCB0aGlzW29uRHJhZ092ZXJDb250YWluZXJdKS5vbignZHJhZzpvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzdHJveXMgU29ydGFibGUgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuXHJcbiAgICB0aGlzLm9mZignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vZmYoJ2RyYWc6b3Zlcjpjb250YWluZXInLCB0aGlzW29uRHJhZ092ZXJDb250YWluZXJdKS5vZmYoJ2RyYWc6b3ZlcicsIHRoaXNbb25EcmFnT3Zlcl0pLm9mZignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaW5kZXggb2YgZWxlbWVudCB3aXRoaW4gaXRzIGNvbnRhaW5lciBkdXJpbmcgZHJhZyBvcGVyYXRpb24sIGkuZS4gZXhjbHVkaW5nIG1pcnJvciBhbmQgb3JpZ2luYWwgc291cmNlXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEFuIGVsZW1lbnRcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICovXHJcbiAgaW5kZXgoZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIoZWxlbWVudC5wYXJlbnROb2RlKS5pbmRleE9mKGVsZW1lbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdTdGFydEV2ZW50fSBldmVudCAtIERyYWcgc3RhcnQgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RhcnRdKGV2ZW50KSB7XHJcbiAgICB0aGlzLnN0YXJ0Q29udGFpbmVyID0gZXZlbnQuc291cmNlLnBhcmVudE5vZGU7XHJcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSB0aGlzLmluZGV4KGV2ZW50LnNvdXJjZSk7XHJcblxyXG4gICAgY29uc3Qgc29ydGFibGVTdGFydEV2ZW50ID0gbmV3IF9Tb3J0YWJsZUV2ZW50LlNvcnRhYmxlU3RhcnRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIHN0YXJ0SW5kZXg6IHRoaXMuc3RhcnRJbmRleCxcclxuICAgICAgc3RhcnRDb250YWluZXI6IHRoaXMuc3RhcnRDb250YWluZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVN0YXJ0RXZlbnQpO1xyXG5cclxuICAgIGlmIChzb3J0YWJsZVN0YXJ0RXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICBldmVudC5jYW5jZWwoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgb3ZlciBjb250YWluZXIgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnT3ZlckNvbnRhaW5lckV2ZW50fSBldmVudCAtIERyYWcgb3ZlciBjb250YWluZXIgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnT3ZlckNvbnRhaW5lcl0oZXZlbnQpIHtcclxuICAgIGlmIChldmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHNvdXJjZSwgb3Zlciwgb3ZlckNvbnRhaW5lciB9ID0gZXZlbnQ7XHJcbiAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuaW5kZXgoc291cmNlKTtcclxuXHJcbiAgICBjb25zdCBzb3J0YWJsZVNvcnRFdmVudCA9IG5ldyBfU29ydGFibGVFdmVudC5Tb3J0YWJsZVNvcnRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGN1cnJlbnRJbmRleDogb2xkSW5kZXgsXHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgb3ZlclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHNvcnRhYmxlU29ydEV2ZW50KTtcclxuXHJcbiAgICBpZiAoc29ydGFibGVTb3J0RXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpO1xyXG4gICAgY29uc3QgbW92ZXMgPSBtb3ZlKHsgc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyLCBjaGlsZHJlbiB9KTtcclxuXHJcbiAgICBpZiAoIW1vdmVzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IG9sZENvbnRhaW5lciwgbmV3Q29udGFpbmVyIH0gPSBtb3ZlcztcclxuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5pbmRleChldmVudC5zb3VyY2UpO1xyXG5cclxuICAgIGNvbnN0IHNvcnRhYmxlU29ydGVkRXZlbnQgPSBuZXcgX1NvcnRhYmxlRXZlbnQuU29ydGFibGVTb3J0ZWRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIG9sZEluZGV4LFxyXG4gICAgICBuZXdJbmRleCxcclxuICAgICAgb2xkQ29udGFpbmVyLFxyXG4gICAgICBuZXdDb250YWluZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVNvcnRlZEV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgb3ZlciBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnR9IGV2ZW50IC0gRHJhZyBvdmVyIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ092ZXJdKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQub3ZlciA9PT0gZXZlbnQub3JpZ2luYWxTb3VyY2UgfHwgZXZlbnQub3ZlciA9PT0gZXZlbnQuc291cmNlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHNvdXJjZSwgb3Zlciwgb3ZlckNvbnRhaW5lciB9ID0gZXZlbnQ7XHJcbiAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuaW5kZXgoc291cmNlKTtcclxuXHJcbiAgICBjb25zdCBzb3J0YWJsZVNvcnRFdmVudCA9IG5ldyBfU29ydGFibGVFdmVudC5Tb3J0YWJsZVNvcnRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIGN1cnJlbnRJbmRleDogb2xkSW5kZXgsXHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgb3ZlclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHNvcnRhYmxlU29ydEV2ZW50KTtcclxuXHJcbiAgICBpZiAoc29ydGFibGVTb3J0RXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldERyYWdnYWJsZUVsZW1lbnRzRm9yQ29udGFpbmVyKG92ZXJDb250YWluZXIpO1xyXG4gICAgY29uc3QgbW92ZXMgPSBtb3ZlKHsgc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyLCBjaGlsZHJlbiB9KTtcclxuXHJcbiAgICBpZiAoIW1vdmVzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IG9sZENvbnRhaW5lciwgbmV3Q29udGFpbmVyIH0gPSBtb3ZlcztcclxuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5pbmRleChzb3VyY2UpO1xyXG5cclxuICAgIGNvbnN0IHNvcnRhYmxlU29ydGVkRXZlbnQgPSBuZXcgX1NvcnRhYmxlRXZlbnQuU29ydGFibGVTb3J0ZWRFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIG9sZEluZGV4LFxyXG4gICAgICBuZXdJbmRleCxcclxuICAgICAgb2xkQ29udGFpbmVyLFxyXG4gICAgICBuZXdDb250YWluZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzb3J0YWJsZVNvcnRlZEV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RvcCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdTdG9wRXZlbnR9IGV2ZW50IC0gRHJhZyBzdG9wIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XHJcbiAgICBjb25zdCBzb3J0YWJsZVN0b3BFdmVudCA9IG5ldyBfU29ydGFibGVFdmVudC5Tb3J0YWJsZVN0b3BFdmVudCh7XHJcbiAgICAgIGRyYWdFdmVudDogZXZlbnQsXHJcbiAgICAgIG9sZEluZGV4OiB0aGlzLnN0YXJ0SW5kZXgsXHJcbiAgICAgIG5ld0luZGV4OiB0aGlzLmluZGV4KGV2ZW50LnNvdXJjZSksXHJcbiAgICAgIG9sZENvbnRhaW5lcjogdGhpcy5zdGFydENvbnRhaW5lcixcclxuICAgICAgbmV3Q29udGFpbmVyOiBldmVudC5zb3VyY2UucGFyZW50Tm9kZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHNvcnRhYmxlU3RvcEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBudWxsO1xyXG4gICAgdGhpcy5zdGFydENvbnRhaW5lciA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBTb3J0YWJsZTtcclxuZnVuY3Rpb24gaW5kZXgoZWxlbWVudCkge1xyXG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGVsZW1lbnQucGFyZW50Tm9kZS5jaGlsZHJlbiwgZWxlbWVudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vdmUoeyBzb3VyY2UsIG92ZXIsIG92ZXJDb250YWluZXIsIGNoaWxkcmVuIH0pIHtcclxuICBjb25zdCBlbXB0eU92ZXJDb250YWluZXIgPSAhY2hpbGRyZW4ubGVuZ3RoO1xyXG4gIGNvbnN0IGRpZmZlcmVudENvbnRhaW5lciA9IHNvdXJjZS5wYXJlbnROb2RlICE9PSBvdmVyQ29udGFpbmVyO1xyXG4gIGNvbnN0IHNhbWVDb250YWluZXIgPSBvdmVyICYmICFkaWZmZXJlbnRDb250YWluZXI7XHJcblxyXG4gIGlmIChlbXB0eU92ZXJDb250YWluZXIpIHtcclxuICAgIHJldHVybiBtb3ZlSW5zaWRlRW1wdHlDb250YWluZXIoc291cmNlLCBvdmVyQ29udGFpbmVyKTtcclxuICB9IGVsc2UgaWYgKHNhbWVDb250YWluZXIpIHtcclxuICAgIHJldHVybiBtb3ZlV2l0aGluQ29udGFpbmVyKHNvdXJjZSwgb3Zlcik7XHJcbiAgfSBlbHNlIGlmIChkaWZmZXJlbnRDb250YWluZXIpIHtcclxuICAgIHJldHVybiBtb3ZlT3V0c2lkZUNvbnRhaW5lcihzb3VyY2UsIG92ZXIsIG92ZXJDb250YWluZXIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vdmVJbnNpZGVFbXB0eUNvbnRhaW5lcihzb3VyY2UsIG92ZXJDb250YWluZXIpIHtcclxuICBjb25zdCBvbGRDb250YWluZXIgPSBzb3VyY2UucGFyZW50Tm9kZTtcclxuXHJcbiAgb3ZlckNvbnRhaW5lci5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG5cclxuICByZXR1cm4geyBvbGRDb250YWluZXIsIG5ld0NvbnRhaW5lcjogb3ZlckNvbnRhaW5lciB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBtb3ZlV2l0aGluQ29udGFpbmVyKHNvdXJjZSwgb3Zlcikge1xyXG4gIGNvbnN0IG9sZEluZGV4ID0gaW5kZXgoc291cmNlKTtcclxuICBjb25zdCBuZXdJbmRleCA9IGluZGV4KG92ZXIpO1xyXG5cclxuICBpZiAob2xkSW5kZXggPCBuZXdJbmRleCkge1xyXG4gICAgc291cmNlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNvdXJjZSwgb3Zlci5uZXh0RWxlbWVudFNpYmxpbmcpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzb3VyY2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc291cmNlLCBvdmVyKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7IG9sZENvbnRhaW5lcjogc291cmNlLnBhcmVudE5vZGUsIG5ld0NvbnRhaW5lcjogc291cmNlLnBhcmVudE5vZGUgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gbW92ZU91dHNpZGVDb250YWluZXIoc291cmNlLCBvdmVyLCBvdmVyQ29udGFpbmVyKSB7XHJcbiAgY29uc3Qgb2xkQ29udGFpbmVyID0gc291cmNlLnBhcmVudE5vZGU7XHJcblxyXG4gIGlmIChvdmVyKSB7XHJcbiAgICBvdmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNvdXJjZSwgb3Zlcik7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIG5lZWQgdG8gZmlndXJlIG91dCBwcm9wZXIgcG9zaXRpb25cclxuICAgIG92ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoc291cmNlKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7IG9sZENvbnRhaW5lciwgbmV3Q29udGFpbmVyOiBzb3VyY2UucGFyZW50Tm9kZSB9O1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuU29ydGFibGVTdG9wRXZlbnQgPSBleHBvcnRzLlNvcnRhYmxlU29ydGVkRXZlbnQgPSBleHBvcnRzLlNvcnRhYmxlU29ydEV2ZW50ID0gZXhwb3J0cy5Tb3J0YWJsZVN0YXJ0RXZlbnQgPSBleHBvcnRzLlNvcnRhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIHNvcnRhYmxlIGV2ZW50XHJcbiAqIEBjbGFzcyBTb3J0YWJsZUV2ZW50XHJcbiAqIEBtb2R1bGUgU29ydGFibGVFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBTb3J0YWJsZUV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBkcmFnIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgc29ydGFibGUgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgZHJhZ0V2ZW50XHJcbiAgICogQHR5cGUge0RyYWdFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ0V2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLlNvcnRhYmxlRXZlbnQgPSBTb3J0YWJsZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU29ydGFibGUgc3RhcnQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNvcnRhYmxlU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNvcnRhYmxlU3RhcnRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTb3J0YWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU29ydGFibGVFdmVudC50eXBlID0gJ3NvcnRhYmxlJztcclxuY2xhc3MgU29ydGFibGVTdGFydEV2ZW50IGV4dGVuZHMgU29ydGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGluZGV4IG9mIHNvdXJjZSBvbiBzb3J0YWJsZSBzdGFydFxyXG4gICAqIEBwcm9wZXJ0eSBzdGFydEluZGV4XHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc3RhcnRJbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc3RhcnRJbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGNvbnRhaW5lciBvbiBzb3J0YWJsZSBzdGFydFxyXG4gICAqIEBwcm9wZXJ0eSBzdGFydENvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc3RhcnRDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN0YXJ0Q29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Tb3J0YWJsZVN0YXJ0RXZlbnQgPSBTb3J0YWJsZVN0YXJ0RXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU29ydGFibGUgc29ydCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNvcnRhYmxlU29ydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNvcnRhYmxlU29ydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTb3J0YWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblNvcnRhYmxlU3RhcnRFdmVudC50eXBlID0gJ3NvcnRhYmxlOnN0YXJ0JztcclxuU29ydGFibGVTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBTb3J0YWJsZVNvcnRFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBJbmRleCBvZiBjdXJyZW50IGRyYWdnYWJsZSBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IGN1cnJlbnRJbmRleFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGN1cnJlbnRJbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuY3VycmVudEluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGVsZW1lbnQgeW91IGFyZSBob3ZlcmluZyBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9sZEluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciBlbGVtZW50IHlvdSBhcmUgaG92ZXJpbmcgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5uZXdJbmRleDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU29ydGFibGVTb3J0RXZlbnQgPSBTb3J0YWJsZVNvcnRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU29ydGFibGUgc29ydGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFNvcnRhYmxlU29ydGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNvcnRhYmxlU29ydGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTb3J0YWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Tb3J0YWJsZVNvcnRFdmVudC50eXBlID0gJ3NvcnRhYmxlOnNvcnQnO1xyXG5Tb3J0YWJsZVNvcnRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgU29ydGFibGVTb3J0ZWRFdmVudCBleHRlbmRzIFNvcnRhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBJbmRleCBvZiBsYXN0IHNvcnRlZCBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBvbGRJbmRleFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9sZEluZGV4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vbGRJbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5ldyBpbmRleCBvZiB0aGlzIHNvcnRlZCBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBuZXdJbmRleFxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG5ld0luZGV4KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5uZXdJbmRleDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9sZCBjb250YWluZXIgb2YgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgb2xkQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvbGRDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9sZENvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5ldyBjb250YWluZXIgb2YgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbmV3Q29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBuZXdDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0NvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU29ydGFibGVTb3J0ZWRFdmVudCA9IFNvcnRhYmxlU29ydGVkRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTb3J0YWJsZSBzdG9wIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTb3J0YWJsZVN0b3BFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFNvcnRhYmxlU3RvcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIFNvcnRhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Tb3J0YWJsZVNvcnRlZEV2ZW50LnR5cGUgPSAnc29ydGFibGU6c29ydGVkJztcclxuY2xhc3MgU29ydGFibGVTdG9wRXZlbnQgZXh0ZW5kcyBTb3J0YWJsZUV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgaW5kZXggb24gc29ydGFibGUgc3RhcnRcclxuICAgKiBAcHJvcGVydHkgb2xkSW5kZXhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvbGRJbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub2xkSW5kZXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOZXcgaW5kZXggb2YgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbmV3SW5kZXhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBuZXdJbmRleCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubmV3SW5kZXg7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBjb250YWluZXIgb2YgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgb2xkQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvbGRDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm9sZENvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5ldyBjb250YWluZXIgb2YgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbmV3Q29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBuZXdDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm5ld0NvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5Tb3J0YWJsZVN0b3BFdmVudCA9IFNvcnRhYmxlU3RvcEV2ZW50O1xyXG5Tb3J0YWJsZVN0b3BFdmVudC50eXBlID0gJ3NvcnRhYmxlOnN0b3AnO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Tb3J0YWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHJcbk9iamVjdC5rZXlzKF9Tb3J0YWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX1NvcnRhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX1NvcnRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XHJcblxyXG52YXIgX1NvcnRhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NvcnRhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfU29ydGFibGUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxudmFyIF9EcmFnZ2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxudmFyIF9EcmFnZ2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ2dhYmxlKTtcclxuXHJcbnZhciBfU3dhcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnT3ZlciA9IFN5bWJvbCgnb25EcmFnT3ZlcicpO1xyXG5jb25zdCBvbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBhbm5vdW5jZW1lbnQgbWVzc2FnZSB3aGVuIHRoZSBEcmFnZ2FibGUgZWxlbWVudCBpcyBzd2FwcGVkIHdpdGggYW5vdGhlciBkcmFnZ2FibGUgZWxlbWVudFxyXG4gKiBAcGFyYW0ge1N3YXBwYWJsZVN3YXBwZWRFdmVudH0gc3dhcHBhYmxlRXZlbnRcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gb25Td2FwcGFibGVTd2FwcGVkRGVmYXVsdEFubm91bmNlbWVudCh7IGRyYWdFdmVudCwgc3dhcHBlZEVsZW1lbnQgfSkge1xyXG4gIGNvbnN0IHNvdXJjZVRleHQgPSBkcmFnRXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcmFnRXZlbnQuc291cmNlLmlkIHx8ICdzd2FwcGFibGUgZWxlbWVudCc7XHJcbiAgY29uc3Qgb3ZlclRleHQgPSBzd2FwcGVkRWxlbWVudC50ZXh0Q29udGVudC50cmltKCkgfHwgc3dhcHBlZEVsZW1lbnQuaWQgfHwgJ3N3YXBwYWJsZSBlbGVtZW50JztcclxuXHJcbiAgcmV0dXJuIGBTd2FwcGVkICR7c291cmNlVGV4dH0gd2l0aCAke292ZXJUZXh0fWA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAY29uc3Qge09iamVjdH0gZGVmYXVsdEFubm91bmNlbWVudHNcclxuICogQGNvbnN0IHtGdW5jdGlvbn0gZGVmYXVsdEFubm91bmNlbWVudHNbJ3N3YXBwYWJsZWQ6c3dhcHBlZCddXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0QW5ub3VuY2VtZW50cyA9IHtcclxuICAnc3dhcHBhYmxlZDpzd2FwcGVkJzogb25Td2FwcGFibGVTd2FwcGVkRGVmYXVsdEFubm91bmNlbWVudFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN3YXBwYWJsZSBpcyBidWlsdCBvbiB0b3Agb2YgRHJhZ2dhYmxlIGFuZCBhbGxvd3Mgc3dhcHBpbmcgb2YgZHJhZ2dhYmxlIGVsZW1lbnRzLlxyXG4gKiBPcmRlciBpcyBpcnJlbGV2YW50IHRvIFN3YXBwYWJsZS5cclxuICogQGNsYXNzIFN3YXBwYWJsZVxyXG4gKiBAbW9kdWxlIFN3YXBwYWJsZVxyXG4gKiBAZXh0ZW5kcyBEcmFnZ2FibGVcclxuICovXHJcbmNsYXNzIFN3YXBwYWJsZSBleHRlbmRzIF9EcmFnZ2FibGUyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIFN3YXBwYWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBTd2FwcGFibGVcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBTd2FwcGFibGUgY29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgU3dhcHBhYmxlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtdLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKGNvbnRhaW5lcnMsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XHJcbiAgICAgIGFubm91bmNlbWVudHM6IF9leHRlbmRzKHt9LCBkZWZhdWx0QW5ub3VuY2VtZW50cywgb3B0aW9ucy5hbm5vdW5jZW1lbnRzIHx8IHt9KVxyXG4gICAgfSkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGFzdCBkcmFnZ2FibGUgZWxlbWVudCB0aGF0IHdhcyBkcmFnZ2VkIG92ZXJcclxuICAgICAqIEBwcm9wZXJ0eSBsYXN0T3ZlclxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxhc3RPdmVyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ092ZXJdID0gdGhpc1tvbkRyYWdPdmVyXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLm9uKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9uKCdkcmFnOm92ZXInLCB0aGlzW29uRHJhZ092ZXJdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95cyBTd2FwcGFibGUgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuXHJcbiAgICB0aGlzLm9mZignZHJhZzpzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KS5vZmYoJ2RyYWc6b3ZlcicsIHRoaXMuX29uRHJhZ092ZXIpLm9mZignZHJhZzpzdG9wJywgdGhpcy5fb25EcmFnU3RvcCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHN0YXJ0IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0YXJ0RXZlbnR9IGV2ZW50IC0gRHJhZyBzdGFydCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHN3YXBwYWJsZVN0YXJ0RXZlbnQgPSBuZXcgX1N3YXBwYWJsZUV2ZW50LlN3YXBwYWJsZVN0YXJ0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoc3dhcHBhYmxlU3RhcnRFdmVudCk7XHJcblxyXG4gICAgaWYgKHN3YXBwYWJsZVN0YXJ0RXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICBldmVudC5jYW5jZWwoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgb3ZlciBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdPdmVyRXZlbnR9IGV2ZW50IC0gRHJhZyBvdmVyIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ092ZXJdKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQub3ZlciA9PT0gZXZlbnQub3JpZ2luYWxTb3VyY2UgfHwgZXZlbnQub3ZlciA9PT0gZXZlbnQuc291cmNlIHx8IGV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN3YXBwYWJsZVN3YXBFdmVudCA9IG5ldyBfU3dhcHBhYmxlRXZlbnQuU3dhcHBhYmxlU3dhcEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgb3ZlcjogZXZlbnQub3ZlcixcclxuICAgICAgb3ZlckNvbnRhaW5lcjogZXZlbnQub3ZlckNvbnRhaW5lclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHN3YXBwYWJsZVN3YXBFdmVudCk7XHJcblxyXG4gICAgaWYgKHN3YXBwYWJsZVN3YXBFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzd2FwIG9yaWdpbmFsbHkgc3dhcHBlZCBlbGVtZW50IGJhY2tcclxuICAgIGlmICh0aGlzLmxhc3RPdmVyICYmIHRoaXMubGFzdE92ZXIgIT09IGV2ZW50Lm92ZXIpIHtcclxuICAgICAgc3dhcCh0aGlzLmxhc3RPdmVyLCBldmVudC5zb3VyY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmxhc3RPdmVyID09PSBldmVudC5vdmVyKSB7XHJcbiAgICAgIHRoaXMubGFzdE92ZXIgPSBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5sYXN0T3ZlciA9IGV2ZW50Lm92ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgc3dhcChldmVudC5zb3VyY2UsIGV2ZW50Lm92ZXIpO1xyXG5cclxuICAgIGNvbnN0IHN3YXBwYWJsZVN3YXBwZWRFdmVudCA9IG5ldyBfU3dhcHBhYmxlRXZlbnQuU3dhcHBhYmxlU3dhcHBlZEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgc3dhcHBlZEVsZW1lbnQ6IGV2ZW50Lm92ZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihzd2FwcGFibGVTd2FwcGVkRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdG9wIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0b3BFdmVudH0gZXZlbnQgLSBEcmFnIHN0b3AgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RvcF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHN3YXBwYWJsZVN0b3BFdmVudCA9IG5ldyBfU3dhcHBhYmxlRXZlbnQuU3dhcHBhYmxlU3RvcEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHN3YXBwYWJsZVN0b3BFdmVudCk7XHJcbiAgICB0aGlzLmxhc3RPdmVyID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IFN3YXBwYWJsZTtcclxuZnVuY3Rpb24gd2l0aFRlbXBFbGVtZW50KGNhbGxiYWNrKSB7XHJcbiAgY29uc3QgdG1wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gIGNhbGxiYWNrKHRtcEVsZW1lbnQpO1xyXG4gIHRtcEVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0bXBFbGVtZW50KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3dhcChzb3VyY2UsIG92ZXIpIHtcclxuICBjb25zdCBvdmVyUGFyZW50ID0gb3Zlci5wYXJlbnROb2RlO1xyXG4gIGNvbnN0IHNvdXJjZVBhcmVudCA9IHNvdXJjZS5wYXJlbnROb2RlO1xyXG5cclxuICB3aXRoVGVtcEVsZW1lbnQodG1wRWxlbWVudCA9PiB7XHJcbiAgICBzb3VyY2VQYXJlbnQuaW5zZXJ0QmVmb3JlKHRtcEVsZW1lbnQsIHNvdXJjZSk7XHJcbiAgICBvdmVyUGFyZW50Lmluc2VydEJlZm9yZShzb3VyY2UsIG92ZXIpO1xyXG4gICAgc291cmNlUGFyZW50Lmluc2VydEJlZm9yZShvdmVyLCB0bXBFbGVtZW50KTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLlN3YXBwYWJsZVN0b3BFdmVudCA9IGV4cG9ydHMuU3dhcHBhYmxlU3dhcHBlZEV2ZW50ID0gZXhwb3J0cy5Td2FwcGFibGVTd2FwRXZlbnQgPSBleHBvcnRzLlN3YXBwYWJsZVN0YXJ0RXZlbnQgPSBleHBvcnRzLlN3YXBwYWJsZUV2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogQmFzZSBzd2FwcGFibGUgZXZlbnRcclxuICogQGNsYXNzIFN3YXBwYWJsZUV2ZW50XHJcbiAqIEBtb2R1bGUgU3dhcHBhYmxlRXZlbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgU3dhcHBhYmxlRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIGRyYWcgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBzd2FwcGFibGUgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgZHJhZ0V2ZW50XHJcbiAgICogQHR5cGUge0RyYWdFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ0V2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLlN3YXBwYWJsZUV2ZW50ID0gU3dhcHBhYmxlRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFN3YXBwYWJsZSBzdGFydCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTd2FwcGFibGVTdGFydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBTd2FwcGFibGVTdGFydEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU3dhcHBhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblN3YXBwYWJsZUV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlJztcclxuY2xhc3MgU3dhcHBhYmxlU3RhcnRFdmVudCBleHRlbmRzIFN3YXBwYWJsZUV2ZW50IHt9XHJcblxyXG5leHBvcnRzLlN3YXBwYWJsZVN0YXJ0RXZlbnQgPSBTd2FwcGFibGVTdGFydEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3dhcHBhYmxlIHN3YXAgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIFN3YXBwYWJsZVN3YXBFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFN3YXBwYWJsZVN3YXBFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTd2FwcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblN3YXBwYWJsZVN0YXJ0RXZlbnQudHlwZSA9ICdzd2FwcGFibGU6c3RhcnQnO1xyXG5Td2FwcGFibGVTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBTd2FwcGFibGVTd2FwRXZlbnQgZXh0ZW5kcyBTd2FwcGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBlbGVtZW50IHlvdSBhcmUgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgYXJlIG92ZXJcclxuICAgKiBAcHJvcGVydHkgb3ZlckNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlckNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlckNvbnRhaW5lcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuU3dhcHBhYmxlU3dhcEV2ZW50ID0gU3dhcHBhYmxlU3dhcEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFN3YXBwYWJsZSBzd2FwcGVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgU3dhcHBhYmxlU3dhcHBlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIFN3YXBwYWJsZVN3YXBwZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU3dhcHBhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuU3dhcHBhYmxlU3dhcEV2ZW50LnR5cGUgPSAnc3dhcHBhYmxlOnN3YXAnO1xyXG5Td2FwcGFibGVTd2FwRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIFN3YXBwYWJsZVN3YXBwZWRFdmVudCBleHRlbmRzIFN3YXBwYWJsZUV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRyYWdnYWJsZSBlbGVtZW50IHRoYXQgeW91IHN3YXBwZWQgd2l0aFxyXG4gICAqIEBwcm9wZXJ0eSBzd2FwcGVkRWxlbWVudFxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc3dhcHBlZEVsZW1lbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnN3YXBwZWRFbGVtZW50O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Td2FwcGFibGVTd2FwcGVkRXZlbnQgPSBTd2FwcGFibGVTd2FwcGVkRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3dhcHBhYmxlIHN0b3AgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBTd2FwcGFibGVTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgU3dhcHBhYmxlU3RvcEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTd2FwcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Td2FwcGFibGVTd2FwcGVkRXZlbnQudHlwZSA9ICdzd2FwcGFibGU6c3dhcHBlZCc7XHJcbmNsYXNzIFN3YXBwYWJsZVN0b3BFdmVudCBleHRlbmRzIFN3YXBwYWJsZUV2ZW50IHt9XHJcbmV4cG9ydHMuU3dhcHBhYmxlU3RvcEV2ZW50ID0gU3dhcHBhYmxlU3RvcEV2ZW50O1xyXG5Td2FwcGFibGVTdG9wRXZlbnQudHlwZSA9ICdzd2FwcGFibGU6c3RvcCc7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1N3YXBwYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblxyXG5PYmplY3Qua2V5cyhfU3dhcHBhYmxlRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfU3dhcHBhYmxlRXZlbnRba2V5XTtcclxuICAgIH1cclxuICB9KTtcclxufSk7XHJcblxyXG52YXIgX1N3YXBwYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xyXG5cclxudmFyIF9Td2FwcGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3dhcHBhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfU3dhcHBhYmxlMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxudmFyIF9EcmFnZ2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxudmFyIF9EcmFnZ2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZ2dhYmxlKTtcclxuXHJcbnZhciBfRHJvcHBhYmxlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkRyYWdTdGFydCA9IFN5bWJvbCgnb25EcmFnU3RhcnQnKTtcclxuY29uc3Qgb25EcmFnTW92ZSA9IFN5bWJvbCgnb25EcmFnTW92ZScpO1xyXG5jb25zdCBvbkRyYWdTdG9wID0gU3ltYm9sKCdvbkRyYWdTdG9wJyk7XHJcbmNvbnN0IGRyb3BJbkRyb3B6b25lID0gU3ltYm9sKCdkcm9wSW5Ecm9wWm9uZScpO1xyXG5jb25zdCByZXR1cm5Ub09yaWdpbmFsRHJvcHpvbmUgPSBTeW1ib2woJ3JldHVyblRvT3JpZ2luYWxEcm9wem9uZScpO1xyXG5jb25zdCBjbG9zZXN0RHJvcHpvbmUgPSBTeW1ib2woJ2Nsb3Nlc3REcm9wem9uZScpO1xyXG5jb25zdCBnZXREcm9wem9uZXMgPSBTeW1ib2woJ2dldERyb3B6b25lcycpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYW5ub3VuY2VtZW50IG1lc3NhZ2Ugd2hlbiB0aGUgRHJhZ2dhYmxlIGVsZW1lbnQgaXMgZHJvcHBlZCBpbnRvIGEgZHJvcHpvbmUgZWxlbWVudFxyXG4gKiBAcGFyYW0ge0Ryb3BwYWJsZURyb3BwZWRFdmVudH0gZHJvcHBhYmxlRXZlbnRcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gb25Ecm9wcGFibGVEcm9wcGVkRGVmYXVsdEFubm91bmNlbWVudCh7IGRyYWdFdmVudCwgZHJvcHpvbmUgfSkge1xyXG4gIGNvbnN0IHNvdXJjZVRleHQgPSBkcmFnRXZlbnQuc291cmNlLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcmFnRXZlbnQuc291cmNlLmlkIHx8ICdkcmFnZ2FibGUgZWxlbWVudCc7XHJcbiAgY29uc3QgZHJvcHpvbmVUZXh0ID0gZHJvcHpvbmUudGV4dENvbnRlbnQudHJpbSgpIHx8IGRyb3B6b25lLmlkIHx8ICdkcm9wcGFibGUgZWxlbWVudCc7XHJcblxyXG4gIHJldHVybiBgRHJvcHBlZCAke3NvdXJjZVRleHR9IGludG8gJHtkcm9wem9uZVRleHR9YDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYW5ub3VuY2VtZW50IG1lc3NhZ2Ugd2hlbiB0aGUgRHJhZ2dhYmxlIGVsZW1lbnQgaGFzIHJldHVybmVkIHRvIGl0cyBvcmlnaW5hbCBkcm9wem9uZSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7RHJvcHBhYmxlUmV0dXJuZWRFdmVudH0gZHJvcHBhYmxlRXZlbnRcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gb25Ecm9wcGFibGVSZXR1cm5lZERlZmF1bHRBbm5vdW5jZW1lbnQoeyBkcmFnRXZlbnQsIGRyb3B6b25lIH0pIHtcclxuICBjb25zdCBzb3VyY2VUZXh0ID0gZHJhZ0V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZHJhZ0V2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnO1xyXG4gIGNvbnN0IGRyb3B6b25lVGV4dCA9IGRyb3B6b25lLnRleHRDb250ZW50LnRyaW0oKSB8fCBkcm9wem9uZS5pZCB8fCAnZHJvcHBhYmxlIGVsZW1lbnQnO1xyXG5cclxuICByZXR1cm4gYFJldHVybmVkICR7c291cmNlVGV4dH0gZnJvbSAke2Ryb3B6b25lVGV4dH1gO1xyXG59XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtPYmplY3R9IGRlZmF1bHRBbm5vdW5jZW1lbnRzXHJcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydkcm9wcGFibGU6ZHJvcHBlZCddXHJcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydkcm9wcGFibGU6cmV0dXJuZWQnXVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XHJcbiAgJ2Ryb3BwYWJsZTpkcm9wcGVkJzogb25Ecm9wcGFibGVEcm9wcGVkRGVmYXVsdEFubm91bmNlbWVudCxcclxuICAnZHJvcHBhYmxlOnJldHVybmVkJzogb25Ecm9wcGFibGVSZXR1cm5lZERlZmF1bHRBbm5vdW5jZW1lbnRcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRDbGFzc2VzID0ge1xyXG4gICdkcm9wcGFibGU6YWN0aXZlJzogJ2RyYWdnYWJsZS1kcm9wem9uZS0tYWN0aXZlJyxcclxuICAnZHJvcHBhYmxlOm9jY3VwaWVkJzogJ2RyYWdnYWJsZS1kcm9wem9uZS0tb2NjdXBpZWQnXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcclxuICBkcm9wem9uZTogJy5kcmFnZ2FibGUtZHJvcHBhYmxlJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERyb3BwYWJsZSBpcyBidWlsdCBvbiB0b3Agb2YgRHJhZ2dhYmxlIGFuZCBhbGxvd3MgZHJvcHBpbmcgZHJhZ2dhYmxlIGVsZW1lbnRzXHJcbiAqIGludG8gZHJvcHpvbmUgZWxlbWVudFxyXG4gKiBAY2xhc3MgRHJvcHBhYmxlXHJcbiAqIEBtb2R1bGUgRHJvcHBhYmxlXHJcbiAqIEBleHRlbmRzIERyYWdnYWJsZVxyXG4gKi9cclxuY2xhc3MgRHJvcHBhYmxlIGV4dGVuZHMgX0RyYWdnYWJsZTIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogRHJvcHBhYmxlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIERyb3BwYWJsZVxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIERyb3BwYWJsZSBjb250YWluZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciBEcm9wcGFibGVcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zLCB7XHJcbiAgICAgIGNsYXNzZXM6IF9leHRlbmRzKHt9LCBkZWZhdWx0Q2xhc3Nlcywgb3B0aW9ucy5jbGFzc2VzIHx8IHt9KSxcclxuICAgICAgYW5ub3VuY2VtZW50czogX2V4dGVuZHMoe30sIGRlZmF1bHRBbm5vdW5jZW1lbnRzLCBvcHRpb25zLmFubm91bmNlbWVudHMgfHwge30pXHJcbiAgICB9KSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgZHJvcHpvbmUgZWxlbWVudHMgb24gZHJhZyBzdGFydFxyXG4gICAgICogQHByb3BlcnR5IGRyb3B6b25lc1xyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJvcHpvbmVzID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExhc3QgZHJvcHpvbmUgZWxlbWVudCB0aGF0IHRoZSBzb3VyY2Ugd2FzIGRyb3BwZWQgaW50b1xyXG4gICAgICogQHByb3BlcnR5IGxhc3REcm9wem9uZVxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxhc3REcm9wem9uZSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsIGRyb3B6b25lIGVsZW1lbnQgdGhhdCB0aGUgc291cmNlIHdhcyBkcmFnIGZyb21cclxuICAgICAqIEBwcm9wZXJ0eSBpbml0aWFsRHJvcHpvbmVcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5pbml0aWFsRHJvcHpvbmUgPSBudWxsO1xyXG5cclxuICAgIHRoaXNbb25EcmFnU3RhcnRdID0gdGhpc1tvbkRyYWdTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnTW92ZV0gPSB0aGlzW29uRHJhZ01vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0b3BdID0gdGhpc1tvbkRyYWdTdG9wXS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIHRoaXMub24oJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub24oJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0pLm9uKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3lzIERyb3BwYWJsZSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG5cclxuICAgIHRoaXMub2ZmKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9mZignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub2ZmKCdkcmFnOnN0b3AnLCB0aGlzW29uRHJhZ1N0b3BdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnU3RhcnRFdmVudH0gZXZlbnQgLSBEcmFnIHN0YXJ0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0YXJ0XShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZHJvcHpvbmVzID0gWy4uLnRoaXNbZ2V0RHJvcHpvbmVzXSgpXTtcclxuICAgIGNvbnN0IGRyb3B6b25lID0gKDAsIF91dGlscy5jbG9zZXN0KShldmVudC5zZW5zb3JFdmVudC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcm9wem9uZSk7XHJcblxyXG4gICAgaWYgKCFkcm9wem9uZSkge1xyXG4gICAgICBldmVudC5jYW5jZWwoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyb3BwYWJsZVN0YXJ0RXZlbnQgPSBuZXcgX0Ryb3BwYWJsZUV2ZW50LkRyb3BwYWJsZVN0YXJ0RXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBkcm9wem9uZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyb3BwYWJsZVN0YXJ0RXZlbnQpO1xyXG5cclxuICAgIGlmIChkcm9wcGFibGVTdGFydEV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgZXZlbnQuY2FuY2VsKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmluaXRpYWxEcm9wem9uZSA9IGRyb3B6b25lO1xyXG5cclxuICAgIGZvciAoY29uc3QgZHJvcHpvbmVFbGVtZW50IG9mIHRoaXMuZHJvcHpvbmVzKSB7XHJcbiAgICAgIGlmIChkcm9wem9uZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKSkpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZHJvcHpvbmVFbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5nZXRDbGFzc05hbWVGb3IoJ2Ryb3BwYWJsZTphY3RpdmUnKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG1vdmUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnTW92ZUV2ZW50fSBldmVudCAtIERyYWcgbW92ZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdNb3ZlXShldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRyb3B6b25lID0gdGhpc1tjbG9zZXN0RHJvcHpvbmVdKGV2ZW50LnNlbnNvckV2ZW50LnRhcmdldCk7XHJcbiAgICBjb25zdCBvdmVyRW1wdHlEcm9wem9uZSA9IGRyb3B6b25lICYmICFkcm9wem9uZS5jbGFzc0xpc3QuY29udGFpbnModGhpcy5nZXRDbGFzc05hbWVGb3IoJ2Ryb3BwYWJsZTpvY2N1cGllZCcpKTtcclxuXHJcbiAgICBpZiAob3ZlckVtcHR5RHJvcHpvbmUgJiYgdGhpc1tkcm9wSW5Ecm9wem9uZV0oZXZlbnQsIGRyb3B6b25lKSkge1xyXG4gICAgICB0aGlzLmxhc3REcm9wem9uZSA9IGRyb3B6b25lO1xyXG4gICAgfSBlbHNlIGlmICgoIWRyb3B6b25lIHx8IGRyb3B6b25lID09PSB0aGlzLmluaXRpYWxEcm9wem9uZSkgJiYgdGhpcy5sYXN0RHJvcHpvbmUpIHtcclxuICAgICAgdGhpc1tyZXR1cm5Ub09yaWdpbmFsRHJvcHpvbmVdKGV2ZW50KTtcclxuICAgICAgdGhpcy5sYXN0RHJvcHpvbmUgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdG9wIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RHJhZ1N0b3BFdmVudH0gZXZlbnQgLSBEcmFnIHN0b3AgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RvcF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IGRyb3BwYWJsZVN0b3BFdmVudCA9IG5ldyBfRHJvcHBhYmxlRXZlbnQuRHJvcHBhYmxlU3RvcEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgZHJvcHpvbmU6IHRoaXMubGFzdERyb3B6b25lIHx8IHRoaXMuaW5pdGlhbERyb3B6b25lXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJvcHBhYmxlU3RvcEV2ZW50KTtcclxuXHJcbiAgICBjb25zdCBvY2N1cGllZENsYXNzID0gdGhpcy5nZXRDbGFzc05hbWVGb3IoJ2Ryb3BwYWJsZTpvY2N1cGllZCcpO1xyXG5cclxuICAgIGZvciAoY29uc3QgZHJvcHpvbmUgb2YgdGhpcy5kcm9wem9uZXMpIHtcclxuICAgICAgZHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmdldENsYXNzTmFtZUZvcignZHJvcHBhYmxlOmFjdGl2ZScpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5sYXN0RHJvcHpvbmUgJiYgdGhpcy5sYXN0RHJvcHpvbmUgIT09IHRoaXMuaW5pdGlhbERyb3B6b25lKSB7XHJcbiAgICAgIHRoaXMuaW5pdGlhbERyb3B6b25lLmNsYXNzTGlzdC5yZW1vdmUob2NjdXBpZWRDbGFzcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kcm9wem9uZXMgPSBudWxsO1xyXG4gICAgdGhpcy5sYXN0RHJvcHpvbmUgPSBudWxsO1xyXG4gICAgdGhpcy5pbml0aWFsRHJvcHpvbmUgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJvcHMgYSBkcmFnZ2FibGUgZWxlbWVudCBpbnRvIGEgZHJvcHpvbmUgZWxlbWVudFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtEcmFnTW92ZUV2ZW50fSBldmVudCAtIERyYWcgbW92ZSBldmVudFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRyb3B6b25lIC0gRHJvcHpvbmUgZWxlbWVudCB0byBkcm9wIGRyYWdnYWJsZSBpbnRvXHJcbiAgICovXHJcbiAgW2Ryb3BJbkRyb3B6b25lXShldmVudCwgZHJvcHpvbmUpIHtcclxuICAgIGNvbnN0IGRyb3BwYWJsZURyb3BwZWRFdmVudCA9IG5ldyBfRHJvcHBhYmxlRXZlbnQuRHJvcHBhYmxlRHJvcHBlZEV2ZW50KHtcclxuICAgICAgZHJhZ0V2ZW50OiBldmVudCxcclxuICAgICAgZHJvcHpvbmVcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcm9wcGFibGVEcm9wcGVkRXZlbnQpO1xyXG5cclxuICAgIGlmIChkcm9wcGFibGVEcm9wcGVkRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb2NjdXBpZWRDbGFzcyA9IHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcm9wcGFibGU6b2NjdXBpZWQnKTtcclxuXHJcbiAgICBpZiAodGhpcy5sYXN0RHJvcHpvbmUpIHtcclxuICAgICAgdGhpcy5sYXN0RHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZShvY2N1cGllZENsYXNzKTtcclxuICAgIH1cclxuXHJcbiAgICBkcm9wem9uZS5hcHBlbmRDaGlsZChldmVudC5zb3VyY2UpO1xyXG4gICAgZHJvcHpvbmUuY2xhc3NMaXN0LmFkZChvY2N1cGllZENsYXNzKTtcclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdmVzIHRoZSBwcmV2aW91c2x5IGRyb3BwZWQgZWxlbWVudCBiYWNrIGludG8gaXRzIG9yaWdpbmFsIGRyb3B6b25lXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0RyYWdNb3ZlRXZlbnR9IGV2ZW50IC0gRHJhZyBtb3ZlIGV2ZW50XHJcbiAgICovXHJcbiAgW3JldHVyblRvT3JpZ2luYWxEcm9wem9uZV0oZXZlbnQpIHtcclxuICAgIGNvbnN0IGRyb3BwYWJsZVJldHVybmVkRXZlbnQgPSBuZXcgX0Ryb3BwYWJsZUV2ZW50LkRyb3BwYWJsZVJldHVybmVkRXZlbnQoe1xyXG4gICAgICBkcmFnRXZlbnQ6IGV2ZW50LFxyXG4gICAgICBkcm9wem9uZTogdGhpcy5sYXN0RHJvcHpvbmVcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcm9wcGFibGVSZXR1cm5lZEV2ZW50KTtcclxuXHJcbiAgICBpZiAoZHJvcHBhYmxlUmV0dXJuZWRFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmluaXRpYWxEcm9wem9uZS5hcHBlbmRDaGlsZChldmVudC5zb3VyY2UpO1xyXG4gICAgdGhpcy5sYXN0RHJvcHpvbmUuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmdldENsYXNzTmFtZUZvcignZHJvcHBhYmxlOm9jY3VwaWVkJykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBjbG9zZXN0IGRyb3B6b25lIGVsZW1lbnQgZm9yIGV2ZW4gdGFyZ2V0XHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBFdmVudCB0YXJnZXRcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfVxyXG4gICAqL1xyXG4gIFtjbG9zZXN0RHJvcHpvbmVdKHRhcmdldCkge1xyXG4gICAgaWYgKCF0aGlzLmRyb3B6b25lcykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMuZHJvcHpvbmVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWxsIGN1cnJlbnQgZHJvcHpvbmUgZWxlbWVudHMgZm9yIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJuIHtOb2RlTGlzdHxIVE1MRWxlbWVudFtdfEFycmF5fVxyXG4gICAqL1xyXG4gIFtnZXREcm9wem9uZXNdKCkge1xyXG4gICAgY29uc3QgZHJvcHpvbmUgPSB0aGlzLm9wdGlvbnMuZHJvcHpvbmU7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkcm9wem9uZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZHJvcHpvbmUpO1xyXG4gICAgfSBlbHNlIGlmIChkcm9wem9uZSBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IGRyb3B6b25lIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgcmV0dXJuIGRyb3B6b25lO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHJvcHpvbmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIGRyb3B6b25lKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERyb3BwYWJsZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5Ecm9wcGFibGVTdG9wRXZlbnQgPSBleHBvcnRzLkRyb3BwYWJsZVJldHVybmVkRXZlbnQgPSBleHBvcnRzLkRyb3BwYWJsZURyb3BwZWRFdmVudCA9IGV4cG9ydHMuRHJvcHBhYmxlU3RhcnRFdmVudCA9IGV4cG9ydHMuRHJvcHBhYmxlRXZlbnQgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Fic3RyYWN0RXZlbnQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbi8qKlxyXG4gKiBCYXNlIGRyb3BwYWJsZSBldmVudFxyXG4gKiBAY2xhc3MgRHJvcHBhYmxlRXZlbnRcclxuICogQG1vZHVsZSBEcm9wcGFibGVFdmVudFxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdEV2ZW50XHJcbiAqL1xyXG5jbGFzcyBEcm9wcGFibGVFdmVudCBleHRlbmRzIF9BYnN0cmFjdEV2ZW50Mi5kZWZhdWx0IHtcclxuXHJcbiAgLyoqXHJcbiAgICogT3JpZ2luYWwgZHJhZyBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGRyb3BwYWJsZSBldmVudFxyXG4gICAqIEBwcm9wZXJ0eSBkcmFnRXZlbnRcclxuICAgKiBAdHlwZSB7RHJhZ0V2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkcmFnRXZlbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdFdmVudDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJvcHBhYmxlRXZlbnQgPSBEcm9wcGFibGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJvcHBhYmxlIHN0YXJ0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyb3BwYWJsZVN0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyb3BwYWJsZVN0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcm9wcGFibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJvcHBhYmxlRXZlbnQudHlwZSA9ICdkcm9wcGFibGUnO1xyXG5jbGFzcyBEcm9wcGFibGVTdGFydEV2ZW50IGV4dGVuZHMgRHJvcHBhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgaW5pdGlhbCBkcm9wem9uZSBlbGVtZW50IG9mIHRoZSBjdXJyZW50bHkgZHJhZ2dpbmcgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgZHJvcHpvbmVcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyb3B6b25lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcm9wem9uZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJvcHBhYmxlU3RhcnRFdmVudCA9IERyb3BwYWJsZVN0YXJ0RXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcm9wcGFibGUgZHJvcHBlZCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJvcHBhYmxlRHJvcHBlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJvcHBhYmxlRHJvcHBlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyb3BwYWJsZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJvcHBhYmxlU3RhcnRFdmVudC50eXBlID0gJ2Ryb3BwYWJsZTpzdGFydCc7XHJcbkRyb3BwYWJsZVN0YXJ0RXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIERyb3BwYWJsZURyb3BwZWRFdmVudCBleHRlbmRzIERyb3BwYWJsZUV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRyb3B6b25lIGVsZW1lbnQgeW91IGRyb3BwZWQgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGludG9cclxuICAgKiBAcHJvcGVydHkgZHJvcHpvbmVcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyb3B6b25lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcm9wem9uZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJvcHBhYmxlRHJvcHBlZEV2ZW50ID0gRHJvcHBhYmxlRHJvcHBlZEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyb3BwYWJsZSByZXR1cm5lZCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyb3BwYWJsZVJldHVybmVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJvcHBhYmxlUmV0dXJuZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJvcHBhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJvcHBhYmxlRHJvcHBlZEV2ZW50LnR5cGUgPSAnZHJvcHBhYmxlOmRyb3BwZWQnO1xyXG5Ecm9wcGFibGVEcm9wcGVkRXZlbnQuY2FuY2VsYWJsZSA9IHRydWU7XHJcbmNsYXNzIERyb3BwYWJsZVJldHVybmVkRXZlbnQgZXh0ZW5kcyBEcm9wcGFibGVFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBkcm9wem9uZSBlbGVtZW50IHlvdSBkcmFnZ2VkIGF3YXkgZnJvbVxyXG4gICAqIEBwcm9wZXJ0eSBkcm9wem9uZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJvcHpvbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyb3B6b25lO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5Ecm9wcGFibGVSZXR1cm5lZEV2ZW50ID0gRHJvcHBhYmxlUmV0dXJuZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyb3BwYWJsZSBzdG9wIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcm9wcGFibGVTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBEcm9wcGFibGVTdG9wRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgRHJvcHBhYmxlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5Ecm9wcGFibGVSZXR1cm5lZEV2ZW50LnR5cGUgPSAnZHJvcHBhYmxlOnJldHVybmVkJztcclxuRHJvcHBhYmxlUmV0dXJuZWRFdmVudC5jYW5jZWxhYmxlID0gdHJ1ZTtcclxuY2xhc3MgRHJvcHBhYmxlU3RvcEV2ZW50IGV4dGVuZHMgRHJvcHBhYmxlRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZmluYWwgZHJvcHpvbmUgZWxlbWVudCBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgZHJvcHpvbmVcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGRyb3B6b25lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcm9wem9uZTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5Ecm9wcGFibGVTdG9wRXZlbnQgPSBEcm9wcGFibGVTdG9wRXZlbnQ7XHJcbkRyb3BwYWJsZVN0b3BFdmVudC50eXBlID0gJ2Ryb3BwYWJsZTpzdG9wJztcclxuRHJvcHBhYmxlU3RvcEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9Ecm9wcGFibGVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5cclxuT2JqZWN0LmtleXMoX0Ryb3BwYWJsZUV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX0Ryb3BwYWJsZUV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxudmFyIF9Ecm9wcGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcclxuXHJcbnZhciBfRHJvcHBhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Ryb3BwYWJsZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX0Ryb3BwYWJsZTIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuLyoqXHJcbiAqIFRoZSBFbWl0dGVyIGlzIGEgc2ltcGxlIGVtaXR0ZXIgY2xhc3MgdGhhdCBwcm92aWRlcyB5b3Ugd2l0aCBgb24oKWAsIGBvZmYoKWAgYW5kIGB0cmlnZ2VyKClgIG1ldGhvZHNcclxuICogQGNsYXNzIEVtaXR0ZXJcclxuICogQG1vZHVsZSBFbWl0dGVyXHJcbiAqL1xyXG5jbGFzcyBFbWl0dGVyIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGJ5IGV2ZW50IG5hbWVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGNhbGxiYWNrc1xyXG4gICAqL1xyXG4gIG9uKHR5cGUsIC4uLmNhbGxiYWNrcykge1xyXG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1t0eXBlXSkge1xyXG4gICAgICB0aGlzLmNhbGxiYWNrc1t0eXBlXSA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdLnB1c2goLi4uY2FsbGJhY2tzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVucmVnaXN0ZXJzIGNhbGxiYWNrcyBieSBldmVudCBuYW1lXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIG9mZih0eXBlLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKCF0aGlzLmNhbGxiYWNrc1t0eXBlXSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb3B5ID0gdGhpcy5jYWxsYmFja3NbdHlwZV0uc2xpY2UoMCk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3B5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChjYWxsYmFjayA9PT0gY29weVtpXSkge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW3R5cGVdLnNwbGljZShpLCAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlcnMgZXZlbnQgY2FsbGJhY2tzIGJ5IGV2ZW50IG9iamVjdFxyXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RFdmVudH0gZXZlbnRcclxuICAgKi9cclxuICB0cmlnZ2VyKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50LnR5cGVdKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNhbGxiYWNrcyA9IFsuLi50aGlzLmNhbGxiYWNrc1tldmVudC50eXBlXV07XHJcbiAgICBjb25zdCBjYXVnaHRFcnJvcnMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjYWxsYmFjayhldmVudCk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY2F1Z2h0RXJyb3JzLnB1c2goZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNhdWdodEVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBEcmFnZ2FibGUgY2F1Z2h0IGVycm9ycyB3aGlsZSB0cmlnZ2VyaW5nICcke2V2ZW50LnR5cGV9J2AsIGNhdWdodEVycm9ycyk7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gRW1pdHRlcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG5cclxudmFyIF9FbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0VtaXR0ZXIpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9FbWl0dGVyMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxudmFyIF9QbHVnaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblxyXG52YXIgX0VtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcclxuXHJcbnZhciBfRW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FbWl0dGVyKTtcclxuXHJcbnZhciBfU2Vuc29ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG52YXIgX0RyYWdnYWJsZUV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblxyXG52YXIgX0RyYWdFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdNb3ZlID0gU3ltYm9sKCdvbkRyYWdNb3ZlJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgb25EcmFnUHJlc3N1cmUgPSBTeW1ib2woJ29uRHJhZ1ByZXNzdXJlJyk7XHJcblxyXG4vKipcclxuICogQGNvbnN0IHtPYmplY3R9IGRlZmF1bHRBbm5vdW5jZW1lbnRzXHJcbiAqIEBjb25zdCB7RnVuY3Rpb259IGRlZmF1bHRBbm5vdW5jZW1lbnRzWydkcmFnOnN0YXJ0J11cclxuICogQGNvbnN0IHtGdW5jdGlvbn0gZGVmYXVsdEFubm91bmNlbWVudHNbJ2RyYWc6c3RvcCddXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0QW5ub3VuY2VtZW50cyA9IHtcclxuICAnZHJhZzpzdGFydCc6IGV2ZW50ID0+IGBQaWNrZWQgdXAgJHtldmVudC5zb3VyY2UudGV4dENvbnRlbnQudHJpbSgpIHx8IGV2ZW50LnNvdXJjZS5pZCB8fCAnZHJhZ2dhYmxlIGVsZW1lbnQnfWAsXHJcbiAgJ2RyYWc6c3RvcCc6IGV2ZW50ID0+IGBSZWxlYXNlZCAke2V2ZW50LnNvdXJjZS50ZXh0Q29udGVudC50cmltKCkgfHwgZXZlbnQuc291cmNlLmlkIHx8ICdkcmFnZ2FibGUgZWxlbWVudCd9YFxyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdENsYXNzZXMgPSB7XHJcbiAgJ2NvbnRhaW5lcjpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1pcy1kcmFnZ2luZycsXHJcbiAgJ3NvdXJjZTpkcmFnZ2luZyc6ICdkcmFnZ2FibGUtc291cmNlLS1pcy1kcmFnZ2luZycsXHJcbiAgJ3NvdXJjZTpwbGFjZWQnOiAnZHJhZ2dhYmxlLXNvdXJjZS0tcGxhY2VkJyxcclxuICAnY29udGFpbmVyOnBsYWNlZCc6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1wbGFjZWQnLFxyXG4gICdib2R5OmRyYWdnaW5nJzogJ2RyYWdnYWJsZS0taXMtZHJhZ2dpbmcnLFxyXG4gICdkcmFnZ2FibGU6b3Zlcic6ICdkcmFnZ2FibGUtLW92ZXInLFxyXG4gICdjb250YWluZXI6b3Zlcic6ICdkcmFnZ2FibGUtY29udGFpbmVyLS1vdmVyJyxcclxuICAnc291cmNlOm9yaWdpbmFsJzogJ2RyYWdnYWJsZS0tb3JpZ2luYWwnLFxyXG4gIG1pcnJvcjogJ2RyYWdnYWJsZS1taXJyb3InXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgZHJhZ2dhYmxlOiAnLmRyYWdnYWJsZS1zb3VyY2UnLFxyXG4gIGhhbmRsZTogbnVsbCxcclxuICBkZWxheTogMTAwLFxyXG4gIHBsYWNlZFRpbWVvdXQ6IDgwMCxcclxuICBwbHVnaW5zOiBbXSxcclxuICBzZW5zb3JzOiBbXVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdGhlIGNvcmUgZHJhZ2dhYmxlIGxpYnJhcnkgdGhhdCBkb2VzIHRoZSBoZWF2eSBsaWZ0aW5nXHJcbiAqIEBjbGFzcyBEcmFnZ2FibGVcclxuICogQG1vZHVsZSBEcmFnZ2FibGVcclxuICovXHJcbmNsYXNzIERyYWdnYWJsZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBEcmFnZ2FibGVcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W118Tm9kZUxpc3R8SFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBEcmFnZ2FibGUgY29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZHJhZ2dhYmxlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY29udGFpbmVycyA9IFtkb2N1bWVudC5ib2R5XSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZSBjb250YWluZXJzXHJcbiAgICAgKiBAcHJvcGVydHkgY29udGFpbmVyc1xyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XHJcbiAgICAgKi9cclxuICAgIGlmIChjb250YWluZXJzIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgY29udGFpbmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi5jb250YWluZXJzXTtcclxuICAgIH0gZWxzZSBpZiAoY29udGFpbmVycyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuY29udGFpbmVycyA9IFtjb250YWluZXJzXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRHJhZ2dhYmxlIGNvbnRhaW5lcnMgYXJlIGV4cGVjdGVkIHRvIGJlIG9mIHR5cGUgYE5vZGVMaXN0YCwgYEhUTUxFbGVtZW50W11gIG9yIGBIVE1MRWxlbWVudGAnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMsIHtcclxuICAgICAgY2xhc3NlczogX2V4dGVuZHMoe30sIGRlZmF1bHRDbGFzc2VzLCBvcHRpb25zLmNsYXNzZXMgfHwge30pLFxyXG4gICAgICBhbm5vdW5jZW1lbnRzOiBfZXh0ZW5kcyh7fSwgZGVmYXVsdEFubm91bmNlbWVudHMsIG9wdGlvbnMuYW5ub3VuY2VtZW50cyB8fCB7fSlcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhZ2dhYmxlcyBldmVudCBlbWl0dGVyXHJcbiAgICAgKiBAcHJvcGVydHkgZW1pdHRlclxyXG4gICAgICogQHR5cGUge0VtaXR0ZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZW1pdHRlciA9IG5ldyBfRW1pdHRlcjIuZGVmYXVsdCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBkcmFnIHN0YXRlXHJcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dpbmdcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmUgcGx1Z2luc1xyXG4gICAgICogQHByb3BlcnR5IHBsdWdpbnNcclxuICAgICAqIEB0eXBlIHtQbHVnaW5bXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5wbHVnaW5zID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmUgc2Vuc29yc1xyXG4gICAgICogQHByb3BlcnR5IHNlbnNvcnNcclxuICAgICAqIEB0eXBlIHtTZW5zb3JbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZW5zb3JzID0gW107XHJcblxyXG4gICAgdGhpc1tvbkRyYWdTdGFydF0gPSB0aGlzW29uRHJhZ1N0YXJ0XS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdNb3ZlXSA9IHRoaXNbb25EcmFnTW92ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EcmFnU3RvcF0gPSB0aGlzW29uRHJhZ1N0b3BdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1ByZXNzdXJlXSA9IHRoaXNbb25EcmFnUHJlc3N1cmVdLmJpbmQodGhpcyk7XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWc6bW92ZScsIHRoaXNbb25EcmFnTW92ZV0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnOnByZXNzdXJlJywgdGhpc1tvbkRyYWdQcmVzc3VyZV0sIHRydWUpO1xyXG5cclxuICAgIGNvbnN0IGRlZmF1bHRQbHVnaW5zID0gT2JqZWN0LnZhbHVlcyhEcmFnZ2FibGUuUGx1Z2lucykubWFwKFBsdWdpbiA9PiBQbHVnaW4pO1xyXG4gICAgY29uc3QgZGVmYXVsdFNlbnNvcnMgPSBbX1NlbnNvcnMuTW91c2VTZW5zb3IsIF9TZW5zb3JzLlRvdWNoU2Vuc29yXTtcclxuXHJcbiAgICB0aGlzLmFkZFBsdWdpbiguLi5bLi4uZGVmYXVsdFBsdWdpbnMsIC4uLnRoaXMub3B0aW9ucy5wbHVnaW5zXSk7XHJcbiAgICB0aGlzLmFkZFNlbnNvciguLi5bLi4uZGVmYXVsdFNlbnNvcnMsIC4uLnRoaXMub3B0aW9ucy5zZW5zb3JzXSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCA9IG5ldyBfRHJhZ2dhYmxlRXZlbnQuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCh7XHJcbiAgICAgIGRyYWdnYWJsZTogdGhpc1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5vbignbWlycm9yOmNyZWF0ZWQnLCAoeyBtaXJyb3IgfSkgPT4gdGhpcy5taXJyb3IgPSBtaXJyb3IpO1xyXG4gICAgdGhpcy5vbignbWlycm9yOmRlc3Ryb3knLCAoKSA9PiB0aGlzLm1pcnJvciA9IG51bGwpO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3lzIERyYWdnYWJsZSBpbnN0YW5jZS4gVGhpcyByZW1vdmVzIGFsbCBpbnRlcm5hbCBldmVudCBsaXN0ZW5lcnMgYW5kXHJcbiAgICogZGVhY3RpdmF0ZXMgc2Vuc29ycyBhbmQgcGx1Z2luc1xyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBEZWZhdWx0IHBsdWdpbnMgZHJhZ2dhYmxlIHVzZXNcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFBsdWdpbnNcclxuICAgKiBAcHJvcGVydHkge0Fubm91bmNlbWVudH0gUGx1Z2lucy5Bbm5vdW5jZW1lbnRcclxuICAgKiBAcHJvcGVydHkge0ZvY3VzYWJsZX0gUGx1Z2lucy5Gb2N1c2FibGVcclxuICAgKiBAcHJvcGVydHkge01pcnJvcn0gUGx1Z2lucy5NaXJyb3JcclxuICAgKiBAcHJvcGVydHkge1Njcm9sbGFibGV9IFBsdWdpbnMuU2Nyb2xsYWJsZVxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdLCB0cnVlKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZzpwcmVzc3VyZScsIHRoaXNbb25EcmFnUHJlc3N1cmVdLCB0cnVlKTtcclxuXHJcbiAgICBjb25zdCBkcmFnZ2FibGVEZXN0cm95RXZlbnQgPSBuZXcgX0RyYWdnYWJsZUV2ZW50LkRyYWdnYWJsZURlc3Ryb3lFdmVudCh7XHJcbiAgICAgIGRyYWdnYWJsZTogdGhpc1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdnYWJsZURlc3Ryb3lFdmVudCk7XHJcblxyXG4gICAgdGhpcy5yZW1vdmVQbHVnaW4oLi4udGhpcy5wbHVnaW5zLm1hcChwbHVnaW4gPT4gcGx1Z2luLmNvbnN0cnVjdG9yKSk7XHJcbiAgICB0aGlzLnJlbW92ZVNlbnNvciguLi50aGlzLnNlbnNvcnMubWFwKHNlbnNvciA9PiBzZW5zb3IuY29uc3RydWN0b3IpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgcGx1Z2luIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHdpbGwgZW5kIHVwIGNhbGxpbmcgdGhlIGF0dGFjaCBtZXRob2Qgb2YgdGhlIHBsdWdpblxyXG4gICAqIEBwYXJhbSB7Li4udHlwZW9mIFBsdWdpbn0gcGx1Z2lucyAtIFBsdWdpbnMgdGhhdCB5b3Ugd2FudCBhdHRhY2hlZCB0byBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLmFkZFBsdWdpbihDdXN0b21BMTF5UGx1Z2luLCBDdXN0b21NaXJyb3JQbHVnaW4pXHJcbiAgICovXHJcbiAgYWRkUGx1Z2luKC4uLnBsdWdpbnMpIHtcclxuICAgIGNvbnN0IGFjdGl2ZVBsdWdpbnMgPSBwbHVnaW5zLm1hcChQbHVnaW4gPT4gbmV3IFBsdWdpbih0aGlzKSk7XHJcblxyXG4gICAgYWN0aXZlUGx1Z2lucy5mb3JFYWNoKHBsdWdpbiA9PiBwbHVnaW4uYXR0YWNoKCkpO1xyXG4gICAgdGhpcy5wbHVnaW5zID0gWy4uLnRoaXMucGx1Z2lucywgLi4uYWN0aXZlUGx1Z2luc107XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIHBsdWdpbnMgdGhhdCBhcmUgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZS4gVGhpcyB3aWxsIGVuZCB1cCBjYWxsaW5nXHJcbiAgICogdGhlIGRldGFjaCBtZXRob2Qgb2YgdGhlIHBsdWdpblxyXG4gICAqIEBwYXJhbSB7Li4udHlwZW9mIFBsdWdpbn0gcGx1Z2lucyAtIFBsdWdpbnMgdGhhdCB5b3Ugd2FudCBkZXRhY2hlZCBmcm9tIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUucmVtb3ZlUGx1Z2luKE1pcnJvclBsdWdpbiwgQ3VzdG9tTWlycm9yUGx1Z2luKVxyXG4gICAqL1xyXG4gIHJlbW92ZVBsdWdpbiguLi5wbHVnaW5zKSB7XHJcbiAgICBjb25zdCByZW1vdmVkUGx1Z2lucyA9IHRoaXMucGx1Z2lucy5maWx0ZXIocGx1Z2luID0+IHBsdWdpbnMuaW5jbHVkZXMocGx1Z2luLmNvbnN0cnVjdG9yKSk7XHJcblxyXG4gICAgcmVtb3ZlZFBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4gcGx1Z2luLmRldGFjaCgpKTtcclxuICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucGx1Z2lucy5maWx0ZXIocGx1Z2luID0+ICFwbHVnaW5zLmluY2x1ZGVzKHBsdWdpbi5jb25zdHJ1Y3RvcikpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBzZW5zb3JzIHRvIHRoaXMgZHJhZ2dhYmxlIGluc3RhbmNlLiBUaGlzIHdpbGwgZW5kIHVwIGNhbGxpbmcgdGhlIGF0dGFjaCBtZXRob2Qgb2YgdGhlIHNlbnNvclxyXG4gICAqIEBwYXJhbSB7Li4udHlwZW9mIFNlbnNvcn0gc2Vuc29ycyAtIFNlbnNvcnMgdGhhdCB5b3Ugd2FudCBhdHRhY2hlZCB0byBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLmFkZFNlbnNvcihGb3JjZVRvdWNoU2Vuc29yLCBDdXN0b21TZW5zb3IpXHJcbiAgICovXHJcbiAgYWRkU2Vuc29yKC4uLnNlbnNvcnMpIHtcclxuICAgIGNvbnN0IGFjdGl2ZVNlbnNvcnMgPSBzZW5zb3JzLm1hcChTZW5zb3IgPT4gbmV3IFNlbnNvcih0aGlzLmNvbnRhaW5lcnMsIHRoaXMub3B0aW9ucykpO1xyXG5cclxuICAgIGFjdGl2ZVNlbnNvcnMuZm9yRWFjaChzZW5zb3IgPT4gc2Vuc29yLmF0dGFjaCgpKTtcclxuICAgIHRoaXMuc2Vuc29ycyA9IFsuLi50aGlzLnNlbnNvcnMsIC4uLmFjdGl2ZVNlbnNvcnNdO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBzZW5zb3JzIHRoYXQgYXJlIGFscmVhZHkgYXR0YWNoZWQgdG8gdGhpcyBkcmFnZ2FibGUgaW5zdGFuY2UuIFRoaXMgd2lsbCBlbmQgdXAgY2FsbGluZ1xyXG4gICAqIHRoZSBkZXRhY2ggbWV0aG9kIG9mIHRoZSBzZW5zb3JcclxuICAgKiBAcGFyYW0gey4uLnR5cGVvZiBTZW5zb3J9IHNlbnNvcnMgLSBTZW5zb3JzIHRoYXQgeW91IHdhbnQgYXR0YWNoZWQgdG8gZHJhZ2dhYmxlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5yZW1vdmVTZW5zb3IoVG91Y2hTZW5zb3IsIERyYWdTZW5zb3IpXHJcbiAgICovXHJcbiAgcmVtb3ZlU2Vuc29yKC4uLnNlbnNvcnMpIHtcclxuICAgIGNvbnN0IHJlbW92ZWRTZW5zb3JzID0gdGhpcy5zZW5zb3JzLmZpbHRlcihzZW5zb3IgPT4gc2Vuc29ycy5pbmNsdWRlcyhzZW5zb3IuY29uc3RydWN0b3IpKTtcclxuXHJcbiAgICByZW1vdmVkU2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IuZGV0YWNoKCkpO1xyXG4gICAgdGhpcy5zZW5zb3JzID0gdGhpcy5zZW5zb3JzLmZpbHRlcihzZW5zb3IgPT4gIXNlbnNvcnMuaW5jbHVkZXMoc2Vuc29yLmNvbnN0cnVjdG9yKSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGNvbnRhaW5lciB0byB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7Li4uSFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzIHlvdSB3YW50IHRvIGFkZCB0byBkcmFnZ2FibGVcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLmFkZENvbnRhaW5lcihkb2N1bWVudC5ib2R5KVxyXG4gICAqL1xyXG4gIGFkZENvbnRhaW5lciguLi5jb250YWluZXJzKSB7XHJcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSBbLi4udGhpcy5jb250YWluZXJzLCAuLi5jb250YWluZXJzXTtcclxuICAgIHRoaXMuc2Vuc29ycy5mb3JFYWNoKHNlbnNvciA9PiBzZW5zb3IuYWRkQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBjb250YWluZXIgZnJvbSB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7Li4uSFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzIHlvdSB3YW50IHRvIHJlbW92ZSBmcm9tIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge0RyYWdnYWJsZX1cclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUucmVtb3ZlQ29udGFpbmVyKGRvY3VtZW50LmJvZHkpXHJcbiAgICovXHJcbiAgcmVtb3ZlQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcclxuICAgIHRoaXMuY29udGFpbmVycyA9IHRoaXMuY29udGFpbmVycy5maWx0ZXIoY29udGFpbmVyID0+ICFjb250YWluZXJzLmluY2x1ZGVzKGNvbnRhaW5lcikpO1xyXG4gICAgdGhpcy5zZW5zb3JzLmZvckVhY2goc2Vuc29yID0+IHNlbnNvci5yZW1vdmVDb250YWluZXIoLi4uY29udGFpbmVycykpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGxpc3RlbmVyIGZvciBkcmFnZ2FibGUgZXZlbnRzXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBFdmVudCBuYW1lXHJcbiAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gY2FsbGJhY2tzIC0gRXZlbnQgY2FsbGJhY2tzXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS5vbignZHJhZzpzdGFydCcsIChkcmFnRXZlbnQpID0+IGRyYWdFdmVudC5jYW5jZWwoKSk7XHJcbiAgICovXHJcbiAgb24odHlwZSwgLi4uY2FsbGJhY2tzKSB7XHJcbiAgICB0aGlzLmVtaXR0ZXIub24odHlwZSwgLi4uY2FsbGJhY2tzKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBsaXN0ZW5lciBmcm9tIGRyYWdnYWJsZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gRXZlbnQgbmFtZVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRXZlbnQgY2FsbGJhY2tcclxuICAgKiBAcmV0dXJuIHtEcmFnZ2FibGV9XHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLm9mZignZHJhZzpzdGFydCcsIGhhbmRsZXJGdW5jdGlvbik7XHJcbiAgICovXHJcbiAgb2ZmKHR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLmVtaXR0ZXIub2ZmKHR5cGUsIGNhbGxiYWNrKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlcnMgZHJhZ2dhYmxlIGV2ZW50XHJcbiAgICogQHBhcmFtIHtBYnN0cmFjdEV2ZW50fSBldmVudCAtIEV2ZW50IGluc3RhbmNlXHJcbiAgICogQHJldHVybiB7RHJhZ2dhYmxlfVxyXG4gICAqIEBleGFtcGxlIGRyYWdnYWJsZS50cmlnZ2VyKGV2ZW50KTtcclxuICAgKi9cclxuICB0cmlnZ2VyKGV2ZW50KSB7XHJcbiAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcihldmVudCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY2xhc3MgbmFtZSBmb3IgY2xhc3MgaWRlbnRpZmllclxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiBjbGFzcyBpZGVudGlmaWVyXHJcbiAgICogQHJldHVybiB7U3RyaW5nfG51bGx9XHJcbiAgICovXHJcbiAgZ2V0Q2xhc3NOYW1lRm9yKG5hbWUpIHtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY2xhc3Nlc1tuYW1lXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGRyYWdnYWJsZSBpbnN0YW5jZSBpcyBjdXJyZW50bHkgZHJhZ2dpbmdcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGlzRHJhZ2dpbmcoKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmRyYWdnaW5nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWxsIGRyYWdnYWJsZSBlbGVtZW50c1xyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XHJcbiAgICovXHJcbiAgZ2V0RHJhZ2dhYmxlRWxlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJzLnJlZHVjZSgoY3VycmVudCwgY29udGFpbmVyKSA9PiB7XHJcbiAgICAgIHJldHVybiBbLi4uY3VycmVudCwgLi4udGhpcy5nZXREcmFnZ2FibGVFbGVtZW50c0ZvckNvbnRhaW5lcihjb250YWluZXIpXTtcclxuICAgIH0sIFtdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgZHJhZ2dhYmxlIGVsZW1lbnRzIGZvciBhIGdpdmVuIGNvbnRhaW5lciwgZXhjbHVkaW5nIHRoZSBtaXJyb3IgYW5kXHJcbiAgICogb3JpZ2luYWwgc291cmNlIGVsZW1lbnQgaWYgcHJlc2VudFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119XHJcbiAgICovXHJcbiAgZ2V0RHJhZ2dhYmxlRWxlbWVudHNGb3JDb250YWluZXIoY29udGFpbmVyKSB7XHJcbiAgICBjb25zdCBhbGxEcmFnZ2FibGVFbGVtZW50cyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG5cclxuICAgIHJldHVybiBbLi4uYWxsRHJhZ2dhYmxlRWxlbWVudHNdLmZpbHRlcihjaGlsZEVsZW1lbnQgPT4ge1xyXG4gICAgICByZXR1cm4gY2hpbGRFbGVtZW50ICE9PSB0aGlzLm9yaWdpbmFsU291cmNlICYmIGNoaWxkRWxlbWVudCAhPT0gdGhpcy5taXJyb3I7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBET00gRHJhZyBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdTdGFydF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xyXG4gICAgY29uc3QgeyB0YXJnZXQsIGNvbnRhaW5lciB9ID0gc2Vuc29yRXZlbnQ7XHJcblxyXG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcnMuaW5jbHVkZXMoY29udGFpbmVyKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oYW5kbGUgJiYgdGFyZ2V0ICYmICEoMCwgX3V0aWxzLmNsb3Nlc3QpKHRhcmdldCwgdGhpcy5vcHRpb25zLmhhbmRsZSkpIHtcclxuICAgICAgc2Vuc29yRXZlbnQuY2FuY2VsKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5kIGRyYWdnYWJsZSBzb3VyY2UgZWxlbWVudFxyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZSA9ICgwLCBfdXRpbHMuY2xvc2VzdCkodGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcclxuICAgIHRoaXMuc291cmNlQ29udGFpbmVyID0gY29udGFpbmVyO1xyXG5cclxuICAgIGlmICghdGhpcy5vcmlnaW5hbFNvdXJjZSkge1xyXG4gICAgICBzZW5zb3JFdmVudC5jYW5jZWwoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmxhc3RQbGFjZWRTb3VyY2UgJiYgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBsYWNlZFRpbWVvdXRJRCk7XHJcbiAgICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xyXG4gICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmdldENsYXNzTmFtZUZvcignY29udGFpbmVyOnBsYWNlZCcpKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNvdXJjZSA9IHRoaXMub3JpZ2luYWxTb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnNvdXJjZSwgdGhpcy5vcmlnaW5hbFNvdXJjZSk7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgY29uc3QgZHJhZ0V2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ1N0YXJ0RXZlbnQoe1xyXG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZTogdGhpcy5vcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyOiBjb250YWluZXIsXHJcbiAgICAgIHNlbnNvckV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoZHJhZ0V2ZW50KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdFdmVudC5jYW5jZWxlZCgpO1xyXG5cclxuICAgIGlmIChkcmFnRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICB0aGlzLnNvdXJjZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc291cmNlKTtcclxuICAgICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UuY2xhc3NMaXN0LmFkZCh0aGlzLmdldENsYXNzTmFtZUZvcignc291cmNlOm9yaWdpbmFsJykpO1xyXG4gICAgdGhpcy5zb3VyY2UuY2xhc3NMaXN0LmFkZCh0aGlzLmdldENsYXNzTmFtZUZvcignc291cmNlOmRyYWdnaW5nJykpO1xyXG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmdldENsYXNzTmFtZUZvcignY29udGFpbmVyOmRyYWdnaW5nJykpO1xyXG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdib2R5OmRyYWdnaW5nJykpO1xyXG4gICAgYXBwbHlVc2VyU2VsZWN0KGRvY3VtZW50LmJvZHksICdub25lJyk7XHJcblxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgY29uc3Qgb2xkU2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XHJcbiAgICAgIGNvbnN0IG5ld1NlbnNvckV2ZW50ID0gb2xkU2Vuc29yRXZlbnQuY2xvbmUoeyB0YXJnZXQ6IHRoaXMuc291cmNlIH0pO1xyXG5cclxuICAgICAgdGhpc1tvbkRyYWdNb3ZlXShfZXh0ZW5kcyh7fSwgZXZlbnQsIHtcclxuICAgICAgICBkZXRhaWw6IG5ld1NlbnNvckV2ZW50XHJcbiAgICAgIH0pKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRE9NIERyYWcgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnTW92ZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBnZXRTZW5zb3JFdmVudChldmVudCk7XHJcbiAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gc2Vuc29yRXZlbnQ7XHJcbiAgICBsZXQgdGFyZ2V0ID0gc2Vuc29yRXZlbnQudGFyZ2V0O1xyXG5cclxuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnTW92ZUV2ZW50KHtcclxuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2U6IHRoaXMub3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdNb3ZlRXZlbnQpO1xyXG5cclxuICAgIGlmIChkcmFnTW92ZUV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgc2Vuc29yRXZlbnQuY2FuY2VsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGFyZ2V0ID0gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpO1xyXG4gICAgY29uc3Qgd2l0aGluQ29ycmVjdENvbnRhaW5lciA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoc2Vuc29yRXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xyXG4gICAgY29uc3Qgb3ZlckNvbnRhaW5lciA9IHNlbnNvckV2ZW50Lm92ZXJDb250YWluZXIgfHwgd2l0aGluQ29ycmVjdENvbnRhaW5lcjtcclxuICAgIGNvbnN0IGlzTGVhdmluZ0NvbnRhaW5lciA9IHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgJiYgb3ZlckNvbnRhaW5lciAhPT0gdGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lcjtcclxuICAgIGNvbnN0IGlzTGVhdmluZ0RyYWdnYWJsZSA9IHRoaXMuY3VycmVudE92ZXIgJiYgdGFyZ2V0ICE9PSB0aGlzLmN1cnJlbnRPdmVyO1xyXG4gICAgY29uc3QgaXNPdmVyQ29udGFpbmVyID0gb3ZlckNvbnRhaW5lciAmJiB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyICE9PSBvdmVyQ29udGFpbmVyO1xyXG4gICAgY29uc3QgaXNPdmVyRHJhZ2dhYmxlID0gd2l0aGluQ29ycmVjdENvbnRhaW5lciAmJiB0YXJnZXQgJiYgdGhpcy5jdXJyZW50T3ZlciAhPT0gdGFyZ2V0O1xyXG5cclxuICAgIGlmIChpc0xlYXZpbmdEcmFnZ2FibGUpIHtcclxuICAgICAgY29uc3QgZHJhZ091dEV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ091dEV2ZW50KHtcclxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG92ZXI6IHRoaXMuY3VycmVudE92ZXJcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoJ2RyYWdnYWJsZTpvdmVyJykpO1xyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyID0gbnVsbDtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3V0RXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0xlYXZpbmdDb250YWluZXIpIHtcclxuICAgICAgY29uc3QgZHJhZ091dENvbnRhaW5lckV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ091dENvbnRhaW5lckV2ZW50KHtcclxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG92ZXJDb250YWluZXI6IHRoaXMuY3VycmVudE92ZXJDb250YWluZXJcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoJ2NvbnRhaW5lcjpvdmVyJykpO1xyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyID0gbnVsbDtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3V0Q29udGFpbmVyRXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc092ZXJDb250YWluZXIpIHtcclxuICAgICAgb3ZlckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdjb250YWluZXI6b3ZlcicpKTtcclxuXHJcbiAgICAgIGNvbnN0IGRyYWdPdmVyQ29udGFpbmVyRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnT3ZlckNvbnRhaW5lckV2ZW50KHtcclxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG92ZXJDb250YWluZXJcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyID0gb3ZlckNvbnRhaW5lcjtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3ZlckNvbnRhaW5lckV2ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNPdmVyRHJhZ2dhYmxlKSB7XHJcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcmFnZ2FibGU6b3ZlcicpKTtcclxuXHJcbiAgICAgIGNvbnN0IGRyYWdPdmVyRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnT3ZlckV2ZW50KHtcclxuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxyXG4gICAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICAgIHNvdXJjZUNvbnRhaW5lcjogY29udGFpbmVyLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG92ZXJDb250YWluZXIsXHJcbiAgICAgICAgb3ZlcjogdGFyZ2V0XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5jdXJyZW50T3ZlciA9IHRhcmdldDtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihkcmFnT3ZlckV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgc3RvcCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERPTSBEcmFnIGV2ZW50XHJcbiAgICovXHJcbiAgW29uRHJhZ1N0b3BdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdCBkcmFnU3RvcEV2ZW50ID0gbmV3IF9EcmFnRXZlbnQuRHJhZ1N0b3BFdmVudCh7XHJcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXHJcbiAgICAgIG9yaWdpbmFsU291cmNlOiB0aGlzLm9yaWdpbmFsU291cmNlLFxyXG4gICAgICBzZW5zb3JFdmVudDogZXZlbnQuc2Vuc29yRXZlbnQsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcjogdGhpcy5zb3VyY2VDb250YWluZXJcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihkcmFnU3RvcEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLnNvdXJjZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLm9yaWdpbmFsU291cmNlLCB0aGlzLnNvdXJjZSk7XHJcbiAgICB0aGlzLnNvdXJjZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc291cmNlKTtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2Uuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG5cclxuICAgIHRoaXMuc291cmNlLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoJ3NvdXJjZTpkcmFnZ2luZycpKTtcclxuICAgIHRoaXMub3JpZ2luYWxTb3VyY2UuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmdldENsYXNzTmFtZUZvcignc291cmNlOm9yaWdpbmFsJykpO1xyXG4gICAgdGhpcy5vcmlnaW5hbFNvdXJjZS5jbGFzc0xpc3QuYWRkKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdzb3VyY2U6cGxhY2VkJykpO1xyXG4gICAgdGhpcy5zb3VyY2VDb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmdldENsYXNzTmFtZUZvcignY29udGFpbmVyOnBsYWNlZCcpKTtcclxuICAgIHRoaXMuc291cmNlQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoJ2NvbnRhaW5lcjpkcmFnZ2luZycpKTtcclxuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmdldENsYXNzTmFtZUZvcignYm9keTpkcmFnZ2luZycpKTtcclxuICAgIGFwcGx5VXNlclNlbGVjdChkb2N1bWVudC5ib2R5LCAnJyk7XHJcblxyXG4gICAgaWYgKHRoaXMuY3VycmVudE92ZXIpIHtcclxuICAgICAgdGhpcy5jdXJyZW50T3Zlci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0Q2xhc3NOYW1lRm9yKCdkcmFnZ2FibGU6b3ZlcicpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50T3ZlckNvbnRhaW5lcikge1xyXG4gICAgICB0aGlzLmN1cnJlbnRPdmVyQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoJ2NvbnRhaW5lcjpvdmVyJykpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubGFzdFBsYWNlZFNvdXJjZSA9IHRoaXMub3JpZ2luYWxTb3VyY2U7XHJcbiAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIgPSB0aGlzLnNvdXJjZUNvbnRhaW5lcjtcclxuXHJcbiAgICB0aGlzLnBsYWNlZFRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5sYXN0UGxhY2VkU291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0UGxhY2VkU291cmNlLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5nZXRDbGFzc05hbWVGb3IoJ3NvdXJjZTpwbGFjZWQnKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLmxhc3RQbGFjZWRDb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmxhc3RQbGFjZWRDb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmdldENsYXNzTmFtZUZvcignY29udGFpbmVyOnBsYWNlZCcpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5sYXN0UGxhY2VkU291cmNlID0gbnVsbDtcclxuICAgICAgdGhpcy5sYXN0UGxhY2VkQ29udGFpbmVyID0gbnVsbDtcclxuICAgIH0sIHRoaXMub3B0aW9ucy5wbGFjZWRUaW1lb3V0KTtcclxuXHJcbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7XHJcbiAgICB0aGlzLm9yaWdpbmFsU291cmNlID0gbnVsbDtcclxuICAgIHRoaXMuY3VycmVudE92ZXJDb250YWluZXIgPSBudWxsO1xyXG4gICAgdGhpcy5jdXJyZW50T3ZlciA9IG51bGw7XHJcbiAgICB0aGlzLnNvdXJjZUNvbnRhaW5lciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIHByZXNzdXJlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRE9NIERyYWcgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnUHJlc3N1cmVdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNlbnNvckV2ZW50ID0gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpO1xyXG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2UgfHwgKDAsIF91dGlscy5jbG9zZXN0KShzZW5zb3JFdmVudC5vcmlnaW5hbEV2ZW50LnRhcmdldCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ1ByZXNzdXJlRXZlbnQgPSBuZXcgX0RyYWdFdmVudC5EcmFnUHJlc3N1cmVFdmVudCh7XHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIHByZXNzdXJlOiBzZW5zb3JFdmVudC5wcmVzc3VyZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGRyYWdQcmVzc3VyZUV2ZW50KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdnYWJsZTtcclxuRHJhZ2dhYmxlLlBsdWdpbnMgPSB7IEFubm91bmNlbWVudDogX1BsdWdpbnMuQW5ub3VuY2VtZW50LCBGb2N1c2FibGU6IF9QbHVnaW5zLkZvY3VzYWJsZSwgTWlycm9yOiBfUGx1Z2lucy5NaXJyb3IsIFNjcm9sbGFibGU6IF9QbHVnaW5zLlNjcm9sbGFibGUgfTtcclxuZnVuY3Rpb24gZ2V0U2Vuc29yRXZlbnQoZXZlbnQpIHtcclxuICByZXR1cm4gZXZlbnQuZGV0YWlsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVVzZXJTZWxlY3QoZWxlbWVudCwgdmFsdWUpIHtcclxuICBlbGVtZW50LnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSB2YWx1ZTtcclxuICBlbGVtZW50LnN0eWxlLm1velVzZXJTZWxlY3QgPSB2YWx1ZTtcclxuICBlbGVtZW50LnN0eWxlLm1zVXNlclNlbGVjdCA9IHZhbHVlO1xyXG4gIGVsZW1lbnQuc3R5bGUub1VzZXJTZWxlY3QgPSB2YWx1ZTtcclxuICBlbGVtZW50LnN0eWxlLnVzZXJTZWxlY3QgPSB2YWx1ZTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9TZW5zb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxudmFyIF9TZW5zb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2Vuc29yKTtcclxuXHJcbnZhciBfU2Vuc29yRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uTW91c2VGb3JjZVdpbGxCZWdpbiA9IFN5bWJvbCgnb25Nb3VzZUZvcmNlV2lsbEJlZ2luJyk7XHJcbmNvbnN0IG9uTW91c2VGb3JjZURvd24gPSBTeW1ib2woJ29uTW91c2VGb3JjZURvd24nKTtcclxuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XHJcbmNvbnN0IG9uTW91c2VGb3JjZUNoYW5nZSA9IFN5bWJvbCgnb25Nb3VzZUZvcmNlQ2hhbmdlJyk7XHJcbmNvbnN0IG9uTW91c2VNb3ZlID0gU3ltYm9sKCdvbk1vdXNlTW92ZScpO1xyXG5jb25zdCBvbk1vdXNlVXAgPSBTeW1ib2woJ29uTW91c2VVcCcpO1xyXG5jb25zdCBvbk1vdXNlRm9yY2VHbG9iYWxDaGFuZ2UgPSBTeW1ib2woJ29uTW91c2VGb3JjZUdsb2JhbENoYW5nZScpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgc2Vuc29yIHBpY2tzIHVwIG5hdGl2ZSBmb3JjZSB0b3VjaCBldmVudHMgYW5kIGRpY3RhdGVzIGRyYWcgb3BlcmF0aW9uc1xyXG4gKiBAY2xhc3MgRm9yY2VUb3VjaFNlbnNvclxyXG4gKiBAbW9kdWxlIEZvcmNlVG91Y2hTZW5zb3JcclxuICogQGV4dGVuZHMgU2Vuc29yXHJcbiAqL1xyXG5jbGFzcyBGb3JjZVRvdWNoU2Vuc29yIGV4dGVuZHMgX1NlbnNvcjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogRm9yY2VUb3VjaFNlbnNvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBGb3JjZVRvdWNoU2Vuc29yXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfE5vZGVMaXN0fEhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVyc1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcnMgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihjb250YWluZXJzLCBvcHRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERyYWdnYWJsZSBlbGVtZW50IG5lZWRzIHRvIGJlIHJlbWVtYmVyZWQgdG8gdW5zZXQgdGhlIGRyYWdnYWJsZSBhdHRyaWJ1dGUgYWZ0ZXIgZHJhZyBvcGVyYXRpb24gaGFzIGNvbXBsZXRlZFxyXG4gICAgICogQHByb3BlcnR5IG1pZ2h0RHJhZ1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMubWlnaHREcmFnID0gZmFsc2U7XHJcblxyXG4gICAgdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dID0gdGhpc1tvbk1vdXNlRm9yY2VXaWxsQmVnaW5dLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VGb3JjZURvd25dID0gdGhpc1tvbk1vdXNlRm9yY2VEb3duXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlRG93bl0gPSB0aGlzW29uTW91c2VEb3duXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdID0gdGhpc1tvbk1vdXNlRm9yY2VDaGFuZ2VdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VNb3ZlXSA9IHRoaXNbb25Nb3VzZU1vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VVcF0gPSB0aGlzW29uTW91c2VVcF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICBmb3IgKGNvbnN0IGNvbnRhaW5lciBvZiB0aGlzLmNvbnRhaW5lcnMpIHtcclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLCB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0sIGZhbHNlKTtcclxuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2Vkb3duJywgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSwgZmFsc2UpO1xyXG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWNoYW5nZWQnLCB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICBmb3IgKGNvbnN0IGNvbnRhaW5lciBvZiB0aGlzLmNvbnRhaW5lcnMpIHtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2V3aWxsYmVnaW4nLCB0aGlzW29uTW91c2VGb3JjZVdpbGxCZWdpbl0sIGZhbHNlKTtcclxuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdG1vdXNlZm9yY2Vkb3duJywgdGhpc1tvbk1vdXNlRm9yY2VEb3duXSwgZmFsc2UpO1xyXG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0bW91c2Vmb3JjZWNoYW5nZWQnLCB0aGlzW29uTW91c2VGb3JjZUNoYW5nZV0sIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpc1tvbk1vdXNlVXBdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGZvcmNlIHdpbGwgYmVnaW4gaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSB3aWxsIGJlZ2luIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VGb3JjZVdpbGxCZWdpbl0oZXZlbnQpIHtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB0aGlzLm1pZ2h0RHJhZyA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBmb3JjZSBkb3duIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZm9yY2UgZG93biBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRm9yY2VEb3duXShldmVudCkge1xyXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdGFydEV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnU3RhcnRTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGNvbnRhaW5lciwgZHJhZ1N0YXJ0RXZlbnQpO1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIHRoaXMuZHJhZ2dpbmcgPSAhZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKTtcclxuICAgIHRoaXMubWlnaHREcmFnID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSB1cCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIHVwIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VVcF0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0b3BTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldDogbnVsbCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBudWxsO1xyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5taWdodERyYWcgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGRvd24gaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBkb3duIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VEb3duXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLm1pZ2h0RHJhZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTmVlZCB3b3JrYXJvdW5kIGZvciByZWFsIGNsaWNrXHJcbiAgICAvLyBDYW5jZWwgcG90ZW50aWFsIGRyYWcgZXZlbnRzXHJcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIG1vdmUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSB3aWxsIGJlZ2luIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VNb3ZlXShldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdNb3ZlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdNb3ZlU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jdXJyZW50Q29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRoaXMuY3VycmVudENvbnRhaW5lciwgZHJhZ01vdmVFdmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBmb3JjZSBjaGFuZ2UgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSBjaGFuZ2UgZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZUZvcmNlQ2hhbmdlXShldmVudCkge1xyXG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XHJcblxyXG4gICAgY29uc3QgZHJhZ1ByZXNzdXJlRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50KHtcclxuICAgICAgcHJlc3N1cmU6IGV2ZW50LndlYmtpdEZvcmNlLFxyXG4gICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxyXG4gICAgICB0YXJnZXQsXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdQcmVzc3VyZUV2ZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIGZvcmNlIGdsb2JhbCBjaGFuZ2UgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSBmb3JjZSBnbG9iYWwgY2hhbmdlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uTW91c2VGb3JjZUdsb2JhbENoYW5nZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuICAgIGNvbnN0IGRyYWdQcmVzc3VyZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnUHJlc3N1cmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIHByZXNzdXJlOiBldmVudC53ZWJraXRGb3JjZSxcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdQcmVzc3VyZUV2ZW50KTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gRm9yY2VUb3VjaFNlbnNvcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRm9yY2VUb3VjaFNlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xyXG5cclxudmFyIF9Gb3JjZVRvdWNoU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0ZvcmNlVG91Y2hTZW5zb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9Gb3JjZVRvdWNoU2Vuc29yMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG52YXIgX1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpO1xyXG5cclxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XHJcbmNvbnN0IG9uTW91c2VVcCA9IFN5bWJvbCgnb25Nb3VzZVVwJyk7XHJcbmNvbnN0IG9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdPdmVyID0gU3ltYm9sKCdvbkRyYWdPdmVyJyk7XHJcbmNvbnN0IG9uRHJhZ0VuZCA9IFN5bWJvbCgnb25EcmFnRW5kJyk7XHJcbmNvbnN0IG9uRHJvcCA9IFN5bWJvbCgnb25Ecm9wJyk7XHJcbmNvbnN0IHJlc2V0ID0gU3ltYm9sKCdyZXNldCcpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgc2Vuc29yIHBpY2tzIHVwIG5hdGl2ZSBicm93c2VyIGRyYWcgZXZlbnRzIGFuZCBkaWN0YXRlcyBkcmFnIG9wZXJhdGlvbnNcclxuICogQGNsYXNzIERyYWdTZW5zb3JcclxuICogQG1vZHVsZSBEcmFnU2Vuc29yXHJcbiAqIEBleHRlbmRzIFNlbnNvclxyXG4gKi9cclxuY2xhc3MgRHJhZ1NlbnNvciBleHRlbmRzIF9TZW5zb3IyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIERyYWdTZW5zb3IgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgRHJhZ1NlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3VzZSBkb3duIHRpbWVyIHdoaWNoIHdpbGwgZW5kIHVwIHNldHRpbmcgdGhlIGRyYWdnYWJsZSBhdHRyaWJ1dGUsIHVubGVzcyBjYW5jZWxlZFxyXG4gICAgICogQHByb3BlcnR5IG1vdXNlRG93blRpbWVvdXRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmFnZ2FibGUgZWxlbWVudCBuZWVkcyB0byBiZSByZW1lbWJlcmVkIHRvIHVuc2V0IHRoZSBkcmFnZ2FibGUgYXR0cmlidXRlIGFmdGVyIGRyYWcgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWRcclxuICAgICAqIEBwcm9wZXJ0eSBkcmFnZ2FibGVFbGVtZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOYXRpdmUgZHJhZ2dhYmxlIGVsZW1lbnQgY291bGQgYmUgbGlua3Mgb3IgaW1hZ2VzLCB0aGVpciBkcmFnZ2FibGUgc3RhdGUgd2lsbCBiZSBkaXNhYmxlZCBkdXJpbmcgZHJhZyBvcGVyYXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSBuYXRpdmVEcmFnZ2FibGVFbGVtZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9IG51bGw7XHJcblxyXG4gICAgdGhpc1tvbk1vdXNlRG93bl0gPSB0aGlzW29uTW91c2VEb3duXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1vdXNlVXBdID0gdGhpc1tvbk1vdXNlVXBdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ092ZXJdID0gdGhpc1tvbkRyYWdPdmVyXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdFbmRdID0gdGhpc1tvbkRyYWdFbmRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJvcF0gPSB0aGlzW29uRHJvcF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIERyYWcgc3RhcnQgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnU3RhcnRdKGV2ZW50KSB7XHJcbiAgICAvLyBOZWVkIGZvciBmaXJlZm94LiBcInRleHRcIiBrZXkgaXMgbmVlZGVkIGZvciBJRVxyXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQnLCAnJyk7XHJcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IHRoaXMub3B0aW9ucy50eXBlO1xyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSAoMCwgX3V0aWxzLmNsb3Nlc3QpKGV2ZW50LnRhcmdldCwgdGhpcy5jb250YWluZXJzKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuY3VycmVudENvbnRhaW5lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdGFydFNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFdvcmthcm91bmRcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XHJcblxyXG4gICAgICBpZiAoZHJhZ1N0YXJ0RXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSwgMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG92ZXIgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBEcmFnIG92ZXIgZXZlbnRcclxuICAgKi9cclxuICBbb25EcmFnT3Zlcl0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbnRhaW5lcjtcclxuXHJcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnTW92ZVNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnTW92ZUV2ZW50KTtcclxuXHJcbiAgICBpZiAoIWRyYWdNb3ZlRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IHRoaXMub3B0aW9ucy50eXBlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBlbmQgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBEcmFnIGVuZCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyYWdFbmRdKGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0sIHRydWUpO1xyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmN1cnJlbnRDb250YWluZXI7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0b3BTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKGNvbnRhaW5lciwgZHJhZ1N0b3BFdmVudCk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXNbcmVzZXRdKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcm9wIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gRHJvcCBldmVudFxyXG4gICAqL1xyXG4gIFtvbkRyb3BdKGV2ZW50KSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBkb3duIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgZG93biBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlRG93bl0oZXZlbnQpIHtcclxuICAgIC8vIEZpcmVmb3ggYnVnIGZvciBpbnB1dHMgd2l0aGluIGRyYWdnYWJsZXMgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzM5MDcxXHJcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICYmIChldmVudC50YXJnZXQuZm9ybSB8fCBldmVudC50YXJnZXQuY29udGVudGVkaXRhYmxlKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmF0aXZlRHJhZ2dhYmxlRWxlbWVudCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCBlbGVtZW50ID0+IGVsZW1lbnQuZHJhZ2dhYmxlKTtcclxuXHJcbiAgICBpZiAobmF0aXZlRHJhZ2dhYmxlRWxlbWVudCkge1xyXG4gICAgICBuYXRpdmVEcmFnZ2FibGVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQgPSBuYXRpdmVEcmFnZ2FibGVFbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzW29uTW91c2VVcF0sIHRydWUpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0sIGZhbHNlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpc1tvbkRyYWdPdmVyXSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIHRoaXNbb25EcmFnRW5kXSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXNbb25Ecm9wXSwgZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKTtcclxuXHJcbiAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5tb3VzZURvd25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xyXG4gICAgICB0aGlzLmRyYWdnYWJsZUVsZW1lbnQgPSB0YXJnZXQ7XHJcbiAgICB9LCB0aGlzLm9wdGlvbnMuZGVsYXkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgdXAgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlVXBdKCkge1xyXG4gICAgdGhpc1tyZXNldF0oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1vdXNlIHVwIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgdXAgZXZlbnRcclxuICAgKi9cclxuICBbcmVzZXRdKCkge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSwgdHJ1ZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSwgZmFsc2UpO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzW29uRHJhZ092ZXJdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpc1tvbkRyYWdFbmRdLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpc1tvbkRyb3BdLCBmYWxzZSk7XHJcblxyXG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlRWxlbWVudCkge1xyXG4gICAgICB0aGlzLm5hdGl2ZURyYWdnYWJsZUVsZW1lbnQuZHJhZ2dhYmxlID0gdHJ1ZTtcclxuICAgICAgdGhpcy5uYXRpdmVEcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5kcmFnZ2FibGVFbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuZHJhZ2dhYmxlRWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcclxuICAgICAgdGhpcy5kcmFnZ2FibGVFbGVtZW50ID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ1NlbnNvcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfRHJhZ1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG5cclxudmFyIF9EcmFnU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RyYWdTZW5zb3IpO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmV4cG9ydHMuZGVmYXVsdCA9IF9EcmFnU2Vuc29yMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG52YXIgX1NlbnNvciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG52YXIgX1NlbnNvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TZW5zb3IpO1xyXG5cclxudmFyIF9TZW5zb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Ub3VjaFN0YXJ0ID0gU3ltYm9sKCdvblRvdWNoU3RhcnQnKTtcclxuY29uc3Qgb25Ub3VjaEhvbGQgPSBTeW1ib2woJ29uVG91Y2hIb2xkJyk7XHJcbmNvbnN0IG9uVG91Y2hFbmQgPSBTeW1ib2woJ29uVG91Y2hFbmQnKTtcclxuY29uc3Qgb25Ub3VjaE1vdmUgPSBTeW1ib2woJ29uVG91Y2hNb3ZlJyk7XHJcblxyXG4vKipcclxuICogUHJldmVudHMgc2Nyb2xsaW5nIHdoZW4gc2V0IHRvIHRydWVcclxuICogQHZhciB7Qm9vbGVhbn0gcHJldmVudFNjcm9sbGluZ1xyXG4gKi9cclxubGV0IHByZXZlbnRTY3JvbGxpbmcgPSBmYWxzZTtcclxuXHJcbi8vIFdlYktpdCByZXF1aXJlcyBjYW5jZWxhYmxlIGB0b3VjaG1vdmVgIGV2ZW50cyB0byBiZSBhZGRlZCBhcyBlYXJseSBhcyBwb3NzaWJsZVxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZXZlbnQgPT4ge1xyXG4gIGlmICghcHJldmVudFNjcm9sbGluZykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gUHJldmVudCBzY3JvbGxpbmdcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG59LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgc2Vuc29yIHBpY2tzIHVwIG5hdGl2ZSBicm93c2VyIHRvdWNoIGV2ZW50cyBhbmQgZGljdGF0ZXMgZHJhZyBvcGVyYXRpb25zXHJcbiAqIEBjbGFzcyBUb3VjaFNlbnNvclxyXG4gKiBAbW9kdWxlIFRvdWNoU2Vuc29yXHJcbiAqIEBleHRlbmRzIFNlbnNvclxyXG4gKi9cclxuY2xhc3MgVG91Y2hTZW5zb3IgZXh0ZW5kcyBfU2Vuc29yMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBUb3VjaFNlbnNvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBUb3VjaFNlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXN0IHNjcm9sbGFibGUgY29udGFpbmVyIHNvIGFjY2lkZW50YWwgc2Nyb2xsIGNhbiBjYW5jZWwgbG9uZyB0b3VjaFxyXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRTY3JvbGxhYmxlUGFyZW50XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3VycmVudFNjcm9sbGFibGVQYXJlbnQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGltZW91dElEIGZvciBsb25nIHRvdWNoXHJcbiAgICAgKiBAcHJvcGVydHkgdGFwVGltZW91dFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy50YXBUaW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHRvdWNoTW92ZWQgaW5kaWNhdGVzIGlmIHRvdWNoIGhhcyBtb3ZlZCBkdXJpbmcgdGFwVGltZW91dFxyXG4gICAgICogQHByb3BlcnR5IHRvdWNoTW92ZWRcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRvdWNoTW92ZWQgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzW29uVG91Y2hTdGFydF0gPSB0aGlzW29uVG91Y2hTdGFydF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Ub3VjaEhvbGRdID0gdGhpc1tvblRvdWNoSG9sZF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25Ub3VjaEVuZF0gPSB0aGlzW29uVG91Y2hFbmRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uVG91Y2hNb3ZlXSA9IHRoaXNbb25Ub3VjaE1vdmVdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXNbb25Ub3VjaFN0YXJ0XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXNbb25Ub3VjaFN0YXJ0XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUb3VjaCBzdGFydCBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRvdWNoIHN0YXJ0IGV2ZW50XHJcbiAgICovXHJcbiAgW29uVG91Y2hTdGFydF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZXZlbnQudGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xyXG5cclxuICAgIGlmICghY29udGFpbmVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzW29uVG91Y2hNb3ZlXSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzW29uVG91Y2hFbmRdKTtcclxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUpO1xyXG5cclxuICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgIHRoaXMudGFwVGltZW91dCA9IHNldFRpbWVvdXQodGhpc1tvblRvdWNoSG9sZF0oZXZlbnQsIGNvbnRhaW5lciksIHRoaXMub3B0aW9ucy5kZWxheSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUb3VjaCBob2xkIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVG91Y2ggc3RhcnQgZXZlbnRcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBDb250YWluZXIgZWxlbWVudFxyXG4gICAqL1xyXG4gIFtvblRvdWNoSG9sZF0oZXZlbnQsIGNvbnRhaW5lcikge1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKHRoaXMudG91Y2hNb3ZlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdIHx8IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG4gICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XHJcblxyXG4gICAgICBjb25zdCBkcmFnU3RhcnRFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQoe1xyXG4gICAgICAgIGNsaWVudFg6IHRvdWNoLnBhZ2VYLFxyXG4gICAgICAgIGNsaWVudFk6IHRvdWNoLnBhZ2VZLFxyXG4gICAgICAgIHRhcmdldCxcclxuICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLnRyaWdnZXIoY29udGFpbmVyLCBkcmFnU3RhcnRFdmVudCk7XHJcblxyXG4gICAgICB0aGlzLmRyYWdnaW5nID0gIWRyYWdTdGFydEV2ZW50LmNhbmNlbGVkKCk7XHJcbiAgICAgIHByZXZlbnRTY3JvbGxpbmcgPSB0aGlzLmRyYWdnaW5nO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvdWNoIG1vdmUgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUb3VjaCBtb3ZlIGV2ZW50XHJcbiAgICovXHJcbiAgW29uVG91Y2hNb3ZlXShldmVudCkge1xyXG4gICAgdGhpcy50b3VjaE1vdmVkID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXSB8fCBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2gucGFnZVggLSB3aW5kb3cuc2Nyb2xsWCwgdG91Y2gucGFnZVkgLSB3aW5kb3cuc2Nyb2xsWSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ01vdmVFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ01vdmVTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IHRvdWNoLnBhZ2VYLFxyXG4gICAgICBjbGllbnRZOiB0b3VjaC5wYWdlWSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVG91Y2ggZW5kIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVG91Y2ggZW5kIGV2ZW50XHJcbiAgICovXHJcbiAgW29uVG91Y2hFbmRdKGV2ZW50KSB7XHJcbiAgICB0aGlzLnRvdWNoTW92ZWQgPSBmYWxzZTtcclxuICAgIHByZXZlbnRTY3JvbGxpbmcgPSBmYWxzZTtcclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXNbb25Ub3VjaEVuZF0pO1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzW29uVG91Y2hFbmRdKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXNbb25Ub3VjaE1vdmVdKTtcclxuXHJcbiAgICBpZiAodGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudENvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRhcFRpbWVvdXQpO1xyXG5cclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdIHx8IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5wYWdlWCAtIHdpbmRvdy5zY3JvbGxYLCB0b3VjaC5wYWdlWSAtIHdpbmRvdy5zY3JvbGxZKTtcclxuXHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIGNvbnN0IGRyYWdTdG9wRXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdG9wU2Vuc29yRXZlbnQoe1xyXG4gICAgICBjbGllbnRYOiB0b3VjaC5wYWdlWCxcclxuICAgICAgY2xpZW50WTogdG91Y2gucGFnZVksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBudWxsO1xyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gVG91Y2hTZW5zb3I7XHJcbmZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX1RvdWNoU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XHJcblxyXG52YXIgX1RvdWNoU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RvdWNoU2Vuc29yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfVG91Y2hTZW5zb3IyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdTdG9wU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdNb3ZlU2Vuc29yRXZlbnQgPSBleHBvcnRzLkRyYWdTdGFydFNlbnNvckV2ZW50ID0gZXhwb3J0cy5TZW5zb3JFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2Ugc2Vuc29yIGV2ZW50XHJcbiAqIEBjbGFzcyBTZW5zb3JFdmVudFxyXG4gKiBAbW9kdWxlIFNlbnNvckV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIFNlbnNvckV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIE9yaWdpbmFsIGJyb3dzZXIgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgYSBzZW5zb3JcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxFdmVudFxyXG4gICAqIEB0eXBlIHtFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxFdmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZWQgY2xpZW50WCBmb3IgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzXHJcbiAgICogQHByb3BlcnR5IGNsaWVudFhcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjbGllbnRYKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5jbGllbnRYO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTm9ybWFsaXplZCBjbGllbnRZIGZvciBib3RoIHRvdWNoIGFuZCBtb3VzZSBldmVudHNcclxuICAgKiBAcHJvcGVydHkgY2xpZW50WVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGNsaWVudFkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNsaWVudFk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3JtYWxpemVkIHRhcmdldCBmb3IgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzXHJcbiAgICogUmV0dXJucyB0aGUgZWxlbWVudCB0aGF0IGlzIGJlaGluZCBjdXJzb3Igb3IgdG91Y2ggcG9pbnRlclxyXG4gICAqIEBwcm9wZXJ0eSB0YXJnZXRcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHRhcmdldCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEudGFyZ2V0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udGFpbmVyIHRoYXQgaW5pdGlhdGVkIHRoZSBzZW5zb3JcclxuICAgKiBAcHJvcGVydHkgY29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYWNrcGFkIHByZXNzdXJlXHJcbiAgICogQHByb3BlcnR5IHByZXNzdXJlXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcHJlc3N1cmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnByZXNzdXJlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5TZW5zb3JFdmVudCA9IFNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0YXJ0IHNlbnNvciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnU3RhcnRTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0YXJ0U2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuY2xhc3MgRHJhZ1N0YXJ0U2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxyXG5cclxuZXhwb3J0cy5EcmFnU3RhcnRTZW5zb3JFdmVudCA9IERyYWdTdGFydFNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG1vdmUgc2Vuc29yIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdNb3ZlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdNb3ZlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ1N0YXJ0U2Vuc29yRXZlbnQudHlwZSA9ICdkcmFnOnN0YXJ0JztcclxuY2xhc3MgRHJhZ01vdmVTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdNb3ZlU2Vuc29yRXZlbnQgPSBEcmFnTW92ZVNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBzdG9wIHNlbnNvciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1N0b3BTZW5zb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdTdG9wU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnTW92ZVNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzptb3ZlJztcclxuY2xhc3MgRHJhZ1N0b3BTZW5zb3JFdmVudCBleHRlbmRzIFNlbnNvckV2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdTdG9wU2Vuc29yRXZlbnQgPSBEcmFnU3RvcFNlbnNvckV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBwcmVzc3VyZSBzZW5zb3IgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdQcmVzc3VyZVNlbnNvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgU2Vuc29yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnU3RvcFNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzpzdG9wJztcclxuY2xhc3MgRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQgZXh0ZW5kcyBTZW5zb3JFdmVudCB7fVxyXG5leHBvcnRzLkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50ID0gRHJhZ1ByZXNzdXJlU2Vuc29yRXZlbnQ7XHJcbkRyYWdQcmVzc3VyZVNlbnNvckV2ZW50LnR5cGUgPSAnZHJhZzpwcmVzc3VyZSc7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcbnZhciBfU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcbnZhciBfU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbnNvcik7XHJcblxyXG52YXIgX1NlbnNvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5jb25zdCBvbkNvbnRleHRNZW51V2hpbGVEcmFnZ2luZyA9IFN5bWJvbCgnb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmcnKTtcclxuY29uc3Qgb25Nb3VzZURvd24gPSBTeW1ib2woJ29uTW91c2VEb3duJyk7XHJcbmNvbnN0IG9uTW91c2VNb3ZlID0gU3ltYm9sKCdvbk1vdXNlTW92ZScpO1xyXG5jb25zdCBvbk1vdXNlVXAgPSBTeW1ib2woJ29uTW91c2VVcCcpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgc2Vuc29yIHBpY2tzIHVwIG5hdGl2ZSBicm93c2VyIG1vdXNlIGV2ZW50cyBhbmQgZGljdGF0ZXMgZHJhZyBvcGVyYXRpb25zXHJcbiAqIEBjbGFzcyBNb3VzZVNlbnNvclxyXG4gKiBAbW9kdWxlIE1vdXNlU2Vuc29yXHJcbiAqIEBleHRlbmRzIFNlbnNvclxyXG4gKi9cclxuY2xhc3MgTW91c2VTZW5zb3IgZXh0ZW5kcyBfU2Vuc29yMi5kZWZhdWx0IHtcclxuICAvKipcclxuICAgKiBNb3VzZVNlbnNvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBNb3VzZVNlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoY29udGFpbmVycywgb3B0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgaWYgbW91c2UgYnV0dG9uIGlzIHN0aWxsIGRvd25cclxuICAgICAqIEBwcm9wZXJ0eSBtb3VzZURvd25cclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW91c2UgZG93biB0aW1lciB3aGljaCB3aWxsIGVuZCB1cCB0cmlnZ2VyaW5nIHRoZSBkcmFnIHN0YXJ0IG9wZXJhdGlvblxyXG4gICAgICogQHByb3BlcnR5IG1vdXNlRG93blRpbWVvdXRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubW91c2VEb3duVGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgaWYgY29udGV4dCBtZW51IGhhcyBiZWVuIG9wZW5lZCBkdXJpbmcgZHJhZyBvcGVyYXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSBvcGVuZWRDb250ZXh0TWVudVxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMub3BlbmVkQ29udGV4dE1lbnUgPSBmYWxzZTtcclxuXHJcbiAgICB0aGlzW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXSA9IHRoaXNbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VEb3duXSA9IHRoaXNbb25Nb3VzZURvd25dLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VNb3ZlXSA9IHRoaXNbb25Nb3VzZU1vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uTW91c2VVcF0gPSB0aGlzW29uTW91c2VVcF0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzW29uTW91c2VEb3duXSwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpc1tvbk1vdXNlRG93bl0sIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgZG93biBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIE1vdXNlIGRvd24gZXZlbnRcclxuICAgKi9cclxuICBbb25Nb3VzZURvd25dKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9ICgwLCBfdXRpbHMuY2xvc2VzdCkodGFyZ2V0LCB0aGlzLmNvbnRhaW5lcnMpO1xyXG5cclxuICAgIGlmICghY29udGFpbmVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBwcmV2ZW50TmF0aXZlRHJhZ1N0YXJ0KTtcclxuXHJcbiAgICB0aGlzLm1vdXNlRG93biA9IHRydWU7XHJcblxyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VEb3duVGltZW91dCk7XHJcbiAgICB0aGlzLm1vdXNlRG93blRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLm1vdXNlRG93bikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZHJhZ1N0YXJ0RXZlbnQgPSBuZXcgX1NlbnNvckV2ZW50LkRyYWdTdGFydFNlbnNvckV2ZW50KHtcclxuICAgICAgICBjbGllbnRYOiBldmVudC5jbGllbnRYLFxyXG4gICAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgICAgdGFyZ2V0LFxyXG4gICAgICAgIGNvbnRhaW5lcixcclxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihjb250YWluZXIsIGRyYWdTdGFydEV2ZW50KTtcclxuXHJcbiAgICAgIHRoaXMuY3VycmVudENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgdGhpcy5kcmFnZ2luZyA9ICFkcmFnU3RhcnRFdmVudC5jYW5jZWxlZCgpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXNbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddKTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzW29uTW91c2VNb3ZlXSk7XHJcbiAgICAgIH1cclxuICAgIH0sIHRoaXMub3B0aW9ucy5kZWxheSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gTW91c2UgbW92ZSBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlTW92ZV0oZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy5kcmFnZ2luZykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcclxuXHJcbiAgICBjb25zdCBkcmFnTW92ZUV2ZW50ID0gbmV3IF9TZW5zb3JFdmVudC5EcmFnTW92ZVNlbnNvckV2ZW50KHtcclxuICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcclxuICAgICAgY2xpZW50WTogZXZlbnQuY2xpZW50WSxcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICBjb250YWluZXI6IHRoaXMuY3VycmVudENvbnRhaW5lcixcclxuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aGlzLmN1cnJlbnRDb250YWluZXIsIGRyYWdNb3ZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW91c2UgdXAgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBNb3VzZSB1cCBldmVudFxyXG4gICAqL1xyXG4gIFtvbk1vdXNlVXBdKGV2ZW50KSB7XHJcbiAgICB0aGlzLm1vdXNlRG93biA9IEJvb2xlYW4odGhpcy5vcGVuZWRDb250ZXh0TWVudSk7XHJcblxyXG4gICAgaWYgKHRoaXMub3BlbmVkQ29udGV4dE1lbnUpIHtcclxuICAgICAgdGhpcy5vcGVuZWRDb250ZXh0TWVudSA9IGZhbHNlO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXNbb25Nb3VzZVVwXSk7XHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBwcmV2ZW50TmF0aXZlRHJhZ1N0YXJ0KTtcclxuXHJcbiAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XHJcblxyXG4gICAgY29uc3QgZHJhZ1N0b3BFdmVudCA9IG5ldyBfU2Vuc29yRXZlbnQuRHJhZ1N0b3BTZW5zb3JFdmVudCh7XHJcbiAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXHJcbiAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgY29udGFpbmVyOiB0aGlzLmN1cnJlbnRDb250YWluZXIsXHJcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGhpcy5jdXJyZW50Q29udGFpbmVyLCBkcmFnU3RvcEV2ZW50KTtcclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXNbb25Db250ZXh0TWVudVdoaWxlRHJhZ2dpbmddKTtcclxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXNbb25Nb3VzZU1vdmVdKTtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb250YWluZXIgPSBudWxsO1xyXG4gICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udGV4dCBtZW51IGhhbmRsZXJcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gQ29udGV4dCBtZW51IGV2ZW50XHJcbiAgICovXHJcbiAgW29uQ29udGV4dE1lbnVXaGlsZURyYWdnaW5nXShldmVudCkge1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIHRoaXMub3BlbmVkQ29udGV4dE1lbnUgPSB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gTW91c2VTZW5zb3I7XHJcbmZ1bmN0aW9uIHByZXZlbnROYXRpdmVEcmFnU3RhcnQoZXZlbnQpIHtcclxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX01vdXNlU2Vuc29yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XHJcblxyXG52YXIgX01vdXNlU2Vuc29yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vdXNlU2Vuc29yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfTW91c2VTZW5zb3IyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xyXG5cclxuLyoqXHJcbiAqIEJhc2Ugc2Vuc29yIGNsYXNzLiBFeHRlbmQgZnJvbSB0aGlzIGNsYXNzIHRvIGNyZWF0ZSBhIG5ldyBvciBjdXN0b20gc2Vuc29yXHJcbiAqIEBjbGFzcyBTZW5zb3JcclxuICogQG1vZHVsZSBTZW5zb3JcclxuICovXHJcbmNsYXNzIFNlbnNvciB7XHJcbiAgLyoqXHJcbiAgICogU2Vuc29yIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBjb25zdHJ1Y3RzIFNlbnNvclxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXXxOb2RlTGlzdHxIVE1MRWxlbWVudH0gY29udGFpbmVycyAtIENvbnRhaW5lcnNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcclxuICAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb250YWluZXJzID0gW10sIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGNvbnRhaW5lcnNcclxuICAgICAqIEBwcm9wZXJ0eSBjb250YWluZXJzXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb250YWluZXJzID0gWy4uLmNvbnRhaW5lcnNdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkgb3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBkcmFnIHN0YXRlXHJcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dpbmdcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGNvbnRhaW5lclxyXG4gICAgICogQHByb3BlcnR5IGN1cnJlbnRDb250YWluZXJcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIHNlbnNvcnMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBET01cclxuICAgKiBAcmV0dXJuIHtTZW5zb3J9XHJcbiAgICovXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRhY2hlcyBzZW5zb3JzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgRE9NXHJcbiAgICogQHJldHVybiB7U2Vuc29yfVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBjb250YWluZXIgdG8gdGhpcyBzZW5zb3IgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0gey4uLkhUTUxFbGVtZW50fSBjb250YWluZXJzIC0gQ29udGFpbmVycyB5b3Ugd2FudCB0byBhZGQgdG8gdGhpcyBzZW5zb3JcclxuICAgKiBAZXhhbXBsZSBkcmFnZ2FibGUuYWRkQ29udGFpbmVyKGRvY3VtZW50LmJvZHkpXHJcbiAgICovXHJcbiAgYWRkQ29udGFpbmVyKC4uLmNvbnRhaW5lcnMpIHtcclxuICAgIHRoaXMuY29udGFpbmVycyA9IFsuLi50aGlzLmNvbnRhaW5lcnMsIC4uLmNvbnRhaW5lcnNdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBjb250YWluZXIgZnJvbSB0aGlzIHNlbnNvciBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7Li4uSFRNTEVsZW1lbnR9IGNvbnRhaW5lcnMgLSBDb250YWluZXJzIHlvdSB3YW50IHRvIHJlbW92ZSBmcm9tIHRoaXMgc2Vuc29yXHJcbiAgICogQGV4YW1wbGUgZHJhZ2dhYmxlLnJlbW92ZUNvbnRhaW5lcihkb2N1bWVudC5ib2R5KVxyXG4gICAqL1xyXG4gIHJlbW92ZUNvbnRhaW5lciguLi5jb250YWluZXJzKSB7XHJcbiAgICB0aGlzLmNvbnRhaW5lcnMgPSB0aGlzLmNvbnRhaW5lcnMuZmlsdGVyKGNvbnRhaW5lciA9PiAhY29udGFpbmVycy5pbmNsdWRlcyhjb250YWluZXIpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXJzIGV2ZW50IG9uIHRhcmdldCBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gdHJpZ2dlciBldmVudCBvblxyXG4gICAqIEBwYXJhbSB7U2Vuc29yRXZlbnR9IHNlbnNvckV2ZW50IC0gU2Vuc29yIGV2ZW50IHRvIHRyaWdnZXJcclxuICAgKi9cclxuICB0cmlnZ2VyKGVsZW1lbnQsIHNlbnNvckV2ZW50KSB7XHJcbiAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xyXG4gICAgZXZlbnQuZGV0YWlsID0gc2Vuc29yRXZlbnQ7XHJcbiAgICBldmVudC5pbml0RXZlbnQoc2Vuc29yRXZlbnQudHlwZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgdGhpcy5sYXN0RXZlbnQgPSBzZW5zb3JFdmVudDtcclxuXHJcbiAgICByZXR1cm4gc2Vuc29yRXZlbnQ7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNlbnNvcjtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0OCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZTtcclxuZnVuY3Rpb24gcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xyXG4gIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9yZXF1ZXN0TmV4dEFuaW1hdGlvbkZyYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XHJcblxyXG52YXIgX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVxdWVzdE5leHRBbmltYXRpb25GcmFtZSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gX3JlcXVlc3ROZXh0QW5pbWF0aW9uRnJhbWUyLmRlZmF1bHQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNTAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb3Nlc3Q7XHJcbmNvbnN0IG1hdGNoRnVuY3Rpb24gPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjbG9zZXN0IHBhcmVudCBlbGVtZW50IG9mIGEgZ2l2ZW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuXHJcbiAqIHNlbGVjdG9yIHN0cmluZyBvciBtYXRjaGluZyBmdW5jdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGNoaWxkIGVsZW1lbnQgdG8gZmluZCBhIHBhcmVudCBvZlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgVGhlIHN0cmluZyBvciBmdW5jdGlvbiB0byB1c2UgdG8gbWF0Y2hcclxuICogICAgIHRoZSBwYXJlbnQgZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtFbGVtZW50fG51bGx9XHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9zZXN0KGVsZW1lbnQsIHZhbHVlKSB7XHJcbiAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNlbGVjdG9yID0gdmFsdWU7XHJcbiAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZTtcclxuICBjb25zdCBub2RlTGlzdCA9IHZhbHVlO1xyXG4gIGNvbnN0IHNpbmdsZUVsZW1lbnQgPSB2YWx1ZTtcclxuXHJcbiAgY29uc3QgaXNTZWxlY3RvciA9IEJvb2xlYW4odHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyk7XHJcbiAgY29uc3QgaXNGdW5jdGlvbiA9IEJvb2xlYW4odHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKTtcclxuICBjb25zdCBpc05vZGVMaXN0ID0gQm9vbGVhbih2YWx1ZSBpbnN0YW5jZW9mIE5vZGVMaXN0IHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpO1xyXG4gIGNvbnN0IGlzRWxlbWVudCA9IEJvb2xlYW4odmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCk7XHJcblxyXG4gIGZ1bmN0aW9uIGNvbmRpdGlvbkZuKGN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICBpZiAoIWN1cnJlbnRFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcclxuICAgIH0gZWxzZSBpZiAoaXNTZWxlY3Rvcikge1xyXG4gICAgICByZXR1cm4gbWF0Y2hGdW5jdGlvbi5jYWxsKGN1cnJlbnRFbGVtZW50LCBzZWxlY3Rvcik7XHJcbiAgICB9IGVsc2UgaWYgKGlzTm9kZUxpc3QpIHtcclxuICAgICAgcmV0dXJuIFsuLi5ub2RlTGlzdF0uaW5jbHVkZXMoY3VycmVudEVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIHNpbmdsZUVsZW1lbnQgPT09IGN1cnJlbnRFbGVtZW50O1xyXG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKSB7XHJcbiAgICAgIHJldHVybiBjYWxsYmFjayhjdXJyZW50RWxlbWVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGxldCBjdXJyZW50ID0gZWxlbWVudDtcclxuXHJcbiAgZG8ge1xyXG4gICAgY3VycmVudCA9IGN1cnJlbnQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQgfHwgY3VycmVudC5jb3JyZXNwb25kaW5nRWxlbWVudCB8fCBjdXJyZW50O1xyXG5cclxuICAgIGlmIChjb25kaXRpb25GbihjdXJyZW50KSkge1xyXG4gICAgICByZXR1cm4gY3VycmVudDtcclxuICAgIH1cclxuXHJcbiAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xyXG4gIH0gd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQuYm9keSAmJiBjdXJyZW50ICE9PSBkb2N1bWVudCk7XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNTEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX2Nsb3Nlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcclxuXHJcbnZhciBfY2xvc2VzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbG9zZXN0KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfY2xvc2VzdDIuZGVmYXVsdDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuc2Nyb2xsID0gZXhwb3J0cy5vbkRyYWdTdG9wID0gZXhwb3J0cy5vbkRyYWdNb3ZlID0gZXhwb3J0cy5vbkRyYWdTdGFydCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBleHBvcnRzLm9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdNb3ZlID0gZXhwb3J0cy5vbkRyYWdNb3ZlID0gU3ltYm9sKCdvbkRyYWdNb3ZlJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBleHBvcnRzLm9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgc2Nyb2xsID0gZXhwb3J0cy5zY3JvbGwgPSBTeW1ib2woJ3Njcm9sbCcpO1xyXG5cclxuLyoqXHJcbiAqIFNjcm9sbGFibGUgZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuc3BlZWRcclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlZmF1bHRPcHRpb25zLnNlbnNpdGl2aXR5XHJcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnRbXX0gZGVmYXVsdE9wdGlvbnMuc2Nyb2xsYWJsZUVsZW1lbnRzXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgc3BlZWQ6IDYsXHJcbiAgc2Vuc2l0aXZpdHk6IDUwLFxyXG4gIHNjcm9sbGFibGVFbGVtZW50czogW11cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTY3JvbGxhYmxlIHBsdWdpbiB3aGljaCBzY3JvbGxzIHRoZSBjbG9zZXN0IHNjcm9sbGFibGUgcGFyZW50XHJcbiAqIEBjbGFzcyBTY3JvbGxhYmxlXHJcbiAqIEBtb2R1bGUgU2Nyb2xsYWJsZVxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFBsdWdpblxyXG4gKi9cclxuY2xhc3MgU2Nyb2xsYWJsZSBleHRlbmRzIF9BYnN0cmFjdFBsdWdpbjIuZGVmYXVsdCB7XHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsYWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBTY3JvbGxhYmxlXHJcbiAgICogQHBhcmFtIHtEcmFnZ2FibGV9IGRyYWdnYWJsZSAtIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGRyYWdnYWJsZSkge1xyXG4gICAgc3VwZXIoZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjcm9sbGFibGUgb3B0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBvcHRpb25zLnNwZWVkXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gb3B0aW9ucy5zZW5zaXRpdml0eVxyXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudFtdfSBvcHRpb25zLnNjcm9sbGFibGVFbGVtZW50c1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZWVwcyBjdXJyZW50IG1vdXNlIHBvc2l0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gY3VycmVudE1vdXNlUG9zaXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRYXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY3VycmVudE1vdXNlUG9zaXRpb24uY2xpZW50WVxyXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNjcm9sbCBhbmltYXRpb24gZnJhbWVcclxuICAgICAqIEBwcm9wZXJ0eSBzY3JvbGxBbmltYXRpb25GcmFtZVxyXG4gICAgICogQHR5cGUge051bWJlcnxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjcm9sbEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3Nlc3Qgc2Nyb2xsYWJsZSBlbGVtZW50XHJcbiAgICAgKiBAcHJvcGVydHkgc2Nyb2xsYWJsZUVsZW1lbnRcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudHxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGlvbiBmcmFtZSBsb29raW5nIGZvciB0aGUgY2xvc2VzdCBzY3JvbGxhYmxlIGVsZW1lbnRcclxuICAgICAqIEBwcm9wZXJ0eSBmaW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZVxyXG4gICAgICogQHR5cGUge051bWJlcnxudWxsfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lID0gbnVsbDtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbc2Nyb2xsXSA9IHRoaXNbc2Nyb2xsXS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZzpzdGFydCcsIHRoaXNbb25EcmFnU3RhcnRdKS5vbignZHJhZzptb3ZlJywgdGhpc1tvbkRyYWdNb3ZlXSkub24oJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuc2Nyb2xsYWJsZSB8fCB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgY2xvc2VzdCBzY3JvbGxhYmxlIGVsZW1lbnRzIGJ5IGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgKi9cclxuICBnZXRTY3JvbGxhYmxlRWxlbWVudCh0YXJnZXQpIHtcclxuICAgIGlmICh0aGlzLmhhc0RlZmluZWRTY3JvbGxhYmxlRWxlbWVudHMoKSkge1xyXG4gICAgICByZXR1cm4gKDAsIF91dGlscy5jbG9zZXN0KSh0YXJnZXQsIHRoaXMub3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudHMpIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBjbG9zZXN0U2Nyb2xsYWJsZUVsZW1lbnQodGFyZ2V0KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgc2Nyb2xsYWJsZSBlbGVtZW50IGhhdmUgYmVlbiBkZWZpbmVkIHZpYSBvcHRpb25zXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBoYXNEZWZpbmVkU2Nyb2xsYWJsZUVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5vcHRpb25zLnNjcm9sbGFibGVFbGVtZW50cy5sZW5ndGggIT09IDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdGFydCBoYW5kbGVyLiBGaW5kcyBjbG9zZXN0IHNjcm9sbGFibGUgcGFyZW50IGluIHNlcGFyYXRlIGZyYW1lXHJcbiAgICogQHBhcmFtIHtEcmFnU3RhcnRFdmVudH0gZHJhZ0V2ZW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25EcmFnU3RhcnRdKGRyYWdFdmVudCkge1xyXG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgPSB0aGlzLmdldFNjcm9sbGFibGVFbGVtZW50KGRyYWdFdmVudC5zb3VyY2UpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnIG1vdmUgaGFuZGxlci4gUmVtZW1iZXJzIG1vdXNlIHBvc2l0aW9uIGFuZCBpbml0aWF0ZXMgc2Nyb2xsaW5nXHJcbiAgICogQHBhcmFtIHtEcmFnTW92ZUV2ZW50fSBkcmFnRXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbkRyYWdNb3ZlXShkcmFnRXZlbnQpIHtcclxuICAgIHRoaXMuZmluZFNjcm9sbGFibGVFbGVtZW50RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gdGhpcy5nZXRTY3JvbGxhYmxlRWxlbWVudChkcmFnRXZlbnQuc2Vuc29yRXZlbnQudGFyZ2V0KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghdGhpcy5zY3JvbGxhYmxlRWxlbWVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2Vuc29yRXZlbnQgPSBkcmFnRXZlbnQuc2Vuc29yRXZlbnQ7XHJcbiAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcclxuXHJcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XHJcbiAgICAgIHNjcm9sbE9mZnNldC55ID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgMDtcclxuICAgICAgc2Nyb2xsT2Zmc2V0LnggPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0IHx8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbiA9IHtcclxuICAgICAgY2xpZW50WDogc2Vuc29yRXZlbnQuY2xpZW50WCAtIHNjcm9sbE9mZnNldC54LFxyXG4gICAgICBjbGllbnRZOiBzZW5zb3JFdmVudC5jbGllbnRZIC0gc2Nyb2xsT2Zmc2V0LnlcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzW3Njcm9sbF0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZyBzdG9wIGhhbmRsZXIuIENhbmNlbHMgc2Nyb2xsIGFuaW1hdGlvbnMgYW5kIHJlc2V0cyBzdGF0ZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRHJhZ1N0b3BdKCkge1xyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSk7XHJcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZpbmRTY3JvbGxhYmxlRWxlbWVudEZyYW1lKTtcclxuXHJcbiAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50ID0gbnVsbDtcclxuICAgIHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUgPSBudWxsO1xyXG4gICAgdGhpcy5maW5kU2Nyb2xsYWJsZUVsZW1lbnRGcmFtZSA9IG51bGw7XHJcbiAgICB0aGlzLmN1cnJlbnRNb3VzZVBvc2l0aW9uID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjcm9sbCBmdW5jdGlvbiB0aGF0IGRvZXMgdGhlIGhlYXZ5bGlmdGluZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW3Njcm9sbF0oKSB7XHJcbiAgICBpZiAoIXRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQgfHwgIXRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsQW5pbWF0aW9uRnJhbWUpO1xyXG5cclxuICAgIGNvbnN0IHsgc3BlZWQsIHNlbnNpdGl2aXR5IH0gPSB0aGlzLm9wdGlvbnM7XHJcblxyXG4gICAgY29uc3QgcmVjdCA9IHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBjb25zdCBib3R0b21DdXRPZmYgPSByZWN0LmJvdHRvbSA+IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgIGNvbnN0IHRvcEN1dE9mZiA9IHJlY3QudG9wIDwgMDtcclxuICAgIGNvbnN0IGN1dE9mZiA9IHRvcEN1dE9mZiB8fCBib3R0b21DdXRPZmY7XHJcblxyXG4gICAgY29uc3QgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50ID0gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCk7XHJcbiAgICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9IHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnQ7XHJcbiAgICBjb25zdCBjbGllbnRYID0gdGhpcy5jdXJyZW50TW91c2VQb3NpdGlvbi5jbGllbnRYO1xyXG4gICAgY29uc3QgY2xpZW50WSA9IHRoaXMuY3VycmVudE1vdXNlUG9zaXRpb24uY2xpZW50WTtcclxuXHJcbiAgICBpZiAoc2Nyb2xsYWJsZUVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgc2Nyb2xsYWJsZUVsZW1lbnQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhY3V0T2ZmKSB7XHJcbiAgICAgIGNvbnN0IHsgb2Zmc2V0SGVpZ2h0LCBvZmZzZXRXaWR0aCB9ID0gc2Nyb2xsYWJsZUVsZW1lbnQ7XHJcblxyXG4gICAgICBpZiAocmVjdC50b3AgKyBvZmZzZXRIZWlnaHQgLSBjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3AgKz0gc3BlZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50WSAtIHJlY3QudG9wIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3AgLT0gc3BlZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZWN0LmxlZnQgKyBvZmZzZXRXaWR0aCAtIGNsaWVudFggPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbExlZnQgKz0gc3BlZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50WCAtIHJlY3QubGVmdCA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsTGVmdCAtPSBzcGVlZDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgeyBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCB9ID0gd2luZG93O1xyXG5cclxuICAgICAgaWYgKGNsaWVudFkgPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxUb3AgLT0gc3BlZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoaW5uZXJIZWlnaHQgLSBjbGllbnRZIDwgc2Vuc2l0aXZpdHkpIHtcclxuICAgICAgICBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wICs9IHNwZWVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2xpZW50WCA8IHNlbnNpdGl2aXR5KSB7XHJcbiAgICAgICAgZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50LnNjcm9sbExlZnQgLT0gc3BlZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAoaW5uZXJXaWR0aCAtIGNsaWVudFggPCBzZW5zaXRpdml0eSkge1xyXG4gICAgICAgIGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxMZWZ0ICs9IHNwZWVkO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zY3JvbGxBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzW3Njcm9sbF0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5kZWZhdWx0ID0gU2Nyb2xsYWJsZTsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaGFzIG92ZXJmbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5mdW5jdGlvbiBoYXNPdmVyZmxvdyhlbGVtZW50KSB7XHJcbiAgY29uc3Qgb3ZlcmZsb3dSZWdleCA9IC8oYXV0b3xzY3JvbGwpLztcclxuICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XHJcblxyXG4gIGNvbnN0IG92ZXJmbG93ID0gY29tcHV0ZWRTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cnKSArIGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXknKSArIGNvbXB1dGVkU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXgnKTtcclxuXHJcbiAgcmV0dXJuIG92ZXJmbG93UmVnZXgudGVzdChvdmVyZmxvdyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCBlbGVtZW50IGlzIHN0YXRpY2FsbHkgcG9zaXRpb25lZFxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1N0YXRpY2FsbHlQb3NpdGlvbmVkKGVsZW1lbnQpIHtcclxuICBjb25zdCBwb3NpdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKTtcclxuICByZXR1cm4gcG9zaXRpb24gPT09ICdzdGF0aWMnO1xyXG59XHJcblxyXG4vKipcclxuICogRmluZHMgY2xvc2VzdCBzY3JvbGxhYmxlIGVsZW1lbnRcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNsb3Nlc3RTY3JvbGxhYmxlRWxlbWVudChlbGVtZW50KSB7XHJcbiAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZ2V0RG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBwb3NpdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKTtcclxuICBjb25zdCBleGNsdWRlU3RhdGljUGFyZW50cyA9IHBvc2l0aW9uID09PSAnYWJzb2x1dGUnO1xyXG5cclxuICBjb25zdCBzY3JvbGxhYmxlRWxlbWVudCA9ICgwLCBfdXRpbHMuY2xvc2VzdCkoZWxlbWVudCwgcGFyZW50ID0+IHtcclxuICAgIGlmIChleGNsdWRlU3RhdGljUGFyZW50cyAmJiBpc1N0YXRpY2FsbHlQb3NpdGlvbmVkKHBhcmVudCkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc092ZXJmbG93KHBhcmVudCk7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChwb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCAhc2Nyb2xsYWJsZUVsZW1lbnQpIHtcclxuICAgIHJldHVybiBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHNjcm9sbGFibGVFbGVtZW50O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgZWxlbWVudCB0aGF0IHNjcm9sbHMgZG9jdW1lbnRcclxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoKSB7XHJcbiAgcmV0dXJuIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNTMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX1Njcm9sbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcclxuXHJcbnZhciBfU2Nyb2xsYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TY3JvbGxhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfU2Nyb2xsYWJsZTIuZGVmYXVsdDtcclxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IF9TY3JvbGxhYmxlLmRlZmF1bHRPcHRpb25zO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDU0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLk1pcnJvckRlc3Ryb3lFdmVudCA9IGV4cG9ydHMuTWlycm9yTW92ZUV2ZW50ID0gZXhwb3J0cy5NaXJyb3JBdHRhY2hlZEV2ZW50ID0gZXhwb3J0cy5NaXJyb3JDcmVhdGVkRXZlbnQgPSBleHBvcnRzLk1pcnJvckNyZWF0ZUV2ZW50ID0gZXhwb3J0cy5NaXJyb3JFdmVudCA9IHVuZGVmaW5lZDtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuLyoqXHJcbiAqIEJhc2UgbWlycm9yIGV2ZW50XHJcbiAqIEBjbGFzcyBNaXJyb3JFdmVudFxyXG4gKiBAbW9kdWxlIE1pcnJvckV2ZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0RXZlbnRcclxuICovXHJcbmNsYXNzIE1pcnJvckV2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgc291cmNlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgc291cmNlXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzb3VyY2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNvdXJjZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgb3JpZ2luYWwgc291cmNlIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxTb3VyY2VcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG9yaWdpbmFsU291cmNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vcmlnaW5hbFNvdXJjZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgc291cmNlIGNvbnRhaW5lciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IHNvdXJjZUNvbnRhaW5lclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc291cmNlQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2VDb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5zb3IgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgc2Vuc29yRXZlbnRcclxuICAgKiBAdHlwZSB7U2Vuc29yRXZlbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNlbnNvckV2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zZW5zb3JFdmVudDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWcgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgZHJhZ0V2ZW50XHJcbiAgICogQHR5cGUge0RyYWdFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgZHJhZ0V2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kcmFnRXZlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBldmVudCB0aGF0IHRyaWdnZXJlZCBzZW5zb3IgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxFdmVudFxyXG4gICAqIEB0eXBlIHtFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxFdmVudCgpIHtcclxuICAgIGlmICh0aGlzLnNlbnNvckV2ZW50KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLk1pcnJvckV2ZW50ID0gTWlycm9yRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBjcmVhdGUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yQ3JlYXRlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIE1pcnJvckNyZWF0ZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmNsYXNzIE1pcnJvckNyZWF0ZUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge31cclxuXHJcbmV4cG9ydHMuTWlycm9yQ3JlYXRlRXZlbnQgPSBNaXJyb3JDcmVhdGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWlycm9yIGNyZWF0ZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgTWlycm9yQ3JlYXRlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JDcmVhdGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBNaXJyb3JFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuTWlycm9yQ3JlYXRlRXZlbnQudHlwZSA9ICdtaXJyb3I6Y3JlYXRlJztcclxuY2xhc3MgTWlycm9yQ3JlYXRlZEV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG1pcnJvclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbWlycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLk1pcnJvckNyZWF0ZWRFdmVudCA9IE1pcnJvckNyZWF0ZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNaXJyb3IgYXR0YWNoZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JBdHRhY2hlZEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIE1pcnJvckF0dGFjaGVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIE1pcnJvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbk1pcnJvckNyZWF0ZWRFdmVudC50eXBlID0gJ21pcnJvcjpjcmVhdGVkJztcclxuY2xhc3MgTWlycm9yQXR0YWNoZWRFdmVudCBleHRlbmRzIE1pcnJvckV2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlcyBtaXJyb3IgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBtaXJyb3JcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG1pcnJvcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEubWlycm9yO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5NaXJyb3JBdHRhY2hlZEV2ZW50ID0gTWlycm9yQXR0YWNoZWRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1pcnJvciBtb3ZlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBNaXJyb3JNb3ZlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JNb3ZlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGV4dGVuZHMgTWlycm9yRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5NaXJyb3JBdHRhY2hlZEV2ZW50LnR5cGUgPSAnbWlycm9yOmF0dGFjaGVkJztcclxuY2xhc3MgTWlycm9yTW92ZUV2ZW50IGV4dGVuZHMgTWlycm9yRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG1pcnJvclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbWlycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLk1pcnJvck1vdmVFdmVudCA9IE1pcnJvck1vdmVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNaXJyb3IgZGVzdHJveSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIE1pcnJvckRlc3Ryb3lFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1vZHVsZSBNaXJyb3JEZXN0cm95RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIE1pcnJvckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbk1pcnJvck1vdmVFdmVudC50eXBlID0gJ21pcnJvcjptb3ZlJztcclxuTWlycm9yTW92ZUV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBNaXJyb3JEZXN0cm95RXZlbnQgZXh0ZW5kcyBNaXJyb3JFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZXMgbWlycm9yIGVsZW1lbnRcclxuICAgKiBAcHJvcGVydHkgbWlycm9yXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBtaXJyb3IoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm1pcnJvcjtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5NaXJyb3JEZXN0cm95RXZlbnQgPSBNaXJyb3JEZXN0cm95RXZlbnQ7XHJcbk1pcnJvckRlc3Ryb3lFdmVudC50eXBlID0gJ21pcnJvcjpkZXN0cm95JztcclxuTWlycm9yRGVzdHJveUV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDU1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9NaXJyb3JFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xyXG5cclxuT2JqZWN0LmtleXMoX01pcnJvckV2ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xyXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gX01pcnJvckV2ZW50W2tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDU2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZXhwb3J0cy5nZXRBcHBlbmRhYmxlQ29udGFpbmVyID0gZXhwb3J0cy5vblNjcm9sbCA9IGV4cG9ydHMub25NaXJyb3JNb3ZlID0gZXhwb3J0cy5vbk1pcnJvckNyZWF0ZWQgPSBleHBvcnRzLm9uRHJhZ1N0b3AgPSBleHBvcnRzLm9uRHJhZ01vdmUgPSBleHBvcnRzLm9uRHJhZ1N0YXJ0ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG52YXIgX01pcnJvckV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxyXG5cclxuY29uc3Qgb25EcmFnU3RhcnQgPSBleHBvcnRzLm9uRHJhZ1N0YXJ0ID0gU3ltYm9sKCdvbkRyYWdTdGFydCcpO1xyXG5jb25zdCBvbkRyYWdNb3ZlID0gZXhwb3J0cy5vbkRyYWdNb3ZlID0gU3ltYm9sKCdvbkRyYWdNb3ZlJyk7XHJcbmNvbnN0IG9uRHJhZ1N0b3AgPSBleHBvcnRzLm9uRHJhZ1N0b3AgPSBTeW1ib2woJ29uRHJhZ1N0b3AnKTtcclxuY29uc3Qgb25NaXJyb3JDcmVhdGVkID0gZXhwb3J0cy5vbk1pcnJvckNyZWF0ZWQgPSBTeW1ib2woJ29uTWlycm9yQ3JlYXRlZCcpO1xyXG5jb25zdCBvbk1pcnJvck1vdmUgPSBleHBvcnRzLm9uTWlycm9yTW92ZSA9IFN5bWJvbCgnb25NaXJyb3JNb3ZlJyk7XHJcbmNvbnN0IG9uU2Nyb2xsID0gZXhwb3J0cy5vblNjcm9sbCA9IFN5bWJvbCgnb25TY3JvbGwnKTtcclxuY29uc3QgZ2V0QXBwZW5kYWJsZUNvbnRhaW5lciA9IGV4cG9ydHMuZ2V0QXBwZW5kYWJsZUNvbnRhaW5lciA9IFN5bWJvbCgnZ2V0QXBwZW5kYWJsZUNvbnRhaW5lcicpO1xyXG5cclxuLyoqXHJcbiAqIE1pcnJvciBkZWZhdWx0IG9wdGlvbnNcclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRlZmF1bHRPcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVmYXVsdE9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9uc1xyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRlZmF1bHRPcHRpb25zLnhBeGlzXHJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVmYXVsdE9wdGlvbnMueUF4aXNcclxuICogQHByb3BlcnR5IHtudWxsfSBkZWZhdWx0T3B0aW9ucy5jdXJzb3JPZmZzZXRYXHJcbiAqIEBwcm9wZXJ0eSB7bnVsbH0gZGVmYXVsdE9wdGlvbnMuY3Vyc29yT2Zmc2V0WVxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xyXG4gIGNvbnN0cmFpbkRpbWVuc2lvbnM6IGZhbHNlLFxyXG4gIHhBeGlzOiB0cnVlLFxyXG4gIHlBeGlzOiB0cnVlLFxyXG4gIGN1cnNvck9mZnNldFg6IG51bGwsXHJcbiAgY3Vyc29yT2Zmc2V0WTogbnVsbFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1pcnJvciBwbHVnaW4gd2hpY2ggY29udHJvbHMgdGhlIG1pcnJvciBwb3NpdGlvbmluZyB3aGlsZSBkcmFnZ2luZ1xyXG4gKiBAY2xhc3MgTWlycm9yXHJcbiAqIEBtb2R1bGUgTWlycm9yXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBNaXJyb3IgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIE1pcnJvciBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBNaXJyb3JcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWlycm9yIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBvcHRpb25zLnhBeGlzXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IG9wdGlvbnMueUF4aXNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfG51bGx9IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8bnVsbH0gb3B0aW9ucy5jdXJzb3JPZmZzZXRZXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudHxGdW5jdGlvbn0gb3B0aW9ucy5hcHBlbmRUb1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCB0aGlzLmdldE9wdGlvbnMoKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY3JvbGwgb2Zmc2V0IGZvciB0b3VjaCBkZXZpY2VzIGJlY2F1c2UgdGhlIG1pcnJvciBpcyBwb3NpdGlvbmVkIGZpeGVkXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gc2Nyb2xsT2Zmc2V0XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc2Nyb2xsT2Zmc2V0LnhcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY3JvbGxPZmZzZXQueVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbCBzY3JvbGwgb2Zmc2V0IGZvciB0b3VjaCBkZXZpY2VzIGJlY2F1c2UgdGhlIG1pcnJvciBpcyBwb3NpdGlvbmVkIGZpeGVkXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gc2Nyb2xsT2Zmc2V0XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gc2Nyb2xsT2Zmc2V0LnhcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBzY3JvbGxPZmZzZXQueVxyXG4gICAgICovXHJcbiAgICB0aGlzLmluaXRpYWxTY3JvbGxPZmZzZXQgPSB7XHJcbiAgICAgIHg6IHdpbmRvdy5zY3JvbGxYLFxyXG4gICAgICB5OiB3aW5kb3cuc2Nyb2xsWVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzW29uRHJhZ1N0YXJ0XSA9IHRoaXNbb25EcmFnU3RhcnRdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRHJhZ01vdmVdID0gdGhpc1tvbkRyYWdNb3ZlXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbkRyYWdTdG9wXSA9IHRoaXNbb25EcmFnU3RvcF0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25NaXJyb3JDcmVhdGVkXSA9IHRoaXNbb25NaXJyb3JDcmVhdGVkXS5iaW5kKHRoaXMpO1xyXG4gICAgdGhpc1tvbk1pcnJvck1vdmVdID0gdGhpc1tvbk1pcnJvck1vdmVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uU2Nyb2xsXSA9IHRoaXNbb25TY3JvbGxdLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2hlcyBwbHVnaW5zIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnOnN0YXJ0JywgdGhpc1tvbkRyYWdTdGFydF0pLm9uKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vbignZHJhZzpzdG9wJywgdGhpc1tvbkRyYWdTdG9wXSkub24oJ21pcnJvcjpjcmVhdGVkJywgdGhpc1tvbk1pcnJvckNyZWF0ZWRdKS5vbignbWlycm9yOm1vdmUnLCB0aGlzW29uTWlycm9yTW92ZV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgcGx1Z2lucyBldmVudCBsaXN0ZW5lcnNcclxuICAgKi9cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vZmYoJ2RyYWc6c3RhcnQnLCB0aGlzW29uRHJhZ1N0YXJ0XSkub2ZmKCdkcmFnOm1vdmUnLCB0aGlzW29uRHJhZ01vdmVdKS5vZmYoJ2RyYWc6c3RvcCcsIHRoaXNbb25EcmFnU3RvcF0pLm9mZignbWlycm9yOmNyZWF0ZWQnLCB0aGlzW29uTWlycm9yQ3JlYXRlZF0pLm9mZignbWlycm9yOm1vdmUnLCB0aGlzW29uTWlycm9yTW92ZV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMubWlycm9yIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgW29uRHJhZ1N0YXJ0XShkcmFnRXZlbnQpIHtcclxuICAgIGlmIChkcmFnRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xyXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzW29uU2Nyb2xsXSwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0ID0ge1xyXG4gICAgICB4OiB3aW5kb3cuc2Nyb2xsWCxcclxuICAgICAgeTogd2luZG93LnNjcm9sbFlcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgeyBzb3VyY2UsIG9yaWdpbmFsU291cmNlLCBzb3VyY2VDb250YWluZXIsIHNlbnNvckV2ZW50IH0gPSBkcmFnRXZlbnQ7XHJcblxyXG4gICAgY29uc3QgbWlycm9yQ3JlYXRlRXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvckNyZWF0ZUV2ZW50KHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgZHJhZ0V2ZW50XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckNyZWF0ZUV2ZW50KTtcclxuXHJcbiAgICBpZiAoaXNOYXRpdmVEcmFnRXZlbnQoc2Vuc29yRXZlbnQpIHx8IG1pcnJvckNyZWF0ZUV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFwcGVuZGFibGVDb250YWluZXIgPSB0aGlzW2dldEFwcGVuZGFibGVDb250YWluZXJdKHNvdXJjZSkgfHwgc291cmNlQ29udGFpbmVyO1xyXG4gICAgdGhpcy5taXJyb3IgPSBzb3VyY2UuY2xvbmVOb2RlKHRydWUpO1xyXG5cclxuICAgIGNvbnN0IG1pcnJvckNyZWF0ZWRFdmVudCA9IG5ldyBfTWlycm9yRXZlbnQuTWlycm9yQ3JlYXRlZEV2ZW50KHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgZHJhZ0V2ZW50LFxyXG4gICAgICBtaXJyb3I6IHRoaXMubWlycm9yXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBtaXJyb3JBdHRhY2hlZEV2ZW50ID0gbmV3IF9NaXJyb3JFdmVudC5NaXJyb3JBdHRhY2hlZEV2ZW50KHtcclxuICAgICAgc291cmNlLFxyXG4gICAgICBvcmlnaW5hbFNvdXJjZSxcclxuICAgICAgc291cmNlQ29udGFpbmVyLFxyXG4gICAgICBzZW5zb3JFdmVudCxcclxuICAgICAgZHJhZ0V2ZW50LFxyXG4gICAgICBtaXJyb3I6IHRoaXMubWlycm9yXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyKG1pcnJvckNyZWF0ZWRFdmVudCk7XHJcbiAgICBhcHBlbmRhYmxlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubWlycm9yKTtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIobWlycm9yQXR0YWNoZWRFdmVudCk7XHJcbiAgfVxyXG5cclxuICBbb25EcmFnTW92ZV0oZHJhZ0V2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMubWlycm9yIHx8IGRyYWdFdmVudC5jYW5jZWxlZCgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHNvdXJjZSwgb3JpZ2luYWxTb3VyY2UsIHNvdXJjZUNvbnRhaW5lciwgc2Vuc29yRXZlbnQgfSA9IGRyYWdFdmVudDtcclxuXHJcbiAgICBjb25zdCBtaXJyb3JNb3ZlRXZlbnQgPSBuZXcgX01pcnJvckV2ZW50Lk1pcnJvck1vdmVFdmVudCh7XHJcbiAgICAgIHNvdXJjZSxcclxuICAgICAgb3JpZ2luYWxTb3VyY2UsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIGRyYWdFdmVudCxcclxuICAgICAgbWlycm9yOiB0aGlzLm1pcnJvclxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JNb3ZlRXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgW29uRHJhZ1N0b3BdKGRyYWdFdmVudCkge1xyXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykge1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzW29uU2Nyb2xsXSwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XHJcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xyXG5cclxuICAgIGlmICghdGhpcy5taXJyb3IpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgc291cmNlLCBzb3VyY2VDb250YWluZXIsIHNlbnNvckV2ZW50IH0gPSBkcmFnRXZlbnQ7XHJcblxyXG4gICAgY29uc3QgbWlycm9yRGVzdHJveUV2ZW50ID0gbmV3IF9NaXJyb3JFdmVudC5NaXJyb3JEZXN0cm95RXZlbnQoe1xyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXHJcbiAgICAgIHNvdXJjZUNvbnRhaW5lcixcclxuICAgICAgc2Vuc29yRXZlbnQsXHJcbiAgICAgIGRyYWdFdmVudFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kcmFnZ2FibGUudHJpZ2dlcihtaXJyb3JEZXN0cm95RXZlbnQpO1xyXG5cclxuICAgIGlmICghbWlycm9yRGVzdHJveUV2ZW50LmNhbmNlbGVkKCkpIHtcclxuICAgICAgdGhpcy5taXJyb3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm1pcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBbb25TY3JvbGxdKCkge1xyXG4gICAgdGhpcy5zY3JvbGxPZmZzZXQgPSB7XHJcbiAgICAgIHg6IHdpbmRvdy5zY3JvbGxYIC0gdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0LngsXHJcbiAgICAgIHk6IHdpbmRvdy5zY3JvbGxZIC0gdGhpcy5pbml0aWFsU2Nyb2xsT2Zmc2V0LnlcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNaXJyb3IgY3JlYXRlZCBoYW5kbGVyXHJcbiAgICogQHBhcmFtIHtNaXJyb3JDcmVhdGVkRXZlbnR9IG1pcnJvckV2ZW50XHJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbk1pcnJvckNyZWF0ZWRdKHsgbWlycm9yLCBzb3VyY2UsIHNlbnNvckV2ZW50IH0pIHtcclxuICAgIGNvbnN0IG1pcnJvckNsYXNzID0gdGhpcy5kcmFnZ2FibGUuZ2V0Q2xhc3NOYW1lRm9yKCdtaXJyb3InKTtcclxuXHJcbiAgICBjb25zdCBzZXRTdGF0ZSA9IChfcmVmKSA9PiB7XHJcbiAgICAgIGxldCB7IG1pcnJvck9mZnNldCwgaW5pdGlhbFgsIGluaXRpYWxZIH0gPSBfcmVmLFxyXG4gICAgICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ21pcnJvck9mZnNldCcsICdpbml0aWFsWCcsICdpbml0aWFsWSddKTtcclxuXHJcbiAgICAgIHRoaXMubWlycm9yT2Zmc2V0ID0gbWlycm9yT2Zmc2V0O1xyXG4gICAgICB0aGlzLmluaXRpYWxYID0gaW5pdGlhbFg7XHJcbiAgICAgIHRoaXMuaW5pdGlhbFkgPSBpbml0aWFsWTtcclxuICAgICAgcmV0dXJuIF9leHRlbmRzKHsgbWlycm9yT2Zmc2V0LCBpbml0aWFsWCwgaW5pdGlhbFkgfSwgYXJncyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcclxuICAgICAgbWlycm9yLFxyXG4gICAgICBzb3VyY2UsXHJcbiAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICBtaXJyb3JDbGFzcyxcclxuICAgICAgc2Nyb2xsT2Zmc2V0OiB0aGlzLnNjcm9sbE9mZnNldCxcclxuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW5pdGlhbFN0YXRlKVxyXG4gICAgLy8gRml4IHJlZmxvdyBoZXJlXHJcbiAgICAudGhlbihjb21wdXRlTWlycm9yRGltZW5zaW9ucykudGhlbihjYWxjdWxhdGVNaXJyb3JPZmZzZXQpLnRoZW4ocmVzZXRNaXJyb3IpLnRoZW4oYWRkTWlycm9yQ2xhc3NlcykudGhlbihwb3NpdGlvbk1pcnJvcih7IGluaXRpYWw6IHRydWUgfSkpLnRoZW4ocmVtb3ZlTWlycm9ySUQpLnRoZW4oc2V0U3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWlycm9yIG1vdmUgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7TWlycm9yTW92ZUV2ZW50fSBtaXJyb3JFdmVudFxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V8bnVsbH1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIFtvbk1pcnJvck1vdmVdKG1pcnJvckV2ZW50KSB7XHJcbiAgICBpZiAobWlycm9yRXZlbnQuY2FuY2VsZWQoKSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XHJcbiAgICAgIG1pcnJvcjogbWlycm9yRXZlbnQubWlycm9yLFxyXG4gICAgICBzZW5zb3JFdmVudDogbWlycm9yRXZlbnQuc2Vuc29yRXZlbnQsXHJcbiAgICAgIG1pcnJvck9mZnNldDogdGhpcy5taXJyb3JPZmZzZXQsXHJcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcclxuICAgICAgaW5pdGlhbFg6IHRoaXMuaW5pdGlhbFgsXHJcbiAgICAgIGluaXRpYWxZOiB0aGlzLmluaXRpYWxZLFxyXG4gICAgICBzY3JvbGxPZmZzZXQ6IHRoaXMuc2Nyb2xsT2Zmc2V0XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW5pdGlhbFN0YXRlKS50aGVuKHBvc2l0aW9uTWlycm9yKHsgcmFmOiB0cnVlIH0pKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYXBwZW5kYWJsZSBjb250YWluZXIgZm9yIG1pcnJvciBiYXNlZCBvbiB0aGUgYXBwZW5kVG8gb3B0aW9uXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMuc291cmNlIC0gQ3VycmVudCBzb3VyY2VcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cclxuICAgKi9cclxuICBbZ2V0QXBwZW5kYWJsZUNvbnRhaW5lcl0oc291cmNlKSB7XHJcbiAgICBjb25zdCBhcHBlbmRUbyA9IHRoaXMub3B0aW9ucy5hcHBlbmRUbztcclxuXHJcbiAgICBpZiAodHlwZW9mIGFwcGVuZFRvID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcHBlbmRUbyk7XHJcbiAgICB9IGVsc2UgaWYgKGFwcGVuZFRvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGFwcGVuZFRvO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXBwZW5kVG8gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIGFwcGVuZFRvKHNvdXJjZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gc291cmNlLnBhcmVudE5vZGU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBNaXJyb3I7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbXB1dGVzIG1pcnJvciBkaW1lbnNpb25zIGJhc2VkIG9uIHRoZSBzb3VyY2UgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFkZHMgc291cmNlUmVjdCB0byBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLnNvdXJjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVNaXJyb3JEaW1lbnNpb25zKF9yZWYyKSB7XHJcbiAgbGV0IHsgc291cmNlIH0gPSBfcmVmMixcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydzb3VyY2UnXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIGNvbnN0IHNvdXJjZVJlY3QgPSBzb3VyY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICByZXNvbHZlKF9leHRlbmRzKHsgc291cmNlLCBzb3VyY2VSZWN0IH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgbWlycm9yIG9mZnNldFxyXG4gKiBBZGRzIG1pcnJvck9mZnNldCB0byBzdGF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcclxuICogQHBhcmFtIHtTZW5zb3JFdmVudH0gc3RhdGUuc2Vuc29yRXZlbnRcclxuICogQHBhcmFtIHtET01SZWN0fSBzdGF0ZS5zb3VyY2VSZWN0XHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGVNaXJyb3JPZmZzZXQoX3JlZjMpIHtcclxuICBsZXQgeyBzZW5zb3JFdmVudCwgc291cmNlUmVjdCwgb3B0aW9ucyB9ID0gX3JlZjMsXHJcbiAgICAgIGFyZ3MgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjMsIFsnc2Vuc29yRXZlbnQnLCAnc291cmNlUmVjdCcsICdvcHRpb25zJ10pO1xyXG5cclxuICByZXR1cm4gd2l0aFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICBjb25zdCB0b3AgPSBvcHRpb25zLmN1cnNvck9mZnNldFkgPT09IG51bGwgPyBzZW5zb3JFdmVudC5jbGllbnRZIC0gc291cmNlUmVjdC50b3AgOiBvcHRpb25zLmN1cnNvck9mZnNldFk7XHJcbiAgICBjb25zdCBsZWZ0ID0gb3B0aW9ucy5jdXJzb3JPZmZzZXRYID09PSBudWxsID8gc2Vuc29yRXZlbnQuY2xpZW50WCAtIHNvdXJjZVJlY3QubGVmdCA6IG9wdGlvbnMuY3Vyc29yT2Zmc2V0WDtcclxuXHJcbiAgICBjb25zdCBtaXJyb3JPZmZzZXQgPSB7IHRvcCwgbGVmdCB9O1xyXG5cclxuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBzZW5zb3JFdmVudCwgc291cmNlUmVjdCwgbWlycm9yT2Zmc2V0LCBvcHRpb25zIH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGx5cyBtaXJyb3Igc3R5bGVzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5taXJyb3JcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc3RhdGUuc291cmNlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZS5vcHRpb25zXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNldE1pcnJvcihfcmVmNCkge1xyXG4gIGxldCB7IG1pcnJvciwgc291cmNlLCBvcHRpb25zIH0gPSBfcmVmNCxcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNCwgWydtaXJyb3InLCAnc291cmNlJywgJ29wdGlvbnMnXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIGxldCBvZmZzZXRIZWlnaHQ7XHJcbiAgICBsZXQgb2Zmc2V0V2lkdGg7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuY29uc3RyYWluRGltZW5zaW9ucykge1xyXG4gICAgICBjb25zdCBjb21wdXRlZFNvdXJjZVN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoc291cmNlKTtcclxuICAgICAgb2Zmc2V0SGVpZ2h0ID0gY29tcHV0ZWRTb3VyY2VTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0Jyk7XHJcbiAgICAgIG9mZnNldFdpZHRoID0gY29tcHV0ZWRTb3VyY2VTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKTtcclxuICAgIH1cclxuXHJcbiAgICBtaXJyb3Iuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xyXG4gICAgbWlycm9yLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcbiAgICBtaXJyb3Iuc3R5bGUudG9wID0gMDtcclxuICAgIG1pcnJvci5zdHlsZS5sZWZ0ID0gMDtcclxuICAgIG1pcnJvci5zdHlsZS5tYXJnaW4gPSAwO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmNvbnN0cmFpbkRpbWVuc2lvbnMpIHtcclxuICAgICAgbWlycm9yLnN0eWxlLmhlaWdodCA9IG9mZnNldEhlaWdodDtcclxuICAgICAgbWlycm9yLnN0eWxlLndpZHRoID0gb2Zmc2V0V2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzb2x2ZShfZXh0ZW5kcyh7IG1pcnJvciwgc291cmNlLCBvcHRpb25zIH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGx5cyBtaXJyb3IgY2xhc3Mgb24gbWlycm9yIGVsZW1lbnRcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLm1pcnJvclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RhdGUubWlycm9yQ2xhc3NcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGFkZE1pcnJvckNsYXNzZXMoX3JlZjUpIHtcclxuICBsZXQgeyBtaXJyb3IsIG1pcnJvckNsYXNzIH0gPSBfcmVmNSxcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNSwgWydtaXJyb3InLCAnbWlycm9yQ2xhc3MnXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIG1pcnJvci5jbGFzc0xpc3QuYWRkKG1pcnJvckNsYXNzKTtcclxuICAgIHJlc29sdmUoX2V4dGVuZHMoeyBtaXJyb3IsIG1pcnJvckNsYXNzIH0sIGFyZ3MpKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgc291cmNlIElEIGZyb20gY2xvbmVkIG1pcnJvciBlbGVtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzdGF0ZS5taXJyb3JcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZU1pcnJvcklEKF9yZWY2KSB7XHJcbiAgbGV0IHsgbWlycm9yIH0gPSBfcmVmNixcclxuICAgICAgYXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNiwgWydtaXJyb3InXSk7XHJcblxyXG4gIHJldHVybiB3aXRoUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIG1pcnJvci5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XHJcbiAgICBkZWxldGUgbWlycm9yLmlkO1xyXG4gICAgcmVzb2x2ZShfZXh0ZW5kcyh7IG1pcnJvciB9LCBhcmdzKSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQb3NpdGlvbnMgbWlycm9yIHdpdGggdHJhbnNsYXRlM2RcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHN0YXRlLm1pcnJvclxyXG4gKiBAcGFyYW0ge1NlbnNvckV2ZW50fSBzdGF0ZS5zZW5zb3JFdmVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUubWlycm9yT2Zmc2V0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0ZS5pbml0aWFsWVxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdGUuaW5pdGlhbFhcclxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlLm9wdGlvbnNcclxuICogQHJldHVybiB7UHJvbWlzZX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHBvc2l0aW9uTWlycm9yKHsgd2l0aEZyYW1lID0gZmFsc2UsIGluaXRpYWwgPSBmYWxzZSB9ID0ge30pIHtcclxuICByZXR1cm4gKF9yZWY3KSA9PiB7XHJcbiAgICBsZXQgeyBtaXJyb3IsIHNlbnNvckV2ZW50LCBtaXJyb3JPZmZzZXQsIGluaXRpYWxZLCBpbml0aWFsWCwgc2Nyb2xsT2Zmc2V0LCBvcHRpb25zIH0gPSBfcmVmNyxcclxuICAgICAgICBhcmdzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWY3LCBbJ21pcnJvcicsICdzZW5zb3JFdmVudCcsICdtaXJyb3JPZmZzZXQnLCAnaW5pdGlhbFknLCAnaW5pdGlhbFgnLCAnc2Nyb2xsT2Zmc2V0JywgJ29wdGlvbnMnXSk7XHJcblxyXG4gICAgcmV0dXJuIHdpdGhQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBfZXh0ZW5kcyh7XHJcbiAgICAgICAgbWlycm9yLFxyXG4gICAgICAgIHNlbnNvckV2ZW50LFxyXG4gICAgICAgIG1pcnJvck9mZnNldCxcclxuICAgICAgICBvcHRpb25zXHJcbiAgICAgIH0sIGFyZ3MpO1xyXG5cclxuICAgICAgaWYgKG1pcnJvck9mZnNldCkge1xyXG4gICAgICAgIGNvbnN0IHggPSBzZW5zb3JFdmVudC5jbGllbnRYIC0gbWlycm9yT2Zmc2V0LmxlZnQgLSBzY3JvbGxPZmZzZXQueDtcclxuICAgICAgICBjb25zdCB5ID0gc2Vuc29yRXZlbnQuY2xpZW50WSAtIG1pcnJvck9mZnNldC50b3AgLSBzY3JvbGxPZmZzZXQueTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMueEF4aXMgJiYgb3B0aW9ucy55QXhpcyB8fCBpbml0aWFsKSB7XHJcbiAgICAgICAgICBtaXJyb3Iuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHt5fXB4LCAwKWA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnhBeGlzICYmICFvcHRpb25zLnlBeGlzKSB7XHJcbiAgICAgICAgICBtaXJyb3Iuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHtpbml0aWFsWX1weCwgMClgO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy55QXhpcyAmJiAhb3B0aW9ucy54QXhpcykge1xyXG4gICAgICAgICAgbWlycm9yLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2luaXRpYWxYfXB4LCAke3l9cHgsIDApYDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbml0aWFsKSB7XHJcbiAgICAgICAgICByZXN1bHQuaW5pdGlhbFggPSB4O1xyXG4gICAgICAgICAgcmVzdWx0LmluaXRpYWxZID0geTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgIH0sIHsgZnJhbWU6IHdpdGhGcmFtZSB9KTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogV3JhcHMgZnVuY3Rpb25zIGluIHByb21pc2Ugd2l0aCBwb3RlbnRpYWwgYW5pbWF0aW9uIGZyYW1lIG9wdGlvblxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMucmFmXHJcbiAqIEByZXR1cm4ge1Byb21pc2V9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoUHJvbWlzZShjYWxsYmFjaywgeyByYWYgPSBmYWxzZSB9ID0ge30pIHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgaWYgKHJhZikge1xyXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgIGNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2Vuc29yIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYnkgYSBuYXRpdmUgYnJvd3NlciBkcmFnIGV2ZW50XHJcbiAqIEBwYXJhbSB7U2Vuc29yRXZlbnR9IHNlbnNvckV2ZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpc05hdGl2ZURyYWdFdmVudChzZW5zb3JFdmVudCkge1xyXG4gIHJldHVybiAoL15kcmFnLy50ZXN0KHNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQudHlwZSlcclxuICApO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNTcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX01pcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xyXG5cclxudmFyIF9NaXJyb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWlycm9yKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfTWlycm9yMi5kZWZhdWx0O1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX01pcnJvci5kZWZhdWx0T3B0aW9ucztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1OCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuXHJcbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cclxuXHJcbmNvbnN0IG9uSW5pdGlhbGl6ZSA9IFN5bWJvbCgnb25Jbml0aWFsaXplJyk7XHJcbmNvbnN0IG9uRGVzdHJveSA9IFN5bWJvbCgnb25EZXN0cm95Jyk7XHJcblxyXG4vKipcclxuICogRm9jdXNhYmxlIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGVmYXVsdE9wdGlvbnNcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge307XHJcblxyXG4vKipcclxuICogRm9jdXNhYmxlIHBsdWdpblxyXG4gKiBAY2xhc3MgRm9jdXNhYmxlXHJcbiAqIEBtb2R1bGUgRm9jdXNhYmxlXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBGb2N1c2FibGUgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIEZvY3VzYWJsZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBGb2N1c2FibGVcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9jdXNhYmxlIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcclxuXHJcbiAgICB0aGlzW29uSW5pdGlhbGl6ZV0gPSB0aGlzW29uSW5pdGlhbGl6ZV0uYmluZCh0aGlzKTtcclxuICAgIHRoaXNbb25EZXN0cm95XSA9IHRoaXNbb25EZXN0cm95XS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXR0YWNoZXMgbGlzdGVuZXJzIHRvIGRyYWdnYWJsZVxyXG4gICAqL1xyXG4gIGF0dGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9uKCdkcmFnZ2FibGU6aW5pdGlhbGl6ZScsIHRoaXNbb25Jbml0aWFsaXplXSkub24oJ2RyYWdnYWJsZTpkZXN0cm95JywgdGhpc1tvbkRlc3Ryb3ldKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGFjaGVzIGxpc3RlbmVycyBmcm9tIGRyYWdnYWJsZVxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZHJhZ2dhYmxlLm9mZignZHJhZ2dhYmxlOmluaXRpYWxpemUnLCB0aGlzW29uSW5pdGlhbGl6ZV0pLm9mZignZHJhZ2dhYmxlOmRlc3Ryb3knLCB0aGlzW29uRGVzdHJveV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGRyYWdnYWJsZVxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRPcHRpb25zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlLm9wdGlvbnMuZm9jdXNhYmxlIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBkcmFnZ2FibGUgY29udGFpbmVycyBhbmQgZWxlbWVudHNcclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudFtdfVxyXG4gICAqL1xyXG4gIGdldEVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIFsuLi50aGlzLmRyYWdnYWJsZS5jb250YWluZXJzLCAuLi50aGlzLmRyYWdnYWJsZS5nZXREcmFnZ2FibGVFbGVtZW50cygpXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGlhbGl6ZSBoYW5kbGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25Jbml0aWFsaXplXSgpIHtcclxuICAgIC8vIENhbiB3YWl0IHVudGlsIHRoZSBuZXh0IGJlc3QgZnJhbWUgaXMgYXZhaWxhYmxlXHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICB0aGlzLmdldEVsZW1lbnRzKCkuZm9yRWFjaChlbGVtZW50ID0+IGRlY29yYXRlRWxlbWVudChlbGVtZW50KSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgaGFuZGxlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRGVzdHJveV0oKSB7XHJcbiAgICAvLyBDYW4gd2FpdCB1bnRpbCB0aGUgbmV4dCBiZXN0IGZyYW1lIGlzIGF2YWlsYWJsZVxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgdGhpcy5nZXRFbGVtZW50cygpLmZvckVhY2goZWxlbWVudCA9PiBzdHJpcEVsZW1lbnQoZWxlbWVudCkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBGb2N1c2FibGU7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgbWlzc2luZyB0YWJpbmRleCBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc28gdGhleSBjYW4gYmUgcmVzZXQgd2hlbiBkcmFnZ2FibGUgZ2V0cyBkZXN0cm95ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3Qge0hUTUxFbGVtZW50W119IGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuY29uc3QgZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4ID0gW107XHJcblxyXG4vKipcclxuICogRGVjb3JhdGVzIGVsZW1lbnQgd2l0aCB0YWJpbmRleCBhdHRyaWJ1dGVzXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZGVjb3JhdGVFbGVtZW50KGVsZW1lbnQpIHtcclxuICBjb25zdCBoYXNNaXNzaW5nVGFiSW5kZXggPSBCb29sZWFuKCFlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSAmJiBlbGVtZW50LnRhYkluZGV4ID09PSAtMSk7XHJcblxyXG4gIGlmIChoYXNNaXNzaW5nVGFiSW5kZXgpIHtcclxuICAgIGVsZW1lbnRzV2l0aE1pc3NpbmdUYWJJbmRleC5wdXNoKGVsZW1lbnQpO1xyXG4gICAgZWxlbWVudC50YWJJbmRleCA9IDA7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBlbGVtZW50cyB0YWJpbmRleCBhdHRyaWJ1dGVzXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHN0cmlwRWxlbWVudChlbGVtZW50KSB7XHJcbiAgY29uc3QgdGFiSW5kZXhFbGVtZW50UG9zaXRpb24gPSBlbGVtZW50c1dpdGhNaXNzaW5nVGFiSW5kZXguaW5kZXhPZihlbGVtZW50KTtcclxuXHJcbiAgaWYgKHRhYkluZGV4RWxlbWVudFBvc2l0aW9uICE9PSAtMSkge1xyXG4gICAgZWxlbWVudC50YWJJbmRleCA9IC0xO1xyXG4gICAgZWxlbWVudHNXaXRoTWlzc2luZ1RhYkluZGV4LnNwbGljZSh0YWJJbmRleEVsZW1lbnRQb3NpdGlvbiwgMSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogNTkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcblxyXG52YXIgX0ZvY3VzYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xyXG5cclxudmFyIF9Gb2N1c2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRm9jdXNhYmxlKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfRm9jdXNhYmxlMi5kZWZhdWx0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDYwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG4vKipcclxuICogQWxsIGRyYWdnYWJsZSBwbHVnaW5zIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzLlxyXG4gKiBAYWJzdHJhY3RcclxuICogQGNsYXNzIEFic3RyYWN0UGx1Z2luXHJcbiAqIEBtb2R1bGUgQWJzdHJhY3RQbHVnaW5cclxuICovXHJcbmNsYXNzIEFic3RyYWN0UGx1Z2luIHtcclxuICAvKipcclxuICAgKiBBYnN0cmFjdFBsdWdpbiBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBBYnN0cmFjdFBsdWdpblxyXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlfSBkcmFnZ2FibGUgLSBEcmFnZ2FibGUgaW5zdGFuY2VcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkcmFnZ2FibGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICAgKiBAcHJvcGVydHkgZHJhZ2dhYmxlXHJcbiAgICAgKiBAdHlwZSB7RHJhZ2dhYmxlfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRyYWdnYWJsZSA9IGRyYWdnYWJsZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE92ZXJyaWRlIHRvIGFkZCBsaXN0ZW5lcnNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBJbXBsZW1lbnRlZCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGUgdG8gcmVtb3ZlIGxpc3RlbmVyc1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xyXG4gIGRldGFjaCgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm90IEltcGxlbWVudGVkJyk7XHJcbiAgfVxyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0UGx1Z2luO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDYxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxudmFyIF9BYnN0cmFjdFBsdWdpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdFBsdWdpbik7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuY29uc3Qgb25Jbml0aWFsaXplID0gU3ltYm9sKCdvbkluaXRpYWxpemUnKTtcclxuY29uc3Qgb25EZXN0cm95ID0gU3ltYm9sKCdvbkRlc3Ryb3knKTtcclxuY29uc3QgYW5ub3VuY2VFdmVudCA9IFN5bWJvbCgnYW5ub3VuY2VFdmVudCcpO1xyXG5jb25zdCBhbm5vdW5jZU1lc3NhZ2UgPSBTeW1ib2woJ2Fubm91bmNlTWVzc2FnZScpO1xyXG5cclxuY29uc3QgQVJJQV9SRUxFVkFOVCA9ICdhcmlhLXJlbGV2YW50JztcclxuY29uc3QgQVJJQV9BVE9NSUMgPSAnYXJpYS1hdG9taWMnO1xyXG5jb25zdCBBUklBX0xJVkUgPSAnYXJpYS1saXZlJztcclxuY29uc3QgUk9MRSA9ICdyb2xlJztcclxuXHJcbi8qKlxyXG4gKiBBbm5vdW5jZW1lbnQgZGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkZWZhdWx0T3B0aW9uc1xyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVmYXVsdE9wdGlvbnMuZXhwaXJlXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB7XHJcbiAgZXhwaXJlOiA3MDAwXHJcbn07XHJcblxyXG4vKipcclxuICogQW5ub3VuY2VtZW50IHBsdWdpblxyXG4gKiBAY2xhc3MgQW5ub3VuY2VtZW50XHJcbiAqIEBtb2R1bGUgQW5ub3VuY2VtZW50XHJcbiAqIEBleHRlbmRzIEFic3RyYWN0UGx1Z2luXHJcbiAqL1xyXG5jbGFzcyBBbm5vdW5jZW1lbnQgZXh0ZW5kcyBfQWJzdHJhY3RQbHVnaW4yLmRlZmF1bHQge1xyXG4gIC8qKlxyXG4gICAqIEFubm91bmNlbWVudCBjb25zdHJ1Y3Rvci5cclxuICAgKiBAY29uc3RydWN0cyBBbm5vdW5jZW1lbnRcclxuICAgKiBAcGFyYW0ge0RyYWdnYWJsZX0gZHJhZ2dhYmxlIC0gRHJhZ2dhYmxlIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZHJhZ2dhYmxlKSB7XHJcbiAgICBzdXBlcihkcmFnZ2FibGUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGx1Z2luIG9wdGlvbnNcclxuICAgICAqIEBwcm9wZXJ0eSBvcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIHRoaXMuZ2V0T3B0aW9ucygpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9yaWdpbmFsIGRyYWdnYWJsZSB0cmlnZ2VyIG1ldGhvZC4gSGFjayB1bnRpbCB3ZSBoYXZlIG9uQWxsIG9yIG9uKCdhbGwnKVxyXG4gICAgICogQHByb3BlcnR5IG9yaWdpbmFsVHJpZ2dlck1ldGhvZFxyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9yaWdpbmFsVHJpZ2dlck1ldGhvZCA9IHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXI7XHJcblxyXG4gICAgdGhpc1tvbkluaXRpYWxpemVdID0gdGhpc1tvbkluaXRpYWxpemVdLmJpbmQodGhpcyk7XHJcbiAgICB0aGlzW29uRGVzdHJveV0gPSB0aGlzW29uRGVzdHJveV0uYmluZCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEF0dGFjaGVzIGxpc3RlbmVycyB0byBkcmFnZ2FibGVcclxuICAgKi9cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS5vbignZHJhZ2dhYmxlOmluaXRpYWxpemUnLCB0aGlzW29uSW5pdGlhbGl6ZV0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0YWNoZXMgbGlzdGVuZXJzIGZyb20gZHJhZ2dhYmxlXHJcbiAgICovXHJcbiAgZGV0YWNoKCkge1xyXG4gICAgdGhpcy5kcmFnZ2FibGUub2ZmKCdkcmFnZ2FibGU6ZGVzdHJveScsIHRoaXNbb25EZXN0cm95XSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHBhc3NlZCBpbiBvcHRpb25zXHJcbiAgICovXHJcbiAgZ2V0T3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZS5vcHRpb25zLmFubm91bmNlbWVudHMgfHwge307XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbm5vdW5jZXMgZXZlbnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RFdmVudH0gZXZlbnRcclxuICAgKi9cclxuICBbYW5ub3VuY2VFdmVudF0oZXZlbnQpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnNbZXZlbnQudHlwZV07XHJcblxyXG4gICAgaWYgKG1lc3NhZ2UgJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRoaXNbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzW2Fubm91bmNlTWVzc2FnZV0obWVzc2FnZShldmVudCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW5ub3VuY2VzIG1lc3NhZ2UgdG8gc2NyZWVuIHJlYWRlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcclxuICAgKi9cclxuICBbYW5ub3VuY2VNZXNzYWdlXShtZXNzYWdlKSB7XHJcbiAgICBhbm5vdW5jZShtZXNzYWdlLCB7IGV4cGlyZTogdGhpcy5vcHRpb25zLmV4cGlyZSB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgaGFuZGVyXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBbb25Jbml0aWFsaXplXSgpIHtcclxuICAgIC8vIEhhY2sgdW50aWwgdGhlcmUgaXMgYW4gYXBpIGZvciBsaXN0ZW5pbmcgZm9yIGFsbCBldmVudHNcclxuICAgIHRoaXMuZHJhZ2dhYmxlLnRyaWdnZXIgPSBldmVudCA9PiB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpc1thbm5vdW5jZUV2ZW50XShldmVudCk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgb3JpZ2luYWwgdHJpZ2dlciBpcyBjYWxsZWRcclxuICAgICAgICB0aGlzLm9yaWdpbmFsVHJpZ2dlck1ldGhvZC5jYWxsKHRoaXMuZHJhZ2dhYmxlLCBldmVudCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IGhhbmRlclxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgW29uRGVzdHJveV0oKSB7XHJcbiAgICB0aGlzLmRyYWdnYWJsZS50cmlnZ2VyID0gdGhpcy5vcmlnaW5hbFRyaWdnZXJNZXRob2Q7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBBbm5vdW5jZW1lbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjb25zdCB7SFRNTEVsZW1lbnR9IGxpdmVSZWdpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbmNvbnN0IGxpdmVSZWdpb24gPSBjcmVhdGVSZWdpb24oKTtcclxuXHJcbi8qKlxyXG4gKiBBbm5vdW5jZXMgbWVzc2FnZSB2aWEgbGl2ZSByZWdpb25cclxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZXhwaXJlXHJcbiAqL1xyXG5mdW5jdGlvbiBhbm5vdW5jZShtZXNzYWdlLCB7IGV4cGlyZSB9KSB7XHJcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG5cclxuICBlbGVtZW50LnRleHRDb250ZW50ID0gbWVzc2FnZTtcclxuICBsaXZlUmVnaW9uLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xyXG5cclxuICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICBsaXZlUmVnaW9uLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xyXG4gIH0sIGV4cGlyZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIHJlZ2lvbiBlbGVtZW50XHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVnaW9uKCkge1xyXG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2RyYWdnYWJsZS1saXZlLXJlZ2lvbicpO1xyXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKEFSSUFfUkVMRVZBTlQsICdhZGRpdGlvbnMnKTtcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZShBUklBX0FUT01JQywgJ3RydWUnKTtcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZShBUklBX0xJVkUsICdhc3NlcnRpdmUnKTtcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZShST0xFLCAnbG9nJyk7XHJcblxyXG4gIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xyXG4gIGVsZW1lbnQuc3R5bGUud2lkdGggPSAnMXB4JztcclxuICBlbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxcHgnO1xyXG4gIGVsZW1lbnQuc3R5bGUudG9wID0gJy0xcHgnO1xyXG4gIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuXHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn1cclxuXHJcbi8vIEFwcGVuZCBsaXZlIHJlZ2lvbiBlbGVtZW50IGFzIGVhcmx5IGFzIHBvc3NpYmxlXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XHJcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaXZlUmVnaW9uKTtcclxufSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNjIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG52YXIgX0Fubm91bmNlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG5cclxudmFyIF9Bbm5vdW5jZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQW5ub3VuY2VtZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG5leHBvcnRzLmRlZmF1bHQgPSBfQW5ub3VuY2VtZW50Mi5kZWZhdWx0O1xyXG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gX0Fubm91bmNlbWVudC5kZWZhdWx0T3B0aW9ucztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2MyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5EcmFnZ2FibGVEZXN0cm95RXZlbnQgPSBleHBvcnRzLkRyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQgPSBleHBvcnRzLkRyYWdnYWJsZUV2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogQmFzZSBkcmFnZ2FibGUgZXZlbnRcclxuICogQGNsYXNzIERyYWdnYWJsZUV2ZW50XHJcbiAqIEBtb2R1bGUgRHJhZ2dhYmxlRXZlbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgRHJhZ2dhYmxlRXZlbnQgZXh0ZW5kcyBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBpbnN0YW5jZVxyXG4gICAqIEBwcm9wZXJ0eSBkcmFnZ2FibGVcclxuICAgKiBAdHlwZSB7RHJhZ2dhYmxlfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBkcmFnZ2FibGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmRyYWdnYWJsZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ2dhYmxlRXZlbnQgPSBEcmFnZ2FibGVFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZ2dhYmxlIGluaXRpYWxpemVkIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnZ2FibGVFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ2dhYmxlRXZlbnQudHlwZSA9ICdkcmFnZ2FibGUnO1xyXG5jbGFzcyBEcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50IGV4dGVuZHMgRHJhZ2dhYmxlRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudCA9IERyYWdnYWJsZUluaXRpYWxpemVkRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnZ2FibGUgZGVzdG9yeSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ2dhYmxlSW5pdGlhbGl6ZWRFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdnYWJsZURlc3Ryb3lFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnZ2FibGVEZXN0cm95RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnZ2FibGVJbml0aWFsaXplZEV2ZW50LnR5cGUgPSAnZHJhZ2dhYmxlOmluaXRpYWxpemUnO1xyXG5jbGFzcyBEcmFnZ2FibGVEZXN0cm95RXZlbnQgZXh0ZW5kcyBEcmFnZ2FibGVFdmVudCB7fVxyXG5leHBvcnRzLkRyYWdnYWJsZURlc3Ryb3lFdmVudCA9IERyYWdnYWJsZURlc3Ryb3lFdmVudDtcclxuRHJhZ2dhYmxlRGVzdHJveUV2ZW50LnR5cGUgPSAnZHJhZ2dhYmxlOmRlc3Ryb3knO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDY0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xyXG4gIHZhbHVlOiB0cnVlXHJcbn0pO1xyXG5cclxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcclxuXHJcbmNvbnN0IGNhbmNlbGVkID0gU3ltYm9sKCdjYW5jZWxlZCcpO1xyXG5cclxuLyoqXHJcbiAqIEFsbCBldmVudHMgZmlyZWQgYnkgZHJhZ2dhYmxlIGluaGVyaXQgdGhpcyBjbGFzcy4gWW91IGNhbiBjYWxsIGBjYW5jZWwoKWAgdG9cclxuICogY2FuY2VsIGEgc3BlY2lmaWMgZXZlbnQgb3IgeW91IGNhbiBjaGVjayBpZiBhbiBldmVudCBoYXMgYmVlbiBjYW5jZWxlZCBieVxyXG4gKiBjYWxsaW5nIGBjYW5jZWxlZCgpYC5cclxuICogQGFic3RyYWN0XHJcbiAqIEBjbGFzcyBBYnN0cmFjdEV2ZW50XHJcbiAqIEBtb2R1bGUgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIEFic3RyYWN0RXZlbnQgY29uc3RydWN0b3IuXHJcbiAgICogQGNvbnN0cnVjdHMgQWJzdHJhY3RFdmVudFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gRXZlbnQgZGF0YVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBFdmVudCB0eXBlXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwcm9wZXJ0eSB0eXBlXHJcbiAgICogQHR5cGUge1N0cmluZ31cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XHJcbiAgICB0aGlzW2NhbmNlbGVkXSA9IGZhbHNlO1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWQtb25seSB0eXBlXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHJldHVybiB7U3RyaW5nfVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRXZlbnQgY2FuY2VsYWJsZVxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqL1xyXG4gIGdldCB0eXBlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudHlwZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWQtb25seSBjYW5jZWxhYmxlXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgY2FuY2VsYWJsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNhbmNlbGFibGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYW5jZWxzIHRoZSBldmVudCBpbnN0YW5jZVxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xyXG4gIGNhbmNlbCgpIHtcclxuICAgIHRoaXNbY2FuY2VsZWRdID0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGV2ZW50IGhhcyBiZWVuIGNhbmNlbGVkXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKi9cclxuICBjYW5jZWxlZCgpIHtcclxuICAgIHJldHVybiBCb29sZWFuKHRoaXNbY2FuY2VsZWRdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgbmV3IGV2ZW50IGluc3RhbmNlIHdpdGggZXhpc3RpbmcgZXZlbnQgZGF0YS5cclxuICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgZm9yIG92ZXJyaWRpbmcgb2YgZXZlbnQgZGF0YS5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG4gICAqIEByZXR1cm4ge0Fic3RyYWN0RXZlbnR9XHJcbiAgICovXHJcbiAgY2xvbmUoZGF0YSkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKF9leHRlbmRzKHt9LCB0aGlzLmRhdGEsIGRhdGEpKTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3RFdmVudDtcclxuQWJzdHJhY3RFdmVudC50eXBlID0gJ2V2ZW50JztcclxuQWJzdHJhY3RFdmVudC5jYW5jZWxhYmxlID0gZmFsc2U7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNjUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XHJcbiAgdmFsdWU6IHRydWVcclxufSk7XHJcbmV4cG9ydHMuRHJhZ1N0b3BFdmVudCA9IGV4cG9ydHMuRHJhZ1ByZXNzdXJlRXZlbnQgPSBleHBvcnRzLkRyYWdPdXRDb250YWluZXJFdmVudCA9IGV4cG9ydHMuRHJhZ092ZXJDb250YWluZXJFdmVudCA9IGV4cG9ydHMuRHJhZ091dEV2ZW50ID0gZXhwb3J0cy5EcmFnT3ZlckV2ZW50ID0gZXhwb3J0cy5EcmFnTW92ZUV2ZW50ID0gZXhwb3J0cy5EcmFnU3RhcnRFdmVudCA9IGV4cG9ydHMuRHJhZ0V2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9BYnN0cmFjdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BYnN0cmFjdEV2ZW50KTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XHJcblxyXG4vKipcclxuICogQmFzZSBkcmFnIGV2ZW50XHJcbiAqIEBjbGFzcyBEcmFnRXZlbnRcclxuICogQG1vZHVsZSBEcmFnRXZlbnRcclxuICogQGV4dGVuZHMgQWJzdHJhY3RFdmVudFxyXG4gKi9cclxuY2xhc3MgRHJhZ0V2ZW50IGV4dGVuZHMgX0Fic3RyYWN0RXZlbnQyLmRlZmF1bHQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIHNvdXJjZSBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IHNvdXJjZVxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgc291cmNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zb3VyY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG9yaWdpbmFsIHNvdXJjZSBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG9yaWdpbmFsU291cmNlXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvcmlnaW5hbFNvdXJjZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3JpZ2luYWxTb3VyY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIG1pcnJvciBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IG1pcnJvclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgbWlycm9yKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5taXJyb3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGVzIHNvdXJjZSBjb250YWluZXIgZWxlbWVudFxyXG4gICAqIEBwcm9wZXJ0eSBzb3VyY2VDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHNvdXJjZUNvbnRhaW5lcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc291cmNlQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2Vuc29yIGV2ZW50XHJcbiAgICogQHByb3BlcnR5IHNlbnNvckV2ZW50XHJcbiAgICogQHR5cGUge1NlbnNvckV2ZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBzZW5zb3JFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEuc2Vuc29yRXZlbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPcmlnaW5hbCBldmVudCB0aGF0IHRyaWdnZXJlZCBzZW5zb3IgZXZlbnRcclxuICAgKiBAcHJvcGVydHkgb3JpZ2luYWxFdmVudFxyXG4gICAqIEB0eXBlIHtFdmVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3JpZ2luYWxFdmVudCgpIHtcclxuICAgIGlmICh0aGlzLnNlbnNvckV2ZW50KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNlbnNvckV2ZW50Lm9yaWdpbmFsRXZlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLkRyYWdFdmVudCA9IERyYWdFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0YXJ0IGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1N0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0YXJ0RXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnRXZlbnQudHlwZSA9ICdkcmFnJztcclxuY2xhc3MgRHJhZ1N0YXJ0RXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge31cclxuXHJcbmV4cG9ydHMuRHJhZ1N0YXJ0RXZlbnQgPSBEcmFnU3RhcnRFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBtb3ZlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdNb3ZlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdNb3ZlRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdTdGFydEV2ZW50LnR5cGUgPSAnZHJhZzpzdGFydCc7XHJcbkRyYWdTdGFydEV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBEcmFnTW92ZUV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHt9XHJcblxyXG5leHBvcnRzLkRyYWdNb3ZlRXZlbnQgPSBEcmFnTW92ZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBvdmVyIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnT3ZlckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ092ZXJFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnTW92ZUV2ZW50LnR5cGUgPSAnZHJhZzptb3ZlJztcclxuY2xhc3MgRHJhZ092ZXJFdmVudCBleHRlbmRzIERyYWdFdmVudCB7XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYWdnYWJsZSBjb250YWluZXIgeW91IGFyZSBvdmVyXHJcbiAgICogQHByb3BlcnR5IG92ZXJDb250YWluZXJcclxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IG92ZXJDb250YWluZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLm92ZXJDb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgZWxlbWVudCB5b3UgYXJlIG92ZXJcclxuICAgKiBAcHJvcGVydHkgb3ZlclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ092ZXJFdmVudCA9IERyYWdPdmVyRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIG91dCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ091dEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ091dEV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdPdmVyRXZlbnQudHlwZSA9ICdkcmFnOm92ZXInO1xyXG5EcmFnT3ZlckV2ZW50LmNhbmNlbGFibGUgPSB0cnVlO1xyXG5jbGFzcyBEcmFnT3V0RXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIHlvdSBhcmUgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGVsZW1lbnQgeW91IGxlZnRcclxuICAgKiBAcHJvcGVydHkgb3ZlclxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgb3ZlcigpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGEub3ZlcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydHMuRHJhZ091dEV2ZW50ID0gRHJhZ091dEV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgb3ZlciBjb250YWluZXIgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEcmFnT3ZlckNvbnRhaW5lckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdPdmVyQ29udGFpbmVyRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5EcmFnT3V0RXZlbnQudHlwZSA9ICdkcmFnOm91dCc7XHJcbmNsYXNzIERyYWdPdmVyQ29udGFpbmVyRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBEcmFnZ2FibGUgY29udGFpbmVyIHlvdSBhcmUgb3ZlclxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnT3ZlckNvbnRhaW5lckV2ZW50ID0gRHJhZ092ZXJDb250YWluZXJFdmVudDsgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERyYWcgb3V0IGNvbnRhaW5lciBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ091dENvbnRhaW5lckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ091dENvbnRhaW5lckV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcbkRyYWdPdmVyQ29udGFpbmVyRXZlbnQudHlwZSA9ICdkcmFnOm92ZXI6Y29udGFpbmVyJztcclxuY2xhc3MgRHJhZ091dENvbnRhaW5lckV2ZW50IGV4dGVuZHMgRHJhZ0V2ZW50IHtcclxuXHJcbiAgLyoqXHJcbiAgICogRHJhZ2dhYmxlIGNvbnRhaW5lciB5b3UgbGVmdFxyXG4gICAqIEBwcm9wZXJ0eSBvdmVyQ29udGFpbmVyXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvdmVyQ29udGFpbmVyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5vdmVyQ29udGFpbmVyO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnT3V0Q29udGFpbmVyRXZlbnQgPSBEcmFnT3V0Q29udGFpbmVyRXZlbnQ7IC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRHJhZyBwcmVzc3VyZSBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzIERyYWdQcmVzc3VyZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbW9kdWxlIERyYWdQcmVzc3VyZUV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXh0ZW5kcyBEcmFnRXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ091dENvbnRhaW5lckV2ZW50LnR5cGUgPSAnZHJhZzpvdXQ6Y29udGFpbmVyJztcclxuY2xhc3MgRHJhZ1ByZXNzdXJlRXZlbnQgZXh0ZW5kcyBEcmFnRXZlbnQge1xyXG5cclxuICAvKipcclxuICAgKiBQcmVzc3VyZSBhcHBsaWVkIG9uIGRyYWdnYWJsZSBlbGVtZW50XHJcbiAgICogQHByb3BlcnR5IHByZXNzdXJlXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcHJlc3N1cmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLnByZXNzdXJlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0cy5EcmFnUHJlc3N1cmVFdmVudCA9IERyYWdQcmVzc3VyZUV2ZW50OyAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEcmFnIHN0b3AgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3MgRHJhZ1N0b3BFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgRHJhZ1N0b3BFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBleHRlbmRzIERyYWdFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuRHJhZ1ByZXNzdXJlRXZlbnQudHlwZSA9ICdkcmFnOnByZXNzdXJlJztcclxuY2xhc3MgRHJhZ1N0b3BFdmVudCBleHRlbmRzIERyYWdFdmVudCB7fVxyXG5leHBvcnRzLkRyYWdTdG9wRXZlbnQgPSBEcmFnU3RvcEV2ZW50O1xyXG5EcmFnU3RvcEV2ZW50LnR5cGUgPSAnZHJhZzpzdG9wJztcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2NiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcclxuICB2YWx1ZTogdHJ1ZVxyXG59KTtcclxuZXhwb3J0cy5QbHVnaW5zID0gZXhwb3J0cy5TZW5zb3JzID0gZXhwb3J0cy5Tb3J0YWJsZSA9IGV4cG9ydHMuU3dhcHBhYmxlID0gZXhwb3J0cy5Ecm9wcGFibGUgPSBleHBvcnRzLkRyYWdnYWJsZSA9IGV4cG9ydHMuQmFzZVBsdWdpbiA9IGV4cG9ydHMuQmFzZUV2ZW50ID0gdW5kZWZpbmVkO1xyXG5cclxudmFyIF9EcmFnZ2FibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdEcmFnZ2FibGUnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EcmFnZ2FibGUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfRHJvcHBhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Ryb3BwYWJsZScsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Ryb3BwYWJsZSkuZGVmYXVsdDtcclxuICB9XHJcbn0pO1xyXG5cclxudmFyIF9Td2FwcGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU3dhcHBhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3dhcHBhYmxlKS5kZWZhdWx0O1xyXG4gIH1cclxufSk7XHJcblxyXG52YXIgX1NvcnRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1NvcnRhYmxlJywge1xyXG4gIGVudW1lcmFibGU6IHRydWUsXHJcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU29ydGFibGUpLmRlZmF1bHQ7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBfQWJzdHJhY3RFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG52YXIgX0Fic3RyYWN0RXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RFdmVudCk7XHJcblxyXG52YXIgX0Fic3RyYWN0UGx1Z2luID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbnZhciBfQWJzdHJhY3RQbHVnaW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQWJzdHJhY3RQbHVnaW4pO1xyXG5cclxudmFyIF9TZW5zb3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcbnZhciBTZW5zb3JzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX1NlbnNvcnMpO1xyXG5cclxudmFyIF9QbHVnaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XHJcblxyXG52YXIgUGx1Z2lucyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9QbHVnaW5zKTtcclxuXHJcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxyXG5cclxuZXhwb3J0cy5CYXNlRXZlbnQgPSBfQWJzdHJhY3RFdmVudDIuZGVmYXVsdDtcclxuZXhwb3J0cy5CYXNlUGx1Z2luID0gX0Fic3RyYWN0UGx1Z2luMi5kZWZhdWx0O1xyXG5leHBvcnRzLlNlbnNvcnMgPSBTZW5zb3JzO1xyXG5leHBvcnRzLlBsdWdpbnMgPSBQbHVnaW5zO1xyXG5cclxuLyoqKi8gfSlcclxuLyoqKioqKi8gXSk7XHJcbn0pOyIsICIvKipcclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqIHRvcGJhciAxLjAuMCwgMjAyMS0wMS0wNlxyXG4gKiBodHRwczovL2J1dW5ndXllbi5naXRodWIuaW8vdG9wYmFyXHJcbiAqIENvcHlyaWdodCAoYykgMjAyMSBCdXUgTmd1eWVuXHJcbiAqL1xyXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQpIHtcclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzE1Nzk2NzFcclxuICAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGxhc3RUaW1lID0gMDtcclxuICAgIHZhciB2ZW5kb3JzID0gW1wibXNcIiwgXCJtb3pcIiwgXCJ3ZWJraXRcIiwgXCJvXCJdO1xyXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XHJcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxyXG4gICAgICAgIHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XHJcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9XHJcbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyBcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdIHx8XHJcbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyBcIkNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcclxuICAgIH1cclxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSlcclxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xyXG4gICAgICAgIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XHJcbiAgICAgICAgfSwgdGltZVRvQ2FsbCk7XHJcbiAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XHJcbiAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgICB9O1xyXG4gICAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpXHJcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XHJcbiAgICAgIH07XHJcbiAgfSkoKTtcclxuXHJcbiAgdmFyIGNhbnZhcyxcclxuICAgIHByb2dyZXNzVGltZXJJZCxcclxuICAgIGZhZGVUaW1lcklkLFxyXG4gICAgY3VycmVudFByb2dyZXNzLFxyXG4gICAgc2hvd2luZyxcclxuICAgIGFkZEV2ZW50ID0gZnVuY3Rpb24gKGVsZW0sIHR5cGUsIGhhbmRsZXIpIHtcclxuICAgICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgICAgZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkgZWxlbS5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBoYW5kbGVyKTtcclxuICAgICAgZWxzZSBlbGVtW1wib25cIiArIHR5cGVdID0gaGFuZGxlcjtcclxuICAgIH0sXHJcbiAgICBvcHRpb25zID0ge1xyXG4gICAgICBhdXRvUnVuOiB0cnVlLFxyXG4gICAgICBiYXJUaGlja25lc3M6IDMsXHJcbiAgICAgIGJhckNvbG9yczoge1xyXG4gICAgICAgIDA6IFwicmdiYSgyNiwgIDE4OCwgMTU2LCAuOSlcIixcclxuICAgICAgICBcIi4yNVwiOiBcInJnYmEoNTIsICAxNTIsIDIxOSwgLjkpXCIsXHJcbiAgICAgICAgXCIuNTBcIjogXCJyZ2JhKDI0MSwgMTk2LCAxNSwgIC45KVwiLFxyXG4gICAgICAgIFwiLjc1XCI6IFwicmdiYSgyMzAsIDEyNiwgMzQsICAuOSlcIixcclxuICAgICAgICBcIjEuMFwiOiBcInJnYmEoMjExLCA4NCwgIDAsICAgLjkpXCIsXHJcbiAgICAgIH0sXHJcbiAgICAgIHNoYWRvd0JsdXI6IDEwLFxyXG4gICAgICBzaGFkb3dDb2xvcjogXCJyZ2JhKDAsICAgMCwgICAwLCAgIC42KVwiLFxyXG4gICAgICBjbGFzc05hbWU6IG51bGwsXHJcbiAgICB9LFxyXG4gICAgcmVwYWludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmJhclRoaWNrbmVzcyAqIDU7IC8vIG5lZWQgc3BhY2UgZm9yIHNoYWRvd1xyXG5cclxuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gb3B0aW9ucy5zaGFkb3dCbHVyO1xyXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSBvcHRpb25zLnNoYWRvd0NvbG9yO1xyXG5cclxuICAgICAgdmFyIGxpbmVHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBjYW52YXMud2lkdGgsIDApO1xyXG4gICAgICBmb3IgKHZhciBzdG9wIGluIG9wdGlvbnMuYmFyQ29sb3JzKVxyXG4gICAgICAgIGxpbmVHcmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgb3B0aW9ucy5iYXJDb2xvcnNbc3RvcF0pO1xyXG4gICAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgY3R4Lm1vdmVUbygwLCBvcHRpb25zLmJhclRoaWNrbmVzcyAvIDIpO1xyXG4gICAgICBjdHgubGluZVRvKFxyXG4gICAgICAgIE1hdGguY2VpbChjdXJyZW50UHJvZ3Jlc3MgKiBjYW52YXMud2lkdGgpLFxyXG4gICAgICAgIG9wdGlvbnMuYmFyVGhpY2tuZXNzIC8gMlxyXG4gICAgICApO1xyXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsaW5lR3JhZGllbnQ7XHJcbiAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XHJcbiAgICAgIHZhciBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcclxuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XHJcbiAgICAgIHN0eWxlLnRvcCA9IHN0eWxlLmxlZnQgPSBzdHlsZS5yaWdodCA9IHN0eWxlLm1hcmdpbiA9IHN0eWxlLnBhZGRpbmcgPSAwO1xyXG4gICAgICBzdHlsZS56SW5kZXggPSAxMDAwMDE7XHJcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgaWYgKG9wdGlvbnMuY2xhc3NOYW1lKSBjYW52YXMuY2xhc3NMaXN0LmFkZChvcHRpb25zLmNsYXNzTmFtZSk7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcclxuICAgICAgYWRkRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCByZXBhaW50KTtcclxuICAgIH0sXHJcbiAgICB0b3BiYXIgPSB7XHJcbiAgICAgIGNvbmZpZzogZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0cylcclxuICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIG9wdGlvbnNba2V5XSA9IG9wdHNba2V5XTtcclxuICAgICAgfSxcclxuICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChzaG93aW5nKSByZXR1cm47XHJcbiAgICAgICAgc2hvd2luZyA9IHRydWU7XHJcbiAgICAgICAgaWYgKGZhZGVUaW1lcklkICE9PSBudWxsKSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoZmFkZVRpbWVySWQpO1xyXG4gICAgICAgIGlmICghY2FudmFzKSBjcmVhdGVDYW52YXMoKTtcclxuICAgICAgICBjYW52YXMuc3R5bGUub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgICAgdG9wYmFyLnByb2dyZXNzKDApO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9SdW4pIHtcclxuICAgICAgICAgIChmdW5jdGlvbiBsb29wKCkge1xyXG4gICAgICAgICAgICBwcm9ncmVzc1RpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xyXG4gICAgICAgICAgICB0b3BiYXIucHJvZ3Jlc3MoXHJcbiAgICAgICAgICAgICAgXCIrXCIgKyAwLjA1ICogTWF0aC5wb3coMSAtIE1hdGguc3FydChjdXJyZW50UHJvZ3Jlc3MpLCAyKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSkoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHByb2dyZXNzOiBmdW5jdGlvbiAodG8pIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gY3VycmVudFByb2dyZXNzO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgIHRvID1cclxuICAgICAgICAgICAgKHRvLmluZGV4T2YoXCIrXCIpID49IDAgfHwgdG8uaW5kZXhPZihcIi1cIikgPj0gMFxyXG4gICAgICAgICAgICAgID8gY3VycmVudFByb2dyZXNzXHJcbiAgICAgICAgICAgICAgOiAwKSArIHBhcnNlRmxvYXQodG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50UHJvZ3Jlc3MgPSB0byA+IDEgPyAxIDogdG87XHJcbiAgICAgICAgcmVwYWludCgpO1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50UHJvZ3Jlc3M7XHJcbiAgICAgIH0sXHJcbiAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXNob3dpbmcpIHJldHVybjtcclxuICAgICAgICBzaG93aW5nID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHByb2dyZXNzVGltZXJJZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUocHJvZ3Jlc3NUaW1lcklkKTtcclxuICAgICAgICAgIHByb2dyZXNzVGltZXJJZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIChmdW5jdGlvbiBsb29wKCkge1xyXG4gICAgICAgICAgaWYgKHRvcGJhci5wcm9ncmVzcyhcIisuMVwiKSA+PSAxKSB7XHJcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5vcGFjaXR5IC09IDAuMDU7XHJcbiAgICAgICAgICAgIGlmIChjYW52YXMuc3R5bGUub3BhY2l0eSA8PSAwLjA1KSB7XHJcbiAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgICBmYWRlVGltZXJJZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmYWRlVGltZXJJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XHJcbiAgICAgICAgfSkoKTtcclxuICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b3BiYXI7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRvcGJhcjtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnRvcGJhciA9IHRvcGJhcjtcclxuICB9XHJcbn0uY2FsbCh0aGlzLCB3aW5kb3csIGRvY3VtZW50KSk7XHJcbiIsICIvKiFcclxuICogQ2hhcnQuanMgdjMuOC4wXHJcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXHJcbiAqIChjKSAyMDIyIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcclxuICovXHJcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcclxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcclxuKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkNoYXJ0ID0gZmFjdG9yeSgpKTtcclxufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gZm9udFN0cmluZyhwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xyXG4gIHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XHJcbn1cclxuY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xyXG59KCkpO1xyXG5mdW5jdGlvbiB0aHJvdHRsZWQoZm4sIHRoaXNBcmcsIHVwZGF0ZUZuKSB7XHJcbiAgY29uc3QgdXBkYXRlQXJncyA9IHVwZGF0ZUZuIHx8ICgoYXJncykgPT4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykpO1xyXG4gIGxldCB0aWNraW5nID0gZmFsc2U7XHJcbiAgbGV0IGFyZ3MgPSBbXTtcclxuICByZXR1cm4gZnVuY3Rpb24oLi4ucmVzdCkge1xyXG4gICAgYXJncyA9IHVwZGF0ZUFyZ3MocmVzdCk7XHJcbiAgICBpZiAoIXRpY2tpbmcpIHtcclxuICAgICAgdGlja2luZyA9IHRydWU7XHJcbiAgICAgIHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcclxuICAgICAgICB0aWNraW5nID0gZmFsc2U7XHJcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIGRlbGF5KSB7XHJcbiAgbGV0IHRpbWVvdXQ7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcclxuICAgIGlmIChkZWxheSkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSwgYXJncyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWxheTtcclxuICB9O1xyXG59XHJcbmNvbnN0IF90b0xlZnRSaWdodENlbnRlciA9IChhbGlnbikgPT4gYWxpZ24gPT09ICdzdGFydCcgPyAnbGVmdCcgOiBhbGlnbiA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XHJcbmNvbnN0IF9hbGlnblN0YXJ0RW5kID0gKGFsaWduLCBzdGFydCwgZW5kKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XHJcbmNvbnN0IF90ZXh0WCA9IChhbGlnbiwgbGVmdCwgcmlnaHQsIHJ0bCkgPT4ge1xyXG4gIGNvbnN0IGNoZWNrID0gcnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcclxuICByZXR1cm4gYWxpZ24gPT09IGNoZWNrID8gcmlnaHQgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyAobGVmdCArIHJpZ2h0KSAvIDIgOiBsZWZ0O1xyXG59O1xyXG5cclxuY2xhc3MgQW5pbWF0b3Ige1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XHJcbiAgICB0aGlzLl9jaGFydHMgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLl9sYXN0RGF0ZSA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsIHR5cGUpIHtcclxuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGFuaW1zLmxpc3RlbmVyc1t0eXBlXTtcclxuICAgIGNvbnN0IG51bVN0ZXBzID0gYW5pbXMuZHVyYXRpb247XHJcbiAgICBjYWxsYmFja3MuZm9yRWFjaChmbiA9PiBmbih7XHJcbiAgICAgIGNoYXJ0LFxyXG4gICAgICBpbml0aWFsOiBhbmltcy5pbml0aWFsLFxyXG4gICAgICBudW1TdGVwcyxcclxuICAgICAgY3VycmVudFN0ZXA6IE1hdGgubWluKGRhdGUgLSBhbmltcy5zdGFydCwgbnVtU3RlcHMpXHJcbiAgICB9KSk7XHJcbiAgfVxyXG4gIF9yZWZyZXNoKCkge1xyXG4gICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XHJcbiAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XHJcbiAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgX3VwZGF0ZShkYXRlID0gRGF0ZS5ub3coKSkge1xyXG4gICAgbGV0IHJlbWFpbmluZyA9IDA7XHJcbiAgICB0aGlzLl9jaGFydHMuZm9yRWFjaCgoYW5pbXMsIGNoYXJ0KSA9PiB7XHJcbiAgICAgIGlmICghYW5pbXMucnVubmluZyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XHJcbiAgICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcclxuICAgICAgbGV0IGRyYXcgPSBmYWxzZTtcclxuICAgICAgbGV0IGl0ZW07XHJcbiAgICAgIGZvciAoOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcclxuICAgICAgICBpZiAoaXRlbS5fYWN0aXZlKSB7XHJcbiAgICAgICAgICBpZiAoaXRlbS5fdG90YWwgPiBhbmltcy5kdXJhdGlvbikge1xyXG4gICAgICAgICAgICBhbmltcy5kdXJhdGlvbiA9IGl0ZW0uX3RvdGFsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaXRlbS50aWNrKGRhdGUpO1xyXG4gICAgICAgICAgZHJhdyA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGl0ZW1zW2ldID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICBpdGVtcy5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGRyYXcpIHtcclxuICAgICAgICBjaGFydC5kcmF3KCk7XHJcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ3Byb2dyZXNzJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICBhbmltcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ2NvbXBsZXRlJyk7XHJcbiAgICAgICAgYW5pbXMuaW5pdGlhbCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJlbWFpbmluZyArPSBpdGVtcy5sZW5ndGg7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuX2xhc3REYXRlID0gZGF0ZTtcclxuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcclxuICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICBfZ2V0QW5pbXMoY2hhcnQpIHtcclxuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuX2NoYXJ0cztcclxuICAgIGxldCBhbmltcyA9IGNoYXJ0cy5nZXQoY2hhcnQpO1xyXG4gICAgaWYgKCFhbmltcykge1xyXG4gICAgICBhbmltcyA9IHtcclxuICAgICAgICBydW5uaW5nOiBmYWxzZSxcclxuICAgICAgICBpbml0aWFsOiB0cnVlLFxyXG4gICAgICAgIGl0ZW1zOiBbXSxcclxuICAgICAgICBsaXN0ZW5lcnM6IHtcclxuICAgICAgICAgIGNvbXBsZXRlOiBbXSxcclxuICAgICAgICAgIHByb2dyZXNzOiBbXVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgY2hhcnRzLnNldChjaGFydCwgYW5pbXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFuaW1zO1xyXG4gIH1cclxuICBsaXN0ZW4oY2hhcnQsIGV2ZW50LCBjYikge1xyXG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLmxpc3RlbmVyc1tldmVudF0ucHVzaChjYik7XHJcbiAgfVxyXG4gIGFkZChjaGFydCwgaXRlbXMpIHtcclxuICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMucHVzaCguLi5pdGVtcyk7XHJcbiAgfVxyXG4gIGhhcyhjaGFydCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5sZW5ndGggPiAwO1xyXG4gIH1cclxuICBzdGFydChjaGFydCkge1xyXG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcclxuICAgIGlmICghYW5pbXMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgYW5pbXMucnVubmluZyA9IHRydWU7XHJcbiAgICBhbmltcy5zdGFydCA9IERhdGUubm93KCk7XHJcbiAgICBhbmltcy5kdXJhdGlvbiA9IGFuaW1zLml0ZW1zLnJlZHVjZSgoYWNjLCBjdXIpID0+IE1hdGgubWF4KGFjYywgY3VyLl9kdXJhdGlvbiksIDApO1xyXG4gICAgdGhpcy5fcmVmcmVzaCgpO1xyXG4gIH1cclxuICBydW5uaW5nKGNoYXJ0KSB7XHJcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcclxuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgc3RvcChjaGFydCkge1xyXG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcclxuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xyXG4gICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xyXG4gICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgIGl0ZW1zW2ldLmNhbmNlbCgpO1xyXG4gICAgfVxyXG4gICAgYW5pbXMuaXRlbXMgPSBbXTtcclxuICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIERhdGUubm93KCksICdjb21wbGV0ZScpO1xyXG4gIH1cclxuICByZW1vdmUoY2hhcnQpIHtcclxuICAgIHJldHVybiB0aGlzLl9jaGFydHMuZGVsZXRlKGNoYXJ0KTtcclxuICB9XHJcbn1cclxudmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKCk7XHJcblxyXG4vKiFcclxuICogQGt1cmtsZS9jb2xvciB2MC4yLjFcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcclxuICogKGMpIDIwMjIgSnVra2EgS3Vya2VsYVxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcclxuICovXHJcbmZ1bmN0aW9uIHJvdW5kKHYpIHtcclxuICByZXR1cm4gdiArIDAuNSB8IDA7XHJcbn1cclxuY29uc3QgbGltID0gKHYsIGwsIGgpID0+IE1hdGgubWF4KE1hdGgubWluKHYsIGgpLCBsKTtcclxuZnVuY3Rpb24gcDJiKHYpIHtcclxuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyLjU1KSwgMCwgMjU1KTtcclxufVxyXG5mdW5jdGlvbiBuMmIodikge1xyXG4gIHJldHVybiBsaW0ocm91bmQodiAqIDI1NSksIDAsIDI1NSk7XHJcbn1cclxuZnVuY3Rpb24gYjJuKHYpIHtcclxuICByZXR1cm4gbGltKHJvdW5kKHYgLyAyLjU1KSAvIDEwMCwgMCwgMSk7XHJcbn1cclxuZnVuY3Rpb24gbjJwKHYpIHtcclxuICByZXR1cm4gbGltKHJvdW5kKHYgKiAxMDApLCAwLCAxMDApO1xyXG59XHJcbmNvbnN0IG1hcCQxID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xyXG5jb25zdCBoZXggPSBbLi4uJzAxMjM0NTY3ODlBQkNERUYnXTtcclxuY29uc3QgaDEgPSBiID0+IGhleFtiICYgMHhGXTtcclxuY29uc3QgaDIgPSBiID0+IGhleFsoYiAmIDB4RjApID4+IDRdICsgaGV4W2IgJiAweEZdO1xyXG5jb25zdCBlcSA9IGIgPT4gKChiICYgMHhGMCkgPj4gNCkgPT09IChiICYgMHhGKTtcclxuY29uc3QgaXNTaG9ydCA9IHYgPT4gZXEodi5yKSAmJiBlcSh2LmcpICYmIGVxKHYuYikgJiYgZXEodi5hKTtcclxuZnVuY3Rpb24gaGV4UGFyc2Uoc3RyKSB7XHJcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XHJcbiAgdmFyIHJldDtcclxuICBpZiAoc3RyWzBdID09PSAnIycpIHtcclxuICAgIGlmIChsZW4gPT09IDQgfHwgbGVuID09PSA1KSB7XHJcbiAgICAgIHJldCA9IHtcclxuICAgICAgICByOiAyNTUgJiBtYXAkMVtzdHJbMV1dICogMTcsXHJcbiAgICAgICAgZzogMjU1ICYgbWFwJDFbc3RyWzJdXSAqIDE3LFxyXG4gICAgICAgIGI6IDI1NSAmIG1hcCQxW3N0clszXV0gKiAxNyxcclxuICAgICAgICBhOiBsZW4gPT09IDUgPyBtYXAkMVtzdHJbNF1dICogMTcgOiAyNTVcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAobGVuID09PSA3IHx8IGxlbiA9PT0gOSkge1xyXG4gICAgICByZXQgPSB7XHJcbiAgICAgICAgcjogbWFwJDFbc3RyWzFdXSA8PCA0IHwgbWFwJDFbc3RyWzJdXSxcclxuICAgICAgICBnOiBtYXAkMVtzdHJbM11dIDw8IDQgfCBtYXAkMVtzdHJbNF1dLFxyXG4gICAgICAgIGI6IG1hcCQxW3N0cls1XV0gPDwgNCB8IG1hcCQxW3N0cls2XV0sXHJcbiAgICAgICAgYTogbGVuID09PSA5ID8gKG1hcCQxW3N0cls3XV0gPDwgNCB8IG1hcCQxW3N0cls4XV0pIDogMjU1XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuY29uc3QgYWxwaGEgPSAoYSwgZikgPT4gYSA8IDI1NSA/IGYoYSkgOiAnJztcclxuZnVuY3Rpb24gaGV4U3RyaW5nKHYpIHtcclxuICB2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xyXG4gIHJldHVybiB2XHJcbiAgICA/ICcjJyArIGYodi5yKSArIGYodi5nKSArIGYodi5iKSArIGFscGhhKHYuYSwgZilcclxuICAgIDogdW5kZWZpbmVkO1xyXG59XHJcbmNvbnN0IEhVRV9SRSA9IC9eKGhzbGE/fGh3Ynxoc3YpXFwoXFxzKihbLSsuZVxcZF0rKSg/OmRlZyk/W1xccyxdKyhbLSsuZVxcZF0rKSVbXFxzLF0rKFstKy5lXFxkXSspJSg/OltcXHMsXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XHJcbmZ1bmN0aW9uIGhzbDJyZ2JuKGgsIHMsIGwpIHtcclxuICBjb25zdCBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcclxuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyAzMCkgJSAxMikgPT4gbCAtIGEgKiBNYXRoLm1heChNYXRoLm1pbihrIC0gMywgOSAtIGssIDEpLCAtMSk7XHJcbiAgcmV0dXJuIFtmKDApLCBmKDgpLCBmKDQpXTtcclxufVxyXG5mdW5jdGlvbiBoc3YycmdibihoLCBzLCB2KSB7XHJcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gNjApICUgNikgPT4gdiAtIHYgKiBzICogTWF0aC5tYXgoTWF0aC5taW4oaywgNCAtIGssIDEpLCAwKTtcclxuICByZXR1cm4gW2YoNSksIGYoMyksIGYoMSldO1xyXG59XHJcbmZ1bmN0aW9uIGh3YjJyZ2JuKGgsIHcsIGIpIHtcclxuICBjb25zdCByZ2IgPSBoc2wycmdibihoLCAxLCAwLjUpO1xyXG4gIGxldCBpO1xyXG4gIGlmICh3ICsgYiA+IDEpIHtcclxuICAgIGkgPSAxIC8gKHcgKyBiKTtcclxuICAgIHcgKj0gaTtcclxuICAgIGIgKj0gaTtcclxuICB9XHJcbiAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xyXG4gICAgcmdiW2ldICo9IDEgLSB3IC0gYjtcclxuICAgIHJnYltpXSArPSB3O1xyXG4gIH1cclxuICByZXR1cm4gcmdiO1xyXG59XHJcbmZ1bmN0aW9uIGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCkge1xyXG4gIGlmIChyID09PSBtYXgpIHtcclxuICAgIHJldHVybiAoKGcgLSBiKSAvIGQpICsgKGcgPCBiID8gNiA6IDApO1xyXG4gIH1cclxuICBpZiAoZyA9PT0gbWF4KSB7XHJcbiAgICByZXR1cm4gKGIgLSByKSAvIGQgKyAyO1xyXG4gIH1cclxuICByZXR1cm4gKHIgLSBnKSAvIGQgKyA0O1xyXG59XHJcbmZ1bmN0aW9uIHJnYjJoc2wodikge1xyXG4gIGNvbnN0IHJhbmdlID0gMjU1O1xyXG4gIGNvbnN0IHIgPSB2LnIgLyByYW5nZTtcclxuICBjb25zdCBnID0gdi5nIC8gcmFuZ2U7XHJcbiAgY29uc3QgYiA9IHYuYiAvIHJhbmdlO1xyXG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xyXG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xyXG4gIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XHJcbiAgbGV0IGgsIHMsIGQ7XHJcbiAgaWYgKG1heCAhPT0gbWluKSB7XHJcbiAgICBkID0gbWF4IC0gbWluO1xyXG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xyXG4gICAgaCA9IGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCk7XHJcbiAgICBoID0gaCAqIDYwICsgMC41O1xyXG4gIH1cclxuICByZXR1cm4gW2ggfCAwLCBzIHx8IDAsIGxdO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGxuKGYsIGEsIGIsIGMpIHtcclxuICByZXR1cm4gKFxyXG4gICAgQXJyYXkuaXNBcnJheShhKVxyXG4gICAgICA/IGYoYVswXSwgYVsxXSwgYVsyXSlcclxuICAgICAgOiBmKGEsIGIsIGMpXHJcbiAgKS5tYXAobjJiKTtcclxufVxyXG5mdW5jdGlvbiBoc2wycmdiKGgsIHMsIGwpIHtcclxuICByZXR1cm4gY2FsbG4oaHNsMnJnYm4sIGgsIHMsIGwpO1xyXG59XHJcbmZ1bmN0aW9uIGh3YjJyZ2IoaCwgdywgYikge1xyXG4gIHJldHVybiBjYWxsbihod2IycmdibiwgaCwgdywgYik7XHJcbn1cclxuZnVuY3Rpb24gaHN2MnJnYihoLCBzLCB2KSB7XHJcbiAgcmV0dXJuIGNhbGxuKGhzdjJyZ2JuLCBoLCBzLCB2KTtcclxufVxyXG5mdW5jdGlvbiBodWUoaCkge1xyXG4gIHJldHVybiAoaCAlIDM2MCArIDM2MCkgJSAzNjA7XHJcbn1cclxuZnVuY3Rpb24gaHVlUGFyc2Uoc3RyKSB7XHJcbiAgY29uc3QgbSA9IEhVRV9SRS5leGVjKHN0cik7XHJcbiAgbGV0IGEgPSAyNTU7XHJcbiAgbGV0IHY7XHJcbiAgaWYgKCFtKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChtWzVdICE9PSB2KSB7XHJcbiAgICBhID0gbVs2XSA/IHAyYigrbVs1XSkgOiBuMmIoK21bNV0pO1xyXG4gIH1cclxuICBjb25zdCBoID0gaHVlKCttWzJdKTtcclxuICBjb25zdCBwMSA9ICttWzNdIC8gMTAwO1xyXG4gIGNvbnN0IHAyID0gK21bNF0gLyAxMDA7XHJcbiAgaWYgKG1bMV0gPT09ICdod2InKSB7XHJcbiAgICB2ID0gaHdiMnJnYihoLCBwMSwgcDIpO1xyXG4gIH0gZWxzZSBpZiAobVsxXSA9PT0gJ2hzdicpIHtcclxuICAgIHYgPSBoc3YycmdiKGgsIHAxLCBwMik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHYgPSBoc2wycmdiKGgsIHAxLCBwMik7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICByOiB2WzBdLFxyXG4gICAgZzogdlsxXSxcclxuICAgIGI6IHZbMl0sXHJcbiAgICBhOiBhXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiByb3RhdGUodiwgZGVnKSB7XHJcbiAgdmFyIGggPSByZ2IyaHNsKHYpO1xyXG4gIGhbMF0gPSBodWUoaFswXSArIGRlZyk7XHJcbiAgaCA9IGhzbDJyZ2IoaCk7XHJcbiAgdi5yID0gaFswXTtcclxuICB2LmcgPSBoWzFdO1xyXG4gIHYuYiA9IGhbMl07XHJcbn1cclxuZnVuY3Rpb24gaHNsU3RyaW5nKHYpIHtcclxuICBpZiAoIXYpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgYSA9IHJnYjJoc2wodik7XHJcbiAgY29uc3QgaCA9IGFbMF07XHJcbiAgY29uc3QgcyA9IG4ycChhWzFdKTtcclxuICBjb25zdCBsID0gbjJwKGFbMl0pO1xyXG4gIHJldHVybiB2LmEgPCAyNTVcclxuICAgID8gYGhzbGEoJHtofSwgJHtzfSUsICR7bH0lLCAke2Iybih2LmEpfSlgXHJcbiAgICA6IGBoc2woJHtofSwgJHtzfSUsICR7bH0lKWA7XHJcbn1cclxuY29uc3QgbWFwJDIgPSB7XHJcbiAgeDogJ2RhcmsnLFxyXG4gIFo6ICdsaWdodCcsXHJcbiAgWTogJ3JlJyxcclxuICBYOiAnYmx1JyxcclxuICBXOiAnZ3InLFxyXG4gIFY6ICdtZWRpdW0nLFxyXG4gIFU6ICdzbGF0ZScsXHJcbiAgQTogJ2VlJyxcclxuICBUOiAnb2wnLFxyXG4gIFM6ICdvcicsXHJcbiAgQjogJ3JhJyxcclxuICBDOiAnbGF0ZWcnLFxyXG4gIEQ6ICdpZ2h0cycsXHJcbiAgUjogJ2luJyxcclxuICBROiAndHVycXVvaXMnLFxyXG4gIEU6ICdoaScsXHJcbiAgUDogJ3JvJyxcclxuICBPOiAnYWwnLFxyXG4gIE46ICdsZScsXHJcbiAgTTogJ2RlJyxcclxuICBMOiAneWVsbG8nLFxyXG4gIEY6ICdlbicsXHJcbiAgSzogJ2NoJyxcclxuICBHOiAnYXJrcycsXHJcbiAgSDogJ2VhJyxcclxuICBJOiAnaWdodGcnLFxyXG4gIEo6ICd3aCdcclxufTtcclxuY29uc3QgbmFtZXMkMSA9IHtcclxuICBPaWNlWGU6ICdmMGY4ZmYnLFxyXG4gIGFudGlxdWV3RXRlOiAnZmFlYmQ3JyxcclxuICBhcXVhOiAnZmZmZicsXHJcbiAgYXF1YW1hclJlOiAnN2ZmZmQ0JyxcclxuICBhenVZOiAnZjBmZmZmJyxcclxuICBiZWlnZTogJ2Y1ZjVkYycsXHJcbiAgYmlzcXVlOiAnZmZlNGM0JyxcclxuICBibGFjazogJzAnLFxyXG4gIGJsYW5LZWRPbW9uZDogJ2ZmZWJjZCcsXHJcbiAgWGU6ICdmZicsXHJcbiAgWGV2aVRldDogJzhhMmJlMicsXHJcbiAgYlB3bjogJ2E1MmEyYScsXHJcbiAgYnVybHl3b29kOiAnZGViODg3JyxcclxuICBjYU10WGU6ICc1ZjllYTAnLFxyXG4gIEthcnRZdXNlOiAnN2ZmZjAwJyxcclxuICBLb2NUYXRlOiAnZDI2OTFlJyxcclxuICBjU086ICdmZjdmNTAnLFxyXG4gIGNTbmZsb3dlclhlOiAnNjQ5NWVkJyxcclxuICBjU25zaWxrOiAnZmZmOGRjJyxcclxuICBjcmltc29uOiAnZGMxNDNjJyxcclxuICBjeWFuOiAnZmZmZicsXHJcbiAgeFhlOiAnOGInLFxyXG4gIHhjeWFuOiAnOGI4YicsXHJcbiAgeGdUTW5QZDogJ2I4ODYwYicsXHJcbiAgeFdheTogJ2E5YTlhOScsXHJcbiAgeGdZRjogJzY0MDAnLFxyXG4gIHhnWXk6ICdhOWE5YTknLFxyXG4gIHhraGFraTogJ2JkYjc2YicsXHJcbiAgeG1hZ0Z0YTogJzhiMDA4YicsXHJcbiAgeFRpdmVnWUY6ICc1NTZiMmYnLFxyXG4gIHhTYW5nZTogJ2ZmOGMwMCcsXHJcbiAgeFNjRWQ6ICc5OTMyY2MnLFxyXG4gIHhZZDogJzhiMDAwMCcsXHJcbiAgeHNPbW9uOiAnZTk5NjdhJyxcclxuICB4c0hnWUY6ICc4ZmJjOGYnLFxyXG4gIHhVWGU6ICc0ODNkOGInLFxyXG4gIHhVV2F5OiAnMmY0ZjRmJyxcclxuICB4VWdZeTogJzJmNGY0ZicsXHJcbiAgeFFlOiAnY2VkMScsXHJcbiAgeHZpVGV0OiAnOTQwMGQzJyxcclxuICBkQXBwUms6ICdmZjE0OTMnLFxyXG4gIGRBcHNreVhlOiAnYmZmZicsXHJcbiAgZGltV2F5OiAnNjk2OTY5JyxcclxuICBkaW1nWXk6ICc2OTY5NjknLFxyXG4gIGRvZGdlclhlOiAnMWU5MGZmJyxcclxuICBmaVlicmljazogJ2IyMjIyMicsXHJcbiAgZmxTT3dFdGU6ICdmZmZhZjAnLFxyXG4gIGZvWXN0V0FuOiAnMjI4YjIyJyxcclxuICBmdUtzaWE6ICdmZjAwZmYnLFxyXG4gIGdhUnNiU286ICdkY2RjZGMnLFxyXG4gIGdob3N0d0V0ZTogJ2Y4ZjhmZicsXHJcbiAgZ1RkOiAnZmZkNzAwJyxcclxuICBnVE1uUGQ6ICdkYWE1MjAnLFxyXG4gIFdheTogJzgwODA4MCcsXHJcbiAgZ1lGOiAnODAwMCcsXHJcbiAgZ1lGTHc6ICdhZGZmMmYnLFxyXG4gIGdZeTogJzgwODA4MCcsXHJcbiAgaG9uZXlNdzogJ2YwZmZmMCcsXHJcbiAgaG90cFJrOiAnZmY2OWI0JyxcclxuICBSZGlhbllkOiAnY2Q1YzVjJyxcclxuICBSZGlnbzogJzRiMDA4MicsXHJcbiAgaXZTeTogJ2ZmZmZmMCcsXHJcbiAga2hha2k6ICdmMGU2OGMnLFxyXG4gIGxhdkZNcjogJ2U2ZTZmYScsXHJcbiAgbGF2Rk1yWHNoOiAnZmZmMGY1JyxcclxuICBsYXduZ1lGOiAnN2NmYzAwJyxcclxuICBObW9uY0VmZm9uOiAnZmZmYWNkJyxcclxuICBaWGU6ICdhZGQ4ZTYnLFxyXG4gIFpjU086ICdmMDgwODAnLFxyXG4gIFpjeWFuOiAnZTBmZmZmJyxcclxuICBaZ1RNblBkTHc6ICdmYWZhZDInLFxyXG4gIFpXYXk6ICdkM2QzZDMnLFxyXG4gIFpnWUY6ICc5MGVlOTAnLFxyXG4gIFpnWXk6ICdkM2QzZDMnLFxyXG4gIFpwUms6ICdmZmI2YzEnLFxyXG4gIFpzT21vbjogJ2ZmYTA3YScsXHJcbiAgWnNIZ1lGOiAnMjBiMmFhJyxcclxuICBac2t5WGU6ICc4N2NlZmEnLFxyXG4gIFpVV2F5OiAnNzc4ODk5JyxcclxuICBaVWdZeTogJzc3ODg5OScsXHJcbiAgWnN0QWxYZTogJ2IwYzRkZScsXHJcbiAgWkx3OiAnZmZmZmUwJyxcclxuICBsaW1lOiAnZmYwMCcsXHJcbiAgbGltZWdZRjogJzMyY2QzMicsXHJcbiAgbFJGOiAnZmFmMGU2JyxcclxuICBtYWdGdGE6ICdmZjAwZmYnLFxyXG4gIG1hUG9uOiAnODAwMDAwJyxcclxuICBWYXF1YW1hclJlOiAnNjZjZGFhJyxcclxuICBWWGU6ICdjZCcsXHJcbiAgVlNjRWQ6ICdiYTU1ZDMnLFxyXG4gIFZwdXJwTjogJzkzNzBkYicsXHJcbiAgVnNIZ1lGOiAnM2NiMzcxJyxcclxuICBWVVhlOiAnN2I2OGVlJyxcclxuICBWc3ByUmdnWUY6ICdmYTlhJyxcclxuICBWUWU6ICc0OGQxY2MnLFxyXG4gIFZ2aVRldFlkOiAnYzcxNTg1JyxcclxuICBtaWRuaWdodFhlOiAnMTkxOTcwJyxcclxuICBtUnRjWWFtOiAnZjVmZmZhJyxcclxuICBtaXN0eVBzZTogJ2ZmZTRlMScsXHJcbiAgbW9jY2FzUjogJ2ZmZTRiNScsXHJcbiAgbmF2YWpvd0V0ZTogJ2ZmZGVhZCcsXHJcbiAgbmF2eTogJzgwJyxcclxuICBUZGxhY2U6ICdmZGY1ZTYnLFxyXG4gIFRpdmU6ICc4MDgwMDAnLFxyXG4gIFRpdmVkQmI6ICc2YjhlMjMnLFxyXG4gIFNhbmdlOiAnZmZhNTAwJyxcclxuICBTYW5nZVlkOiAnZmY0NTAwJyxcclxuICBTY0VkOiAnZGE3MGQ2JyxcclxuICBwT2VnVE1uUGQ6ICdlZWU4YWEnLFxyXG4gIHBPZWdZRjogJzk4ZmI5OCcsXHJcbiAgcE9lUWU6ICdhZmVlZWUnLFxyXG4gIHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxyXG4gIHBhcGF5YXdFcDogJ2ZmZWZkNScsXHJcbiAgcEhLcHVmZjogJ2ZmZGFiOScsXHJcbiAgcGVydTogJ2NkODUzZicsXHJcbiAgcFJrOiAnZmZjMGNiJyxcclxuICBwbHVtOiAnZGRhMGRkJyxcclxuICBwb3dNclhlOiAnYjBlMGU2JyxcclxuICBwdXJwTjogJzgwMDA4MCcsXHJcbiAgWWJlY2NhcHVycE46ICc2NjMzOTknLFxyXG4gIFlkOiAnZmYwMDAwJyxcclxuICBQc3licm93bjogJ2JjOGY4ZicsXHJcbiAgUHlPWGU6ICc0MTY5ZTEnLFxyXG4gIHNhZGROYlB3bjogJzhiNDUxMycsXHJcbiAgc09tb246ICdmYTgwNzInLFxyXG4gIHNhbmR5YlB3bjogJ2Y0YTQ2MCcsXHJcbiAgc0hnWUY6ICcyZThiNTcnLFxyXG4gIHNIc2hlbGw6ICdmZmY1ZWUnLFxyXG4gIHNpRm5hOiAnYTA1MjJkJyxcclxuICBzaWx2ZXI6ICdjMGMwYzAnLFxyXG4gIHNreVhlOiAnODdjZWViJyxcclxuICBVWGU6ICc2YTVhY2QnLFxyXG4gIFVXYXk6ICc3MDgwOTAnLFxyXG4gIFVnWXk6ICc3MDgwOTAnLFxyXG4gIHNub3c6ICdmZmZhZmEnLFxyXG4gIHNwclJnZ1lGOiAnZmY3ZicsXHJcbiAgc3RBbFhlOiAnNDY4MmI0JyxcclxuICB0YW46ICdkMmI0OGMnLFxyXG4gIHRlTzogJzgwODAnLFxyXG4gIHRFc3ROOiAnZDhiZmQ4JyxcclxuICB0b21hdG86ICdmZjYzNDcnLFxyXG4gIFFlOiAnNDBlMGQwJyxcclxuICB2aVRldDogJ2VlODJlZScsXHJcbiAgSkh0OiAnZjVkZWIzJyxcclxuICB3RXRlOiAnZmZmZmZmJyxcclxuICB3RXRlc21va2U6ICdmNWY1ZjUnLFxyXG4gIEx3OiAnZmZmZjAwJyxcclxuICBMd2dZRjogJzlhY2QzMidcclxufTtcclxuZnVuY3Rpb24gdW5wYWNrKCkge1xyXG4gIGNvbnN0IHVucGFja2VkID0ge307XHJcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG5hbWVzJDEpO1xyXG4gIGNvbnN0IHRrZXlzID0gT2JqZWN0LmtleXMobWFwJDIpO1xyXG4gIGxldCBpLCBqLCBrLCBvaywgbms7XHJcbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIG9rID0gbmsgPSBrZXlzW2ldO1xyXG4gICAgZm9yIChqID0gMDsgaiA8IHRrZXlzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgIGsgPSB0a2V5c1tqXTtcclxuICAgICAgbmsgPSBuay5yZXBsYWNlKGssIG1hcCQyW2tdKTtcclxuICAgIH1cclxuICAgIGsgPSBwYXJzZUludChuYW1lcyQxW29rXSwgMTYpO1xyXG4gICAgdW5wYWNrZWRbbmtdID0gW2sgPj4gMTYgJiAweEZGLCBrID4+IDggJiAweEZGLCBrICYgMHhGRl07XHJcbiAgfVxyXG4gIHJldHVybiB1bnBhY2tlZDtcclxufVxyXG5sZXQgbmFtZXM7XHJcbmZ1bmN0aW9uIG5hbWVQYXJzZShzdHIpIHtcclxuICBpZiAoIW5hbWVzKSB7XHJcbiAgICBuYW1lcyA9IHVucGFjaygpO1xyXG4gICAgbmFtZXMudHJhbnNwYXJlbnQgPSBbMCwgMCwgMCwgMF07XHJcbiAgfVxyXG4gIGNvbnN0IGEgPSBuYW1lc1tzdHIudG9Mb3dlckNhc2UoKV07XHJcbiAgcmV0dXJuIGEgJiYge1xyXG4gICAgcjogYVswXSxcclxuICAgIGc6IGFbMV0sXHJcbiAgICBiOiBhWzJdLFxyXG4gICAgYTogYS5sZW5ndGggPT09IDQgPyBhWzNdIDogMjU1XHJcbiAgfTtcclxufVxyXG5jb25zdCBSR0JfUkUgPSAvXnJnYmE/XFwoXFxzKihbLSsuXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT8oPzpbXFxzLC9dKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcclxuZnVuY3Rpb24gcmdiUGFyc2Uoc3RyKSB7XHJcbiAgY29uc3QgbSA9IFJHQl9SRS5leGVjKHN0cik7XHJcbiAgbGV0IGEgPSAyNTU7XHJcbiAgbGV0IHIsIGcsIGI7XHJcbiAgaWYgKCFtKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChtWzddICE9PSByKSB7XHJcbiAgICBjb25zdCB2ID0gK21bN107XHJcbiAgICBhID0gbVs4XSA/IHAyYih2KSA6IGxpbSh2ICogMjU1LCAwLCAyNTUpO1xyXG4gIH1cclxuICByID0gK21bMV07XHJcbiAgZyA9ICttWzNdO1xyXG4gIGIgPSArbVs1XTtcclxuICByID0gMjU1ICYgKG1bMl0gPyBwMmIocikgOiBsaW0ociwgMCwgMjU1KSk7XHJcbiAgZyA9IDI1NSAmIChtWzRdID8gcDJiKGcpIDogbGltKGcsIDAsIDI1NSkpO1xyXG4gIGIgPSAyNTUgJiAobVs2XSA/IHAyYihiKSA6IGxpbShiLCAwLCAyNTUpKTtcclxuICByZXR1cm4ge1xyXG4gICAgcjogcixcclxuICAgIGc6IGcsXHJcbiAgICBiOiBiLFxyXG4gICAgYTogYVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gcmdiU3RyaW5nKHYpIHtcclxuICByZXR1cm4gdiAmJiAoXHJcbiAgICB2LmEgPCAyNTVcclxuICAgICAgPyBgcmdiYSgke3Yucn0sICR7di5nfSwgJHt2LmJ9LCAke2Iybih2LmEpfSlgXHJcbiAgICAgIDogYHJnYigke3Yucn0sICR7di5nfSwgJHt2LmJ9KWBcclxuICApO1xyXG59XHJcbmNvbnN0IHRvID0gdiA9PiB2IDw9IDAuMDAzMTMwOCA/IHYgKiAxMi45MiA6IE1hdGgucG93KHYsIDEuMCAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xyXG5jb25zdCBmcm9tID0gdiA9PiB2IDw9IDAuMDQwNDUgPyB2IC8gMTIuOTIgOiBNYXRoLnBvdygodiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xyXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSQxKHJnYjEsIHJnYjIsIHQpIHtcclxuICBjb25zdCByID0gZnJvbShiMm4ocmdiMS5yKSk7XHJcbiAgY29uc3QgZyA9IGZyb20oYjJuKHJnYjEuZykpO1xyXG4gIGNvbnN0IGIgPSBmcm9tKGIybihyZ2IxLmIpKTtcclxuICByZXR1cm4ge1xyXG4gICAgcjogbjJiKHRvKHIgKyB0ICogKGZyb20oYjJuKHJnYjIucikpIC0gcikpKSxcclxuICAgIGc6IG4yYih0byhnICsgdCAqIChmcm9tKGIybihyZ2IyLmcpKSAtIGcpKSksXHJcbiAgICBiOiBuMmIodG8oYiArIHQgKiAoZnJvbShiMm4ocmdiMi5iKSkgLSBiKSkpLFxyXG4gICAgYTogcmdiMS5hICsgdCAqIChyZ2IyLmEgLSByZ2IxLmEpXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBtb2RIU0wodiwgaSwgcmF0aW8pIHtcclxuICBpZiAodikge1xyXG4gICAgbGV0IHRtcCA9IHJnYjJoc2wodik7XHJcbiAgICB0bXBbaV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0bXBbaV0gKyB0bXBbaV0gKiByYXRpbywgaSA9PT0gMCA/IDM2MCA6IDEpKTtcclxuICAgIHRtcCA9IGhzbDJyZ2IodG1wKTtcclxuICAgIHYuciA9IHRtcFswXTtcclxuICAgIHYuZyA9IHRtcFsxXTtcclxuICAgIHYuYiA9IHRtcFsyXTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gY2xvbmUkMSh2LCBwcm90bykge1xyXG4gIHJldHVybiB2ID8gT2JqZWN0LmFzc2lnbihwcm90byB8fCB7fSwgdikgOiB2O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21PYmplY3QoaW5wdXQpIHtcclxuICB2YXIgdiA9IHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAyNTV9O1xyXG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+PSAzKSB7XHJcbiAgICAgIHYgPSB7cjogaW5wdXRbMF0sIGc6IGlucHV0WzFdLCBiOiBpbnB1dFsyXSwgYTogMjU1fTtcclxuICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDMpIHtcclxuICAgICAgICB2LmEgPSBuMmIoaW5wdXRbM10pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHYgPSBjbG9uZSQxKGlucHV0LCB7cjogMCwgZzogMCwgYjogMCwgYTogMX0pO1xyXG4gICAgdi5hID0gbjJiKHYuYSk7XHJcbiAgfVxyXG4gIHJldHVybiB2O1xyXG59XHJcbmZ1bmN0aW9uIGZ1bmN0aW9uUGFyc2Uoc3RyKSB7XHJcbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICdyJykge1xyXG4gICAgcmV0dXJuIHJnYlBhcnNlKHN0cik7XHJcbiAgfVxyXG4gIHJldHVybiBodWVQYXJzZShzdHIpO1xyXG59XHJcbmNsYXNzIENvbG9yIHtcclxuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xyXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcclxuICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgfVxyXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcclxuICAgIGxldCB2O1xyXG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHYgPSBmcm9tT2JqZWN0KGlucHV0KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdiA9IGhleFBhcnNlKGlucHV0KSB8fCBuYW1lUGFyc2UoaW5wdXQpIHx8IGZ1bmN0aW9uUGFyc2UoaW5wdXQpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fcmdiID0gdjtcclxuICAgIHRoaXMuX3ZhbGlkID0gISF2O1xyXG4gIH1cclxuICBnZXQgdmFsaWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQ7XHJcbiAgfVxyXG4gIGdldCByZ2IoKSB7XHJcbiAgICB2YXIgdiA9IGNsb25lJDEodGhpcy5fcmdiKTtcclxuICAgIGlmICh2KSB7XHJcbiAgICAgIHYuYSA9IGIybih2LmEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHY7XHJcbiAgfVxyXG4gIHNldCByZ2Iob2JqKSB7XHJcbiAgICB0aGlzLl9yZ2IgPSBmcm9tT2JqZWN0KG9iaik7XHJcbiAgfVxyXG4gIHJnYlN0cmluZygpIHtcclxuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IHJnYlN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuICBoZXhTdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyBoZXhTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgaHNsU3RyaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaHNsU3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIG1peChjb2xvciwgd2VpZ2h0KSB7XHJcbiAgICBpZiAoY29sb3IpIHtcclxuICAgICAgY29uc3QgYzEgPSB0aGlzLnJnYjtcclxuICAgICAgY29uc3QgYzIgPSBjb2xvci5yZ2I7XHJcbiAgICAgIGxldCB3MjtcclxuICAgICAgY29uc3QgcCA9IHdlaWdodCA9PT0gdzIgPyAwLjUgOiB3ZWlnaHQ7XHJcbiAgICAgIGNvbnN0IHcgPSAyICogcCAtIDE7XHJcbiAgICAgIGNvbnN0IGEgPSBjMS5hIC0gYzIuYTtcclxuICAgICAgY29uc3QgdzEgPSAoKHcgKiBhID09PSAtMSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XHJcbiAgICAgIHcyID0gMSAtIHcxO1xyXG4gICAgICBjMS5yID0gMHhGRiAmIHcxICogYzEuciArIHcyICogYzIuciArIDAuNTtcclxuICAgICAgYzEuZyA9IDB4RkYgJiB3MSAqIGMxLmcgKyB3MiAqIGMyLmcgKyAwLjU7XHJcbiAgICAgIGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xyXG4gICAgICBjMS5hID0gcCAqIGMxLmEgKyAoMSAtIHApICogYzIuYTtcclxuICAgICAgdGhpcy5yZ2IgPSBjMTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICBpbnRlcnBvbGF0ZShjb2xvciwgdCkge1xyXG4gICAgaWYgKGNvbG9yKSB7XHJcbiAgICAgIHRoaXMuX3JnYiA9IGludGVycG9sYXRlJDEodGhpcy5fcmdiLCBjb2xvci5fcmdiLCB0KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICBjbG9uZSgpIHtcclxuICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yZ2IpO1xyXG4gIH1cclxuICBhbHBoYShhKSB7XHJcbiAgICB0aGlzLl9yZ2IuYSA9IG4yYihhKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICBjbGVhcmVyKHJhdGlvKSB7XHJcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XHJcbiAgICByZ2IuYSAqPSAxIC0gcmF0aW87XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgZ3JleXNjYWxlKCkge1xyXG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xyXG4gICAgY29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xyXG4gICAgcmdiLnIgPSByZ2IuZyA9IHJnYi5iID0gdmFsO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIG9wYXF1ZXIocmF0aW8pIHtcclxuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcclxuICAgIHJnYi5hICo9IDEgKyByYXRpbztcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICBuZWdhdGUoKSB7XHJcbiAgICBjb25zdCB2ID0gdGhpcy5fcmdiO1xyXG4gICAgdi5yID0gMjU1IC0gdi5yO1xyXG4gICAgdi5nID0gMjU1IC0gdi5nO1xyXG4gICAgdi5iID0gMjU1IC0gdi5iO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIGxpZ2h0ZW4ocmF0aW8pIHtcclxuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIHJhdGlvKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICBkYXJrZW4ocmF0aW8pIHtcclxuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgc2F0dXJhdGUocmF0aW8pIHtcclxuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIHJhdGlvKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICBkZXNhdHVyYXRlKHJhdGlvKSB7XHJcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCAtcmF0aW8pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIHJvdGF0ZShkZWcpIHtcclxuICAgIHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gaW5kZXhfZXNtKGlucHV0KSB7XHJcbiAgcmV0dXJuIG5ldyBDb2xvcihpbnB1dCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpIHtcclxuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgY29uc3QgdHlwZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICByZXR1cm4gdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc7XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xyXG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSA/IHZhbHVlIDogaW5kZXhfZXNtKHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlKSB7XHJcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpXHJcbiAgICA/IHZhbHVlXHJcbiAgICA6IGluZGV4X2VzbSh2YWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9vcCgpIHt9XHJcbmNvbnN0IHVpZCA9IChmdW5jdGlvbigpIHtcclxuICBsZXQgaWQgPSAwO1xyXG4gIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBpZCsrO1xyXG4gIH07XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWYodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcclxufVxyXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcclxuICBpZiAodHlwZS5zbGljZSgwLCA3KSA9PT0gJ1tvYmplY3QnICYmIHR5cGUuc2xpY2UoLTYpID09PSAnQXJyYXldJykge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcclxufVxyXG5jb25zdCBpc051bWJlckZpbml0ZSA9ICh2YWx1ZSkgPT4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKCt2YWx1ZSk7XHJcbmZ1bmN0aW9uIGZpbml0ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIHZhbHVlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xyXG59XHJcbmNvbnN0IHRvUGVyY2VudGFnZSA9ICh2YWx1ZSwgZGltZW5zaW9uKSA9PlxyXG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XHJcbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMFxyXG4gICAgOiB2YWx1ZSAvIGRpbWVuc2lvbjtcclxuY29uc3QgdG9EaW1lbnNpb24gPSAodmFsdWUsIGRpbWVuc2lvbikgPT5cclxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xyXG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBkaW1lbnNpb25cclxuICAgIDogK3ZhbHVlO1xyXG5mdW5jdGlvbiBjYWxsYmFjayhmbiwgYXJncywgdGhpc0FyZykge1xyXG4gIGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBlYWNoKGxvb3BhYmxlLCBmbiwgdGhpc0FyZywgcmV2ZXJzZSkge1xyXG4gIGxldCBpLCBsZW4sIGtleXM7XHJcbiAgaWYgKGlzQXJyYXkobG9vcGFibGUpKSB7XHJcbiAgICBsZW4gPSBsb29wYWJsZS5sZW5ndGg7XHJcbiAgICBpZiAocmV2ZXJzZSkge1xyXG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobG9vcGFibGUpKSB7XHJcbiAgICBrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xyXG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIF9lbGVtZW50c0VxdWFsKGEwLCBhMSkge1xyXG4gIGxldCBpLCBpbGVuLCB2MCwgdjE7XHJcbiAgaWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgZm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgdjAgPSBhMFtpXTtcclxuICAgIHYxID0gYTFbaV07XHJcbiAgICBpZiAodjAuZGF0YXNldEluZGV4ICE9PSB2MS5kYXRhc2V0SW5kZXggfHwgdjAuaW5kZXggIT09IHYxLmluZGV4KSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gY2xvbmUoc291cmNlKSB7XHJcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xyXG4gICAgcmV0dXJuIHNvdXJjZS5tYXAoY2xvbmUpO1xyXG4gIH1cclxuICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xyXG4gICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xyXG4gICAgbGV0IGsgPSAwO1xyXG4gICAgZm9yICg7IGsgPCBrbGVuOyArK2spIHtcclxuICAgICAgdGFyZ2V0W2tleXNba11dID0gY2xvbmUoc291cmNlW2tleXNba11dKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgfVxyXG4gIHJldHVybiBzb3VyY2U7XHJcbn1cclxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcclxuICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5kZXhPZihrZXkpID09PSAtMTtcclxufVxyXG5mdW5jdGlvbiBfbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcclxuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XHJcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xyXG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xyXG4gICAgbWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRhcmdldFtrZXldID0gY2xvbmUoc3ZhbCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XHJcbiAgY29uc3Qgc291cmNlcyA9IGlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xyXG4gIGNvbnN0IGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcclxuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgfVxyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIGNvbnN0IG1lcmdlciA9IG9wdGlvbnMubWVyZ2VyIHx8IF9tZXJnZXI7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XHJcbiAgICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcclxuICAgIGZvciAobGV0IGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcclxuICAgICAgbWVyZ2VyKGtleXNba10sIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUlmKHRhcmdldCwgc291cmNlKSB7XHJcbiAgcmV0dXJuIG1lcmdlKHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBfbWVyZ2VySWZ9KTtcclxufVxyXG5mdW5jdGlvbiBfbWVyZ2VySWYoa2V5LCB0YXJnZXQsIHNvdXJjZSkge1xyXG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcclxuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XHJcbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XHJcbiAgICBtZXJnZUlmKHR2YWwsIHN2YWwpO1xyXG4gIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcclxuICAgIHRhcmdldFtrZXldID0gY2xvbmUoc3ZhbCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIF9kZXByZWNhdGVkKHNjb3BlLCB2YWx1ZSwgcHJldmlvdXMsIGN1cnJlbnQpIHtcclxuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgY29uc29sZS53YXJuKHNjb3BlICsgJzogXCInICsgcHJldmlvdXMgK1xyXG5cdFx0XHQnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcclxuICB9XHJcbn1cclxuY29uc3QgZW1wdHlTdHJpbmcgPSAnJztcclxuY29uc3QgZG90ID0gJy4nO1xyXG5mdW5jdGlvbiBpbmRleE9mRG90T3JMZW5ndGgoa2V5LCBzdGFydCkge1xyXG4gIGNvbnN0IGlkeCA9IGtleS5pbmRleE9mKGRvdCwgc3RhcnQpO1xyXG4gIHJldHVybiBpZHggPT09IC0xID8ga2V5Lmxlbmd0aCA6IGlkeDtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KSB7XHJcbiAgaWYgKGtleSA9PT0gZW1wdHlTdHJpbmcpIHtcclxuICAgIHJldHVybiBvYmo7XHJcbiAgfVxyXG4gIGxldCBwb3MgPSAwO1xyXG4gIGxldCBpZHggPSBpbmRleE9mRG90T3JMZW5ndGgoa2V5LCBwb3MpO1xyXG4gIHdoaWxlIChvYmogJiYgaWR4ID4gcG9zKSB7XHJcbiAgICBvYmogPSBvYmpba2V5LnNsaWNlKHBvcywgaWR4KV07XHJcbiAgICBwb3MgPSBpZHggKyAxO1xyXG4gICAgaWR4ID0gaW5kZXhPZkRvdE9yTGVuZ3RoKGtleSwgcG9zKTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5mdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHIpIHtcclxuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xyXG59XHJcbmNvbnN0IGRlZmluZWQgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XHJcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcclxuY29uc3Qgc2V0c0VxdWFsID0gKGEsIGIpID0+IHtcclxuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcclxuICAgIGlmICghYi5oYXMoaXRlbSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuZnVuY3Rpb24gX2lzQ2xpY2tFdmVudChlKSB7XHJcbiAgcmV0dXJuIGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgPT09ICdjb250ZXh0bWVudSc7XHJcbn1cclxuXHJcbmNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuZnVuY3Rpb24gZ2V0U2NvcGUkMShub2RlLCBrZXkpIHtcclxuICBpZiAoIWtleSkge1xyXG4gICAgcmV0dXJuIG5vZGU7XHJcbiAgfVxyXG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcclxuICBmb3IgKGxldCBpID0gMCwgbiA9IGtleXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XHJcbiAgICBjb25zdCBrID0ga2V5c1tpXTtcclxuICAgIG5vZGUgPSBub2RlW2tdIHx8IChub2RlW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XHJcbiAgfVxyXG4gIHJldHVybiBub2RlO1xyXG59XHJcbmZ1bmN0aW9uIHNldChyb290LCBzY29wZSwgdmFsdWVzKSB7XHJcbiAgaWYgKHR5cGVvZiBzY29wZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBtZXJnZShnZXRTY29wZSQxKHJvb3QsIHNjb3BlKSwgdmFsdWVzKTtcclxuICB9XHJcbiAgcmV0dXJuIG1lcmdlKGdldFNjb3BlJDEocm9vdCwgJycpLCBzY29wZSk7XHJcbn1cclxuY2xhc3MgRGVmYXVsdHMge1xyXG4gIGNvbnN0cnVjdG9yKF9kZXNjcmlwdG9ycykge1xyXG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xyXG4gICAgdGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xyXG4gICAgdGhpcy5jb2xvciA9ICcjNjY2JztcclxuICAgIHRoaXMuZGF0YXNldHMgPSB7fTtcclxuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IChjb250ZXh0KSA9PiBjb250ZXh0LmNoYXJ0LnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcclxuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcclxuICAgIHRoaXMuZXZlbnRzID0gW1xyXG4gICAgICAnbW91c2Vtb3ZlJyxcclxuICAgICAgJ21vdXNlb3V0JyxcclxuICAgICAgJ2NsaWNrJyxcclxuICAgICAgJ3RvdWNoc3RhcnQnLFxyXG4gICAgICAndG91Y2htb3ZlJ1xyXG4gICAgXTtcclxuICAgIHRoaXMuZm9udCA9IHtcclxuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXHJcbiAgICAgIHNpemU6IDEyLFxyXG4gICAgICBzdHlsZTogJ25vcm1hbCcsXHJcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcclxuICAgICAgd2VpZ2h0OiBudWxsXHJcbiAgICB9O1xyXG4gICAgdGhpcy5ob3ZlciA9IHt9O1xyXG4gICAgdGhpcy5ob3ZlckJhY2tncm91bmRDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpO1xyXG4gICAgdGhpcy5ob3ZlckJvcmRlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKTtcclxuICAgIHRoaXMuaG92ZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5jb2xvcik7XHJcbiAgICB0aGlzLmluZGV4QXhpcyA9ICd4JztcclxuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XHJcbiAgICAgIG1vZGU6ICduZWFyZXN0JyxcclxuICAgICAgaW50ZXJzZWN0OiB0cnVlLFxyXG4gICAgICBpbmNsdWRlSW52aXNpYmxlOiBmYWxzZVxyXG4gICAgfTtcclxuICAgIHRoaXMubWFpbnRhaW5Bc3BlY3RSYXRpbyA9IHRydWU7XHJcbiAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xyXG4gICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcclxuICAgIHRoaXMucGFyc2luZyA9IHRydWU7XHJcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcclxuICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRydWU7XHJcbiAgICB0aGlzLnNjYWxlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcclxuICAgIHRoaXMuc2hvd0xpbmUgPSB0cnVlO1xyXG4gICAgdGhpcy5kcmF3QWN0aXZlRWxlbWVudHNPblRvcCA9IHRydWU7XHJcbiAgICB0aGlzLmRlc2NyaWJlKF9kZXNjcmlwdG9ycyk7XHJcbiAgfVxyXG4gIHNldChzY29wZSwgdmFsdWVzKSB7XHJcbiAgICByZXR1cm4gc2V0KHRoaXMsIHNjb3BlLCB2YWx1ZXMpO1xyXG4gIH1cclxuICBnZXQoc2NvcGUpIHtcclxuICAgIHJldHVybiBnZXRTY29wZSQxKHRoaXMsIHNjb3BlKTtcclxuICB9XHJcbiAgZGVzY3JpYmUoc2NvcGUsIHZhbHVlcykge1xyXG4gICAgcmV0dXJuIHNldChkZXNjcmlwdG9ycywgc2NvcGUsIHZhbHVlcyk7XHJcbiAgfVxyXG4gIG92ZXJyaWRlKHNjb3BlLCB2YWx1ZXMpIHtcclxuICAgIHJldHVybiBzZXQob3ZlcnJpZGVzLCBzY29wZSwgdmFsdWVzKTtcclxuICB9XHJcbiAgcm91dGUoc2NvcGUsIG5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKSB7XHJcbiAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgc2NvcGUpO1xyXG4gICAgY29uc3QgdGFyZ2V0U2NvcGVPYmplY3QgPSBnZXRTY29wZSQxKHRoaXMsIHRhcmdldFNjb3BlKTtcclxuICAgIGNvbnN0IHByaXZhdGVOYW1lID0gJ18nICsgbmFtZTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlT2JqZWN0LCB7XHJcbiAgICAgIFtwcml2YXRlTmFtZV06IHtcclxuICAgICAgICB2YWx1ZTogc2NvcGVPYmplY3RbbmFtZV0sXHJcbiAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgfSxcclxuICAgICAgW25hbWVdOiB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICBjb25zdCBsb2NhbCA9IHRoaXNbcHJpdmF0ZU5hbWVdO1xyXG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2NvcGVPYmplY3RbdGFyZ2V0TmFtZV07XHJcbiAgICAgICAgICBpZiAoaXNPYmplY3QobG9jYWwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQsIGxvY2FsKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsb2NhbCwgdGFyZ2V0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCh2YWx1ZSkge1xyXG4gICAgICAgICAgdGhpc1twcml2YXRlTmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG52YXIgZGVmYXVsdHMgPSBuZXcgRGVmYXVsdHMoe1xyXG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcclxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2V2ZW50cycsXHJcbiAgaG92ZXI6IHtcclxuICAgIF9mYWxsYmFjazogJ2ludGVyYWN0aW9uJ1xyXG4gIH0sXHJcbiAgaW50ZXJhY3Rpb246IHtcclxuICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcclxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxyXG4gIH1cclxufSk7XHJcblxyXG5mdW5jdGlvbiBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgY21wKSB7XHJcbiAgY21wID0gY21wIHx8ICgoaW5kZXgpID0+IHRhYmxlW2luZGV4XSA8IHZhbHVlKTtcclxuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xyXG4gIGxldCBsbyA9IDA7XHJcbiAgbGV0IG1pZDtcclxuICB3aGlsZSAoaGkgLSBsbyA+IDEpIHtcclxuICAgIG1pZCA9IChsbyArIGhpKSA+PiAxO1xyXG4gICAgaWYgKGNtcChtaWQpKSB7XHJcbiAgICAgIGxvID0gbWlkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaGkgPSBtaWQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB7bG8sIGhpfTtcclxufVxyXG5jb25zdCBfbG9va3VwQnlLZXkgPSAodGFibGUsIGtleSwgdmFsdWUpID0+XHJcbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldIDwgdmFsdWUpO1xyXG5jb25zdCBfcmxvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlKSA9PlxyXG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA+PSB2YWx1ZSk7XHJcbmZ1bmN0aW9uIF9maWx0ZXJCZXR3ZWVuKHZhbHVlcywgbWluLCBtYXgpIHtcclxuICBsZXQgc3RhcnQgPSAwO1xyXG4gIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoO1xyXG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XHJcbiAgICBzdGFydCsrO1xyXG4gIH1cclxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XHJcbiAgICBlbmQtLTtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXJ0ID4gMCB8fCBlbmQgPCB2YWx1ZXMubGVuZ3RoXHJcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxyXG4gICAgOiB2YWx1ZXM7XHJcbn1cclxuY29uc3QgYXJyYXlFdmVudHMgPSBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsICd1bnNoaWZ0J107XHJcbmZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xyXG4gIGlmIChhcnJheS5fY2hhcnRqcykge1xyXG4gICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcclxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgdmFsdWU6IHtcclxuICAgICAgbGlzdGVuZXJzOiBbbGlzdGVuZXJdXHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgYXJyYXlFdmVudHMuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICBjb25zdCBtZXRob2QgPSAnX29uRGF0YScgKyBfY2FwaXRhbGl6ZShrZXkpO1xyXG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xyXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICB2YWx1ZSguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMuZm9yRWFjaCgob2JqZWN0KSA9PiB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdFttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XHJcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xyXG4gIGlmICghc3R1Yikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcclxuICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcclxuICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICB9XHJcbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgZGVsZXRlIGFycmF5W2tleV07XHJcbiAgfSk7XHJcbiAgZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xyXG59XHJcbmZ1bmN0aW9uIF9hcnJheVVuaXF1ZShpdGVtcykge1xyXG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcclxuICBsZXQgaSwgaWxlbjtcclxuICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICBzZXQuYWRkKGl0ZW1zW2ldKTtcclxuICB9XHJcbiAgaWYgKHNldC5zaXplID09PSBpbGVuKSB7XHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbiAgfVxyXG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XHJcbn1cclxuXHJcbmNvbnN0IFBJID0gTWF0aC5QSTtcclxuY29uc3QgVEFVID0gMiAqIFBJO1xyXG5jb25zdCBQSVRBVSA9IFRBVSArIFBJO1xyXG5jb25zdCBJTkZJTklUWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuY29uc3QgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcclxuY29uc3QgSEFMRl9QSSA9IFBJIC8gMjtcclxuY29uc3QgUVVBUlRFUl9QSSA9IFBJIC8gNDtcclxuY29uc3QgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XHJcbmNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMDtcclxuY29uc3Qgc2lnbiA9IE1hdGguc2lnbjtcclxuZnVuY3Rpb24gbmljZU51bShyYW5nZSkge1xyXG4gIGNvbnN0IHJvdW5kZWRSYW5nZSA9IE1hdGgucm91bmQocmFuZ2UpO1xyXG4gIHJhbmdlID0gYWxtb3N0RXF1YWxzKHJhbmdlLCByb3VuZGVkUmFuZ2UsIHJhbmdlIC8gMTAwMCkgPyByb3VuZGVkUmFuZ2UgOiByYW5nZTtcclxuICBjb25zdCBuaWNlUmFuZ2UgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChyYW5nZSkpKTtcclxuICBjb25zdCBmcmFjdGlvbiA9IHJhbmdlIC8gbmljZVJhbmdlO1xyXG4gIGNvbnN0IG5pY2VGcmFjdGlvbiA9IGZyYWN0aW9uIDw9IDEgPyAxIDogZnJhY3Rpb24gPD0gMiA/IDIgOiBmcmFjdGlvbiA8PSA1ID8gNSA6IDEwO1xyXG4gIHJldHVybiBuaWNlRnJhY3Rpb24gKiBuaWNlUmFuZ2U7XHJcbn1cclxuZnVuY3Rpb24gX2ZhY3Rvcml6ZSh2YWx1ZSkge1xyXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xyXG4gIGxldCBpO1xyXG4gIGZvciAoaSA9IDE7IGkgPCBzcXJ0OyBpKyspIHtcclxuICAgIGlmICh2YWx1ZSAlIGkgPT09IDApIHtcclxuICAgICAgcmVzdWx0LnB1c2goaSk7XHJcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlIC8gaSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChzcXJ0ID09PSAoc3FydCB8IDApKSB7XHJcbiAgICByZXN1bHQucHVzaChzcXJ0KTtcclxuICB9XHJcbiAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEgLSBiKS5wb3AoKTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcclxuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xyXG59XHJcbmZ1bmN0aW9uIGFsbW9zdEVxdWFscyh4LCB5LCBlcHNpbG9uKSB7XHJcbiAgcmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XHJcbn1cclxuZnVuY3Rpb24gYWxtb3N0V2hvbGUoeCwgZXBzaWxvbikge1xyXG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xyXG4gIHJldHVybiAoKHJvdW5kZWQgLSBlcHNpbG9uKSA8PSB4KSAmJiAoKHJvdW5kZWQgKyBlcHNpbG9uKSA+PSB4KTtcclxufVxyXG5mdW5jdGlvbiBfc2V0TWluQW5kTWF4QnlLZXkoYXJyYXksIHRhcmdldCwgcHJvcGVydHkpIHtcclxuICBsZXQgaSwgaWxlbiwgdmFsdWU7XHJcbiAgZm9yIChpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xyXG4gICAgdmFsdWUgPSBhcnJheVtpXVtwcm9wZXJ0eV07XHJcbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xyXG4gICAgICB0YXJnZXQubWluID0gTWF0aC5taW4odGFyZ2V0Lm1pbiwgdmFsdWUpO1xyXG4gICAgICB0YXJnZXQubWF4ID0gTWF0aC5tYXgodGFyZ2V0Lm1heCwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xyXG4gIHJldHVybiBkZWdyZWVzICogKFBJIC8gMTgwKTtcclxufVxyXG5mdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFucykge1xyXG4gIHJldHVybiByYWRpYW5zICogKDE4MCAvIFBJKTtcclxufVxyXG5mdW5jdGlvbiBfZGVjaW1hbFBsYWNlcyh4KSB7XHJcbiAgaWYgKCFpc051bWJlckZpbml0ZSh4KSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBsZXQgZSA9IDE7XHJcbiAgbGV0IHAgPSAwO1xyXG4gIHdoaWxlIChNYXRoLnJvdW5kKHggKiBlKSAvIGUgIT09IHgpIHtcclxuICAgIGUgKj0gMTA7XHJcbiAgICBwKys7XHJcbiAgfVxyXG4gIHJldHVybiBwO1xyXG59XHJcbmZ1bmN0aW9uIGdldEFuZ2xlRnJvbVBvaW50KGNlbnRyZVBvaW50LCBhbmdsZVBvaW50KSB7XHJcbiAgY29uc3QgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XHJcbiAgY29uc3QgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XHJcbiAgY29uc3QgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xyXG4gIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XHJcbiAgaWYgKGFuZ2xlIDwgKC0wLjUgKiBQSSkpIHtcclxuICAgIGFuZ2xlICs9IFRBVTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIGFuZ2xlLFxyXG4gICAgZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHB0MSwgcHQyKSB7XHJcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcclxufVxyXG5mdW5jdGlvbiBfYW5nbGVEaWZmKGEsIGIpIHtcclxuICByZXR1cm4gKGEgLSBiICsgUElUQVUpICUgVEFVIC0gUEk7XHJcbn1cclxuZnVuY3Rpb24gX25vcm1hbGl6ZUFuZ2xlKGEpIHtcclxuICByZXR1cm4gKGEgJSBUQVUgKyBUQVUpICUgVEFVO1xyXG59XHJcbmZ1bmN0aW9uIF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0LCBlbmQsIHNhbWVBbmdsZUlzRnVsbENpcmNsZSkge1xyXG4gIGNvbnN0IGEgPSBfbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xyXG4gIGNvbnN0IHMgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xyXG4gIGNvbnN0IGUgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcclxuICBjb25zdCBhbmdsZVRvU3RhcnQgPSBfbm9ybWFsaXplQW5nbGUocyAtIGEpO1xyXG4gIGNvbnN0IGFuZ2xlVG9FbmQgPSBfbm9ybWFsaXplQW5nbGUoZSAtIGEpO1xyXG4gIGNvbnN0IHN0YXJ0VG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gcyk7XHJcbiAgY29uc3QgZW5kVG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gZSk7XHJcbiAgcmV0dXJuIGEgPT09IHMgfHwgYSA9PT0gZSB8fCAoc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlICYmIHMgPT09IGUpXHJcbiAgICB8fCAoYW5nbGVUb1N0YXJ0ID4gYW5nbGVUb0VuZCAmJiBzdGFydFRvQW5nbGUgPCBlbmRUb0FuZ2xlKTtcclxufVxyXG5mdW5jdGlvbiBfbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpIHtcclxuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XHJcbn1cclxuZnVuY3Rpb24gX2ludDE2UmFuZ2UodmFsdWUpIHtcclxuICByZXR1cm4gX2xpbWl0VmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0JldHdlZW4odmFsdWUsIHN0YXJ0LCBlbmQsIGVwc2lsb24gPSAxZS02KSB7XHJcbiAgcmV0dXJuIHZhbHVlID49IE1hdGgubWluKHN0YXJ0LCBlbmQpIC0gZXBzaWxvbiAmJiB2YWx1ZSA8PSBNYXRoLm1heChzdGFydCwgZW5kKSArIGVwc2lsb247XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpIHtcclxuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcclxufVxyXG5mdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlKSB7XHJcbiAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcclxuICBpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcclxuICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xyXG4gIH1cclxuICByZXR1cm4gcGFyZW50O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcclxuICBsZXQgdmFsdWVJblBpeGVscztcclxuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICB2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xyXG4gICAgaWYgKHN0eWxlVmFsdWUuaW5kZXhPZignJScpICE9PSAtMSkge1xyXG4gICAgICB2YWx1ZUluUGl4ZWxzID0gdmFsdWVJblBpeGVscyAvIDEwMCAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xyXG4gIH1cclxuICByZXR1cm4gdmFsdWVJblBpeGVscztcclxufVxyXG5jb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQpID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xyXG5mdW5jdGlvbiBnZXRTdHlsZShlbCwgcHJvcGVydHkpIHtcclxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XHJcbn1cclxuY29uc3QgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcclxuZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlcywgc3R5bGUsIHN1ZmZpeCkge1xyXG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG4gIHN1ZmZpeCA9IHN1ZmZpeCA/ICctJyArIHN1ZmZpeCA6ICcnO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XHJcbiAgICByZXN1bHRbcG9zXSA9IHBhcnNlRmxvYXQoc3R5bGVzW3N0eWxlICsgJy0nICsgcG9zICsgc3VmZml4XSkgfHwgMDtcclxuICB9XHJcbiAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmxlZnQgKyByZXN1bHQucmlnaHQ7XHJcbiAgcmVzdWx0LmhlaWdodCA9IHJlc3VsdC50b3AgKyByZXN1bHQuYm90dG9tO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuY29uc3QgdXNlT2Zmc2V0UG9zID0gKHgsIHksIHRhcmdldCkgPT4gKHggPiAwIHx8IHkgPiAwKSAmJiAoIXRhcmdldCB8fCAhdGFyZ2V0LnNoYWRvd1Jvb3QpO1xyXG5mdW5jdGlvbiBnZXRDYW52YXNQb3NpdGlvbihlLCBjYW52YXMpIHtcclxuICBjb25zdCB0b3VjaGVzID0gZS50b3VjaGVzO1xyXG4gIGNvbnN0IHNvdXJjZSA9IHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPyB0b3VjaGVzWzBdIDogZTtcclxuICBjb25zdCB7b2Zmc2V0WCwgb2Zmc2V0WX0gPSBzb3VyY2U7XHJcbiAgbGV0IGJveCA9IGZhbHNlO1xyXG4gIGxldCB4LCB5O1xyXG4gIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XHJcbiAgICB4ID0gb2Zmc2V0WDtcclxuICAgIHkgPSBvZmZzZXRZO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgeCA9IHNvdXJjZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xyXG4gICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XHJcbiAgICBib3ggPSB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4ge3gsIHksIGJveH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihldnQsIGNoYXJ0KSB7XHJcbiAgaWYgKCduYXRpdmUnIGluIGV2dCkge1xyXG4gICAgcmV0dXJuIGV2dDtcclxuICB9XHJcbiAgY29uc3Qge2NhbnZhcywgY3VycmVudERldmljZVBpeGVsUmF0aW99ID0gY2hhcnQ7XHJcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XHJcbiAgY29uc3QgYm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XHJcbiAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XHJcbiAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xyXG4gIGNvbnN0IHt4LCB5LCBib3h9ID0gZ2V0Q2FudmFzUG9zaXRpb24oZXZ0LCBjYW52YXMpO1xyXG4gIGNvbnN0IHhPZmZzZXQgPSBwYWRkaW5ncy5sZWZ0ICsgKGJveCAmJiBib3JkZXJzLmxlZnQpO1xyXG4gIGNvbnN0IHlPZmZzZXQgPSBwYWRkaW5ncy50b3AgKyAoYm94ICYmIGJvcmRlcnMudG9wKTtcclxuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY2hhcnQ7XHJcbiAgaWYgKGJvcmRlckJveCkge1xyXG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xyXG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgeDogTWF0aC5yb3VuZCgoeCAtIHhPZmZzZXQpIC8gd2lkdGggKiBjYW52YXMud2lkdGggLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyksXHJcbiAgICB5OiBNYXRoLnJvdW5kKCh5IC0geU9mZnNldCkgLyBoZWlnaHQgKiBjYW52YXMuaGVpZ2h0IC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCkge1xyXG4gIGxldCBtYXhXaWR0aCwgbWF4SGVpZ2h0O1xyXG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xyXG4gICAgaWYgKCFjb250YWluZXIpIHtcclxuICAgICAgd2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGg7XHJcbiAgICAgIGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcclxuICAgICAgY29uc3QgY29udGFpbmVyQm9yZGVyID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdwYWRkaW5nJyk7XHJcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCAtIGNvbnRhaW5lclBhZGRpbmcud2lkdGggLSBjb250YWluZXJCb3JkZXIud2lkdGg7XHJcbiAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gY29udGFpbmVyUGFkZGluZy5oZWlnaHQgLSBjb250YWluZXJCb3JkZXIuaGVpZ2h0O1xyXG4gICAgICBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4V2lkdGgsIGNvbnRhaW5lciwgJ2NsaWVudFdpZHRoJyk7XHJcbiAgICAgIG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0LCBjb250YWluZXIsICdjbGllbnRIZWlnaHQnKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHdpZHRoLFxyXG4gICAgaGVpZ2h0LFxyXG4gICAgbWF4V2lkdGg6IG1heFdpZHRoIHx8IElORklOSVRZLFxyXG4gICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgfHwgSU5GSU5JVFlcclxuICB9O1xyXG59XHJcbmNvbnN0IHJvdW5kMSA9IHYgPT4gTWF0aC5yb3VuZCh2ICogMTApIC8gMTA7XHJcbmZ1bmN0aW9uIGdldE1heGltdW1TaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQsIGFzcGVjdFJhdGlvKSB7XHJcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XHJcbiAgY29uc3QgbWFyZ2lucyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ21hcmdpbicpO1xyXG4gIGNvbnN0IG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhXaWR0aCwgY2FudmFzLCAnY2xpZW50V2lkdGgnKSB8fCBJTkZJTklUWTtcclxuICBjb25zdCBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heEhlaWdodCwgY2FudmFzLCAnY2xpZW50SGVpZ2h0JykgfHwgSU5GSU5JVFk7XHJcbiAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGdldENvbnRhaW5lclNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCk7XHJcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNvbnRhaW5lclNpemU7XHJcbiAgaWYgKHN0eWxlLmJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94Jykge1xyXG4gICAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xyXG4gICAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XHJcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XHJcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XHJcbiAgfVxyXG4gIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSBtYXJnaW5zLndpZHRoKTtcclxuICBoZWlnaHQgPSBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQgLSBtYXJnaW5zLmhlaWdodCk7XHJcbiAgd2lkdGggPSByb3VuZDEoTWF0aC5taW4od2lkdGgsIG1heFdpZHRoLCBjb250YWluZXJTaXplLm1heFdpZHRoKSk7XHJcbiAgaGVpZ2h0ID0gcm91bmQxKE1hdGgubWluKGhlaWdodCwgbWF4SGVpZ2h0LCBjb250YWluZXJTaXplLm1heEhlaWdodCkpO1xyXG4gIGlmICh3aWR0aCAmJiAhaGVpZ2h0KSB7XHJcbiAgICBoZWlnaHQgPSByb3VuZDEod2lkdGggLyAyKTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHdpZHRoLFxyXG4gICAgaGVpZ2h0XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiByZXRpbmFTY2FsZShjaGFydCwgZm9yY2VSYXRpbywgZm9yY2VTdHlsZSkge1xyXG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8IDE7XHJcbiAgY29uc3QgZGV2aWNlSGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcclxuICBjb25zdCBkZXZpY2VXaWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGggKiBwaXhlbFJhdGlvKTtcclxuICBjaGFydC5oZWlnaHQgPSBkZXZpY2VIZWlnaHQgLyBwaXhlbFJhdGlvO1xyXG4gIGNoYXJ0LndpZHRoID0gZGV2aWNlV2lkdGggLyBwaXhlbFJhdGlvO1xyXG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcclxuICBpZiAoY2FudmFzLnN0eWxlICYmIChmb3JjZVN0eWxlIHx8ICghY2FudmFzLnN0eWxlLmhlaWdodCAmJiAhY2FudmFzLnN0eWxlLndpZHRoKSkpIHtcclxuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtjaGFydC5oZWlnaHR9cHhgO1xyXG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xyXG4gIH1cclxuICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IHBpeGVsUmF0aW9cclxuICAgICAgfHwgY2FudmFzLmhlaWdodCAhPT0gZGV2aWNlSGVpZ2h0XHJcbiAgICAgIHx8IGNhbnZhcy53aWR0aCAhPT0gZGV2aWNlV2lkdGgpIHtcclxuICAgIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBkZXZpY2VIZWlnaHQ7XHJcbiAgICBjYW52YXMud2lkdGggPSBkZXZpY2VXaWR0aDtcclxuICAgIGNoYXJ0LmN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmNvbnN0IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSAoZnVuY3Rpb24oKSB7XHJcbiAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgZ2V0IHBhc3NpdmUoKSB7XHJcbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcclxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gIH1cclxuICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcclxufSgpKTtcclxuZnVuY3Rpb24gcmVhZFVzZWRTaXplKGVsZW1lbnQsIHByb3BlcnR5KSB7XHJcbiAgY29uc3QgdmFsdWUgPSBnZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XHJcbiAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xyXG4gIHJldHVybiBtYXRjaGVzID8gK21hdGNoZXNbMV0gOiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250KSB7XHJcbiAgaWYgKCFmb250IHx8IGlzTnVsbE9yVW5kZWYoZm9udC5zaXplKSB8fCBpc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcclxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcclxuXHRcdCsgZm9udC5zaXplICsgJ3B4ICdcclxuXHRcdCsgZm9udC5mYW1pbHk7XHJcbn1cclxuZnVuY3Rpb24gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xyXG4gIGxldCB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XHJcbiAgaWYgKCF0ZXh0V2lkdGgpIHtcclxuICAgIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xyXG4gICAgZ2MucHVzaChzdHJpbmcpO1xyXG4gIH1cclxuICBpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xyXG4gICAgbG9uZ2VzdCA9IHRleHRXaWR0aDtcclxuICB9XHJcbiAgcmV0dXJuIGxvbmdlc3Q7XHJcbn1cclxuZnVuY3Rpb24gX2xvbmdlc3RUZXh0KGN0eCwgZm9udCwgYXJyYXlPZlRoaW5ncywgY2FjaGUpIHtcclxuICBjYWNoZSA9IGNhY2hlIHx8IHt9O1xyXG4gIGxldCBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XHJcbiAgbGV0IGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcclxuICBpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xyXG4gICAgZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcclxuICAgIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcclxuICAgIGNhY2hlLmZvbnQgPSBmb250O1xyXG4gIH1cclxuICBjdHguc2F2ZSgpO1xyXG4gIGN0eC5mb250ID0gZm9udDtcclxuICBsZXQgbG9uZ2VzdCA9IDA7XHJcbiAgY29uc3QgaWxlbiA9IGFycmF5T2ZUaGluZ3MubGVuZ3RoO1xyXG4gIGxldCBpLCBqLCBqbGVuLCB0aGluZywgbmVzdGVkVGhpbmc7XHJcbiAgZm9yIChpID0gMDsgaSA8IGlsZW47IGkrKykge1xyXG4gICAgdGhpbmcgPSBhcnJheU9mVGhpbmdzW2ldO1xyXG4gICAgaWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgaXNBcnJheSh0aGluZykgIT09IHRydWUpIHtcclxuICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XHJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpbmcpKSB7XHJcbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSB0aGluZy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcclxuICAgICAgICBuZXN0ZWRUaGluZyA9IHRoaW5nW2pdO1xyXG4gICAgICAgIGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KG5lc3RlZFRoaW5nKSkge1xyXG4gICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGN0eC5yZXN0b3JlKCk7XHJcbiAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xyXG4gIGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xyXG4gICAgICBkZWxldGUgZGF0YVtnY1tpXV07XHJcbiAgICB9XHJcbiAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xyXG4gIH1cclxuICByZXR1cm4gbG9uZ2VzdDtcclxufVxyXG5mdW5jdGlvbiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIHdpZHRoKSB7XHJcbiAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xyXG4gIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcclxuICByZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KSB7XHJcbiAgY3R4ID0gY3R4IHx8IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gIGN0eC5zYXZlKCk7XHJcbiAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XHJcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gIGN0eC5yZXN0b3JlKCk7XHJcbn1cclxuZnVuY3Rpb24gZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgeCwgeSkge1xyXG4gIGxldCB0eXBlLCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBjb3JuZXJSYWRpdXM7XHJcbiAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnBvaW50U3R5bGU7XHJcbiAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xyXG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xyXG4gIGxldCByYWQgPSAocm90YXRpb24gfHwgMCkgKiBSQURfUEVSX0RFRztcclxuICBpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xyXG4gICAgdHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XHJcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcclxuICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgY3R4LnJvdGF0ZShyYWQpO1xyXG4gICAgICBjdHguZHJhd0ltYWdlKHN0eWxlLCAtc3R5bGUud2lkdGggLyAyLCAtc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XHJcbiAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDApIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gIHN3aXRjaCAoc3R5bGUpIHtcclxuICBkZWZhdWx0OlxyXG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIFRBVSk7XHJcbiAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICBicmVhaztcclxuICBjYXNlICd0cmlhbmdsZSc6XHJcbiAgICBjdHgubW92ZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XHJcbiAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcclxuICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcclxuICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xyXG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xyXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgYnJlYWs7XHJcbiAgY2FzZSAncmVjdFJvdW5kZWQnOlxyXG4gICAgY29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XHJcbiAgICBzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xyXG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcclxuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XHJcbiAgICBjdHguYXJjKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XHJcbiAgICBjdHguYXJjKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xyXG4gICAgY3R4LmFyYyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcclxuICAgIGN0eC5hcmMoeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcclxuICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgIGJyZWFrO1xyXG4gIGNhc2UgJ3JlY3QnOlxyXG4gICAgaWYgKCFyb3RhdGlvbikge1xyXG4gICAgICBzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xyXG4gICAgICBjdHgucmVjdCh4IC0gc2l6ZSwgeSAtIHNpemUsIDIgKiBzaXplLCAyICogc2l6ZSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmFkICs9IFFVQVJURVJfUEk7XHJcbiAgY2FzZSAncmVjdFJvdCc6XHJcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcclxuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xyXG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xyXG4gICAgY3R4LmxpbmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xyXG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xyXG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xyXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgYnJlYWs7XHJcbiAgY2FzZSAnY3Jvc3NSb3QnOlxyXG4gICAgcmFkICs9IFFVQVJURVJfUEk7XHJcbiAgY2FzZSAnY3Jvc3MnOlxyXG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XHJcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcclxuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcclxuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcclxuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcclxuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcclxuICAgIGJyZWFrO1xyXG4gIGNhc2UgJ3N0YXInOlxyXG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XHJcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcclxuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcclxuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcclxuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcclxuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcclxuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xyXG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XHJcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcclxuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcclxuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcclxuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcclxuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcclxuICAgIGJyZWFrO1xyXG4gIGNhc2UgJ2xpbmUnOlxyXG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XHJcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcclxuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcclxuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcclxuICAgIGJyZWFrO1xyXG4gIGNhc2UgJ2Rhc2gnOlxyXG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcclxuICAgIGN0eC5saW5lVG8oeCArIE1hdGguY29zKHJhZCkgKiByYWRpdXMsIHkgKyBNYXRoLnNpbihyYWQpICogcmFkaXVzKTtcclxuICAgIGJyZWFrO1xyXG4gIH1cclxuICBjdHguZmlsbCgpO1xyXG4gIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBfaXNQb2ludEluQXJlYShwb2ludCwgYXJlYSwgbWFyZ2luKSB7XHJcbiAgbWFyZ2luID0gbWFyZ2luIHx8IDAuNTtcclxuICByZXR1cm4gIWFyZWEgfHwgKHBvaW50ICYmIHBvaW50LnggPiBhcmVhLmxlZnQgLSBtYXJnaW4gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBtYXJnaW4gJiZcclxuXHRcdHBvaW50LnkgPiBhcmVhLnRvcCAtIG1hcmdpbiAmJiBwb2ludC55IDwgYXJlYS5ib3R0b20gKyBtYXJnaW4pO1xyXG59XHJcbmZ1bmN0aW9uIGNsaXBBcmVhKGN0eCwgYXJlYSkge1xyXG4gIGN0eC5zYXZlKCk7XHJcbiAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gIGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xyXG4gIGN0eC5jbGlwKCk7XHJcbn1cclxuZnVuY3Rpb24gdW5jbGlwQXJlYShjdHgpIHtcclxuICBjdHgucmVzdG9yZSgpO1xyXG59XHJcbmZ1bmN0aW9uIF9zdGVwcGVkTGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCwgbW9kZSkge1xyXG4gIGlmICghcHJldmlvdXMpIHtcclxuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XHJcbiAgfVxyXG4gIGlmIChtb2RlID09PSAnbWlkZGxlJykge1xyXG4gICAgY29uc3QgbWlkcG9pbnQgPSAocHJldmlvdXMueCArIHRhcmdldC54KSAvIDIuMDtcclxuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHByZXZpb3VzLnkpO1xyXG4gICAgY3R4LmxpbmVUbyhtaWRwb2ludCwgdGFyZ2V0LnkpO1xyXG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2FmdGVyJyAhPT0gISFmbGlwKSB7XHJcbiAgICBjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcclxuICB9IGVsc2Uge1xyXG4gICAgY3R4LmxpbmVUbyh0YXJnZXQueCwgcHJldmlvdXMueSk7XHJcbiAgfVxyXG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcclxufVxyXG5mdW5jdGlvbiBfYmV6aWVyQ3VydmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXApIHtcclxuICBpZiAoIXByZXZpb3VzKSB7XHJcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xyXG4gIH1cclxuICBjdHguYmV6aWVyQ3VydmVUbyhcclxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF4IDogcHJldmlvdXMuY3AyeCxcclxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF5IDogcHJldmlvdXMuY3AyeSxcclxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeCA6IHRhcmdldC5jcDF4LFxyXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ5IDogdGFyZ2V0LmNwMXksXHJcbiAgICB0YXJnZXQueCxcclxuICAgIHRhcmdldC55KTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJUZXh0KGN0eCwgdGV4dCwgeCwgeSwgZm9udCwgb3B0cyA9IHt9KSB7XHJcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KHRleHQpID8gdGV4dCA6IFt0ZXh0XTtcclxuICBjb25zdCBzdHJva2UgPSBvcHRzLnN0cm9rZVdpZHRoID4gMCAmJiBvcHRzLnN0cm9rZUNvbG9yICE9PSAnJztcclxuICBsZXQgaSwgbGluZTtcclxuICBjdHguc2F2ZSgpO1xyXG4gIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XHJcbiAgc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpO1xyXG4gIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgaWYgKHN0cm9rZSkge1xyXG4gICAgICBpZiAob3B0cy5zdHJva2VDb2xvcikge1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdHMuc3Ryb2tlQ29sb3I7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMuc3Ryb2tlV2lkdGgpKSB7XHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGg7XHJcbiAgICAgIH1cclxuICAgICAgY3R4LnN0cm9rZVRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XHJcbiAgICB9XHJcbiAgICBjdHguZmlsbFRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XHJcbiAgICBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKTtcclxuICAgIHkgKz0gZm9udC5saW5lSGVpZ2h0O1xyXG4gIH1cclxuICBjdHgucmVzdG9yZSgpO1xyXG59XHJcbmZ1bmN0aW9uIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKSB7XHJcbiAgaWYgKG9wdHMudHJhbnNsYXRpb24pIHtcclxuICAgIGN0eC50cmFuc2xhdGUob3B0cy50cmFuc2xhdGlvblswXSwgb3B0cy50cmFuc2xhdGlvblsxXSk7XHJcbiAgfVxyXG4gIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnJvdGF0aW9uKSkge1xyXG4gICAgY3R4LnJvdGF0ZShvcHRzLnJvdGF0aW9uKTtcclxuICB9XHJcbiAgaWYgKG9wdHMuY29sb3IpIHtcclxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yO1xyXG4gIH1cclxuICBpZiAob3B0cy50ZXh0QWxpZ24pIHtcclxuICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRzLnRleHRBbGlnbjtcclxuICB9XHJcbiAgaWYgKG9wdHMudGV4dEJhc2VsaW5lKSB7XHJcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gb3B0cy50ZXh0QmFzZWxpbmU7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpIHtcclxuICBpZiAob3B0cy5zdHJpa2V0aHJvdWdoIHx8IG9wdHMudW5kZXJsaW5lKSB7XHJcbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUpO1xyXG4gICAgY29uc3QgbGVmdCA9IHggLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdDtcclxuICAgIGNvbnN0IHJpZ2h0ID0geCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodDtcclxuICAgIGNvbnN0IHRvcCA9IHkgLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xyXG4gICAgY29uc3QgYm90dG9tID0geSArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xyXG4gICAgY29uc3QgeURlY29yYXRpb24gPSBvcHRzLnN0cmlrZXRocm91Z2ggPyAodG9wICsgYm90dG9tKSAvIDIgOiBib3R0b207XHJcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuZGVjb3JhdGlvbldpZHRoIHx8IDI7XHJcbiAgICBjdHgubW92ZVRvKGxlZnQsIHlEZWNvcmF0aW9uKTtcclxuICAgIGN0eC5saW5lVG8ocmlnaHQsIHlEZWNvcmF0aW9uKTtcclxuICAgIGN0eC5zdHJva2UoKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwgcmVjdCkge1xyXG4gIGNvbnN0IHt4LCB5LCB3LCBoLCByYWRpdXN9ID0gcmVjdDtcclxuICBjdHguYXJjKHggKyByYWRpdXMudG9wTGVmdCwgeSArIHJhZGl1cy50b3BMZWZ0LCByYWRpdXMudG9wTGVmdCwgLUhBTEZfUEksIFBJLCB0cnVlKTtcclxuICBjdHgubGluZVRvKHgsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQpO1xyXG4gIGN0eC5hcmMoeCArIHJhZGl1cy5ib3R0b21MZWZ0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0LCByYWRpdXMuYm90dG9tTGVmdCwgUEksIEhBTEZfUEksIHRydWUpO1xyXG4gIGN0eC5saW5lVG8oeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoKTtcclxuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21SaWdodCwgcmFkaXVzLmJvdHRvbVJpZ2h0LCBIQUxGX1BJLCAwLCB0cnVlKTtcclxuICBjdHgubGluZVRvKHggKyB3LCB5ICsgcmFkaXVzLnRvcFJpZ2h0KTtcclxuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLnRvcFJpZ2h0LCB5ICsgcmFkaXVzLnRvcFJpZ2h0LCByYWRpdXMudG9wUmlnaHQsIDAsIC1IQUxGX1BJLCB0cnVlKTtcclxuICBjdHgubGluZVRvKHggKyByYWRpdXMudG9wTGVmdCwgeSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzID0gWycnXSwgcm9vdFNjb3BlcyA9IHNjb3BlcywgZmFsbGJhY2ssIGdldFRhcmdldCA9ICgpID0+IHNjb3Blc1swXSkge1xyXG4gIGlmICghZGVmaW5lZChmYWxsYmFjaykpIHtcclxuICAgIGZhbGxiYWNrID0gX3Jlc29sdmUoJ19mYWxsYmFjaycsIHNjb3Blcyk7XHJcbiAgfVxyXG4gIGNvbnN0IGNhY2hlID0ge1xyXG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdPYmplY3QnLFxyXG4gICAgX2NhY2hlYWJsZTogdHJ1ZSxcclxuICAgIF9zY29wZXM6IHNjb3BlcyxcclxuICAgIF9yb290U2NvcGVzOiByb290U2NvcGVzLFxyXG4gICAgX2ZhbGxiYWNrOiBmYWxsYmFjayxcclxuICAgIF9nZXRUYXJnZXQ6IGdldFRhcmdldCxcclxuICAgIG92ZXJyaWRlOiAoc2NvcGUpID0+IF9jcmVhdGVSZXNvbHZlcihbc2NvcGUsIC4uLnNjb3Blc10sIHByZWZpeGVzLCByb290U2NvcGVzLCBmYWxsYmFjayksXHJcbiAgfTtcclxuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XHJcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcclxuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcclxuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5cztcclxuICAgICAgZGVsZXRlIHNjb3Blc1swXVtwcm9wXTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xyXG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXHJcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgdGFyZ2V0KSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xyXG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0Ll9zY29wZXNbMF0sIHByb3ApO1xyXG4gICAgfSxcclxuICAgIGdldFByb3RvdHlwZU9mKCkge1xyXG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xyXG4gICAgfSxcclxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcclxuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkuaW5jbHVkZXMocHJvcCk7XHJcbiAgICB9LFxyXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcclxuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCk7XHJcbiAgICB9LFxyXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcclxuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldC5fc3RvcmFnZSB8fCAodGFyZ2V0Ll9zdG9yYWdlID0gZ2V0VGFyZ2V0KCkpO1xyXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzdG9yYWdlW3Byb3BdID0gdmFsdWU7XHJcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIF9hdHRhY2hDb250ZXh0KHByb3h5LCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XHJcbiAgY29uc3QgY2FjaGUgPSB7XHJcbiAgICBfY2FjaGVhYmxlOiBmYWxzZSxcclxuICAgIF9wcm94eTogcHJveHksXHJcbiAgICBfY29udGV4dDogY29udGV4dCxcclxuICAgIF9zdWJQcm94eTogc3ViUHJveHksXHJcbiAgICBfc3RhY2s6IG5ldyBTZXQoKSxcclxuICAgIF9kZXNjcmlwdG9yczogX2Rlc2NyaXB0b3JzKHByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxyXG4gICAgc2V0Q29udGV4dDogKGN0eCkgPT4gX2F0dGFjaENvbnRleHQocHJveHksIGN0eCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXHJcbiAgICBvdmVycmlkZTogKHNjb3BlKSA9PiBfYXR0YWNoQ29udGV4dChwcm94eS5vdmVycmlkZShzY29wZSksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpXHJcbiAgfTtcclxuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XHJcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcclxuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcclxuICAgICAgZGVsZXRlIHByb3h5W3Byb3BdO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xyXG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXHJcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xyXG4gICAgICByZXR1cm4gdGFyZ2V0Ll9kZXNjcmlwdG9ycy5hbGxLZXlzXHJcbiAgICAgICAgPyBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCkgPyB7ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSA6IHVuZGVmaW5lZFxyXG4gICAgICAgIDogUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJveHksIHByb3ApO1xyXG4gICAgfSxcclxuICAgIGdldFByb3RvdHlwZU9mKCkge1xyXG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihwcm94eSk7XHJcbiAgICB9LFxyXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xyXG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXMocHJveHksIHByb3ApO1xyXG4gICAgfSxcclxuICAgIG93bktleXMoKSB7XHJcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMocHJveHkpO1xyXG4gICAgfSxcclxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XHJcbiAgICAgIHByb3h5W3Byb3BdID0gdmFsdWU7XHJcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbmZ1bmN0aW9uIF9kZXNjcmlwdG9ycyhwcm94eSwgZGVmYXVsdHMgPSB7c2NyaXB0YWJsZTogdHJ1ZSwgaW5kZXhhYmxlOiB0cnVlfSkge1xyXG4gIGNvbnN0IHtfc2NyaXB0YWJsZSA9IGRlZmF1bHRzLnNjcmlwdGFibGUsIF9pbmRleGFibGUgPSBkZWZhdWx0cy5pbmRleGFibGUsIF9hbGxLZXlzID0gZGVmYXVsdHMuYWxsS2V5c30gPSBwcm94eTtcclxuICByZXR1cm4ge1xyXG4gICAgYWxsS2V5czogX2FsbEtleXMsXHJcbiAgICBzY3JpcHRhYmxlOiBfc2NyaXB0YWJsZSxcclxuICAgIGluZGV4YWJsZTogX2luZGV4YWJsZSxcclxuICAgIGlzU2NyaXB0YWJsZTogaXNGdW5jdGlvbihfc2NyaXB0YWJsZSkgPyBfc2NyaXB0YWJsZSA6ICgpID0+IF9zY3JpcHRhYmxlLFxyXG4gICAgaXNJbmRleGFibGU6IGlzRnVuY3Rpb24oX2luZGV4YWJsZSkgPyBfaW5kZXhhYmxlIDogKCkgPT4gX2luZGV4YWJsZVxyXG4gIH07XHJcbn1cclxuY29uc3QgcmVhZEtleSA9IChwcmVmaXgsIG5hbWUpID0+IHByZWZpeCA/IHByZWZpeCArIF9jYXBpdGFsaXplKG5hbWUpIDogbmFtZTtcclxuY29uc3QgbmVlZHNTdWJSZXNvbHZlciA9IChwcm9wLCB2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIHByb3AgIT09ICdhZGFwdGVycycgJiZcclxuICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcclxuZnVuY3Rpb24gX2NhY2hlZCh0YXJnZXQsIHByb3AsIHJlc29sdmUpIHtcclxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcCkpIHtcclxuICAgIHJldHVybiB0YXJnZXRbcHJvcF07XHJcbiAgfVxyXG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xyXG4gIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xyXG4gIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcclxuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcclxuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07XHJcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpICYmIGRlc2NyaXB0b3JzLmlzU2NyaXB0YWJsZShwcm9wKSkge1xyXG4gICAgdmFsdWUgPSBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpO1xyXG4gIH1cclxuICBpZiAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoKSB7XHJcbiAgICB2YWx1ZSA9IF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgZGVzY3JpcHRvcnMuaXNJbmRleGFibGUpO1xyXG4gIH1cclxuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcclxuICAgIHZhbHVlID0gX2F0dGFjaENvbnRleHQodmFsdWUsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycyk7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpIHtcclxuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfc3RhY2t9ID0gdGFyZ2V0O1xyXG4gIGlmIChfc3RhY2suaGFzKHByb3ApKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xyXG4gIH1cclxuICBfc3RhY2suYWRkKHByb3ApO1xyXG4gIHZhbHVlID0gdmFsdWUoX2NvbnRleHQsIF9zdWJQcm94eSB8fCByZWNlaXZlcik7XHJcbiAgX3N0YWNrLmRlbGV0ZShwcm9wKTtcclxuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcclxuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xyXG4gIH1cclxuICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBpc0luZGV4YWJsZSkge1xyXG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xyXG4gIGlmIChkZWZpbmVkKF9jb250ZXh0LmluZGV4KSAmJiBpc0luZGV4YWJsZShwcm9wKSkge1xyXG4gICAgdmFsdWUgPSB2YWx1ZVtfY29udGV4dC5pbmRleCAlIHZhbHVlLmxlbmd0aF07XHJcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZVswXSkpIHtcclxuICAgIGNvbnN0IGFyciA9IHZhbHVlO1xyXG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcclxuICAgIHZhbHVlID0gW107XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XHJcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xyXG4gICAgICB2YWx1ZS5wdXNoKF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVGYWxsYmFjayhmYWxsYmFjaywgcHJvcCwgdmFsdWUpIHtcclxuICByZXR1cm4gaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjayhwcm9wLCB2YWx1ZSkgOiBmYWxsYmFjaztcclxufVxyXG5jb25zdCBnZXRTY29wZSA9IChrZXksIHBhcmVudCkgPT4ga2V5ID09PSB0cnVlID8gcGFyZW50XHJcbiAgOiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHJlc29sdmVPYmplY3RLZXkocGFyZW50LCBrZXkpIDogdW5kZWZpbmVkO1xyXG5mdW5jdGlvbiBhZGRTY29wZXMoc2V0LCBwYXJlbnRTY29wZXMsIGtleSwgcGFyZW50RmFsbGJhY2ssIHZhbHVlKSB7XHJcbiAgZm9yIChjb25zdCBwYXJlbnQgb2YgcGFyZW50U2NvcGVzKSB7XHJcbiAgICBjb25zdCBzY29wZSA9IGdldFNjb3BlKGtleSwgcGFyZW50KTtcclxuICAgIGlmIChzY29wZSkge1xyXG4gICAgICBzZXQuYWRkKHNjb3BlKTtcclxuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2soc2NvcGUuX2ZhbGxiYWNrLCBrZXksIHZhbHVlKTtcclxuICAgICAgaWYgKGRlZmluZWQoZmFsbGJhY2spICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHNjb3BlID09PSBmYWxzZSAmJiBkZWZpbmVkKHBhcmVudEZhbGxiYWNrKSAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIocGFyZW50U2NvcGVzLCByZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcclxuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XHJcbiAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2socmVzb2x2ZXIuX2ZhbGxiYWNrLCBwcm9wLCB2YWx1ZSk7XHJcbiAgY29uc3QgYWxsU2NvcGVzID0gWy4uLnBhcmVudFNjb3BlcywgLi4ucm9vdFNjb3Blc107XHJcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xyXG4gIHNldC5hZGQodmFsdWUpO1xyXG4gIGxldCBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBwcm9wLCBmYWxsYmFjayB8fCBwcm9wLCB2YWx1ZSk7XHJcbiAgaWYgKGtleSA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoZGVmaW5lZChmYWxsYmFjaykgJiYgZmFsbGJhY2sgIT09IHByb3ApIHtcclxuICAgIGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGZhbGxiYWNrLCBrZXksIHZhbHVlKTtcclxuICAgIGlmIChrZXkgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gX2NyZWF0ZVJlc29sdmVyKEFycmF5LmZyb20oc2V0KSwgWycnXSwgcm9vdFNjb3BlcywgZmFsbGJhY2ssXHJcbiAgICAoKSA9PiBzdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AsIHZhbHVlKSk7XHJcbn1cclxuZnVuY3Rpb24gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3Blcywga2V5LCBmYWxsYmFjaywgaXRlbSkge1xyXG4gIHdoaWxlIChrZXkpIHtcclxuICAgIGtleSA9IGFkZFNjb3BlcyhzZXQsIGFsbFNjb3Blcywga2V5LCBmYWxsYmFjaywgaXRlbSk7XHJcbiAgfVxyXG4gIHJldHVybiBrZXk7XHJcbn1cclxuZnVuY3Rpb24gc3ViR2V0VGFyZ2V0KHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkge1xyXG4gIGNvbnN0IHBhcmVudCA9IHJlc29sdmVyLl9nZXRUYXJnZXQoKTtcclxuICBpZiAoIShwcm9wIGluIHBhcmVudCkpIHtcclxuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xyXG4gIH1cclxuICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XHJcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCBwcm94eSkge1xyXG4gIGxldCB2YWx1ZTtcclxuICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xyXG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XHJcbiAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpXHJcbiAgICAgICAgPyBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIHByb3h5LCBwcm9wLCB2YWx1ZSlcclxuICAgICAgICA6IHZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBfcmVzb2x2ZShrZXksIHNjb3Blcykge1xyXG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XHJcbiAgICBpZiAoIXNjb3BlKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdmFsdWUgPSBzY29wZVtrZXldO1xyXG4gICAgaWYgKGRlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KSB7XHJcbiAgbGV0IGtleXMgPSB0YXJnZXQuX2tleXM7XHJcbiAgaWYgKCFrZXlzKSB7XHJcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcclxuICB9XHJcbiAgcmV0dXJuIGtleXM7XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHNjb3Blcykge1xyXG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcclxuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xyXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NvcGUpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpIHtcclxuICAgICAgc2V0LmFkZChrZXkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xyXG59XHJcbmZ1bmN0aW9uIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcclxuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XHJcbiAgY29uc3Qge2tleSA9ICdyJ30gPSB0aGlzLl9wYXJzaW5nO1xyXG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XHJcbiAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xyXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgaW5kZXggPSBpICsgc3RhcnQ7XHJcbiAgICBpdGVtID0gZGF0YVtpbmRleF07XHJcbiAgICBwYXJzZWRbaV0gPSB7XHJcbiAgICAgIHI6IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIGtleSksIGluZGV4KVxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHBhcnNlZDtcclxufVxyXG5cclxuY29uc3QgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xyXG5jb25zdCBnZXRQb2ludCA9IChwb2ludHMsIGkpID0+IGkgPCBwb2ludHMubGVuZ3RoICYmICFwb2ludHNbaV0uc2tpcCAmJiBwb2ludHNbaV07XHJcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXMpID0+IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xyXG5mdW5jdGlvbiBzcGxpbmVDdXJ2ZShmaXJzdFBvaW50LCBtaWRkbGVQb2ludCwgYWZ0ZXJQb2ludCwgdCkge1xyXG4gIGNvbnN0IHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50O1xyXG4gIGNvbnN0IGN1cnJlbnQgPSBtaWRkbGVQb2ludDtcclxuICBjb25zdCBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xyXG4gIGNvbnN0IGQwMSA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhjdXJyZW50LCBwcmV2aW91cyk7XHJcbiAgY29uc3QgZDEyID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKG5leHQsIGN1cnJlbnQpO1xyXG4gIGxldCBzMDEgPSBkMDEgLyAoZDAxICsgZDEyKTtcclxuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XHJcbiAgczAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XHJcbiAgczEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XHJcbiAgY29uc3QgZmEgPSB0ICogczAxO1xyXG4gIGNvbnN0IGZiID0gdCAqIHMxMjtcclxuICByZXR1cm4ge1xyXG4gICAgcHJldmlvdXM6IHtcclxuICAgICAgeDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXHJcbiAgICAgIHk6IGN1cnJlbnQueSAtIGZhICogKG5leHQueSAtIHByZXZpb3VzLnkpXHJcbiAgICB9LFxyXG4gICAgbmV4dDoge1xyXG4gICAgICB4OiBjdXJyZW50LnggKyBmYiAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcclxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcclxuICAgIH1cclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSykge1xyXG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgbGV0IGFscGhhSywgYmV0YUssIHRhdUssIHNxdWFyZWRNYWduaXR1ZGUsIHBvaW50Q3VycmVudDtcclxuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW4gLSAxOyArK2kpIHtcclxuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XHJcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XHJcbiAgICBpZiAoIXBvaW50Q3VycmVudCB8fCAhcG9pbnRBZnRlcikge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmIChhbG1vc3RFcXVhbHMoZGVsdGFLW2ldLCAwLCBFUFNJTE9OKSkge1xyXG4gICAgICBtS1tpXSA9IG1LW2kgKyAxXSA9IDA7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgYWxwaGFLID0gbUtbaV0gLyBkZWx0YUtbaV07XHJcbiAgICBiZXRhSyA9IG1LW2kgKyAxXSAvIGRlbHRhS1tpXTtcclxuICAgIHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xyXG4gICAgaWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xyXG4gICAgbUtbaV0gPSBhbHBoYUsgKiB0YXVLICogZGVsdGFLW2ldO1xyXG4gICAgbUtbaSArIDFdID0gYmV0YUsgKiB0YXVLICogZGVsdGFLW2ldO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBtb25vdG9uZUNvbXB1dGUocG9pbnRzLCBtSywgaW5kZXhBeGlzID0gJ3gnKSB7XHJcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XHJcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcclxuICBsZXQgZGVsdGEsIHBvaW50QmVmb3JlLCBwb2ludEN1cnJlbnQ7XHJcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcclxuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xyXG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcclxuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcclxuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaVBpeGVsID0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XHJcbiAgICBjb25zdCB2UGl4ZWwgPSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXTtcclxuICAgIGlmIChwb2ludEJlZm9yZSkge1xyXG4gICAgICBkZWx0YSA9IChpUGl4ZWwgLSBwb2ludEJlZm9yZVtpbmRleEF4aXNdKSAvIDM7XHJcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgLSBkZWx0YTtcclxuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCAtIGRlbHRhICogbUtbaV07XHJcbiAgICB9XHJcbiAgICBpZiAocG9pbnRBZnRlcikge1xyXG4gICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcclxuICAgICAgcG9pbnRDdXJyZW50W2BjcDIke2luZGV4QXhpc31gXSA9IGlQaXhlbCArIGRlbHRhO1xyXG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7dmFsdWVBeGlzfWBdID0gdlBpeGVsICsgZGVsdGEgKiBtS1tpXTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyA9ICd4Jykge1xyXG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xyXG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgY29uc3QgZGVsdGFLID0gQXJyYXkocG9pbnRzTGVuKS5maWxsKDApO1xyXG4gIGNvbnN0IG1LID0gQXJyYXkocG9pbnRzTGVuKTtcclxuICBsZXQgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudDtcclxuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XHJcbiAgZm9yIChpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XHJcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcclxuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XHJcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XHJcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmIChwb2ludEFmdGVyKSB7XHJcbiAgICAgIGNvbnN0IHNsb3BlRGVsdGEgPSBwb2ludEFmdGVyW2luZGV4QXhpc10gLSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcclxuICAgICAgZGVsdGFLW2ldID0gc2xvcGVEZWx0YSAhPT0gMCA/IChwb2ludEFmdGVyW3ZhbHVlQXhpc10gLSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXSkgLyBzbG9wZURlbHRhIDogMDtcclxuICAgIH1cclxuICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldXHJcbiAgICAgIDogIXBvaW50QWZ0ZXIgPyBkZWx0YUtbaSAtIDFdXHJcbiAgICAgIDogKHNpZ24oZGVsdGFLW2kgLSAxXSkgIT09IHNpZ24oZGVsdGFLW2ldKSkgPyAwXHJcbiAgICAgIDogKGRlbHRhS1tpIC0gMV0gKyBkZWx0YUtbaV0pIC8gMjtcclxuICB9XHJcbiAgbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKTtcclxuICBtb25vdG9uZUNvbXB1dGUocG9pbnRzLCBtSywgaW5kZXhBeGlzKTtcclxufVxyXG5mdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XHJcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xyXG59XHJcbmZ1bmN0aW9uIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpIHtcclxuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGluQXJlYSwgaW5BcmVhUHJldjtcclxuICBsZXQgaW5BcmVhTmV4dCA9IF9pc1BvaW50SW5BcmVhKHBvaW50c1swXSwgYXJlYSk7XHJcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuICAgIGluQXJlYVByZXYgPSBpbkFyZWE7XHJcbiAgICBpbkFyZWEgPSBpbkFyZWFOZXh0O1xyXG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcclxuICAgIGlmICghaW5BcmVhKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgcG9pbnQgPSBwb2ludHNbaV07XHJcbiAgICBpZiAoaW5BcmVhUHJldikge1xyXG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XHJcbiAgICAgIHBvaW50LmNwMXkgPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AxeSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcclxuICAgIH1cclxuICAgIGlmIChpbkFyZWFOZXh0KSB7XHJcbiAgICAgIHBvaW50LmNwMnggPSBjYXBDb250cm9sUG9pbnQocG9pbnQuY3AyeCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcclxuICAgICAgcG9pbnQuY3AyeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyhwb2ludHMsIG9wdGlvbnMsIGFyZWEsIGxvb3AsIGluZGV4QXhpcykge1xyXG4gIGxldCBpLCBpbGVuLCBwb2ludCwgY29udHJvbFBvaW50cztcclxuICBpZiAob3B0aW9ucy5zcGFuR2Fwcykge1xyXG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcclxuICB9XHJcbiAgaWYgKG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xyXG4gICAgc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGxldCBwcmV2ID0gbG9vcCA/IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gOiBwb2ludHNbMF07XHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcclxuICAgICAgY29udHJvbFBvaW50cyA9IHNwbGluZUN1cnZlKFxyXG4gICAgICAgIHByZXYsXHJcbiAgICAgICAgcG9pbnQsXHJcbiAgICAgICAgcG9pbnRzW01hdGgubWluKGkgKyAxLCBpbGVuIC0gKGxvb3AgPyAwIDogMSkpICUgaWxlbl0sXHJcbiAgICAgICAgb3B0aW9ucy50ZW5zaW9uXHJcbiAgICAgICk7XHJcbiAgICAgIHBvaW50LmNwMXggPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLng7XHJcbiAgICAgIHBvaW50LmNwMXkgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XHJcbiAgICAgIHBvaW50LmNwMnggPSBjb250cm9sUG9pbnRzLm5leHQueDtcclxuICAgICAgcG9pbnQuY3AyeSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xyXG4gICAgICBwcmV2ID0gcG9pbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChvcHRpb25zLmNhcEJlemllclBvaW50cykge1xyXG4gICAgY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSk7XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBhdEVkZ2UgPSAodCkgPT4gdCA9PT0gMCB8fCB0ID09PSAxO1xyXG5jb25zdCBlbGFzdGljSW4gPSAodCwgcywgcCkgPT4gLShNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSk7XHJcbmNvbnN0IGVsYXN0aWNPdXQgPSAodCwgcywgcCkgPT4gTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkgKyAxO1xyXG5jb25zdCBlZmZlY3RzID0ge1xyXG4gIGxpbmVhcjogdCA9PiB0LFxyXG4gIGVhc2VJblF1YWQ6IHQgPT4gdCAqIHQsXHJcbiAgZWFzZU91dFF1YWQ6IHQgPT4gLXQgKiAodCAtIDIpLFxyXG4gIGVhc2VJbk91dFF1YWQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxyXG4gICAgPyAwLjUgKiB0ICogdFxyXG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxyXG4gIGVhc2VJbkN1YmljOiB0ID0+IHQgKiB0ICogdCxcclxuICBlYXNlT3V0Q3ViaWM6IHQgPT4gKHQgLT0gMSkgKiB0ICogdCArIDEsXHJcbiAgZWFzZUluT3V0Q3ViaWM6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxyXG4gICAgPyAwLjUgKiB0ICogdCAqIHRcclxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKyAyKSxcclxuICBlYXNlSW5RdWFydDogdCA9PiB0ICogdCAqIHQgKiB0LFxyXG4gIGVhc2VPdXRRdWFydDogdCA9PiAtKCh0IC09IDEpICogdCAqIHQgKiB0IC0gMSksXHJcbiAgZWFzZUluT3V0UXVhcnQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxyXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XHJcbiAgICA6IC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSxcclxuICBlYXNlSW5RdWludDogdCA9PiB0ICogdCAqIHQgKiB0ICogdCxcclxuICBlYXNlT3V0UXVpbnQ6IHQgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcclxuICBlYXNlSW5PdXRRdWludDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXHJcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0XHJcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcclxuICBlYXNlSW5TaW5lOiB0ID0+IC1NYXRoLmNvcyh0ICogSEFMRl9QSSkgKyAxLFxyXG4gIGVhc2VPdXRTaW5lOiB0ID0+IE1hdGguc2luKHQgKiBIQUxGX1BJKSxcclxuICBlYXNlSW5PdXRTaW5lOiB0ID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxyXG4gIGVhc2VJbkV4cG86IHQgPT4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSksXHJcbiAgZWFzZU91dEV4cG86IHQgPT4gKHQgPT09IDEpID8gMSA6IC1NYXRoLnBvdygyLCAtMTAgKiB0KSArIDEsXHJcbiAgZWFzZUluT3V0RXhwbzogdCA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxyXG4gICAgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0ICogMiAtIDEpKVxyXG4gICAgOiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqICh0ICogMiAtIDEpKSArIDIpLFxyXG4gIGVhc2VJbkNpcmM6IHQgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxyXG4gIGVhc2VPdXRDaXJjOiB0ID0+IE1hdGguc3FydCgxIC0gKHQgLT0gMSkgKiB0KSxcclxuICBlYXNlSW5PdXRDaXJjOiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcclxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXHJcbiAgICA6IDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSxcclxuICBlYXNlSW5FbGFzdGljOiB0ID0+IGF0RWRnZSh0KSA/IHQgOiBlbGFzdGljSW4odCwgMC4wNzUsIDAuMyksXHJcbiAgZWFzZU91dEVsYXN0aWM6IHQgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXHJcbiAgZWFzZUluT3V0RWxhc3RpYyh0KSB7XHJcbiAgICBjb25zdCBzID0gMC4xMTI1O1xyXG4gICAgY29uc3QgcCA9IDAuNDU7XHJcbiAgICByZXR1cm4gYXRFZGdlKHQpID8gdCA6XHJcbiAgICAgIHQgPCAwLjVcclxuICAgICAgICA/IDAuNSAqIGVsYXN0aWNJbih0ICogMiwgcywgcClcclxuICAgICAgICA6IDAuNSArIDAuNSAqIGVsYXN0aWNPdXQodCAqIDIgLSAxLCBzLCBwKTtcclxuICB9LFxyXG4gIGVhc2VJbkJhY2sodCkge1xyXG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XHJcbiAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcclxuICB9LFxyXG4gIGVhc2VPdXRCYWNrKHQpIHtcclxuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xyXG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcclxuICB9LFxyXG4gIGVhc2VJbk91dEJhY2sodCkge1xyXG4gICAgbGV0IHMgPSAxLjcwMTU4O1xyXG4gICAgaWYgKCh0IC89IDAuNSkgPCAxKSB7XHJcbiAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKTtcclxuICB9LFxyXG4gIGVhc2VJbkJvdW5jZTogdCA9PiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KSxcclxuICBlYXNlT3V0Qm91bmNlKHQpIHtcclxuICAgIGNvbnN0IG0gPSA3LjU2MjU7XHJcbiAgICBjb25zdCBkID0gMi43NTtcclxuICAgIGlmICh0IDwgKDEgLyBkKSkge1xyXG4gICAgICByZXR1cm4gbSAqIHQgKiB0O1xyXG4gICAgfVxyXG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XHJcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDEuNSAvIGQpKSAqIHQgKyAwLjc1O1xyXG4gICAgfVxyXG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcclxuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMi4yNSAvIGQpKSAqIHQgKyAwLjkzNzU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcclxuICB9LFxyXG4gIGVhc2VJbk91dEJvdW5jZTogdCA9PiAodCA8IDAuNSlcclxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XHJcbiAgICA6IGVmZmVjdHMuZWFzZU91dEJvdW5jZSh0ICogMiAtIDEpICogMC41ICsgMC41LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gX3BvaW50SW5MaW5lKHAxLCBwMiwgdCwgbW9kZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXHJcbiAgICB5OiBwMS55ICsgdCAqIChwMi55IC0gcDEueSlcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIF9zdGVwcGVkSW50ZXJwb2xhdGlvbihwMSwgcDIsIHQsIG1vZGUpIHtcclxuICByZXR1cm4ge1xyXG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxyXG4gICAgeTogbW9kZSA9PT0gJ21pZGRsZScgPyB0IDwgMC41ID8gcDEueSA6IHAyLnlcclxuICAgIDogbW9kZSA9PT0gJ2FmdGVyJyA/IHQgPCAxID8gcDEueSA6IHAyLnlcclxuICAgIDogdCA+IDAgPyBwMi55IDogcDEueVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gX2JlemllckludGVycG9sYXRpb24ocDEsIHAyLCB0LCBtb2RlKSB7XHJcbiAgY29uc3QgY3AxID0ge3g6IHAxLmNwMngsIHk6IHAxLmNwMnl9O1xyXG4gIGNvbnN0IGNwMiA9IHt4OiBwMi5jcDF4LCB5OiBwMi5jcDF5fTtcclxuICBjb25zdCBhID0gX3BvaW50SW5MaW5lKHAxLCBjcDEsIHQpO1xyXG4gIGNvbnN0IGIgPSBfcG9pbnRJbkxpbmUoY3AxLCBjcDIsIHQpO1xyXG4gIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XHJcbiAgY29uc3QgZCA9IF9wb2ludEluTGluZShhLCBiLCB0KTtcclxuICBjb25zdCBlID0gX3BvaW50SW5MaW5lKGIsIGMsIHQpO1xyXG4gIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XHJcbn1cclxuXHJcbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIGNvbnN0IGNhY2hlS2V5ID0gbG9jYWxlICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XHJcbiAgbGV0IGZvcm1hdHRlciA9IGludGxDYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG4gIGlmICghZm9ybWF0dGVyKSB7XHJcbiAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcclxuICAgIGludGxDYWNoZS5zZXQoY2FjaGVLZXksIGZvcm1hdHRlcik7XHJcbiAgfVxyXG4gIHJldHVybiBmb3JtYXR0ZXI7XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bSwgbG9jYWxlLCBvcHRpb25zKSB7XHJcbiAgcmV0dXJuIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChudW0pO1xyXG59XHJcblxyXG5jb25zdCBMSU5FX0hFSUdIVCA9IG5ldyBSZWdFeHAoL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC8pO1xyXG5jb25zdCBGT05UX1NUWUxFID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8aXRhbGljfGluaXRpYWx8aW5oZXJpdHx1bnNldHwob2JsaXF1ZSggLT9bMC05XT9bMC05XWRlZyk/KSkkLyk7XHJcbmZ1bmN0aW9uIHRvTGluZUhlaWdodCh2YWx1ZSwgc2l6ZSkge1xyXG4gIGNvbnN0IG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goTElORV9IRUlHSFQpO1xyXG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xyXG4gICAgcmV0dXJuIHNpemUgKiAxLjI7XHJcbiAgfVxyXG4gIHZhbHVlID0gK21hdGNoZXNbMl07XHJcbiAgc3dpdGNoIChtYXRjaGVzWzNdKSB7XHJcbiAgY2FzZSAncHgnOlxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIGNhc2UgJyUnOlxyXG4gICAgdmFsdWUgLz0gMTAwO1xyXG4gICAgYnJlYWs7XHJcbiAgfVxyXG4gIHJldHVybiBzaXplICogdmFsdWU7XHJcbn1cclxuY29uc3QgbnVtYmVyT3JaZXJvID0gdiA9PiArdiB8fCAwO1xyXG5mdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgcHJvcHMpIHtcclxuICBjb25zdCByZXQgPSB7fTtcclxuICBjb25zdCBvYmpQcm9wcyA9IGlzT2JqZWN0KHByb3BzKTtcclxuICBjb25zdCBrZXlzID0gb2JqUHJvcHMgPyBPYmplY3Qua2V5cyhwcm9wcykgOiBwcm9wcztcclxuICBjb25zdCByZWFkID0gaXNPYmplY3QodmFsdWUpXHJcbiAgICA/IG9ialByb3BzXHJcbiAgICAgID8gcHJvcCA9PiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZVtwcm9wXSwgdmFsdWVbcHJvcHNbcHJvcF1dKVxyXG4gICAgICA6IHByb3AgPT4gdmFsdWVbcHJvcF1cclxuICAgIDogKCkgPT4gdmFsdWU7XHJcbiAgZm9yIChjb25zdCBwcm9wIG9mIGtleXMpIHtcclxuICAgIHJldFtwcm9wXSA9IG51bWJlck9yWmVybyhyZWFkKHByb3ApKTtcclxuICB9XHJcbiAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiB0b1RSQkwodmFsdWUpIHtcclxuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHt0b3A6ICd5JywgcmlnaHQ6ICd4JywgYm90dG9tOiAneScsIGxlZnQ6ICd4J30pO1xyXG59XHJcbmZ1bmN0aW9uIHRvVFJCTENvcm5lcnModmFsdWUpIHtcclxuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsndG9wTGVmdCcsICd0b3BSaWdodCcsICdib3R0b21MZWZ0JywgJ2JvdHRvbVJpZ2h0J10pO1xyXG59XHJcbmZ1bmN0aW9uIHRvUGFkZGluZyh2YWx1ZSkge1xyXG4gIGNvbnN0IG9iaiA9IHRvVFJCTCh2YWx1ZSk7XHJcbiAgb2JqLndpZHRoID0gb2JqLmxlZnQgKyBvYmoucmlnaHQ7XHJcbiAgb2JqLmhlaWdodCA9IG9iai50b3AgKyBvYmouYm90dG9tO1xyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuZnVuY3Rpb24gdG9Gb250KG9wdGlvbnMsIGZhbGxiYWNrKSB7XHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCBkZWZhdWx0cy5mb250O1xyXG4gIGxldCBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zaXplLCBmYWxsYmFjay5zaXplKTtcclxuICBpZiAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBzaXplID0gcGFyc2VJbnQoc2l6ZSwgMTApO1xyXG4gIH1cclxuICBsZXQgc3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnN0eWxlLCBmYWxsYmFjay5zdHlsZSk7XHJcbiAgaWYgKHN0eWxlICYmICEoJycgKyBzdHlsZSkubWF0Y2goRk9OVF9TVFlMRSkpIHtcclxuICAgIGNvbnNvbGUud2FybignSW52YWxpZCBmb250IHN0eWxlIHNwZWNpZmllZDogXCInICsgc3R5bGUgKyAnXCInKTtcclxuICAgIHN0eWxlID0gJyc7XHJcbiAgfVxyXG4gIGNvbnN0IGZvbnQgPSB7XHJcbiAgICBmYW1pbHk6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZmFtaWx5LCBmYWxsYmFjay5mYW1pbHkpLFxyXG4gICAgbGluZUhlaWdodDogdG9MaW5lSGVpZ2h0KHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubGluZUhlaWdodCwgZmFsbGJhY2subGluZUhlaWdodCksIHNpemUpLFxyXG4gICAgc2l6ZSxcclxuICAgIHN0eWxlLFxyXG4gICAgd2VpZ2h0OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLndlaWdodCwgZmFsbGJhY2sud2VpZ2h0KSxcclxuICAgIHN0cmluZzogJydcclxuICB9O1xyXG4gIGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xyXG4gIHJldHVybiBmb250O1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmUoaW5wdXRzLCBjb250ZXh0LCBpbmRleCwgaW5mbykge1xyXG4gIGxldCBjYWNoZWFibGUgPSB0cnVlO1xyXG4gIGxldCBpLCBpbGVuLCB2YWx1ZTtcclxuICBmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgdmFsdWUgPSBpbnB1dHNbaV07XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHZhbHVlID0gdmFsdWUoY29udGV4dCk7XHJcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgdmFsdWUgPSB2YWx1ZVtpbmRleCAlIHZhbHVlLmxlbmd0aF07XHJcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xyXG4gICAgICAgIGluZm8uY2FjaGVhYmxlID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBfYWRkR3JhY2UobWlubWF4LCBncmFjZSwgYmVnaW5BdFplcm8pIHtcclxuICBjb25zdCB7bWluLCBtYXh9ID0gbWlubWF4O1xyXG4gIGNvbnN0IGNoYW5nZSA9IHRvRGltZW5zaW9uKGdyYWNlLCAobWF4IC0gbWluKSAvIDIpO1xyXG4gIGNvbnN0IGtlZXBaZXJvID0gKHZhbHVlLCBhZGQpID0+IGJlZ2luQXRaZXJvICYmIHZhbHVlID09PSAwID8gMCA6IHZhbHVlICsgYWRkO1xyXG4gIHJldHVybiB7XHJcbiAgICBtaW46IGtlZXBaZXJvKG1pbiwgLU1hdGguYWJzKGNoYW5nZSkpLFxyXG4gICAgbWF4OiBrZWVwWmVybyhtYXgsIGNoYW5nZSlcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQocGFyZW50Q29udGV4dCwgY29udGV4dCkge1xyXG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50Q29udGV4dCksIGNvbnRleHQpO1xyXG59XHJcblxyXG5jb25zdCBnZXRSaWdodFRvTGVmdEFkYXB0ZXIgPSBmdW5jdGlvbihyZWN0WCwgd2lkdGgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgeCh4KSB7XHJcbiAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xyXG4gICAgfSxcclxuICAgIHNldFdpZHRoKHcpIHtcclxuICAgICAgd2lkdGggPSB3O1xyXG4gICAgfSxcclxuICAgIHRleHRBbGlnbihhbGlnbikge1xyXG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIGFsaWduO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XHJcbiAgICB9LFxyXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHggLSB2YWx1ZTtcclxuICAgIH0sXHJcbiAgICBsZWZ0Rm9yTHRyKHgsIGl0ZW1XaWR0aCkge1xyXG4gICAgICByZXR1cm4geCAtIGl0ZW1XaWR0aDtcclxuICAgIH0sXHJcbiAgfTtcclxufTtcclxuY29uc3QgZ2V0TGVmdFRvUmlnaHRBZGFwdGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHgoeCkge1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH0sXHJcbiAgICBzZXRXaWR0aCh3KSB7XHJcbiAgICB9LFxyXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XHJcbiAgICAgIHJldHVybiBhbGlnbjtcclxuICAgIH0sXHJcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xyXG4gICAgICByZXR1cm4geCArIHZhbHVlO1xyXG4gICAgfSxcclxuICAgIGxlZnRGb3JMdHIoeCwgX2l0ZW1XaWR0aCkge1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH0sXHJcbiAgfTtcclxufTtcclxuZnVuY3Rpb24gZ2V0UnRsQWRhcHRlcihydGwsIHJlY3RYLCB3aWR0aCkge1xyXG4gIHJldHVybiBydGwgPyBnZXRSaWdodFRvTGVmdEFkYXB0ZXIocmVjdFgsIHdpZHRoKSA6IGdldExlZnRUb1JpZ2h0QWRhcHRlcigpO1xyXG59XHJcbmZ1bmN0aW9uIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIGRpcmVjdGlvbikge1xyXG4gIGxldCBzdHlsZSwgb3JpZ2luYWw7XHJcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicgfHwgZGlyZWN0aW9uID09PSAncnRsJykge1xyXG4gICAgc3R5bGUgPSBjdHguY2FudmFzLnN0eWxlO1xyXG4gICAgb3JpZ2luYWwgPSBbXHJcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpLFxyXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KCdkaXJlY3Rpb24nKSxcclxuICAgIF07XHJcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XHJcbiAgICBjdHgucHJldlRleHREaXJlY3Rpb24gPSBvcmlnaW5hbDtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcmlnaW5hbCkge1xyXG4gIGlmIChvcmlnaW5hbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBkZWxldGUgY3R4LnByZXZUZXh0RGlyZWN0aW9uO1xyXG4gICAgY3R4LmNhbnZhcy5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgb3JpZ2luYWxbMF0sIG9yaWdpbmFsWzFdKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb3BlcnR5Rm4ocHJvcGVydHkpIHtcclxuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGJldHdlZW46IF9hbmdsZUJldHdlZW4sXHJcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXHJcbiAgICAgIG5vcm1hbGl6ZTogX25vcm1hbGl6ZUFuZ2xlLFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIGJldHdlZW46IF9pc0JldHdlZW4sXHJcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXHJcbiAgICBub3JtYWxpemU6IHggPT4geFxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplU2VnbWVudCh7c3RhcnQsIGVuZCwgY291bnQsIGxvb3AsIHN0eWxlfSkge1xyXG4gIHJldHVybiB7XHJcbiAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcclxuICAgIGVuZDogZW5kICUgY291bnQsXHJcbiAgICBsb29wOiBsb29wICYmIChlbmQgLSBzdGFydCArIDEpICUgY291bnQgPT09IDAsXHJcbiAgICBzdHlsZVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xyXG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xyXG4gIGNvbnN0IHtiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XHJcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xyXG4gIGxldCB7c3RhcnQsIGVuZCwgbG9vcH0gPSBzZWdtZW50O1xyXG4gIGxldCBpLCBpbGVuO1xyXG4gIGlmIChsb29wKSB7XHJcbiAgICBzdGFydCArPSBjb3VudDtcclxuICAgIGVuZCArPSBjb3VudDtcclxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICBpZiAoIWJldHdlZW4obm9ybWFsaXplKHBvaW50c1tzdGFydCAlIGNvdW50XVtwcm9wZXJ0eV0pLCBzdGFydEJvdW5kLCBlbmRCb3VuZCkpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBzdGFydC0tO1xyXG4gICAgICBlbmQtLTtcclxuICAgIH1cclxuICAgIHN0YXJ0ICU9IGNvdW50O1xyXG4gICAgZW5kICU9IGNvdW50O1xyXG4gIH1cclxuICBpZiAoZW5kIDwgc3RhcnQpIHtcclxuICAgIGVuZCArPSBjb3VudDtcclxuICB9XHJcbiAgcmV0dXJuIHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZTogc2VnbWVudC5zdHlsZX07XHJcbn1cclxuZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xyXG4gIGlmICghYm91bmRzKSB7XHJcbiAgICByZXR1cm4gW3NlZ21lbnRdO1xyXG4gIH1cclxuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcclxuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XHJcbiAgY29uc3Qge2NvbXBhcmUsIGJldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcclxuICBjb25zdCB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGV9ID0gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcyk7XHJcbiAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgbGV0IGluc2lkZSA9IGZhbHNlO1xyXG4gIGxldCBzdWJTdGFydCA9IG51bGw7XHJcbiAgbGV0IHZhbHVlLCBwb2ludCwgcHJldlZhbHVlO1xyXG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcclxuICBjb25zdCBlbmRJc0JlZm9yZSA9ICgpID0+IGNvbXBhcmUoZW5kQm91bmQsIHZhbHVlKSA9PT0gMCB8fCBiZXR3ZWVuKGVuZEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKTtcclxuICBjb25zdCBzaG91bGRTdGFydCA9ICgpID0+IGluc2lkZSB8fCBzdGFydElzQmVmb3JlKCk7XHJcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcclxuICBmb3IgKGxldCBpID0gc3RhcnQsIHByZXYgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xyXG4gICAgcG9pbnQgPSBwb2ludHNbaSAlIGNvdW50XTtcclxuICAgIGlmIChwb2ludC5za2lwKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcclxuICAgIGlmICh2YWx1ZSA9PT0gcHJldlZhbHVlKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgaW5zaWRlID0gYmV0d2Vlbih2YWx1ZSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpO1xyXG4gICAgaWYgKHN1YlN0YXJ0ID09PSBudWxsICYmIHNob3VsZFN0YXJ0KCkpIHtcclxuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xyXG4gICAgfVxyXG4gICAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsICYmIHNob3VsZFN0b3AoKSkge1xyXG4gICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZDogaSwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xyXG4gICAgICBzdWJTdGFydCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBwcmV2ID0gaTtcclxuICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xyXG4gIH1cclxuICBpZiAoc3ViU3RhcnQgIT09IG51bGwpIHtcclxuICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gX2JvdW5kU2VnbWVudHMobGluZSwgYm91bmRzKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xyXG4gICAgaWYgKHN1Yi5sZW5ndGgpIHtcclxuICAgICAgcmVzdWx0LnB1c2goLi4uc3ViKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpIHtcclxuICBsZXQgc3RhcnQgPSAwO1xyXG4gIGxldCBlbmQgPSBjb3VudCAtIDE7XHJcbiAgaWYgKGxvb3AgJiYgIXNwYW5HYXBzKSB7XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiAhcG9pbnRzW3N0YXJ0XS5za2lwKSB7XHJcbiAgICAgIHN0YXJ0Kys7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xyXG4gICAgc3RhcnQrKztcclxuICB9XHJcbiAgc3RhcnQgJT0gY291bnQ7XHJcbiAgaWYgKGxvb3ApIHtcclxuICAgIGVuZCArPSBzdGFydDtcclxuICB9XHJcbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHBvaW50c1tlbmQgJSBjb3VudF0uc2tpcCkge1xyXG4gICAgZW5kLS07XHJcbiAgfVxyXG4gIGVuZCAlPSBjb3VudDtcclxuICByZXR1cm4ge3N0YXJ0LCBlbmR9O1xyXG59XHJcbmZ1bmN0aW9uIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBsb29wKSB7XHJcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xyXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gIGxldCBsYXN0ID0gc3RhcnQ7XHJcbiAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnRdO1xyXG4gIGxldCBlbmQ7XHJcbiAgZm9yIChlbmQgPSBzdGFydCArIDE7IGVuZCA8PSBtYXg7ICsrZW5kKSB7XHJcbiAgICBjb25zdCBjdXIgPSBwb2ludHNbZW5kICUgY291bnRdO1xyXG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XHJcbiAgICAgIGlmICghcHJldi5za2lwKSB7XHJcbiAgICAgICAgbG9vcCA9IGZhbHNlO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xyXG4gICAgICAgIHN0YXJ0ID0gbGFzdCA9IGN1ci5zdG9wID8gZW5kIDogbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGFzdCA9IGVuZDtcclxuICAgICAgaWYgKHByZXYuc2tpcCkge1xyXG4gICAgICAgIHN0YXJ0ID0gZW5kO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwcmV2ID0gY3VyO1xyXG4gIH1cclxuICBpZiAobGFzdCAhPT0gbnVsbCkge1xyXG4gICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IGxhc3QgJSBjb3VudCwgbG9vcH0pO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIF9jb21wdXRlU2VnbWVudHMobGluZSwgc2VnbWVudE9wdGlvbnMpIHtcclxuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcclxuICBjb25zdCBzcGFuR2FwcyA9IGxpbmUub3B0aW9ucy5zcGFuR2FwcztcclxuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XHJcbiAgaWYgKCFjb3VudCkge1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICBjb25zdCBsb29wID0gISFsaW5lLl9sb29wO1xyXG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XHJcbiAgaWYgKHNwYW5HYXBzID09PSB0cnVlKSB7XHJcbiAgICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBbe3N0YXJ0LCBlbmQsIGxvb3B9XSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XHJcbiAgfVxyXG4gIGNvbnN0IG1heCA9IGVuZCA8IHN0YXJ0ID8gZW5kICsgY291bnQgOiBlbmQ7XHJcbiAgY29uc3QgY29tcGxldGVMb29wID0gISFsaW5lLl9mdWxsTG9vcCAmJiBzdGFydCA9PT0gMCAmJiBlbmQgPT09IGNvdW50IC0gMTtcclxuICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgY29tcGxldGVMb29wKSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gc3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xyXG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xyXG4gICAgcmV0dXJuIHNlZ21lbnRzO1xyXG4gIH1cclxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcclxuICBjb25zdCBjaGFydENvbnRleHQgPSBsaW5lLl9jaGFydC5nZXRDb250ZXh0KCk7XHJcbiAgY29uc3QgYmFzZVN0eWxlID0gcmVhZFN0eWxlKGxpbmUub3B0aW9ucyk7XHJcbiAgY29uc3Qge19kYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCwgb3B0aW9uczoge3NwYW5HYXBzfX0gPSBsaW5lO1xyXG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcclxuICBjb25zdCByZXN1bHQgPSBbXTtcclxuICBsZXQgcHJldlN0eWxlID0gYmFzZVN0eWxlO1xyXG4gIGxldCBzdGFydCA9IHNlZ21lbnRzWzBdLnN0YXJ0O1xyXG4gIGxldCBpID0gc3RhcnQ7XHJcbiAgZnVuY3Rpb24gYWRkU3R5bGUocywgZSwgbCwgc3QpIHtcclxuICAgIGNvbnN0IGRpciA9IHNwYW5HYXBzID8gLTEgOiAxO1xyXG4gICAgaWYgKHMgPT09IGUpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcyArPSBjb3VudDtcclxuICAgIHdoaWxlIChwb2ludHNbcyAlIGNvdW50XS5za2lwKSB7XHJcbiAgICAgIHMgLT0gZGlyO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKHBvaW50c1tlICUgY291bnRdLnNraXApIHtcclxuICAgICAgZSArPSBkaXI7XHJcbiAgICB9XHJcbiAgICBpZiAocyAlIGNvdW50ICE9PSBlICUgY291bnQpIHtcclxuICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzICUgY291bnQsIGVuZDogZSAlIGNvdW50LCBsb29wOiBsLCBzdHlsZTogc3R9KTtcclxuICAgICAgcHJldlN0eWxlID0gc3Q7XHJcbiAgICAgIHN0YXJ0ID0gZSAlIGNvdW50O1xyXG4gICAgfVxyXG4gIH1cclxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcclxuICAgIHN0YXJ0ID0gc3BhbkdhcHMgPyBzdGFydCA6IHNlZ21lbnQuc3RhcnQ7XHJcbiAgICBsZXQgcHJldiA9IHBvaW50c1tzdGFydCAlIGNvdW50XTtcclxuICAgIGxldCBzdHlsZTtcclxuICAgIGZvciAoaSA9IHN0YXJ0ICsgMTsgaSA8PSBzZWdtZW50LmVuZDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHB0ID0gcG9pbnRzW2kgJSBjb3VudF07XHJcbiAgICAgIHN0eWxlID0gcmVhZFN0eWxlKHNlZ21lbnRPcHRpb25zLnNldENvbnRleHQoY3JlYXRlQ29udGV4dChjaGFydENvbnRleHQsIHtcclxuICAgICAgICB0eXBlOiAnc2VnbWVudCcsXHJcbiAgICAgICAgcDA6IHByZXYsXHJcbiAgICAgICAgcDE6IHB0LFxyXG4gICAgICAgIHAwRGF0YUluZGV4OiAoaSAtIDEpICUgY291bnQsXHJcbiAgICAgICAgcDFEYXRhSW5kZXg6IGkgJSBjb3VudCxcclxuICAgICAgICBkYXRhc2V0SW5kZXhcclxuICAgICAgfSkpKTtcclxuICAgICAgaWYgKHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSkge1xyXG4gICAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHByZXYgPSBwdDtcclxuICAgICAgcHJldlN0eWxlID0gc3R5bGU7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhcnQgPCBpIC0gMSkge1xyXG4gICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiByZWFkU3R5bGUob3B0aW9ucykge1xyXG4gIHJldHVybiB7XHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgYm9yZGVyQ2FwU3R5bGU6IG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUsXHJcbiAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXHJcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXHJcbiAgICBib3JkZXJKb2luU3R5bGU6IG9wdGlvbnMuYm9yZGVySm9pblN0eWxlLFxyXG4gICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXHJcbiAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvclxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpIHtcclxuICByZXR1cm4gcHJldlN0eWxlICYmIEpTT04uc3RyaW5naWZ5KHN0eWxlKSAhPT0gSlNPTi5zdHJpbmdpZnkocHJldlN0eWxlKTtcclxufVxyXG5cclxudmFyIGhlbHBlcnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbl9fcHJvdG9fXzogbnVsbCxcclxuZWFzaW5nRWZmZWN0czogZWZmZWN0cyxcclxuaXNQYXR0ZXJuT3JHcmFkaWVudDogaXNQYXR0ZXJuT3JHcmFkaWVudCxcclxuY29sb3I6IGNvbG9yLFxyXG5nZXRIb3ZlckNvbG9yOiBnZXRIb3ZlckNvbG9yLFxyXG5ub29wOiBub29wLFxyXG51aWQ6IHVpZCxcclxuaXNOdWxsT3JVbmRlZjogaXNOdWxsT3JVbmRlZixcclxuaXNBcnJheTogaXNBcnJheSxcclxuaXNPYmplY3Q6IGlzT2JqZWN0LFxyXG5pc0Zpbml0ZTogaXNOdW1iZXJGaW5pdGUsXHJcbmZpbml0ZU9yRGVmYXVsdDogZmluaXRlT3JEZWZhdWx0LFxyXG52YWx1ZU9yRGVmYXVsdDogdmFsdWVPckRlZmF1bHQsXHJcbnRvUGVyY2VudGFnZTogdG9QZXJjZW50YWdlLFxyXG50b0RpbWVuc2lvbjogdG9EaW1lbnNpb24sXHJcbmNhbGxiYWNrOiBjYWxsYmFjayxcclxuZWFjaDogZWFjaCxcclxuX2VsZW1lbnRzRXF1YWw6IF9lbGVtZW50c0VxdWFsLFxyXG5jbG9uZTogY2xvbmUsXHJcbl9tZXJnZXI6IF9tZXJnZXIsXHJcbm1lcmdlOiBtZXJnZSxcclxubWVyZ2VJZjogbWVyZ2VJZixcclxuX21lcmdlcklmOiBfbWVyZ2VySWYsXHJcbl9kZXByZWNhdGVkOiBfZGVwcmVjYXRlZCxcclxucmVzb2x2ZU9iamVjdEtleTogcmVzb2x2ZU9iamVjdEtleSxcclxuX2NhcGl0YWxpemU6IF9jYXBpdGFsaXplLFxyXG5kZWZpbmVkOiBkZWZpbmVkLFxyXG5pc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxyXG5zZXRzRXF1YWw6IHNldHNFcXVhbCxcclxuX2lzQ2xpY2tFdmVudDogX2lzQ2xpY2tFdmVudCxcclxudG9Gb250U3RyaW5nOiB0b0ZvbnRTdHJpbmcsXHJcbl9tZWFzdXJlVGV4dDogX21lYXN1cmVUZXh0LFxyXG5fbG9uZ2VzdFRleHQ6IF9sb25nZXN0VGV4dCxcclxuX2FsaWduUGl4ZWw6IF9hbGlnblBpeGVsLFxyXG5jbGVhckNhbnZhczogY2xlYXJDYW52YXMsXHJcbmRyYXdQb2ludDogZHJhd1BvaW50LFxyXG5faXNQb2ludEluQXJlYTogX2lzUG9pbnRJbkFyZWEsXHJcbmNsaXBBcmVhOiBjbGlwQXJlYSxcclxudW5jbGlwQXJlYTogdW5jbGlwQXJlYSxcclxuX3N0ZXBwZWRMaW5lVG86IF9zdGVwcGVkTGluZVRvLFxyXG5fYmV6aWVyQ3VydmVUbzogX2JlemllckN1cnZlVG8sXHJcbnJlbmRlclRleHQ6IHJlbmRlclRleHQsXHJcbmFkZFJvdW5kZWRSZWN0UGF0aDogYWRkUm91bmRlZFJlY3RQYXRoLFxyXG5fbG9va3VwOiBfbG9va3VwLFxyXG5fbG9va3VwQnlLZXk6IF9sb29rdXBCeUtleSxcclxuX3Jsb29rdXBCeUtleTogX3Jsb29rdXBCeUtleSxcclxuX2ZpbHRlckJldHdlZW46IF9maWx0ZXJCZXR3ZWVuLFxyXG5saXN0ZW5BcnJheUV2ZW50czogbGlzdGVuQXJyYXlFdmVudHMsXHJcbnVubGlzdGVuQXJyYXlFdmVudHM6IHVubGlzdGVuQXJyYXlFdmVudHMsXHJcbl9hcnJheVVuaXF1ZTogX2FycmF5VW5pcXVlLFxyXG5fY3JlYXRlUmVzb2x2ZXI6IF9jcmVhdGVSZXNvbHZlcixcclxuX2F0dGFjaENvbnRleHQ6IF9hdHRhY2hDb250ZXh0LFxyXG5fZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyxcclxuX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlOiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUsXHJcbnNwbGluZUN1cnZlOiBzcGxpbmVDdXJ2ZSxcclxuc3BsaW5lQ3VydmVNb25vdG9uZTogc3BsaW5lQ3VydmVNb25vdG9uZSxcclxuX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHM6IF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzLFxyXG5faXNEb21TdXBwb3J0ZWQ6IF9pc0RvbVN1cHBvcnRlZCxcclxuX2dldFBhcmVudE5vZGU6IF9nZXRQYXJlbnROb2RlLFxyXG5nZXRTdHlsZTogZ2V0U3R5bGUsXHJcbmdldFJlbGF0aXZlUG9zaXRpb246IGdldFJlbGF0aXZlUG9zaXRpb24sXHJcbmdldE1heGltdW1TaXplOiBnZXRNYXhpbXVtU2l6ZSxcclxucmV0aW5hU2NhbGU6IHJldGluYVNjYWxlLFxyXG5zdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zOiBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zLFxyXG5yZWFkVXNlZFNpemU6IHJlYWRVc2VkU2l6ZSxcclxuZm9udFN0cmluZzogZm9udFN0cmluZyxcclxucmVxdWVzdEFuaW1GcmFtZTogcmVxdWVzdEFuaW1GcmFtZSxcclxudGhyb3R0bGVkOiB0aHJvdHRsZWQsXHJcbmRlYm91bmNlOiBkZWJvdW5jZSxcclxuX3RvTGVmdFJpZ2h0Q2VudGVyOiBfdG9MZWZ0UmlnaHRDZW50ZXIsXHJcbl9hbGlnblN0YXJ0RW5kOiBfYWxpZ25TdGFydEVuZCxcclxuX3RleHRYOiBfdGV4dFgsXHJcbl9wb2ludEluTGluZTogX3BvaW50SW5MaW5lLFxyXG5fc3RlcHBlZEludGVycG9sYXRpb246IF9zdGVwcGVkSW50ZXJwb2xhdGlvbixcclxuX2JlemllckludGVycG9sYXRpb246IF9iZXppZXJJbnRlcnBvbGF0aW9uLFxyXG5mb3JtYXROdW1iZXI6IGZvcm1hdE51bWJlcixcclxudG9MaW5lSGVpZ2h0OiB0b0xpbmVIZWlnaHQsXHJcbl9yZWFkVmFsdWVUb1Byb3BzOiBfcmVhZFZhbHVlVG9Qcm9wcyxcclxudG9UUkJMOiB0b1RSQkwsXHJcbnRvVFJCTENvcm5lcnM6IHRvVFJCTENvcm5lcnMsXHJcbnRvUGFkZGluZzogdG9QYWRkaW5nLFxyXG50b0ZvbnQ6IHRvRm9udCxcclxucmVzb2x2ZTogcmVzb2x2ZSxcclxuX2FkZEdyYWNlOiBfYWRkR3JhY2UsXHJcbmNyZWF0ZUNvbnRleHQ6IGNyZWF0ZUNvbnRleHQsXHJcblBJOiBQSSxcclxuVEFVOiBUQVUsXHJcblBJVEFVOiBQSVRBVSxcclxuSU5GSU5JVFk6IElORklOSVRZLFxyXG5SQURfUEVSX0RFRzogUkFEX1BFUl9ERUcsXHJcbkhBTEZfUEk6IEhBTEZfUEksXHJcblFVQVJURVJfUEk6IFFVQVJURVJfUEksXHJcblRXT19USElSRFNfUEk6IFRXT19USElSRFNfUEksXHJcbmxvZzEwOiBsb2cxMCxcclxuc2lnbjogc2lnbixcclxubmljZU51bTogbmljZU51bSxcclxuX2ZhY3Rvcml6ZTogX2ZhY3Rvcml6ZSxcclxuaXNOdW1iZXI6IGlzTnVtYmVyLFxyXG5hbG1vc3RFcXVhbHM6IGFsbW9zdEVxdWFscyxcclxuYWxtb3N0V2hvbGU6IGFsbW9zdFdob2xlLFxyXG5fc2V0TWluQW5kTWF4QnlLZXk6IF9zZXRNaW5BbmRNYXhCeUtleSxcclxudG9SYWRpYW5zOiB0b1JhZGlhbnMsXHJcbnRvRGVncmVlczogdG9EZWdyZWVzLFxyXG5fZGVjaW1hbFBsYWNlczogX2RlY2ltYWxQbGFjZXMsXHJcbmdldEFuZ2xlRnJvbVBvaW50OiBnZXRBbmdsZUZyb21Qb2ludCxcclxuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzOiBkaXN0YW5jZUJldHdlZW5Qb2ludHMsXHJcbl9hbmdsZURpZmY6IF9hbmdsZURpZmYsXHJcbl9ub3JtYWxpemVBbmdsZTogX25vcm1hbGl6ZUFuZ2xlLFxyXG5fYW5nbGVCZXR3ZWVuOiBfYW5nbGVCZXR3ZWVuLFxyXG5fbGltaXRWYWx1ZTogX2xpbWl0VmFsdWUsXHJcbl9pbnQxNlJhbmdlOiBfaW50MTZSYW5nZSxcclxuX2lzQmV0d2VlbjogX2lzQmV0d2VlbixcclxuZ2V0UnRsQWRhcHRlcjogZ2V0UnRsQWRhcHRlcixcclxub3ZlcnJpZGVUZXh0RGlyZWN0aW9uOiBvdmVycmlkZVRleHREaXJlY3Rpb24sXHJcbnJlc3RvcmVUZXh0RGlyZWN0aW9uOiByZXN0b3JlVGV4dERpcmVjdGlvbixcclxuX2JvdW5kU2VnbWVudDogX2JvdW5kU2VnbWVudCxcclxuX2JvdW5kU2VnbWVudHM6IF9ib3VuZFNlZ21lbnRzLFxyXG5fY29tcHV0ZVNlZ21lbnRzOiBfY29tcHV0ZVNlZ21lbnRzXHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKG1ldGFzZXQsIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpIHtcclxuICBjb25zdCB7Y29udHJvbGxlciwgZGF0YSwgX3NvcnRlZH0gPSBtZXRhc2V0O1xyXG4gIGNvbnN0IGlTY2FsZSA9IGNvbnRyb2xsZXIuX2NhY2hlZE1ldGEuaVNjYWxlO1xyXG4gIGlmIChpU2NhbGUgJiYgYXhpcyA9PT0gaVNjYWxlLmF4aXMgJiYgYXhpcyAhPT0gJ3InICYmIF9zb3J0ZWQgJiYgZGF0YS5sZW5ndGgpIHtcclxuICAgIGNvbnN0IGxvb2t1cE1ldGhvZCA9IGlTY2FsZS5fcmV2ZXJzZVBpeGVscyA/IF9ybG9va3VwQnlLZXkgOiBfbG9va3VwQnlLZXk7XHJcbiAgICBpZiAoIWludGVyc2VjdCkge1xyXG4gICAgICByZXR1cm4gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlKTtcclxuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlci5fc2hhcmVkT3B0aW9ucykge1xyXG4gICAgICBjb25zdCBlbCA9IGRhdGFbMF07XHJcbiAgICAgIGNvbnN0IHJhbmdlID0gdHlwZW9mIGVsLmdldFJhbmdlID09PSAnZnVuY3Rpb24nICYmIGVsLmdldFJhbmdlKGF4aXMpO1xyXG4gICAgICBpZiAocmFuZ2UpIHtcclxuICAgICAgICBjb25zdCBzdGFydCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSAtIHJhbmdlKTtcclxuICAgICAgICBjb25zdCBlbmQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgKyByYW5nZSk7XHJcbiAgICAgICAgcmV0dXJuIHtsbzogc3RhcnQubG8sIGhpOiBlbmQuaGl9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB7bG86IDAsIGhpOiBkYXRhLmxlbmd0aCAtIDF9O1xyXG59XHJcbmZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGhhbmRsZXIsIGludGVyc2VjdCkge1xyXG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xyXG4gIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bYXhpc107XHJcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuICAgIGNvbnN0IHtpbmRleCwgZGF0YX0gPSBtZXRhc2V0c1tpXTtcclxuICAgIGNvbnN0IHtsbywgaGl9ID0gYmluYXJ5U2VhcmNoKG1ldGFzZXRzW2ldLCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KTtcclxuICAgIGZvciAobGV0IGogPSBsbzsgaiA8PSBoaTsgKytqKSB7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkYXRhW2pdO1xyXG4gICAgICBpZiAoIWVsZW1lbnQuc2tpcCkge1xyXG4gICAgICAgIGhhbmRsZXIoZWxlbWVudCwgaW5kZXgsIGopO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XHJcbiAgY29uc3QgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcclxuICBjb25zdCB1c2VZID0gYXhpcy5pbmRleE9mKCd5JykgIT09IC0xO1xyXG4gIHJldHVybiBmdW5jdGlvbihwdDEsIHB0Mikge1xyXG4gICAgY29uc3QgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcclxuICAgIGNvbnN0IGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xyXG4gIGNvbnN0IGl0ZW1zID0gW107XHJcbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG4gIH1cclxuICBjb25zdCBldmFsdWF0aW9uRnVuYyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcclxuICAgIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhX2lzUG9pbnRJbkFyZWEoZWxlbWVudCwgY2hhcnQuY2hhcnRBcmVhLCAwKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XHJcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcclxuICAgIH1cclxuICB9O1xyXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jLCB0cnVlKTtcclxuICByZXR1cm4gaXRlbXM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xyXG4gIGxldCBpdGVtcyA9IFtdO1xyXG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcclxuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZX0gPSBlbGVtZW50LmdldFByb3BzKFsnc3RhcnRBbmdsZScsICdlbmRBbmdsZSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcclxuICAgIGNvbnN0IHthbmdsZX0gPSBnZXRBbmdsZUZyb21Qb2ludChlbGVtZW50LCB7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueX0pO1xyXG4gICAgaWYgKF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xyXG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcclxuICByZXR1cm4gaXRlbXM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XHJcbiAgbGV0IGl0ZW1zID0gW107XHJcbiAgY29uc3QgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcyk7XHJcbiAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcclxuICAgIGNvbnN0IGluUmFuZ2UgPSBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XHJcbiAgICBpZiAoaW50ZXJzZWN0ICYmICFpblJhbmdlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XHJcbiAgICBjb25zdCBwb2ludEluQXJlYSA9ICEhaW5jbHVkZUludmlzaWJsZSB8fCBjaGFydC5pc1BvaW50SW5BcmVhKGNlbnRlcik7XHJcbiAgICBpZiAoIXBvaW50SW5BcmVhICYmICFpblJhbmdlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XHJcbiAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xyXG4gICAgICBpdGVtcyA9IFt7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH1dO1xyXG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcclxuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XHJcbiAgcmV0dXJuIGl0ZW1zO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xyXG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbiAgcmV0dXJuIGF4aXMgPT09ICdyJyAmJiAhaW50ZXJzZWN0XHJcbiAgICA/IGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pXHJcbiAgICA6IGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKSB7XHJcbiAgY29uc3QgaXRlbXMgPSBbXTtcclxuICBjb25zdCByYW5nZU1ldGhvZCA9IGF4aXMgPT09ICd4JyA/ICdpblhSYW5nZScgOiAnaW5ZUmFuZ2UnO1xyXG4gIGxldCBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xyXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIChlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSA9PiB7XHJcbiAgICBpZiAoZWxlbWVudFtyYW5nZU1ldGhvZF0ocG9zaXRpb25bYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pKSB7XHJcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcclxuICAgICAgaW50ZXJzZWN0c0l0ZW0gPSBpbnRlcnNlY3RzSXRlbSB8fCBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgaWYgKGludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbiAgcmV0dXJuIGl0ZW1zO1xyXG59XHJcbnZhciBJbnRlcmFjdGlvbiA9IHtcclxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMsXHJcbiAgbW9kZXM6IHtcclxuICAgIGluZGV4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XHJcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XHJcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3gnO1xyXG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xyXG4gICAgICBjb25zdCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XHJcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpXHJcbiAgICAgICAgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XHJcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICAgIGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKChtZXRhKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBpdGVtc1swXS5pbmRleDtcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gbWV0YS5kYXRhW2luZGV4XTtcclxuICAgICAgICBpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5za2lwKSB7XHJcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXgsIGluZGV4fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xyXG4gICAgfSxcclxuICAgIGRhdGFzZXQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcclxuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xyXG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xyXG4gICAgICBsZXQgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxyXG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSA6XHJcbiAgICAgICAgZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xyXG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGFzZXRJbmRleCA9IGl0ZW1zWzBdLmRhdGFzZXRJbmRleDtcclxuICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5kYXRhO1xyXG4gICAgICAgIGl0ZW1zID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICBpdGVtcy5wdXNoKHtlbGVtZW50OiBkYXRhW2ldLCBkYXRhc2V0SW5kZXgsIGluZGV4OiBpfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpdGVtcztcclxuICAgIH0sXHJcbiAgICBwb2ludChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xyXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xyXG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XHJcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XHJcbiAgICAgIHJldHVybiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xyXG4gICAgfSxcclxuICAgIG5lYXJlc3QoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcclxuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xyXG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xyXG4gICAgICByZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xyXG4gICAgfSxcclxuICAgIHgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcclxuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd4Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xyXG4gICAgfSxcclxuICAgIHkoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcclxuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcclxuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd5Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IFNUQVRJQ19QT1NJVElPTlMgPSBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xyXG5mdW5jdGlvbiBmaWx0ZXJCeVBvc2l0aW9uKGFycmF5LCBwb3NpdGlvbikge1xyXG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiB2LnBvcyA9PT0gcG9zaXRpb24pO1xyXG59XHJcbmZ1bmN0aW9uIGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhhcnJheSwgYXhpcykge1xyXG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiBTVEFUSUNfUE9TSVRJT05TLmluZGV4T2Yodi5wb3MpID09PSAtMSAmJiB2LmJveC5heGlzID09PSBheGlzKTtcclxufVxyXG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcclxuICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgY29uc3QgdjAgPSByZXZlcnNlID8gYiA6IGE7XHJcbiAgICBjb25zdCB2MSA9IHJldmVyc2UgPyBhIDogYjtcclxuICAgIHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XHJcbiAgICAgIHYwLmluZGV4IC0gdjEuaW5kZXggOlxyXG4gICAgICB2MC53ZWlnaHQgLSB2MS53ZWlnaHQ7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gd3JhcEJveGVzKGJveGVzKSB7XHJcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSBbXTtcclxuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcclxuICBmb3IgKGkgPSAwLCBpbGVuID0gKGJveGVzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuICAgIGJveCA9IGJveGVzW2ldO1xyXG4gICAgKHtwb3NpdGlvbjogcG9zLCBvcHRpb25zOiB7c3RhY2ssIHN0YWNrV2VpZ2h0ID0gMX19ID0gYm94KTtcclxuICAgIGxheW91dEJveGVzLnB1c2goe1xyXG4gICAgICBpbmRleDogaSxcclxuICAgICAgYm94LFxyXG4gICAgICBwb3MsXHJcbiAgICAgIGhvcml6b250YWw6IGJveC5pc0hvcml6b250YWwoKSxcclxuICAgICAgd2VpZ2h0OiBib3gud2VpZ2h0LFxyXG4gICAgICBzdGFjazogc3RhY2sgJiYgKHBvcyArIHN0YWNrKSxcclxuICAgICAgc3RhY2tXZWlnaHRcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbGF5b3V0Qm94ZXM7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRTdGFja3MobGF5b3V0cykge1xyXG4gIGNvbnN0IHN0YWNrcyA9IHt9O1xyXG4gIGZvciAoY29uc3Qgd3JhcCBvZiBsYXlvdXRzKSB7XHJcbiAgICBjb25zdCB7c3RhY2ssIHBvcywgc3RhY2tXZWlnaHR9ID0gd3JhcDtcclxuICAgIGlmICghc3RhY2sgfHwgIVNUQVRJQ19QT1NJVElPTlMuaW5jbHVkZXMocG9zKSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IF9zdGFjayA9IHN0YWNrc1tzdGFja10gfHwgKHN0YWNrc1tzdGFja10gPSB7Y291bnQ6IDAsIHBsYWNlZDogMCwgd2VpZ2h0OiAwLCBzaXplOiAwfSk7XHJcbiAgICBfc3RhY2suY291bnQrKztcclxuICAgIF9zdGFjay53ZWlnaHQgKz0gc3RhY2tXZWlnaHQ7XHJcbiAgfVxyXG4gIHJldHVybiBzdGFja3M7XHJcbn1cclxuZnVuY3Rpb24gc2V0TGF5b3V0RGltcyhsYXlvdXRzLCBwYXJhbXMpIHtcclxuICBjb25zdCBzdGFja3MgPSBidWlsZFN0YWNrcyhsYXlvdXRzKTtcclxuICBjb25zdCB7dkJveE1heFdpZHRoLCBoQm94TWF4SGVpZ2h0fSA9IHBhcmFtcztcclxuICBsZXQgaSwgaWxlbiwgbGF5b3V0O1xyXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYXlvdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgbGF5b3V0ID0gbGF5b3V0c1tpXTtcclxuICAgIGNvbnN0IHtmdWxsU2l6ZX0gPSBsYXlvdXQuYm94O1xyXG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXTtcclxuICAgIGNvbnN0IGZhY3RvciA9IHN0YWNrICYmIGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodDtcclxuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xyXG4gICAgICBsYXlvdXQud2lkdGggPSBmYWN0b3IgPyBmYWN0b3IgKiB2Qm94TWF4V2lkdGggOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlV2lkdGg7XHJcbiAgICAgIGxheW91dC5oZWlnaHQgPSBoQm94TWF4SGVpZ2h0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGF5b3V0LndpZHRoID0gdkJveE1heFdpZHRoO1xyXG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gZmFjdG9yID8gZmFjdG9yICogaEJveE1heEhlaWdodCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVIZWlnaHQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBzdGFja3M7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRMYXlvdXRCb3hlcyhib3hlcykge1xyXG4gIGNvbnN0IGxheW91dEJveGVzID0gd3JhcEJveGVzKGJveGVzKTtcclxuICBjb25zdCBmdWxsU2l6ZSA9IHNvcnRCeVdlaWdodChsYXlvdXRCb3hlcy5maWx0ZXIod3JhcCA9PiB3cmFwLmJveC5mdWxsU2l6ZSksIHRydWUpO1xyXG4gIGNvbnN0IGxlZnQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2xlZnQnKSwgdHJ1ZSk7XHJcbiAgY29uc3QgcmlnaHQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3JpZ2h0JykpO1xyXG4gIGNvbnN0IHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xyXG4gIGNvbnN0IGJvdHRvbSA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnYm90dG9tJykpO1xyXG4gIGNvbnN0IGNlbnRlckhvcml6b250YWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd4Jyk7XHJcbiAgY29uc3QgY2VudGVyVmVydGljYWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd5Jyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGZ1bGxTaXplLFxyXG4gICAgbGVmdEFuZFRvcDogbGVmdC5jb25jYXQodG9wKSxcclxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcclxuICAgIGNoYXJ0QXJlYTogZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2NoYXJ0QXJlYScpLFxyXG4gICAgdmVydGljYWw6IGxlZnQuY29uY2F0KHJpZ2h0KS5jb25jYXQoY2VudGVyVmVydGljYWwpLFxyXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCBhLCBiKSB7XHJcbiAgcmV0dXJuIE1hdGgubWF4KG1heFBhZGRpbmdbYV0sIGNoYXJ0QXJlYVthXSkgKyBNYXRoLm1heChtYXhQYWRkaW5nW2JdLCBjaGFydEFyZWFbYl0pO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94UGFkZGluZykge1xyXG4gIG1heFBhZGRpbmcudG9wID0gTWF0aC5tYXgobWF4UGFkZGluZy50b3AsIGJveFBhZGRpbmcudG9wKTtcclxuICBtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XHJcbiAgbWF4UGFkZGluZy5ib3R0b20gPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xyXG4gIG1heFBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChtYXhQYWRkaW5nLnJpZ2h0LCBib3hQYWRkaW5nLnJpZ2h0KTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xyXG4gIGNvbnN0IHtwb3MsIGJveH0gPSBsYXlvdXQ7XHJcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xyXG4gIGlmICghaXNPYmplY3QocG9zKSkge1xyXG4gICAgaWYgKGxheW91dC5zaXplKSB7XHJcbiAgICAgIGNoYXJ0QXJlYVtwb3NdIC09IGxheW91dC5zaXplO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7c2l6ZTogMCwgY291bnQ6IDF9O1xyXG4gICAgc3RhY2suc2l6ZSA9IE1hdGgubWF4KHN0YWNrLnNpemUsIGxheW91dC5ob3Jpem9udGFsID8gYm94LmhlaWdodCA6IGJveC53aWR0aCk7XHJcbiAgICBsYXlvdXQuc2l6ZSA9IHN0YWNrLnNpemUgLyBzdGFjay5jb3VudDtcclxuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGxheW91dC5zaXplO1xyXG4gIH1cclxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcclxuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94LmdldFBhZGRpbmcoKSk7XHJcbiAgfVxyXG4gIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVyV2lkdGggLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICdsZWZ0JywgJ3JpZ2h0JykpO1xyXG4gIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKSk7XHJcbiAgY29uc3Qgd2lkdGhDaGFuZ2VkID0gbmV3V2lkdGggIT09IGNoYXJ0QXJlYS53O1xyXG4gIGNvbnN0IGhlaWdodENoYW5nZWQgPSBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oO1xyXG4gIGNoYXJ0QXJlYS53ID0gbmV3V2lkdGg7XHJcbiAgY2hhcnRBcmVhLmggPSBuZXdIZWlnaHQ7XHJcbiAgcmV0dXJuIGxheW91dC5ob3Jpem9udGFsXHJcbiAgICA/IHtzYW1lOiB3aWR0aENoYW5nZWQsIG90aGVyOiBoZWlnaHRDaGFuZ2VkfVxyXG4gICAgOiB7c2FtZTogaGVpZ2h0Q2hhbmdlZCwgb3RoZXI6IHdpZHRoQ2hhbmdlZH07XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpIHtcclxuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XHJcbiAgZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xyXG4gICAgY29uc3QgY2hhbmdlID0gTWF0aC5tYXgobWF4UGFkZGluZ1twb3NdIC0gY2hhcnRBcmVhW3Bvc10sIDApO1xyXG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gY2hhbmdlO1xyXG4gICAgcmV0dXJuIGNoYW5nZTtcclxuICB9XHJcbiAgY2hhcnRBcmVhLnkgKz0gdXBkYXRlUG9zKCd0b3AnKTtcclxuICBjaGFydEFyZWEueCArPSB1cGRhdGVQb3MoJ2xlZnQnKTtcclxuICB1cGRhdGVQb3MoJ3JpZ2h0Jyk7XHJcbiAgdXBkYXRlUG9zKCdib3R0b20nKTtcclxufVxyXG5mdW5jdGlvbiBnZXRNYXJnaW5zKGhvcml6b250YWwsIGNoYXJ0QXJlYSkge1xyXG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcclxuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XHJcbiAgICBjb25zdCBtYXJnaW4gPSB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfTtcclxuICAgIHBvc2l0aW9ucy5mb3JFYWNoKChwb3MpID0+IHtcclxuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG1hcmdpbjtcclxuICB9XHJcbiAgcmV0dXJuIGhvcml6b250YWxcclxuICAgID8gbWFyZ2luRm9yUG9zaXRpb25zKFsnbGVmdCcsICdyaWdodCddKVxyXG4gICAgOiBtYXJnaW5Gb3JQb3NpdGlvbnMoWyd0b3AnLCAnYm90dG9tJ10pO1xyXG59XHJcbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XHJcbiAgY29uc3QgcmVmaXRCb3hlcyA9IFtdO1xyXG4gIGxldCBpLCBpbGVuLCBsYXlvdXQsIGJveCwgcmVmaXQsIGNoYW5nZWQ7XHJcbiAgZm9yIChpID0gMCwgaWxlbiA9IGJveGVzLmxlbmd0aCwgcmVmaXQgPSAwOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcclxuICAgIGJveCA9IGxheW91dC5ib3g7XHJcbiAgICBib3gudXBkYXRlKFxyXG4gICAgICBsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsXHJcbiAgICAgIGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXHJcbiAgICAgIGdldE1hcmdpbnMobGF5b3V0Lmhvcml6b250YWwsIGNoYXJ0QXJlYSlcclxuICAgICk7XHJcbiAgICBjb25zdCB7c2FtZSwgb3RoZXJ9ID0gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpO1xyXG4gICAgcmVmaXQgfD0gc2FtZSAmJiByZWZpdEJveGVzLmxlbmd0aDtcclxuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xyXG4gICAgaWYgKCFib3guZnVsbFNpemUpIHtcclxuICAgICAgcmVmaXRCb3hlcy5wdXNoKGxheW91dCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZWZpdCAmJiBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB8fCBjaGFuZ2VkO1xyXG59XHJcbmZ1bmN0aW9uIHNldEJveERpbXMoYm94LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcclxuICBib3gudG9wID0gdG9wO1xyXG4gIGJveC5sZWZ0ID0gbGVmdDtcclxuICBib3gucmlnaHQgPSBsZWZ0ICsgd2lkdGg7XHJcbiAgYm94LmJvdHRvbSA9IHRvcCArIGhlaWdodDtcclxuICBib3gud2lkdGggPSB3aWR0aDtcclxuICBib3guaGVpZ2h0ID0gaGVpZ2h0O1xyXG59XHJcbmZ1bmN0aW9uIHBsYWNlQm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcclxuICBjb25zdCB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xyXG4gIGxldCB7eCwgeX0gPSBjaGFydEFyZWE7XHJcbiAgZm9yIChjb25zdCBsYXlvdXQgb2YgYm94ZXMpIHtcclxuICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XHJcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtjb3VudDogMSwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDF9O1xyXG4gICAgY29uc3Qgd2VpZ2h0ID0gKGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodCkgfHwgMTtcclxuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xyXG4gICAgICBjb25zdCB3aWR0aCA9IGNoYXJ0QXJlYS53ICogd2VpZ2h0O1xyXG4gICAgICBjb25zdCBoZWlnaHQgPSBzdGFjay5zaXplIHx8IGJveC5oZWlnaHQ7XHJcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xyXG4gICAgICAgIHkgPSBzdGFjay5zdGFydDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XHJcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHVzZXJQYWRkaW5nLmxlZnQsIHksIHBhcmFtcy5vdXRlcldpZHRoIC0gdXNlclBhZGRpbmcucmlnaHQgLSB1c2VyUGFkZGluZy5sZWZ0LCBoZWlnaHQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNldEJveERpbXMoYm94LCBjaGFydEFyZWEubGVmdCArIHN0YWNrLnBsYWNlZCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgICAgc3RhY2suc3RhcnQgPSB5O1xyXG4gICAgICBzdGFjay5wbGFjZWQgKz0gd2lkdGg7XHJcbiAgICAgIHkgPSBib3guYm90dG9tO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgaGVpZ2h0ID0gY2hhcnRBcmVhLmggKiB3ZWlnaHQ7XHJcbiAgICAgIGNvbnN0IHdpZHRoID0gc3RhY2suc2l6ZSB8fCBib3gud2lkdGg7XHJcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xyXG4gICAgICAgIHggPSBzdGFjay5zdGFydDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XHJcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIHVzZXJQYWRkaW5nLnRvcCwgd2lkdGgsIHBhcmFtcy5vdXRlckhlaWdodCAtIHVzZXJQYWRkaW5nLmJvdHRvbSAtIHVzZXJQYWRkaW5nLnRvcCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIGNoYXJ0QXJlYS50b3AgKyBzdGFjay5wbGFjZWQsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICB9XHJcbiAgICAgIHN0YWNrLnN0YXJ0ID0geDtcclxuICAgICAgc3RhY2sucGxhY2VkICs9IGhlaWdodDtcclxuICAgICAgeCA9IGJveC5yaWdodDtcclxuICAgIH1cclxuICB9XHJcbiAgY2hhcnRBcmVhLnggPSB4O1xyXG4gIGNoYXJ0QXJlYS55ID0geTtcclxufVxyXG5kZWZhdWx0cy5zZXQoJ2xheW91dCcsIHtcclxuICBhdXRvUGFkZGluZzogdHJ1ZSxcclxuICBwYWRkaW5nOiB7XHJcbiAgICB0b3A6IDAsXHJcbiAgICByaWdodDogMCxcclxuICAgIGJvdHRvbTogMCxcclxuICAgIGxlZnQ6IDBcclxuICB9XHJcbn0pO1xyXG52YXIgbGF5b3V0cyA9IHtcclxuICBhZGRCb3goY2hhcnQsIGl0ZW0pIHtcclxuICAgIGlmICghY2hhcnQuYm94ZXMpIHtcclxuICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xyXG4gICAgaXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XHJcbiAgICBpdGVtLndlaWdodCA9IGl0ZW0ud2VpZ2h0IHx8IDA7XHJcbiAgICBpdGVtLl9sYXllcnMgPSBpdGVtLl9sYXllcnMgfHwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBbe1xyXG4gICAgICAgIHo6IDAsXHJcbiAgICAgICAgZHJhdyhjaGFydEFyZWEpIHtcclxuICAgICAgICAgIGl0ZW0uZHJhdyhjaGFydEFyZWEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfV07XHJcbiAgICB9O1xyXG4gICAgY2hhcnQuYm94ZXMucHVzaChpdGVtKTtcclxuICB9LFxyXG4gIHJlbW92ZUJveChjaGFydCwgbGF5b3V0SXRlbSkge1xyXG4gICAgY29uc3QgaW5kZXggPSBjaGFydC5ib3hlcyA/IGNoYXJ0LmJveGVzLmluZGV4T2YobGF5b3V0SXRlbSkgOiAtMTtcclxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxuICB9LFxyXG4gIGNvbmZpZ3VyZShjaGFydCwgaXRlbSwgb3B0aW9ucykge1xyXG4gICAgaXRlbS5mdWxsU2l6ZSA9IG9wdGlvbnMuZnVsbFNpemU7XHJcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcclxuICAgIGl0ZW0ud2VpZ2h0ID0gb3B0aW9ucy53ZWlnaHQ7XHJcbiAgfSxcclxuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcclxuICAgIGlmICghY2hhcnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhjaGFydC5vcHRpb25zLmxheW91dC5wYWRkaW5nKTtcclxuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gTWF0aC5tYXgod2lkdGggLSBwYWRkaW5nLndpZHRoLCAwKTtcclxuICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0LCAwKTtcclxuICAgIGNvbnN0IGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XHJcbiAgICBjb25zdCB2ZXJ0aWNhbEJveGVzID0gYm94ZXMudmVydGljYWw7XHJcbiAgICBjb25zdCBob3Jpem9udGFsQm94ZXMgPSBib3hlcy5ob3Jpem9udGFsO1xyXG4gICAgZWFjaChjaGFydC5ib3hlcywgYm94ID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiBib3guYmVmb3JlTGF5b3V0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHZpc2libGVWZXJ0aWNhbEJveENvdW50ID0gdmVydGljYWxCb3hlcy5yZWR1Y2UoKHRvdGFsLCB3cmFwKSA9PlxyXG4gICAgICB3cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcclxuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICBvdXRlcldpZHRoOiB3aWR0aCxcclxuICAgICAgb3V0ZXJIZWlnaHQ6IGhlaWdodCxcclxuICAgICAgcGFkZGluZyxcclxuICAgICAgYXZhaWxhYmxlV2lkdGgsXHJcbiAgICAgIGF2YWlsYWJsZUhlaWdodCxcclxuICAgICAgdkJveE1heFdpZHRoOiBhdmFpbGFibGVXaWR0aCAvIDIgLyB2aXNpYmxlVmVydGljYWxCb3hDb3VudCxcclxuICAgICAgaEJveE1heEhlaWdodDogYXZhaWxhYmxlSGVpZ2h0IC8gMlxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgcGFkZGluZyk7XHJcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIHRvUGFkZGluZyhtaW5QYWRkaW5nKSk7XHJcbiAgICBjb25zdCBjaGFydEFyZWEgPSBPYmplY3QuYXNzaWduKHtcclxuICAgICAgbWF4UGFkZGluZyxcclxuICAgICAgdzogYXZhaWxhYmxlV2lkdGgsXHJcbiAgICAgIGg6IGF2YWlsYWJsZUhlaWdodCxcclxuICAgICAgeDogcGFkZGluZy5sZWZ0LFxyXG4gICAgICB5OiBwYWRkaW5nLnRvcFxyXG4gICAgfSwgcGFkZGluZyk7XHJcbiAgICBjb25zdCBzdGFja3MgPSBzZXRMYXlvdXREaW1zKHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyksIHBhcmFtcyk7XHJcbiAgICBmaXRCb3hlcyhib3hlcy5mdWxsU2l6ZSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XHJcbiAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcclxuICAgIGlmIChmaXRCb3hlcyhob3Jpem9udGFsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpKSB7XHJcbiAgICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xyXG4gICAgcGxhY2VCb3hlcyhib3hlcy5sZWZ0QW5kVG9wLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcclxuICAgIGNoYXJ0QXJlYS54ICs9IGNoYXJ0QXJlYS53O1xyXG4gICAgY2hhcnRBcmVhLnkgKz0gY2hhcnRBcmVhLmg7XHJcbiAgICBwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcclxuICAgIGNoYXJ0LmNoYXJ0QXJlYSA9IHtcclxuICAgICAgbGVmdDogY2hhcnRBcmVhLmxlZnQsXHJcbiAgICAgIHRvcDogY2hhcnRBcmVhLnRvcCxcclxuICAgICAgcmlnaHQ6IGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLncsXHJcbiAgICAgIGJvdHRvbTogY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5oLFxyXG4gICAgICBoZWlnaHQ6IGNoYXJ0QXJlYS5oLFxyXG4gICAgICB3aWR0aDogY2hhcnRBcmVhLncsXHJcbiAgICB9O1xyXG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcclxuICAgICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcclxuICAgICAgT2JqZWN0LmFzc2lnbihib3gsIGNoYXJ0LmNoYXJ0QXJlYSk7XHJcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcblxyXG5jbGFzcyBCYXNlUGxhdGZvcm0ge1xyXG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHt9XHJcbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cclxuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cclxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xyXG4gICAgcmV0dXJuIDE7XHJcbiAgfVxyXG4gIGdldE1heGltdW1TaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XHJcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIHx8IGVsZW1lbnQud2lkdGgpO1xyXG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd2lkdGgsXHJcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0KVxyXG4gICAgfTtcclxuICB9XHJcbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBCYXNpY1BsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcclxuICBhY3F1aXJlQ29udGV4dChpdGVtKSB7XHJcbiAgICByZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQgJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpIHx8IG51bGw7XHJcbiAgfVxyXG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcclxuICAgIGNvbmZpZy5vcHRpb25zLmFuaW1hdGlvbiA9IGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xyXG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcclxuICB0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcclxuICB0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxyXG4gIHRvdWNoZW5kOiAnbW91c2V1cCcsXHJcbiAgcG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXHJcbiAgcG9pbnRlcmRvd246ICdtb3VzZWRvd24nLFxyXG4gIHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcclxuICBwb2ludGVydXA6ICdtb3VzZXVwJyxcclxuICBwb2ludGVybGVhdmU6ICdtb3VzZW91dCcsXHJcbiAgcG9pbnRlcm91dDogJ21vdXNlb3V0J1xyXG59O1xyXG5jb25zdCBpc051bGxPckVtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xyXG5mdW5jdGlvbiBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcclxuICBjb25zdCBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcclxuICBjb25zdCByZW5kZXJIZWlnaHQgPSBjYW52YXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcclxuICBjb25zdCByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XHJcbiAgY2FudmFzW0VYUEFORE9fS0VZXSA9IHtcclxuICAgIGluaXRpYWw6IHtcclxuICAgICAgaGVpZ2h0OiByZW5kZXJIZWlnaHQsXHJcbiAgICAgIHdpZHRoOiByZW5kZXJXaWR0aCxcclxuICAgICAgc3R5bGU6IHtcclxuICAgICAgICBkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxyXG4gICAgICAgIGhlaWdodDogc3R5bGUuaGVpZ2h0LFxyXG4gICAgICAgIHdpZHRoOiBzdHlsZS53aWR0aFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuICBzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xyXG4gIHN0eWxlLmJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyB8fCAnYm9yZGVyLWJveCc7XHJcbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVyV2lkdGgpKSB7XHJcbiAgICBjb25zdCBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcclxuICAgIGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlckhlaWdodCkpIHtcclxuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xyXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoIC8gKGFzcGVjdFJhdGlvIHx8IDIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc3QgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcclxuICAgICAgaWYgKGRpc3BsYXlIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBjYW52YXM7XHJcbn1cclxuY29uc3QgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XHJcbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgY2hhcnQuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XHJcbiAgY29uc3QgdHlwZSA9IEVWRU5UX1RZUEVTW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XHJcbiAgY29uc3Qge3gsIHl9ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlLFxyXG4gICAgY2hhcnQsXHJcbiAgICBuYXRpdmU6IGV2ZW50LFxyXG4gICAgeDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXHJcbiAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIG5vZGVMaXN0Q29udGFpbnMobm9kZUxpc3QsIGNhbnZhcykge1xyXG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTGlzdCkge1xyXG4gICAgaWYgKG5vZGUgPT09IGNhbnZhcyB8fCBub2RlLmNvbnRhaW5zKGNhbnZhcykpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUF0dGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xyXG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcclxuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xyXG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcclxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xyXG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XHJcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcclxuICAgIH1cclxuICAgIGlmICh0cmlnZ2VyKSB7XHJcbiAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xyXG4gIHJldHVybiBvYnNlcnZlcjtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVEZXRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcclxuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XHJcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcclxuICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XHJcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XHJcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XHJcbiAgICB9XHJcbiAgICBpZiAodHJpZ2dlcikge1xyXG4gICAgICBsaXN0ZW5lcigpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcclxuICByZXR1cm4gb2JzZXJ2ZXI7XHJcbn1cclxuY29uc3QgZHJwTGlzdGVuaW5nQ2hhcnRzID0gbmV3IE1hcCgpO1xyXG5sZXQgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IDA7XHJcbmZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xyXG4gIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xyXG4gIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcclxuICBkcnBMaXN0ZW5pbmdDaGFydHMuZm9yRWFjaCgocmVzaXplLCBjaGFydCkgPT4ge1xyXG4gICAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBkcHIpIHtcclxuICAgICAgcmVzaXplKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSkge1xyXG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XHJcbiAgfVxyXG4gIGRycExpc3RlbmluZ0NoYXJ0cy5zZXQoY2hhcnQsIHJlc2l6ZSk7XHJcbn1cclxuZnVuY3Rpb24gdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCkge1xyXG4gIGRycExpc3RlbmluZ0NoYXJ0cy5kZWxldGUoY2hhcnQpO1xyXG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcclxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xyXG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcclxuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcclxuICBpZiAoIWNvbnRhaW5lcikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBjb25zdCByZXNpemUgPSB0aHJvdHRsZWQoKHdpZHRoLCBoZWlnaHQpID0+IHtcclxuICAgIGNvbnN0IHcgPSBjb250YWluZXIuY2xpZW50V2lkdGg7XHJcbiAgICBsaXN0ZW5lcih3aWR0aCwgaGVpZ2h0KTtcclxuICAgIGlmICh3IDwgY29udGFpbmVyLmNsaWVudFdpZHRoKSB7XHJcbiAgICAgIGxpc3RlbmVyKCk7XHJcbiAgICB9XHJcbiAgfSwgd2luZG93KTtcclxuICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcclxuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcclxuICAgIGNvbnN0IHdpZHRoID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XHJcbiAgICBjb25zdCBoZWlnaHQgPSBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQ7XHJcbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICB9KTtcclxuICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lcik7XHJcbiAgbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSk7XHJcbiAgcmV0dXJuIG9ic2VydmVyO1xyXG59XHJcbmZ1bmN0aW9uIHJlbGVhc2VPYnNlcnZlcihjaGFydCwgdHlwZSwgb2JzZXJ2ZXIpIHtcclxuICBpZiAob2JzZXJ2ZXIpIHtcclxuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICB9XHJcbiAgaWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XHJcbiAgICB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUHJveHlBbmRMaXN0ZW4oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xyXG4gIGNvbnN0IHByb3h5ID0gdGhyb3R0bGVkKChldmVudCkgPT4ge1xyXG4gICAgaWYgKGNoYXJ0LmN0eCAhPT0gbnVsbCkge1xyXG4gICAgICBsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XHJcbiAgICB9XHJcbiAgfSwgY2hhcnQsIChhcmdzKSA9PiB7XHJcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XHJcbiAgICByZXR1cm4gW2V2ZW50LCBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZXTtcclxuICB9KTtcclxuICBhZGRMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcclxuICByZXR1cm4gcHJveHk7XHJcbn1cclxuY2xhc3MgRG9tUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xyXG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQgJiYgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gY2FudmFzKSB7XHJcbiAgICAgIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbyk7XHJcbiAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xyXG4gICAgaWYgKCFjYW52YXNbRVhQQU5ET19LRVldKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XHJcbiAgICBbJ2hlaWdodCcsICd3aWR0aCddLmZvckVhY2goKHByb3ApID0+IHtcclxuICAgICAgY29uc3QgdmFsdWUgPSBpbml0aWFsW3Byb3BdO1xyXG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcclxuICAgICAgICBjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHN0eWxlID0gaW5pdGlhbC5zdHlsZSB8fCB7fTtcclxuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgY2FudmFzLnN0eWxlW2tleV0gPSBzdHlsZVtrZXldO1xyXG4gICAgfSk7XHJcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XHJcbiAgICBkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKTtcclxuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcclxuICAgICAgYXR0YWNoOiBjcmVhdGVBdHRhY2hPYnNlcnZlcixcclxuICAgICAgZGV0YWNoOiBjcmVhdGVEZXRhY2hPYnNlcnZlcixcclxuICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxyXG4gICAgfTtcclxuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCBjcmVhdGVQcm94eUFuZExpc3RlbjtcclxuICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XHJcbiAgfVxyXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpIHtcclxuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XHJcbiAgICBjb25zdCBwcm94eSA9IHByb3hpZXNbdHlwZV07XHJcbiAgICBpZiAoIXByb3h5KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xyXG4gICAgICBhdHRhY2g6IHJlbGVhc2VPYnNlcnZlcixcclxuICAgICAgZGV0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXHJcbiAgICAgIHJlc2l6ZTogcmVsZWFzZU9ic2VydmVyXHJcbiAgICB9O1xyXG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUxpc3RlbmVyO1xyXG4gICAgaGFuZGxlcihjaGFydCwgdHlwZSwgcHJveHkpO1xyXG4gICAgcHJveGllc1t0eXBlXSA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcclxuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICB9XHJcbiAgZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xyXG4gICAgcmV0dXJuIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xyXG4gIH1cclxuICBpc0F0dGFjaGVkKGNhbnZhcykge1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gX2dldFBhcmVudE5vZGUoY2FudmFzKTtcclxuICAgIHJldHVybiAhIShjb250YWluZXIgJiYgY29udGFpbmVyLmlzQ29ubmVjdGVkKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcclxuICBpZiAoIV9pc0RvbVN1cHBvcnRlZCgpIHx8ICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpKSB7XHJcbiAgICByZXR1cm4gQmFzaWNQbGF0Zm9ybTtcclxuICB9XHJcbiAgcmV0dXJuIERvbVBsYXRmb3JtO1xyXG59XHJcblxyXG52YXIgcGxhdGZvcm1zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xyXG5fX3Byb3RvX186IG51bGwsXHJcbl9kZXRlY3RQbGF0Zm9ybTogX2RldGVjdFBsYXRmb3JtLFxyXG5CYXNlUGxhdGZvcm06IEJhc2VQbGF0Zm9ybSxcclxuQmFzaWNQbGF0Zm9ybTogQmFzaWNQbGF0Zm9ybSxcclxuRG9tUGxhdGZvcm06IERvbVBsYXRmb3JtXHJcbn0pO1xyXG5cclxuY29uc3QgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xyXG5jb25zdCBpbnRlcnBvbGF0b3JzID0ge1xyXG4gIGJvb2xlYW4oZnJvbSwgdG8sIGZhY3Rvcikge1xyXG4gICAgcmV0dXJuIGZhY3RvciA+IDAuNSA/IHRvIDogZnJvbTtcclxuICB9LFxyXG4gIGNvbG9yKGZyb20sIHRvLCBmYWN0b3IpIHtcclxuICAgIGNvbnN0IGMwID0gY29sb3IoZnJvbSB8fCB0cmFuc3BhcmVudCk7XHJcbiAgICBjb25zdCBjMSA9IGMwLnZhbGlkICYmIGNvbG9yKHRvIHx8IHRyYW5zcGFyZW50KTtcclxuICAgIHJldHVybiBjMSAmJiBjMS52YWxpZFxyXG4gICAgICA/IGMxLm1peChjMCwgZmFjdG9yKS5oZXhTdHJpbmcoKVxyXG4gICAgICA6IHRvO1xyXG4gIH0sXHJcbiAgbnVtYmVyKGZyb20sIHRvLCBmYWN0b3IpIHtcclxuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBmYWN0b3I7XHJcbiAgfVxyXG59O1xyXG5jbGFzcyBBbmltYXRpb24ge1xyXG4gIGNvbnN0cnVjdG9yKGNmZywgdGFyZ2V0LCBwcm9wLCB0bykge1xyXG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdO1xyXG4gICAgdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XHJcbiAgICBjb25zdCBmcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcclxuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XHJcbiAgICB0aGlzLl9mbiA9IGNmZy5mbiB8fCBpbnRlcnBvbGF0b3JzW2NmZy50eXBlIHx8IHR5cGVvZiBmcm9tXTtcclxuICAgIHRoaXMuX2Vhc2luZyA9IGVmZmVjdHNbY2ZnLmVhc2luZ10gfHwgZWZmZWN0cy5saW5lYXI7XHJcbiAgICB0aGlzLl9zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIChjZmcuZGVsYXkgfHwgMCkpO1xyXG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbCA9IE1hdGguZmxvb3IoY2ZnLmR1cmF0aW9uKTtcclxuICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xyXG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgdGhpcy5fcHJvcCA9IHByb3A7XHJcbiAgICB0aGlzLl9mcm9tID0gZnJvbTtcclxuICAgIHRoaXMuX3RvID0gdG87XHJcbiAgICB0aGlzLl9wcm9taXNlcyA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgYWN0aXZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcclxuICB9XHJcbiAgdXBkYXRlKGNmZywgdG8sIGRhdGUpIHtcclxuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcclxuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcclxuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BdO1xyXG4gICAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xyXG4gICAgICBjb25zdCByZW1haW4gPSB0aGlzLl9kdXJhdGlvbiAtIGVsYXBzZWQ7XHJcbiAgICAgIHRoaXMuX3N0YXJ0ID0gZGF0ZTtcclxuICAgICAgdGhpcy5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHJlbWFpbiwgY2ZnLmR1cmF0aW9uKSk7XHJcbiAgICAgIHRoaXMuX3RvdGFsICs9IGVsYXBzZWQ7XHJcbiAgICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xyXG4gICAgICB0aGlzLl90byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcclxuICAgICAgdGhpcy5fZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNhbmNlbCgpIHtcclxuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcclxuICAgICAgdGhpcy50aWNrKERhdGUubm93KCkpO1xyXG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcclxuICAgIH1cclxuICB9XHJcbiAgdGljayhkYXRlKSB7XHJcbiAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xyXG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcclxuICAgIGNvbnN0IHByb3AgPSB0aGlzLl9wcm9wO1xyXG4gICAgY29uc3QgZnJvbSA9IHRoaXMuX2Zyb207XHJcbiAgICBjb25zdCBsb29wID0gdGhpcy5fbG9vcDtcclxuICAgIGNvbnN0IHRvID0gdGhpcy5fdG87XHJcbiAgICBsZXQgZmFjdG9yO1xyXG4gICAgdGhpcy5fYWN0aXZlID0gZnJvbSAhPT0gdG8gJiYgKGxvb3AgfHwgKGVsYXBzZWQgPCBkdXJhdGlvbikpO1xyXG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcclxuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdG87XHJcbiAgICAgIHRoaXMuX25vdGlmeSh0cnVlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGVsYXBzZWQgPCAwKSB7XHJcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IGZyb207XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGZhY3RvciA9IChlbGFwc2VkIC8gZHVyYXRpb24pICUgMjtcclxuICAgIGZhY3RvciA9IGxvb3AgJiYgZmFjdG9yID4gMSA/IDIgLSBmYWN0b3IgOiBmYWN0b3I7XHJcbiAgICBmYWN0b3IgPSB0aGlzLl9lYXNpbmcoTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZmFjdG9yKSkpO1xyXG4gICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdGhpcy5fZm4oZnJvbSwgdG8sIGZhY3Rvcik7XHJcbiAgfVxyXG4gIHdhaXQoKSB7XHJcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcclxuICAgICAgcHJvbWlzZXMucHVzaCh7cmVzLCByZWp9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuICBfbm90aWZ5KHJlc29sdmVkKSB7XHJcbiAgICBjb25zdCBtZXRob2QgPSByZXNvbHZlZCA/ICdyZXMnIDogJ3Jlaic7XHJcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBwcm9taXNlc1tpXVttZXRob2RdKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBudW1iZXJzID0gWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJywgJ3RlbnNpb24nXTtcclxuY29uc3QgY29sb3JzID0gWydjb2xvcicsICdib3JkZXJDb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InXTtcclxuZGVmYXVsdHMuc2V0KCdhbmltYXRpb24nLCB7XHJcbiAgZGVsYXk6IHVuZGVmaW5lZCxcclxuICBkdXJhdGlvbjogMTAwMCxcclxuICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxyXG4gIGZuOiB1bmRlZmluZWQsXHJcbiAgZnJvbTogdW5kZWZpbmVkLFxyXG4gIGxvb3A6IHVuZGVmaW5lZCxcclxuICB0bzogdW5kZWZpbmVkLFxyXG4gIHR5cGU6IHVuZGVmaW5lZCxcclxufSk7XHJcbmNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5hbmltYXRpb24pO1xyXG5kZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xyXG4gIF9mYWxsYmFjazogZmFsc2UsXHJcbiAgX2luZGV4YWJsZTogZmFsc2UsXHJcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnb25Qcm9ncmVzcycgJiYgbmFtZSAhPT0gJ29uQ29tcGxldGUnICYmIG5hbWUgIT09ICdmbicsXHJcbn0pO1xyXG5kZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbnMnLCB7XHJcbiAgY29sb3JzOiB7XHJcbiAgICB0eXBlOiAnY29sb3InLFxyXG4gICAgcHJvcGVydGllczogY29sb3JzXHJcbiAgfSxcclxuICBudW1iZXJzOiB7XHJcbiAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgIHByb3BlcnRpZXM6IG51bWJlcnNcclxuICB9LFxyXG59KTtcclxuZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbnMnLCB7XHJcbiAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJyxcclxufSk7XHJcbmRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XHJcbiAgYWN0aXZlOiB7XHJcbiAgICBhbmltYXRpb246IHtcclxuICAgICAgZHVyYXRpb246IDQwMFxyXG4gICAgfVxyXG4gIH0sXHJcbiAgcmVzaXplOiB7XHJcbiAgICBhbmltYXRpb246IHtcclxuICAgICAgZHVyYXRpb246IDBcclxuICAgIH1cclxuICB9LFxyXG4gIHNob3c6IHtcclxuICAgIGFuaW1hdGlvbnM6IHtcclxuICAgICAgY29sb3JzOiB7XHJcbiAgICAgICAgZnJvbTogJ3RyYW5zcGFyZW50J1xyXG4gICAgICB9LFxyXG4gICAgICB2aXNpYmxlOiB7XHJcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxyXG4gICAgICAgIGR1cmF0aW9uOiAwXHJcbiAgICAgIH0sXHJcbiAgICB9XHJcbiAgfSxcclxuICBoaWRlOiB7XHJcbiAgICBhbmltYXRpb25zOiB7XHJcbiAgICAgIGNvbG9yczoge1xyXG4gICAgICAgIHRvOiAndHJhbnNwYXJlbnQnXHJcbiAgICAgIH0sXHJcbiAgICAgIHZpc2libGU6IHtcclxuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXHJcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcclxuICAgICAgICBmbjogdiA9PiB2IHwgMFxyXG4gICAgICB9LFxyXG4gICAgfVxyXG4gIH1cclxufSk7XHJcbmNsYXNzIEFuaW1hdGlvbnMge1xyXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBjb25maWcpIHtcclxuICAgIHRoaXMuX2NoYXJ0ID0gY2hhcnQ7XHJcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5jb25maWd1cmUoY29uZmlnKTtcclxuICB9XHJcbiAgY29uZmlndXJlKGNvbmZpZykge1xyXG4gICAgaWYgKCFpc09iamVjdChjb25maWcpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xyXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGNvbnN0IGNmZyA9IGNvbmZpZ1trZXldO1xyXG4gICAgICBpZiAoIWlzT2JqZWN0KGNmZykpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcmVzb2x2ZWQgPSB7fTtcclxuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgYW5pbWF0aW9uT3B0aW9ucykge1xyXG4gICAgICAgIHJlc29sdmVkW29wdGlvbl0gPSBjZmdbb3B0aW9uXTtcclxuICAgICAgfVxyXG4gICAgICAoaXNBcnJheShjZmcucHJvcGVydGllcykgJiYgY2ZnLnByb3BlcnRpZXMgfHwgW2tleV0pLmZvckVhY2goKHByb3ApID0+IHtcclxuICAgICAgICBpZiAocHJvcCA9PT0ga2V5IHx8ICFhbmltYXRlZFByb3BzLmhhcyhwcm9wKSkge1xyXG4gICAgICAgICAgYW5pbWF0ZWRQcm9wcy5zZXQocHJvcCwgcmVzb2x2ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSB7XHJcbiAgICBjb25zdCBuZXdPcHRpb25zID0gdmFsdWVzLm9wdGlvbnM7XHJcbiAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKTtcclxuICAgIGlmICghb3B0aW9ucykge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyhvcHRpb25zLCBuZXdPcHRpb25zKTtcclxuICAgIGlmIChuZXdPcHRpb25zLiRzaGFyZWQpIHtcclxuICAgICAgYXdhaXRBbGwodGFyZ2V0Lm9wdGlvbnMuJGFuaW1hdGlvbnMsIG5ld09wdGlvbnMpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcclxuICAgICAgfSwgKCkgPT4ge1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBhbmltYXRpb25zO1xyXG4gIH1cclxuICBfY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xyXG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XHJcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XHJcbiAgICBjb25zdCBydW5uaW5nID0gdGFyZ2V0LiRhbmltYXRpb25zIHx8ICh0YXJnZXQuJGFuaW1hdGlvbnMgPSB7fSk7XHJcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XHJcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcclxuICAgIGxldCBpO1xyXG4gICAgZm9yIChpID0gcHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xyXG4gICAgICBpZiAocHJvcC5jaGFyQXQoMCkgPT09ICckJykge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm9wID09PSAnb3B0aW9ucycpIHtcclxuICAgICAgICBhbmltYXRpb25zLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpKTtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1twcm9wXTtcclxuICAgICAgbGV0IGFuaW1hdGlvbiA9IHJ1bm5pbmdbcHJvcF07XHJcbiAgICAgIGNvbnN0IGNmZyA9IGFuaW1hdGVkUHJvcHMuZ2V0KHByb3ApO1xyXG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgaWYgKGNmZyAmJiBhbmltYXRpb24uYWN0aXZlKCkpIHtcclxuICAgICAgICAgIGFuaW1hdGlvbi51cGRhdGUoY2ZnLCB2YWx1ZSwgZGF0ZSk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoIWNmZyB8fCAhY2ZnLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgcnVubmluZ1twcm9wXSA9IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oY2ZnLCB0YXJnZXQsIHByb3AsIHZhbHVlKTtcclxuICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYW5pbWF0aW9ucztcclxuICB9XHJcbiAgdXBkYXRlKHRhcmdldCwgdmFsdWVzKSB7XHJcbiAgICBpZiAodGhpcy5fcHJvcGVydGllcy5zaXplID09PSAwKSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB2YWx1ZXMpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcyk7XHJcbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgYW5pbWF0b3IuYWRkKHRoaXMuX2NoYXJ0LCBhbmltYXRpb25zKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGF3YWl0QWxsKGFuaW1hdGlvbnMsIHByb3BlcnRpZXMpIHtcclxuICBjb25zdCBydW5uaW5nID0gW107XHJcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgYW5pbSA9IGFuaW1hdGlvbnNba2V5c1tpXV07XHJcbiAgICBpZiAoYW5pbSAmJiBhbmltLmFjdGl2ZSgpKSB7XHJcbiAgICAgIHJ1bm5pbmcucHVzaChhbmltLndhaXQoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBQcm9taXNlLmFsbChydW5uaW5nKTtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpIHtcclxuICBpZiAoIW5ld09wdGlvbnMpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgbGV0IG9wdGlvbnMgPSB0YXJnZXQub3B0aW9ucztcclxuICBpZiAoIW9wdGlvbnMpIHtcclxuICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKG9wdGlvbnMuJHNoYXJlZCkge1xyXG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyRzaGFyZWQ6IGZhbHNlLCAkYW5pbWF0aW9uczoge319KTtcclxuICB9XHJcbiAgcmV0dXJuIG9wdGlvbnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNjYWxlQ2xpcChzY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XHJcbiAgY29uc3Qgb3B0cyA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMgfHwge307XHJcbiAgY29uc3QgcmV2ZXJzZSA9IG9wdHMucmV2ZXJzZTtcclxuICBjb25zdCBtaW4gPSBvcHRzLm1pbiA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcclxuICBjb25zdCBtYXggPSBvcHRzLm1heCA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcclxuICByZXR1cm4ge1xyXG4gICAgc3RhcnQ6IHJldmVyc2UgPyBtYXggOiBtaW4sXHJcbiAgICBlbmQ6IHJldmVyc2UgPyBtaW4gOiBtYXhcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGRlZmF1bHRDbGlwKHhTY2FsZSwgeVNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcclxuICBpZiAoYWxsb3dlZE92ZXJmbG93ID09PSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBjb25zdCB4ID0gc2NhbGVDbGlwKHhTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcclxuICBjb25zdCB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcclxuICByZXR1cm4ge1xyXG4gICAgdG9wOiB5LmVuZCxcclxuICAgIHJpZ2h0OiB4LmVuZCxcclxuICAgIGJvdHRvbTogeS5zdGFydCxcclxuICAgIGxlZnQ6IHguc3RhcnRcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHRvQ2xpcCh2YWx1ZSkge1xyXG4gIGxldCB0LCByLCBiLCBsO1xyXG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgIHQgPSB2YWx1ZS50b3A7XHJcbiAgICByID0gdmFsdWUucmlnaHQ7XHJcbiAgICBiID0gdmFsdWUuYm90dG9tO1xyXG4gICAgbCA9IHZhbHVlLmxlZnQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIHQgPSByID0gYiA9IGwgPSB2YWx1ZTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHRvcDogdCxcclxuICAgIHJpZ2h0OiByLFxyXG4gICAgYm90dG9tOiBiLFxyXG4gICAgbGVmdDogbCxcclxuICAgIGRpc2FibGVkOiB2YWx1ZSA9PT0gZmFsc2VcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XHJcbiAgY29uc3Qga2V5cyA9IFtdO1xyXG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKTtcclxuICBsZXQgaSwgaWxlbjtcclxuICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICBrZXlzLnB1c2gobWV0YXNldHNbaV0uaW5kZXgpO1xyXG4gIH1cclxuICByZXR1cm4ga2V5cztcclxufVxyXG5mdW5jdGlvbiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgZHNJbmRleCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgY29uc3Qga2V5cyA9IHN0YWNrLmtleXM7XHJcbiAgY29uc3Qgc2luZ2xlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ3NpbmdsZSc7XHJcbiAgbGV0IGksIGlsZW4sIGRhdGFzZXRJbmRleCwgb3RoZXJWYWx1ZTtcclxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICBkYXRhc2V0SW5kZXggPSAra2V5c1tpXTtcclxuICAgIGlmIChkYXRhc2V0SW5kZXggPT09IGRzSW5kZXgpIHtcclxuICAgICAgaWYgKG9wdGlvbnMuYWxsKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBvdGhlclZhbHVlID0gc3RhY2sudmFsdWVzW2RhdGFzZXRJbmRleF07XHJcbiAgICBpZiAoaXNOdW1iZXJGaW5pdGUob3RoZXJWYWx1ZSkgJiYgKHNpbmdsZU1vZGUgfHwgKHZhbHVlID09PSAwIHx8IHNpZ24odmFsdWUpID09PSBzaWduKG90aGVyVmFsdWUpKSkpIHtcclxuICAgICAgdmFsdWUgKz0gb3RoZXJWYWx1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhKSB7XHJcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xyXG4gIGNvbnN0IGFkYXRhID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcclxuICBsZXQgaSwgaWxlbiwga2V5O1xyXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAga2V5ID0ga2V5c1tpXTtcclxuICAgIGFkYXRhW2ldID0ge1xyXG4gICAgICB4OiBrZXksXHJcbiAgICAgIHk6IGRhdGFba2V5XVxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIGFkYXRhO1xyXG59XHJcbmZ1bmN0aW9uIGlzU3RhY2tlZChzY2FsZSwgbWV0YSkge1xyXG4gIGNvbnN0IHN0YWNrZWQgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XHJcbiAgcmV0dXJuIHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFN0YWNrS2V5KGluZGV4U2NhbGUsIHZhbHVlU2NhbGUsIG1ldGEpIHtcclxuICByZXR1cm4gYCR7aW5kZXhTY2FsZS5pZH0uJHt2YWx1ZVNjYWxlLmlkfS4ke21ldGEuc3RhY2sgfHwgbWV0YS50eXBlfWA7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VXNlckJvdW5kcyhzY2FsZSkge1xyXG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBzY2FsZS5nZXRVc2VyQm91bmRzKCk7XHJcbiAgcmV0dXJuIHtcclxuICAgIG1pbjogbWluRGVmaW5lZCA/IG1pbiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcclxuICAgIG1heDogbWF4RGVmaW5lZCA/IG1heCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIHN0YWNrS2V5LCBpbmRleFZhbHVlKSB7XHJcbiAgY29uc3Qgc3ViU3RhY2sgPSBzdGFja3Nbc3RhY2tLZXldIHx8IChzdGFja3Nbc3RhY2tLZXldID0ge30pO1xyXG4gIHJldHVybiBzdWJTdGFja1tpbmRleFZhbHVlXSB8fCAoc3ViU3RhY2tbaW5kZXhWYWx1ZV0gPSB7fSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBwb3NpdGl2ZSwgdHlwZSkge1xyXG4gIGZvciAoY29uc3QgbWV0YSBvZiB2U2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkucmV2ZXJzZSgpKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHN0YWNrW21ldGEuaW5kZXhdO1xyXG4gICAgaWYgKChwb3NpdGl2ZSAmJiB2YWx1ZSA+IDApIHx8ICghcG9zaXRpdmUgJiYgdmFsdWUgPCAwKSkge1xyXG4gICAgICByZXR1cm4gbWV0YS5pbmRleDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlU3RhY2tzKGNvbnRyb2xsZXIsIHBhcnNlZCkge1xyXG4gIGNvbnN0IHtjaGFydCwgX2NhY2hlZE1ldGE6IG1ldGF9ID0gY29udHJvbGxlcjtcclxuICBjb25zdCBzdGFja3MgPSBjaGFydC5fc3RhY2tzIHx8IChjaGFydC5fc3RhY2tzID0ge30pO1xyXG4gIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgaW5kZXg6IGRhdGFzZXRJbmRleH0gPSBtZXRhO1xyXG4gIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XHJcbiAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcclxuICBjb25zdCBrZXkgPSBnZXRTdGFja0tleShpU2NhbGUsIHZTY2FsZSwgbWV0YSk7XHJcbiAgY29uc3QgaWxlbiA9IHBhcnNlZC5sZW5ndGg7XHJcbiAgbGV0IHN0YWNrO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICBjb25zdCBpdGVtID0gcGFyc2VkW2ldO1xyXG4gICAgY29uc3Qge1tpQXhpc106IGluZGV4LCBbdkF4aXNdOiB2YWx1ZX0gPSBpdGVtO1xyXG4gICAgY29uc3QgaXRlbVN0YWNrcyA9IGl0ZW0uX3N0YWNrcyB8fCAoaXRlbS5fc3RhY2tzID0ge30pO1xyXG4gICAgc3RhY2sgPSBpdGVtU3RhY2tzW3ZBeGlzXSA9IGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBrZXksIGluZGV4KTtcclxuICAgIHN0YWNrW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcclxuICAgIHN0YWNrLl90b3AgPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHRydWUsIG1ldGEudHlwZSk7XHJcbiAgICBzdGFjay5fYm90dG9tID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBmYWxzZSwgbWV0YS50eXBlKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCBheGlzKSB7XHJcbiAgY29uc3Qgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xyXG4gIHJldHVybiBPYmplY3Qua2V5cyhzY2FsZXMpLmZpbHRlcihrZXkgPT4gc2NhbGVzW2tleV0uYXhpcyA9PT0gYXhpcykuc2hpZnQoKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0Q29udGV4dChwYXJlbnQsIGluZGV4KSB7XHJcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LFxyXG4gICAge1xyXG4gICAgICBhY3RpdmU6IGZhbHNlLFxyXG4gICAgICBkYXRhc2V0OiB1bmRlZmluZWQsXHJcbiAgICAgIGRhdGFzZXRJbmRleDogaW5kZXgsXHJcbiAgICAgIGluZGV4LFxyXG4gICAgICBtb2RlOiAnZGVmYXVsdCcsXHJcbiAgICAgIHR5cGU6ICdkYXRhc2V0J1xyXG4gICAgfVxyXG4gICk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRGF0YUNvbnRleHQocGFyZW50LCBpbmRleCwgZWxlbWVudCkge1xyXG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xyXG4gICAgYWN0aXZlOiBmYWxzZSxcclxuICAgIGRhdGFJbmRleDogaW5kZXgsXHJcbiAgICBwYXJzZWQ6IHVuZGVmaW5lZCxcclxuICAgIHJhdzogdW5kZWZpbmVkLFxyXG4gICAgZWxlbWVudCxcclxuICAgIGluZGV4LFxyXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxyXG4gICAgdHlwZTogJ2RhdGEnXHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY2xlYXJTdGFja3MobWV0YSwgaXRlbXMpIHtcclxuICBjb25zdCBkYXRhc2V0SW5kZXggPSBtZXRhLmNvbnRyb2xsZXIuaW5kZXg7XHJcbiAgY29uc3QgYXhpcyA9IG1ldGEudlNjYWxlICYmIG1ldGEudlNjYWxlLmF4aXM7XHJcbiAgaWYgKCFheGlzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGl0ZW1zID0gaXRlbXMgfHwgbWV0YS5fcGFyc2VkO1xyXG4gIGZvciAoY29uc3QgcGFyc2VkIG9mIGl0ZW1zKSB7XHJcbiAgICBjb25zdCBzdGFja3MgPSBwYXJzZWQuX3N0YWNrcztcclxuICAgIGlmICghc3RhY2tzIHx8IHN0YWNrc1theGlzXSA9PT0gdW5kZWZpbmVkIHx8IHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlIHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdO1xyXG4gIH1cclxufVxyXG5jb25zdCBpc0RpcmVjdFVwZGF0ZU1vZGUgPSAobW9kZSkgPT4gbW9kZSA9PT0gJ3Jlc2V0JyB8fCBtb2RlID09PSAnbm9uZSc7XHJcbmNvbnN0IGNsb25lSWZOb3RTaGFyZWQgPSAoY2FjaGVkLCBzaGFyZWQpID0+IHNoYXJlZCA/IGNhY2hlZCA6IE9iamVjdC5hc3NpZ24oe30sIGNhY2hlZCk7XHJcbmNvbnN0IGNyZWF0ZVN0YWNrID0gKGNhblN0YWNrLCBtZXRhLCBjaGFydCkgPT4gY2FuU3RhY2sgJiYgIW1ldGEuaGlkZGVuICYmIG1ldGEuX3N0YWNrZWRcclxuICAmJiB7a2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLCB2YWx1ZXM6IG51bGx9O1xyXG5jbGFzcyBEYXRhc2V0Q29udHJvbGxlciB7XHJcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xyXG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xyXG4gICAgdGhpcy5fY3R4ID0gY2hhcnQuY3R4O1xyXG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcclxuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XHJcbiAgICB0aGlzLl9jYWNoZWRNZXRhID0gdGhpcy5nZXRNZXRhKCk7XHJcbiAgICB0aGlzLl90eXBlID0gdGhpcy5fY2FjaGVkTWV0YS50eXBlO1xyXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fcGFyc2luZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX29iamVjdERhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl9zaGFyZWRPcHRpb25zID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fZHJhd0NvdW50ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IGZhbHNlO1xyXG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XHJcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICB9XHJcbiAgaW5pdGlhbGl6ZSgpIHtcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xyXG4gICAgdGhpcy5jb25maWd1cmUoKTtcclxuICAgIHRoaXMubGlua1NjYWxlcygpO1xyXG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XHJcbiAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XHJcbiAgfVxyXG4gIHVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCkge1xyXG4gICAgaWYgKHRoaXMuaW5kZXggIT09IGRhdGFzZXRJbmRleCkge1xyXG4gICAgICBjbGVhclN0YWNrcyh0aGlzLl9jYWNoZWRNZXRhKTtcclxuICAgIH1cclxuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XHJcbiAgfVxyXG4gIGxpbmtTY2FsZXMoKSB7XHJcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcclxuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcclxuICAgIGNvbnN0IGNob29zZUlkID0gKGF4aXMsIHgsIHksIHIpID0+IGF4aXMgPT09ICd4JyA/IHggOiBheGlzID09PSAncicgPyByIDogeTtcclxuICAgIGNvbnN0IHhpZCA9IG1ldGEueEF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueEF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneCcpKTtcclxuICAgIGNvbnN0IHlpZCA9IG1ldGEueUF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueUF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneScpKTtcclxuICAgIGNvbnN0IHJpZCA9IG1ldGEuckF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuckF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAncicpKTtcclxuICAgIGNvbnN0IGluZGV4QXhpcyA9IG1ldGEuaW5kZXhBeGlzO1xyXG4gICAgY29uc3QgaWlkID0gbWV0YS5pQXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB4aWQsIHlpZCwgcmlkKTtcclxuICAgIGNvbnN0IHZpZCA9IG1ldGEudkF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeWlkLCB4aWQsIHJpZCk7XHJcbiAgICBtZXRhLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh4aWQpO1xyXG4gICAgbWV0YS55U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeWlkKTtcclxuICAgIG1ldGEuclNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHJpZCk7XHJcbiAgICBtZXRhLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChpaWQpO1xyXG4gICAgbWV0YS52U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQodmlkKTtcclxuICB9XHJcbiAgZ2V0RGF0YXNldCgpIHtcclxuICAgIHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XHJcbiAgfVxyXG4gIGdldE1ldGEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcclxuICB9XHJcbiAgZ2V0U2NhbGVGb3JJZChzY2FsZUlEKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XHJcbiAgfVxyXG4gIF9nZXRPdGhlclNjYWxlKHNjYWxlKSB7XHJcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcclxuICAgIHJldHVybiBzY2FsZSA9PT0gbWV0YS5pU2NhbGVcclxuICAgICAgPyBtZXRhLnZTY2FsZVxyXG4gICAgICA6IG1ldGEuaVNjYWxlO1xyXG4gIH1cclxuICByZXNldCgpIHtcclxuICAgIHRoaXMuX3VwZGF0ZSgncmVzZXQnKTtcclxuICB9XHJcbiAgX2Rlc3Ryb3koKSB7XHJcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcclxuICAgIGlmICh0aGlzLl9kYXRhKSB7XHJcbiAgICAgIHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xyXG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcclxuICAgIH1cclxuICB9XHJcbiAgX2RhdGFDaGVjaygpIHtcclxuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcclxuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcclxuICAgIGNvbnN0IF9kYXRhID0gdGhpcy5fZGF0YTtcclxuICAgIGlmIChpc09iamVjdChkYXRhKSkge1xyXG4gICAgICB0aGlzLl9kYXRhID0gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEpO1xyXG4gICAgfSBlbHNlIGlmIChfZGF0YSAhPT0gZGF0YSkge1xyXG4gICAgICBpZiAoX2RhdGEpIHtcclxuICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKF9kYXRhLCB0aGlzKTtcclxuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcclxuICAgICAgICBjbGVhclN0YWNrcyhtZXRhKTtcclxuICAgICAgICBtZXRhLl9wYXJzZWQgPSBbXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZGF0YSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGRhdGEpKSB7XHJcbiAgICAgICAgbGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgdGhpcyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcclxuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGFkZEVsZW1lbnRzKCkge1xyXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XHJcbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcclxuICAgIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xyXG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcclxuICAgIH1cclxuICB9XHJcbiAgYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xyXG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xyXG4gICAgbGV0IHN0YWNrQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XHJcbiAgICBjb25zdCBvbGRTdGFja2VkID0gbWV0YS5fc3RhY2tlZDtcclxuICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xyXG4gICAgaWYgKG1ldGEuc3RhY2sgIT09IGRhdGFzZXQuc3RhY2spIHtcclxuICAgICAgc3RhY2tDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XHJcbiAgICAgIG1ldGEuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cyk7XHJcbiAgICBpZiAoc3RhY2tDaGFuZ2VkIHx8IG9sZFN0YWNrZWQgIT09IG1ldGEuX3N0YWNrZWQpIHtcclxuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIG1ldGEuX3BhcnNlZCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbmZpZ3VyZSgpIHtcclxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xyXG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSk7XHJcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMsIHRydWUpO1xyXG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KCkpO1xyXG4gICAgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nO1xyXG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcclxuICB9XHJcbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XHJcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IG1ldGEsIF9kYXRhOiBkYXRhfSA9IHRoaXM7XHJcbiAgICBjb25zdCB7aVNjYWxlLCBfc3RhY2tlZH0gPSBtZXRhO1xyXG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcclxuICAgIGxldCBzb3J0ZWQgPSBzdGFydCA9PT0gMCAmJiBjb3VudCA9PT0gZGF0YS5sZW5ndGggPyB0cnVlIDogbWV0YS5fc29ydGVkO1xyXG4gICAgbGV0IHByZXYgPSBzdGFydCA+IDAgJiYgbWV0YS5fcGFyc2VkW3N0YXJ0IC0gMV07XHJcbiAgICBsZXQgaSwgY3VyLCBwYXJzZWQ7XHJcbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcclxuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcclxuICAgICAgbWV0YS5fc29ydGVkID0gdHJ1ZTtcclxuICAgICAgcGFyc2VkID0gZGF0YTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChpc0FycmF5KGRhdGFbc3RhcnRdKSkge1xyXG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcclxuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcclxuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYgPSAoKSA9PiBjdXJbaUF4aXNdID09PSBudWxsIHx8IChwcmV2ICYmIGN1cltpQXhpc10gPCBwcmV2W2lBeGlzXSk7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XHJcbiAgICAgICAgaWYgKHNvcnRlZCkge1xyXG4gICAgICAgICAgaWYgKGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2KCkpIHtcclxuICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwcmV2ID0gY3VyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBtZXRhLl9zb3J0ZWQgPSBzb3J0ZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAoX3N0YWNrZWQpIHtcclxuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIHBhcnNlZCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcclxuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xyXG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcclxuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XHJcbiAgICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XHJcbiAgICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xyXG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcclxuICAgIGxldCBpLCBpbGVuLCBpbmRleDtcclxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcclxuICAgICAgcGFyc2VkW2ldID0ge1xyXG4gICAgICAgIFtpQXhpc106IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaW5kZXhdLCBpbmRleCksXHJcbiAgICAgICAgW3ZBeGlzXTogdlNjYWxlLnBhcnNlKGRhdGFbaW5kZXhdLCBpbmRleClcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJzZWQ7XHJcbiAgfVxyXG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xyXG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XHJcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xyXG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xyXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xyXG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XHJcbiAgICAgIHBhcnNlZFtpXSA9IHtcclxuICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxyXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShpdGVtWzFdLCBpbmRleClcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJzZWQ7XHJcbiAgfVxyXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcclxuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xyXG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xyXG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcclxuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcclxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcclxuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xyXG4gICAgICBwYXJzZWRbaV0gPSB7XHJcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXHJcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeUF4aXNLZXkpLCBpbmRleClcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJzZWQ7XHJcbiAgfVxyXG4gIGdldFBhcnNlZChpbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZFtpbmRleF07XHJcbiAgfVxyXG4gIGdldERhdGFFbGVtZW50KGluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcclxuICB9XHJcbiAgYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XHJcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcclxuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xyXG4gICAgY29uc3Qgc3RhY2sgPSB7XHJcbiAgICAgIGtleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSxcclxuICAgICAgdmFsdWVzOiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXVxyXG4gICAgfTtcclxuICAgIHJldHVybiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgbWV0YS5pbmRleCwge21vZGV9KTtcclxuICB9XHJcbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xyXG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XHJcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRWYWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHBhcnNlZFZhbHVlO1xyXG4gICAgY29uc3QgdmFsdWVzID0gc3RhY2sgJiYgcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc107XHJcbiAgICBpZiAoc3RhY2sgJiYgdmFsdWVzKSB7XHJcbiAgICAgIHN0YWNrLnZhbHVlcyA9IHZhbHVlcztcclxuICAgICAgdmFsdWUgPSBhcHBseVN0YWNrKHN0YWNrLCBwYXJzZWRWYWx1ZSwgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCk7XHJcbiAgICB9XHJcbiAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIHZhbHVlKTtcclxuICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xyXG4gIH1cclxuICBnZXRNaW5NYXgoc2NhbGUsIGNhblN0YWNrKSB7XHJcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcclxuICAgIGNvbnN0IF9wYXJzZWQgPSBtZXRhLl9wYXJzZWQ7XHJcbiAgICBjb25zdCBzb3J0ZWQgPSBtZXRhLl9zb3J0ZWQgJiYgc2NhbGUgPT09IG1ldGEuaVNjYWxlO1xyXG4gICAgY29uc3QgaWxlbiA9IF9wYXJzZWQubGVuZ3RoO1xyXG4gICAgY29uc3Qgb3RoZXJTY2FsZSA9IHRoaXMuX2dldE90aGVyU2NhbGUoc2NhbGUpO1xyXG4gICAgY29uc3Qgc3RhY2sgPSBjcmVhdGVTdGFjayhjYW5TdGFjaywgbWV0YSwgdGhpcy5jaGFydCk7XHJcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xyXG4gICAgY29uc3Qge21pbjogb3RoZXJNaW4sIG1heDogb3RoZXJNYXh9ID0gZ2V0VXNlckJvdW5kcyhvdGhlclNjYWxlKTtcclxuICAgIGxldCBpLCBwYXJzZWQ7XHJcbiAgICBmdW5jdGlvbiBfc2tpcCgpIHtcclxuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcclxuICAgICAgY29uc3Qgb3RoZXJWYWx1ZSA9IHBhcnNlZFtvdGhlclNjYWxlLmF4aXNdO1xyXG4gICAgICByZXR1cm4gIWlzTnVtYmVyRmluaXRlKHBhcnNlZFtzY2FsZS5heGlzXSkgfHwgb3RoZXJNaW4gPiBvdGhlclZhbHVlIHx8IG90aGVyTWF4IDwgb3RoZXJWYWx1ZTtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcclxuICAgICAgaWYgKF9za2lwKCkpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xyXG4gICAgICBpZiAoc29ydGVkKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzb3J0ZWQpIHtcclxuICAgICAgZm9yIChpID0gaWxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgaWYgKF9za2lwKCkpIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmFuZ2U7XHJcbiAgfVxyXG4gIGdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkge1xyXG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkO1xyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBsZXQgaSwgaWxlbiwgdmFsdWU7XHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcGFyc2VkLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICB2YWx1ZSA9IHBhcnNlZFtpXVtzY2FsZS5heGlzXTtcclxuICAgICAgaWYgKGlzTnVtYmVyRmluaXRlKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlcztcclxuICB9XHJcbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xyXG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XHJcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxhYmVsOiBpU2NhbGUgPyAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pIDogJycsXHJcbiAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcclxuICAgIH07XHJcbiAgfVxyXG4gIF91cGRhdGUobW9kZSkge1xyXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XHJcbiAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XHJcbiAgICBtZXRhLl9jbGlwID0gdG9DbGlwKHZhbHVlT3JEZWZhdWx0KHRoaXMub3B0aW9ucy5jbGlwLCBkZWZhdWx0Q2xpcChtZXRhLnhTY2FsZSwgbWV0YS55U2NhbGUsIHRoaXMuZ2V0TWF4T3ZlcmZsb3coKSkpKTtcclxuICB9XHJcbiAgdXBkYXRlKG1vZGUpIHt9XHJcbiAgZHJhdygpIHtcclxuICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcclxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xyXG4gICAgY29uc3QgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XHJcbiAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xyXG4gICAgY29uc3QgYWN0aXZlID0gW107XHJcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2RyYXdTdGFydCB8fCAwO1xyXG4gICAgY29uc3QgY291bnQgPSB0aGlzLl9kcmF3Q291bnQgfHwgKGVsZW1lbnRzLmxlbmd0aCAtIHN0YXJ0KTtcclxuICAgIGNvbnN0IGRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xyXG4gICAgbGV0IGk7XHJcbiAgICBpZiAobWV0YS5kYXRhc2V0KSB7XHJcbiAgICAgIG1ldGEuZGF0YXNldC5kcmF3KGN0eCwgYXJlYSwgc3RhcnQsIGNvdW50KTtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcclxuICAgICAgaWYgKGVsZW1lbnQuaGlkZGVuKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGVsZW1lbnQuYWN0aXZlICYmIGRyYXdBY3RpdmVFbGVtZW50c09uVG9wKSB7XHJcbiAgICAgICAgYWN0aXZlLnB1c2goZWxlbWVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxlbWVudC5kcmF3KGN0eCwgYXJlYSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgYWN0aXZlW2ldLmRyYXcoY3R4LCBhcmVhKTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSkge1xyXG4gICAgY29uc3QgbW9kZSA9IGFjdGl2ZSA/ICdhY3RpdmUnIDogJ2RlZmF1bHQnO1xyXG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0XHJcbiAgICAgID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpXHJcbiAgICAgIDogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4IHx8IDAsIG1vZGUpO1xyXG4gIH1cclxuICBnZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpIHtcclxuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcclxuICAgIGxldCBjb250ZXh0O1xyXG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xyXG4gICAgICBjb250ZXh0ID0gZWxlbWVudC4kY29udGV4dCB8fFxyXG4gICAgICAgIChlbGVtZW50LiRjb250ZXh0ID0gY3JlYXRlRGF0YUNvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBlbGVtZW50KSk7XHJcbiAgICAgIGNvbnRleHQucGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xyXG4gICAgICBjb250ZXh0LnJhdyA9IGRhdGFzZXQuZGF0YVtpbmRleF07XHJcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFJbmRleCA9IGluZGV4O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29udGV4dCA9IHRoaXMuJGNvbnRleHQgfHxcclxuICAgICAgICAodGhpcy4kY29udGV4dCA9IGNyZWF0ZURhdGFzZXRDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLmluZGV4KSk7XHJcbiAgICAgIGNvbnRleHQuZGF0YXNldCA9IGRhdGFzZXQ7XHJcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICB9XHJcbiAgICBjb250ZXh0LmFjdGl2ZSA9ICEhYWN0aXZlO1xyXG4gICAgY29udGV4dC5tb2RlID0gbW9kZTtcclxuICAgIHJldHVybiBjb250ZXh0O1xyXG4gIH1cclxuICByZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhc2V0RWxlbWVudFR5cGUuaWQsIG1vZGUpO1xyXG4gIH1cclxuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YUVsZW1lbnRUeXBlLmlkLCBtb2RlLCBpbmRleCk7XHJcbiAgfVxyXG4gIF9yZXNvbHZlRWxlbWVudE9wdGlvbnMoZWxlbWVudFR5cGUsIG1vZGUgPSAnZGVmYXVsdCcsIGluZGV4KSB7XHJcbiAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcclxuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IGVsZW1lbnRUeXBlICsgJy0nICsgbW9kZTtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcclxuICAgIGNvbnN0IHNoYXJpbmcgPSB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgJiYgZGVmaW5lZChpbmRleCk7XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcclxuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCBlbGVtZW50VHlwZSk7XHJcbiAgICBjb25zdCBwcmVmaXhlcyA9IGFjdGl2ZSA/IFtgJHtlbGVtZW50VHlwZX1Ib3ZlcmAsICdob3ZlcicsIGVsZW1lbnRUeXBlLCAnJ10gOiBbZWxlbWVudFR5cGUsICcnXTtcclxuICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XHJcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gKCkgPT4gdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUpO1xyXG4gICAgY29uc3QgdmFsdWVzID0gY29uZmlnLnJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMpO1xyXG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XHJcbiAgICAgIHZhbHVlcy4kc2hhcmVkID0gc2hhcmluZztcclxuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShjbG9uZUlmTm90U2hhcmVkKHZhbHVlcywgc2hhcmluZykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlcztcclxuICB9XHJcbiAgX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcclxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XHJcbiAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBsZXQgb3B0aW9ucztcclxuICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcclxuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XHJcbiAgICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKHRoaXMuX3R5cGUsIHRyYW5zaXRpb24pO1xyXG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xyXG4gICAgICBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIHRyYW5zaXRpb24pKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fY2FjaGVhYmxlKSB7XHJcbiAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5mcmVlemUoYW5pbWF0aW9ucyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYW5pbWF0aW9ucztcclxuICB9XHJcbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICBpZiAoIW9wdGlvbnMuJHNoYXJlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcclxuICB9XHJcbiAgaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykge1xyXG4gICAgcmV0dXJuICFzaGFyZWRPcHRpb25zIHx8IGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSB8fCB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XHJcbiAgfVxyXG4gIHVwZGF0ZUVsZW1lbnQoZWxlbWVudCwgaW5kZXgsIHByb3BlcnRpZXMsIG1vZGUpIHtcclxuICAgIGlmIChpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcclxuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LCBwcm9wZXJ0aWVzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgbmV3T3B0aW9ucykge1xyXG4gICAgaWYgKHNoYXJlZE9wdGlvbnMgJiYgIWlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xyXG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpLnVwZGF0ZShzaGFyZWRPcHRpb25zLCBuZXdPcHRpb25zKTtcclxuICAgIH1cclxuICB9XHJcbiAgX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCBtb2RlLCBhY3RpdmUpIHtcclxuICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSk7XHJcbiAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgbW9kZSwgYWN0aXZlKS51cGRhdGUoZWxlbWVudCwge1xyXG4gICAgICBvcHRpb25zOiAoIWFjdGl2ZSAmJiB0aGlzLmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykpIHx8IG9wdGlvbnNcclxuICAgIH0pO1xyXG4gIH1cclxuICByZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcclxuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgZmFsc2UpO1xyXG4gIH1cclxuICBzZXRIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcclxuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgdHJ1ZSk7XHJcbiAgfVxyXG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XHJcbiAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XHJcbiAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCB0cnVlKTtcclxuICAgIH1cclxuICB9XHJcbiAgX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcclxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xyXG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XHJcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdIG9mIHRoaXMuX3N5bmNMaXN0KSB7XHJcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XHJcbiAgICBjb25zdCBudW1NZXRhID0gZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgY29uc3QgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xyXG4gICAgY29uc3QgY291bnQgPSBNYXRoLm1pbihudW1EYXRhLCBudW1NZXRhKTtcclxuICAgIGlmIChjb3VudCkge1xyXG4gICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcclxuICAgIH1cclxuICAgIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xyXG4gICAgICB0aGlzLl9pbnNlcnRFbGVtZW50cyhudW1NZXRhLCBudW1EYXRhIC0gbnVtTWV0YSwgcmVzZXROZXdFbGVtZW50cyk7XHJcbiAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XHJcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnRzKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcclxuICAgIH1cclxuICB9XHJcbiAgX2luc2VydEVsZW1lbnRzKHN0YXJ0LCBjb3VudCwgcmVzZXROZXdFbGVtZW50cyA9IHRydWUpIHtcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xyXG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YTtcclxuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XHJcbiAgICBsZXQgaTtcclxuICAgIGNvbnN0IG1vdmUgPSAoYXJyKSA9PiB7XHJcbiAgICAgIGFyci5sZW5ndGggKz0gY291bnQ7XHJcbiAgICAgIGZvciAoaSA9IGFyci5sZW5ndGggLSAxOyBpID49IGVuZDsgaS0tKSB7XHJcbiAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICBtb3ZlKGRhdGEpO1xyXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xyXG4gICAgICBkYXRhW2ldID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xyXG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnBhcnNlKHN0YXJ0LCBjb3VudCk7XHJcbiAgICBpZiAocmVzZXROZXdFbGVtZW50cykge1xyXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHVwZGF0ZUVsZW1lbnRzKGVsZW1lbnQsIHN0YXJ0LCBjb3VudCwgbW9kZSkge31cclxuICBfcmVtb3ZlRWxlbWVudHMoc3RhcnQsIGNvdW50KSB7XHJcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcclxuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XHJcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtZXRhLl9wYXJzZWQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XHJcbiAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XHJcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSwgcmVtb3ZlZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG1ldGEuZGF0YS5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcclxuICB9XHJcbiAgX3N5bmMoYXJncykge1xyXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcclxuICAgICAgdGhpcy5fc3luY0xpc3QucHVzaChhcmdzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcclxuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbdGhpcy5pbmRleCwgLi4uYXJnc10pO1xyXG4gIH1cclxuICBfb25EYXRhUHVzaCgpIHtcclxuICAgIGNvbnN0IGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCB0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudF0pO1xyXG4gIH1cclxuICBfb25EYXRhUG9wKCkge1xyXG4gICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGggLSAxLCAxXSk7XHJcbiAgfVxyXG4gIF9vbkRhdGFTaGlmdCgpIHtcclxuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCAwLCAxXSk7XHJcbiAgfVxyXG4gIF9vbkRhdGFTcGxpY2Uoc3RhcnQsIGNvdW50KSB7XHJcbiAgICBpZiAoY291bnQpIHtcclxuICAgICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHN0YXJ0LCBjb3VudF0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3Q291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcclxuICAgIGlmIChuZXdDb3VudCkge1xyXG4gICAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgc3RhcnQsIG5ld0NvdW50XSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9vbkRhdGFVbnNoaWZ0KCkge1xyXG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIDAsIGFyZ3VtZW50cy5sZW5ndGhdKTtcclxuICB9XHJcbn1cclxuRGF0YXNldENvbnRyb2xsZXIuZGVmYXVsdHMgPSB7fTtcclxuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XHJcbkRhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5kYXRhRWxlbWVudFR5cGUgPSBudWxsO1xyXG5cclxuY2xhc3MgRWxlbWVudCB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb24pIHtcclxuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XHJcbiAgICByZXR1cm4ge3gsIHl9O1xyXG4gIH1cclxuICBoYXNWYWx1ZSgpIHtcclxuICAgIHJldHVybiBpc051bWJlcih0aGlzLngpICYmIGlzTnVtYmVyKHRoaXMueSk7XHJcbiAgfVxyXG4gIGdldFByb3BzKHByb3BzLCBmaW5hbCkge1xyXG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xyXG4gICAgaWYgKCFmaW5hbCB8fCAhYW5pbXMpIHtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXQgPSB7fTtcclxuICAgIHByb3BzLmZvckVhY2gocHJvcCA9PiB7XHJcbiAgICAgIHJldFtwcm9wXSA9IGFuaW1zW3Byb3BdICYmIGFuaW1zW3Byb3BdLmFjdGl2ZSgpID8gYW5pbXNbcHJvcF0uX3RvIDogdGhpc1twcm9wXTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJldDtcclxuICB9XHJcbn1cclxuRWxlbWVudC5kZWZhdWx0cyA9IHt9O1xyXG5FbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB1bmRlZmluZWQ7XHJcblxyXG5jb25zdCBmb3JtYXR0ZXJzID0ge1xyXG4gIHZhbHVlcyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiAnJyArIHZhbHVlO1xyXG4gIH0sXHJcbiAgbnVtZXJpYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xyXG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gJzAnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZTtcclxuICAgIGxldCBub3RhdGlvbjtcclxuICAgIGxldCBkZWx0YSA9IHRpY2tWYWx1ZTtcclxuICAgIGlmICh0aWNrcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIGNvbnN0IG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXS52YWx1ZSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlKSk7XHJcbiAgICAgIGlmIChtYXhUaWNrIDwgMWUtNCB8fCBtYXhUaWNrID4gMWUrMTUpIHtcclxuICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcclxuICAgICAgfVxyXG4gICAgICBkZWx0YSA9IGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbG9nRGVsdGEgPSBsb2cxMChNYXRoLmFicyhkZWx0YSkpO1xyXG4gICAgY29uc3QgbnVtRGVjaW1hbCA9IE1hdGgubWF4KE1hdGgubWluKC0xICogTWF0aC5mbG9vcihsb2dEZWx0YSksIDIwKSwgMCk7XHJcbiAgICBjb25zdCBvcHRpb25zID0ge25vdGF0aW9uLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWwsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbH07XHJcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xyXG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih0aWNrVmFsdWUsIGxvY2FsZSwgb3B0aW9ucyk7XHJcbiAgfSxcclxuICBsb2dhcml0aG1pYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xyXG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gJzAnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVtYWluID0gdGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWx1ZSkpKSk7XHJcbiAgICBpZiAocmVtYWluID09PSAxIHx8IHJlbWFpbiA9PT0gMiB8fCByZW1haW4gPT09IDUpIHtcclxuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtZXJpYy5jYWxsKHRoaXMsIHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcclxuICAgIH1cclxuICAgIHJldHVybiAnJztcclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpIHtcclxuICBsZXQgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0udmFsdWUgLSB0aWNrc1sxXS52YWx1ZSA6IHRpY2tzWzFdLnZhbHVlIC0gdGlja3NbMF0udmFsdWU7XHJcbiAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAxICYmIHRpY2tWYWx1ZSAhPT0gTWF0aC5mbG9vcih0aWNrVmFsdWUpKSB7XHJcbiAgICBkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcclxuICB9XHJcbiAgcmV0dXJuIGRlbHRhO1xyXG59XHJcbnZhciBUaWNrcyA9IHtmb3JtYXR0ZXJzfTtcclxuXHJcbmRlZmF1bHRzLnNldCgnc2NhbGUnLCB7XHJcbiAgZGlzcGxheTogdHJ1ZSxcclxuICBvZmZzZXQ6IGZhbHNlLFxyXG4gIHJldmVyc2U6IGZhbHNlLFxyXG4gIGJlZ2luQXRaZXJvOiBmYWxzZSxcclxuICBib3VuZHM6ICd0aWNrcycsXHJcbiAgZ3JhY2U6IDAsXHJcbiAgZ3JpZDoge1xyXG4gICAgZGlzcGxheTogdHJ1ZSxcclxuICAgIGxpbmVXaWR0aDogMSxcclxuICAgIGRyYXdCb3JkZXI6IHRydWUsXHJcbiAgICBkcmF3T25DaGFydEFyZWE6IHRydWUsXHJcbiAgICBkcmF3VGlja3M6IHRydWUsXHJcbiAgICB0aWNrTGVuZ3RoOiA4LFxyXG4gICAgdGlja1dpZHRoOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5saW5lV2lkdGgsXHJcbiAgICB0aWNrQ29sb3I6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmNvbG9yLFxyXG4gICAgb2Zmc2V0OiBmYWxzZSxcclxuICAgIGJvcmRlckRhc2g6IFtdLFxyXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMC4wLFxyXG4gICAgYm9yZGVyV2lkdGg6IDFcclxuICB9LFxyXG4gIHRpdGxlOiB7XHJcbiAgICBkaXNwbGF5OiBmYWxzZSxcclxuICAgIHRleHQ6ICcnLFxyXG4gICAgcGFkZGluZzoge1xyXG4gICAgICB0b3A6IDQsXHJcbiAgICAgIGJvdHRvbTogNFxyXG4gICAgfVxyXG4gIH0sXHJcbiAgdGlja3M6IHtcclxuICAgIG1pblJvdGF0aW9uOiAwLFxyXG4gICAgbWF4Um90YXRpb246IDUwLFxyXG4gICAgbWlycm9yOiBmYWxzZSxcclxuICAgIHRleHRTdHJva2VXaWR0aDogMCxcclxuICAgIHRleHRTdHJva2VDb2xvcjogJycsXHJcbiAgICBwYWRkaW5nOiAzLFxyXG4gICAgZGlzcGxheTogdHJ1ZSxcclxuICAgIGF1dG9Ta2lwOiB0cnVlLFxyXG4gICAgYXV0b1NraXBQYWRkaW5nOiAzLFxyXG4gICAgbGFiZWxPZmZzZXQ6IDAsXHJcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXHJcbiAgICBtaW5vcjoge30sXHJcbiAgICBtYWpvcjoge30sXHJcbiAgICBhbGlnbjogJ2NlbnRlcicsXHJcbiAgICBjcm9zc0FsaWduOiAnbmVhcicsXHJcbiAgICBzaG93TGFiZWxCYWNrZHJvcDogZmFsc2UsXHJcbiAgICBiYWNrZHJvcENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KScsXHJcbiAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXHJcbiAgfVxyXG59KTtcclxuZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpY2tzJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xyXG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUuZ3JpZCcsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcclxuZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnYm9yZGVyQ29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XHJcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aXRsZScsICdjb2xvcicsICcnLCAnY29sb3InKTtcclxuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlJywge1xyXG4gIF9mYWxsYmFjazogZmFsc2UsXHJcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdiZWZvcmUnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdhZnRlcicpICYmIG5hbWUgIT09ICdjYWxsYmFjaycgJiYgbmFtZSAhPT0gJ3BhcnNlcicsXHJcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAndGlja0JvcmRlckRhc2gnLFxyXG59KTtcclxuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlcycsIHtcclxuICBfZmFsbGJhY2s6ICdzY2FsZScsXHJcbn0pO1xyXG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUudGlja3MnLCB7XHJcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyAmJiBuYW1lICE9PSAnY2FsbGJhY2snLFxyXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyxcclxufSk7XHJcblxyXG5mdW5jdGlvbiBhdXRvU2tpcChzY2FsZSwgdGlja3MpIHtcclxuICBjb25zdCB0aWNrT3B0cyA9IHNjYWxlLm9wdGlvbnMudGlja3M7XHJcbiAgY29uc3QgdGlja3NMaW1pdCA9IHRpY2tPcHRzLm1heFRpY2tzTGltaXQgfHwgZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpO1xyXG4gIGNvbnN0IG1ham9ySW5kaWNlcyA9IHRpY2tPcHRzLm1ham9yLmVuYWJsZWQgPyBnZXRNYWpvckluZGljZXModGlja3MpIDogW107XHJcbiAgY29uc3QgbnVtTWFqb3JJbmRpY2VzID0gbWFqb3JJbmRpY2VzLmxlbmd0aDtcclxuICBjb25zdCBmaXJzdCA9IG1ham9ySW5kaWNlc1swXTtcclxuICBjb25zdCBsYXN0ID0gbWFqb3JJbmRpY2VzW251bU1ham9ySW5kaWNlcyAtIDFdO1xyXG4gIGNvbnN0IG5ld1RpY2tzID0gW107XHJcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IHRpY2tzTGltaXQpIHtcclxuICAgIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xyXG4gICAgcmV0dXJuIG5ld1RpY2tzO1xyXG4gIH1cclxuICBjb25zdCBzcGFjaW5nID0gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KTtcclxuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gMCkge1xyXG4gICAgbGV0IGksIGlsZW47XHJcbiAgICBjb25zdCBhdmdNYWpvclNwYWNpbmcgPSBudW1NYWpvckluZGljZXMgPiAxID8gTWF0aC5yb3VuZCgobGFzdCAtIGZpcnN0KSAvIChudW1NYWpvckluZGljZXMgLSAxKSkgOiBudWxsO1xyXG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IDAgOiBmaXJzdCAtIGF2Z01ham9yU3BhY2luZywgZmlyc3QpO1xyXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspIHtcclxuICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9ySW5kaWNlc1tpXSwgbWFqb3JJbmRpY2VzW2kgKyAxXSk7XHJcbiAgICB9XHJcbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbGFzdCwgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gdGlja3MubGVuZ3RoIDogbGFzdCArIGF2Z01ham9yU3BhY2luZyk7XHJcbiAgICByZXR1cm4gbmV3VGlja3M7XHJcbiAgfVxyXG4gIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nKTtcclxuICByZXR1cm4gbmV3VGlja3M7XHJcbn1cclxuZnVuY3Rpb24gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpIHtcclxuICBjb25zdCBvZmZzZXQgPSBzY2FsZS5vcHRpb25zLm9mZnNldDtcclxuICBjb25zdCB0aWNrTGVuZ3RoID0gc2NhbGUuX3RpY2tTaXplKCk7XHJcbiAgY29uc3QgbWF4U2NhbGUgPSBzY2FsZS5fbGVuZ3RoIC8gdGlja0xlbmd0aCArIChvZmZzZXQgPyAwIDogMSk7XHJcbiAgY29uc3QgbWF4Q2hhcnQgPSBzY2FsZS5fbWF4TGVuZ3RoIC8gdGlja0xlbmd0aDtcclxuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhTY2FsZSwgbWF4Q2hhcnQpKTtcclxufVxyXG5mdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpIHtcclxuICBjb25zdCBldmVuTWFqb3JTcGFjaW5nID0gZ2V0RXZlblNwYWNpbmcobWFqb3JJbmRpY2VzKTtcclxuICBjb25zdCBzcGFjaW5nID0gdGlja3MubGVuZ3RoIC8gdGlja3NMaW1pdDtcclxuICBpZiAoIWV2ZW5NYWpvclNwYWNpbmcpIHtcclxuICAgIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcclxuICB9XHJcbiAgY29uc3QgZmFjdG9ycyA9IF9mYWN0b3JpemUoZXZlbk1ham9yU3BhY2luZyk7XHJcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBmYWN0b3JzLmxlbmd0aCAtIDE7IGkgPCBpbGVuOyBpKyspIHtcclxuICAgIGNvbnN0IGZhY3RvciA9IGZhY3RvcnNbaV07XHJcbiAgICBpZiAoZmFjdG9yID4gc3BhY2luZykge1xyXG4gICAgICByZXR1cm4gZmFjdG9yO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgbGV0IGksIGlsZW47XHJcbiAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xyXG4gICAgaWYgKHRpY2tzW2ldLm1ham9yKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIHNwYWNpbmcpIHtcclxuICBsZXQgY291bnQgPSAwO1xyXG4gIGxldCBuZXh0ID0gbWFqb3JJbmRpY2VzWzBdO1xyXG4gIGxldCBpO1xyXG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XHJcbiAgZm9yIChpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xyXG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcclxuICAgICAgY291bnQrKztcclxuICAgICAgbmV4dCA9IG1ham9ySW5kaWNlc1tjb3VudCAqIHNwYWNpbmddO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JTdGFydCwgbWFqb3JFbmQpIHtcclxuICBjb25zdCBzdGFydCA9IHZhbHVlT3JEZWZhdWx0KG1ham9yU3RhcnQsIDApO1xyXG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHZhbHVlT3JEZWZhdWx0KG1ham9yRW5kLCB0aWNrcy5sZW5ndGgpLCB0aWNrcy5sZW5ndGgpO1xyXG4gIGxldCBjb3VudCA9IDA7XHJcbiAgbGV0IGxlbmd0aCwgaSwgbmV4dDtcclxuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xyXG4gIGlmIChtYWpvckVuZCkge1xyXG4gICAgbGVuZ3RoID0gbWFqb3JFbmQgLSBtYWpvclN0YXJ0O1xyXG4gICAgc3BhY2luZyA9IGxlbmd0aCAvIE1hdGguZmxvb3IobGVuZ3RoIC8gc3BhY2luZyk7XHJcbiAgfVxyXG4gIG5leHQgPSBzdGFydDtcclxuICB3aGlsZSAobmV4dCA8IDApIHtcclxuICAgIGNvdW50Kys7XHJcbiAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XHJcbiAgfVxyXG4gIGZvciAoaSA9IE1hdGgubWF4KHN0YXJ0LCAwKTsgaSA8IGVuZDsgaSsrKSB7XHJcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xyXG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcclxuICAgICAgY291bnQrKztcclxuICAgICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBnZXRFdmVuU3BhY2luZyhhcnIpIHtcclxuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gIGxldCBpLCBkaWZmO1xyXG4gIGlmIChsZW4gPCAyKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGZvciAoZGlmZiA9IGFyclswXSwgaSA9IDE7IGkgPCBsZW47ICsraSkge1xyXG4gICAgaWYgKGFycltpXSAtIGFycltpIC0gMV0gIT09IGRpZmYpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZGlmZjtcclxufVxyXG5cclxuY29uc3QgcmV2ZXJzZUFsaWduID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6IGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogYWxpZ247XHJcbmNvbnN0IG9mZnNldEZyb21FZGdlID0gKHNjYWxlLCBlZGdlLCBvZmZzZXQpID0+IGVkZ2UgPT09ICd0b3AnIHx8IGVkZ2UgPT09ICdsZWZ0JyA/IHNjYWxlW2VkZ2VdICsgb2Zmc2V0IDogc2NhbGVbZWRnZV0gLSBvZmZzZXQ7XHJcbmZ1bmN0aW9uIHNhbXBsZShhcnIsIG51bUl0ZW1zKSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgY29uc3QgaW5jcmVtZW50ID0gYXJyLmxlbmd0aCAvIG51bUl0ZW1zO1xyXG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XHJcbiAgbGV0IGkgPSAwO1xyXG4gIGZvciAoOyBpIDwgbGVuOyBpICs9IGluY3JlbWVudCkge1xyXG4gICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBnZXRQaXhlbEZvckdyaWRMaW5lKHNjYWxlLCBpbmRleCwgb2Zmc2V0R3JpZExpbmVzKSB7XHJcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUudGlja3MubGVuZ3RoO1xyXG4gIGNvbnN0IHZhbGlkSW5kZXggPSBNYXRoLm1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XHJcbiAgY29uc3Qgc3RhcnQgPSBzY2FsZS5fc3RhcnRQaXhlbDtcclxuICBjb25zdCBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XHJcbiAgY29uc3QgZXBzaWxvbiA9IDFlLTY7XHJcbiAgbGV0IGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcclxuICBsZXQgb2Zmc2V0O1xyXG4gIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcclxuICAgIGlmIChsZW5ndGggPT09IDEpIHtcclxuICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgobGluZVZhbHVlIC0gc3RhcnQsIGVuZCAtIGxpbmVWYWx1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XHJcbiAgICAgIG9mZnNldCA9IChzY2FsZS5nZXRQaXhlbEZvclRpY2soMSkgLSBsaW5lVmFsdWUpIC8gMjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XHJcbiAgICB9XHJcbiAgICBsaW5lVmFsdWUgKz0gdmFsaWRJbmRleCA8IGluZGV4ID8gb2Zmc2V0IDogLW9mZnNldDtcclxuICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBsaW5lVmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcclxuICBlYWNoKGNhY2hlcywgKGNhY2hlKSA9PiB7XHJcbiAgICBjb25zdCBnYyA9IGNhY2hlLmdjO1xyXG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xyXG4gICAgbGV0IGk7XHJcbiAgICBpZiAoZ2NMZW4gPiBsZW5ndGgpIHtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyArK2kpIHtcclxuICAgICAgICBkZWxldGUgY2FjaGUuZGF0YVtnY1tpXV07XHJcbiAgICAgIH1cclxuICAgICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zKSB7XHJcbiAgcmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTGVuZ3RoIDogMDtcclxufVxyXG5mdW5jdGlvbiBnZXRUaXRsZUhlaWdodChvcHRpb25zLCBmYWxsYmFjaykge1xyXG4gIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgY29uc3QgZm9udCA9IHRvRm9udChvcHRpb25zLmZvbnQsIGZhbGxiYWNrKTtcclxuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XHJcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KG9wdGlvbnMudGV4dCkgPyBvcHRpb25zLnRleHQubGVuZ3RoIDogMTtcclxuICByZXR1cm4gKGxpbmVzICogZm9udC5saW5lSGVpZ2h0KSArIHBhZGRpbmcuaGVpZ2h0O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XHJcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XHJcbiAgICBzY2FsZSxcclxuICAgIHR5cGU6ICdzY2FsZSdcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVUaWNrQ29udGV4dChwYXJlbnQsIGluZGV4LCB0aWNrKSB7XHJcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XHJcbiAgICB0aWNrLFxyXG4gICAgaW5kZXgsXHJcbiAgICB0eXBlOiAndGljaydcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSkge1xyXG4gIGxldCByZXQgPSBfdG9MZWZ0UmlnaHRDZW50ZXIoYWxpZ24pO1xyXG4gIGlmICgocmV2ZXJzZSAmJiBwb3NpdGlvbiAhPT0gJ3JpZ2h0JykgfHwgKCFyZXZlcnNlICYmIHBvc2l0aW9uID09PSAncmlnaHQnKSkge1xyXG4gICAgcmV0ID0gcmV2ZXJzZUFsaWduKHJldCk7XHJcbiAgfVxyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xyXG4gIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIGNoYXJ0fSA9IHNjYWxlO1xyXG4gIGNvbnN0IHtjaGFydEFyZWEsIHNjYWxlc30gPSBjaGFydDtcclxuICBsZXQgcm90YXRpb24gPSAwO1xyXG4gIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XHJcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xyXG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xyXG4gIGlmIChzY2FsZS5pc0hvcml6b250YWwoKSkge1xyXG4gICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcclxuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcclxuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xyXG4gICAgICB0aXRsZVkgPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgaGVpZ2h0IC0gb2Zmc2V0O1xyXG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgdGl0bGVZID0gKGNoYXJ0QXJlYS5ib3R0b20gKyBjaGFydEFyZWEudG9wKSAvIDIgKyBoZWlnaHQgLSBvZmZzZXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aXRsZVkgPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XHJcbiAgICB9XHJcbiAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xyXG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcclxuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XHJcbiAgICAgIHRpdGxlWCA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgLSB3aWR0aCArIG9mZnNldDtcclxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XHJcbiAgICAgIHRpdGxlWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyIC0gd2lkdGggKyBvZmZzZXQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aXRsZVggPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XHJcbiAgICB9XHJcbiAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xyXG4gICAgcm90YXRpb24gPSBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gLUhBTEZfUEkgOiBIQUxGX1BJO1xyXG4gIH1cclxuICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xyXG59XHJcbmNsYXNzIFNjYWxlIGV4dGVuZHMgRWxlbWVudCB7XHJcbiAgY29uc3RydWN0b3IoY2ZnKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5pZCA9IGNmZy5pZDtcclxuICAgIHRoaXMudHlwZSA9IGNmZy50eXBlO1xyXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5jdHggPSBjZmcuY3R4O1xyXG4gICAgdGhpcy5jaGFydCA9IGNmZy5jaGFydDtcclxuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fbWFyZ2lucyA9IHtcclxuICAgICAgbGVmdDogMCxcclxuICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgIHRvcDogMCxcclxuICAgICAgYm90dG9tOiAwXHJcbiAgICB9O1xyXG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5wYWRkaW5nVG9wID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLm1heCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX3JhbmdlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy50aWNrcyA9IFtdO1xyXG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XHJcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcclxuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xyXG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcclxuICAgIHRoaXMuX21heExlbmd0aCA9IDA7XHJcbiAgICB0aGlzLl9sb25nZXN0VGV4dENhY2hlID0ge307XHJcbiAgICB0aGlzLl9zdGFydFBpeGVsID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gZmFsc2U7XHJcbiAgICB0aGlzLl91c2VyTWF4ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcclxuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gMDtcclxuICAgIHRoaXMuX2NhY2hlID0ge307XHJcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBpbml0KG9wdGlvbnMpIHtcclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XHJcbiAgICB0aGlzLmF4aXMgPSBvcHRpb25zLmF4aXM7XHJcbiAgICB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZShvcHRpb25zLm1pbik7XHJcbiAgICB0aGlzLl91c2VyTWF4ID0gdGhpcy5wYXJzZShvcHRpb25zLm1heCk7XHJcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWluKTtcclxuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5zdWdnZXN0ZWRNYXgpO1xyXG4gIH1cclxuICBwYXJzZShyYXcsIGluZGV4KSB7XHJcbiAgICByZXR1cm4gcmF3O1xyXG4gIH1cclxuICBnZXRVc2VyQm91bmRzKCkge1xyXG4gICAgbGV0IHtfdXNlck1pbiwgX3VzZXJNYXgsIF9zdWdnZXN0ZWRNaW4sIF9zdWdnZXN0ZWRNYXh9ID0gdGhpcztcclxuICAgIF91c2VyTWluID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xyXG4gICAgX3VzZXJNYXggPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XHJcbiAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XHJcbiAgICBfc3VnZ2VzdGVkTWF4ID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChfdXNlck1pbiwgX3N1Z2dlc3RlZE1pbiksXHJcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBfc3VnZ2VzdGVkTWF4KSxcclxuICAgICAgbWluRGVmaW5lZDogaXNOdW1iZXJGaW5pdGUoX3VzZXJNaW4pLFxyXG4gICAgICBtYXhEZWZpbmVkOiBpc051bWJlckZpbml0ZShfdXNlck1heClcclxuICAgIH07XHJcbiAgfVxyXG4gIGdldE1pbk1heChjYW5TdGFjaykge1xyXG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcclxuICAgIGxldCByYW5nZTtcclxuICAgIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHttaW4sIG1heH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcclxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIHJhbmdlID0gbWV0YXNbaV0uY29udHJvbGxlci5nZXRNaW5NYXgodGhpcywgY2FuU3RhY2spO1xyXG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcclxuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJhbmdlLm1pbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XHJcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByYW5nZS5tYXgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBtaW4gPSBtYXhEZWZpbmVkICYmIG1pbiA+IG1heCA/IG1heCA6IG1pbjtcclxuICAgIG1heCA9IG1pbkRlZmluZWQgJiYgbWluID4gbWF4ID8gbWluIDogbWF4O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQobWluLCBmaW5pdGVPckRlZmF1bHQobWF4LCBtaW4pKSxcclxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQobWF4LCBmaW5pdGVPckRlZmF1bHQobWluLCBtYXgpKVxyXG4gICAgfTtcclxuICB9XHJcbiAgZ2V0UGFkZGluZygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxlZnQ6IHRoaXMucGFkZGluZ0xlZnQgfHwgMCxcclxuICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcclxuICAgICAgcmlnaHQ6IHRoaXMucGFkZGluZ1JpZ2h0IHx8IDAsXHJcbiAgICAgIGJvdHRvbTogdGhpcy5wYWRkaW5nQm90dG9tIHx8IDBcclxuICAgIH07XHJcbiAgfVxyXG4gIGdldFRpY2tzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudGlja3M7XHJcbiAgfVxyXG4gIGdldExhYmVscygpIHtcclxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHMgfHwgW107XHJcbiAgfVxyXG4gIGJlZm9yZUxheW91dCgpIHtcclxuICAgIHRoaXMuX2NhY2hlID0ge307XHJcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XHJcbiAgfVxyXG4gIGJlZm9yZVVwZGF0ZSgpIHtcclxuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XHJcbiAgfVxyXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XHJcbiAgICBjb25zdCB7YmVnaW5BdFplcm8sIGdyYWNlLCB0aWNrczogdGlja09wdHN9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRpY2tPcHRzLnNhbXBsZVNpemU7XHJcbiAgICB0aGlzLmJlZm9yZVVwZGF0ZSgpO1xyXG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xyXG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XHJcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICBsZWZ0OiAwLFxyXG4gICAgICByaWdodDogMCxcclxuICAgICAgdG9wOiAwLFxyXG4gICAgICBib3R0b206IDBcclxuICAgIH0sIG1hcmdpbnMpO1xyXG4gICAgdGhpcy50aWNrcyA9IG51bGw7XHJcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcclxuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xyXG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XHJcbiAgICB0aGlzLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcclxuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xyXG4gICAgdGhpcy5hZnRlclNldERpbWVuc2lvbnMoKTtcclxuICAgIHRoaXMuX21heExlbmd0aCA9IHRoaXMuaXNIb3Jpem9udGFsKClcclxuICAgICAgPyB0aGlzLndpZHRoICsgbWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodFxyXG4gICAgICA6IHRoaXMuaGVpZ2h0ICsgbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbTtcclxuICAgIGlmICghdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCkge1xyXG4gICAgICB0aGlzLmJlZm9yZURhdGFMaW1pdHMoKTtcclxuICAgICAgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XHJcbiAgICAgIHRoaXMuYWZ0ZXJEYXRhTGltaXRzKCk7XHJcbiAgICAgIHRoaXMuX3JhbmdlID0gX2FkZEdyYWNlKHRoaXMsIGdyYWNlLCBiZWdpbkF0WmVybyk7XHJcbiAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdGhpcy5iZWZvcmVCdWlsZFRpY2tzKCk7XHJcbiAgICB0aGlzLnRpY2tzID0gdGhpcy5idWlsZFRpY2tzKCkgfHwgW107XHJcbiAgICB0aGlzLmFmdGVyQnVpbGRUaWNrcygpO1xyXG4gICAgY29uc3Qgc2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRoaXMudGlja3MubGVuZ3RoO1xyXG4gICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHMoc2FtcGxpbmdFbmFibGVkID8gc2FtcGxlKHRoaXMudGlja3MsIHNhbXBsZVNpemUpIDogdGhpcy50aWNrcyk7XHJcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xyXG4gICAgdGhpcy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XHJcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcclxuICAgIHRoaXMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XHJcbiAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiAodGlja09wdHMuYXV0b1NraXAgfHwgdGlja09wdHMuc291cmNlID09PSAnYXV0bycpKSB7XHJcbiAgICAgIHRoaXMudGlja3MgPSBhdXRvU2tpcCh0aGlzLCB0aGlzLnRpY2tzKTtcclxuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XHJcbiAgICAgIHRoaXMuYWZ0ZXJBdXRvU2tpcCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHNhbXBsaW5nRW5hYmxlZCkge1xyXG4gICAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyh0aGlzLnRpY2tzKTtcclxuICAgIH1cclxuICAgIHRoaXMuYmVmb3JlRml0KCk7XHJcbiAgICB0aGlzLmZpdCgpO1xyXG4gICAgdGhpcy5hZnRlckZpdCgpO1xyXG4gICAgdGhpcy5hZnRlclVwZGF0ZSgpO1xyXG4gIH1cclxuICBjb25maWd1cmUoKSB7XHJcbiAgICBsZXQgcmV2ZXJzZVBpeGVscyA9IHRoaXMub3B0aW9ucy5yZXZlcnNlO1xyXG4gICAgbGV0IHN0YXJ0UGl4ZWwsIGVuZFBpeGVsO1xyXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcclxuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMubGVmdDtcclxuICAgICAgZW5kUGl4ZWwgPSB0aGlzLnJpZ2h0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMudG9wO1xyXG4gICAgICBlbmRQaXhlbCA9IHRoaXMuYm90dG9tO1xyXG4gICAgICByZXZlcnNlUGl4ZWxzID0gIXJldmVyc2VQaXhlbHM7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcclxuICAgIHRoaXMuX2VuZFBpeGVsID0gZW5kUGl4ZWw7XHJcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gcmV2ZXJzZVBpeGVscztcclxuICAgIHRoaXMuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcclxuICAgIHRoaXMuX2FsaWduVG9QaXhlbHMgPSB0aGlzLm9wdGlvbnMuYWxpZ25Ub1BpeGVscztcclxuICB9XHJcbiAgYWZ0ZXJVcGRhdGUoKSB7XHJcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XHJcbiAgfVxyXG4gIGJlZm9yZVNldERpbWVuc2lvbnMoKSB7XHJcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcclxuICB9XHJcbiAgc2V0RGltZW5zaW9ucygpIHtcclxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XHJcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xyXG4gICAgICB0aGlzLmxlZnQgPSAwO1xyXG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XHJcbiAgICAgIHRoaXMudG9wID0gMDtcclxuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcclxuICAgIH1cclxuICAgIHRoaXMucGFkZGluZ0xlZnQgPSAwO1xyXG4gICAgdGhpcy5wYWRkaW5nVG9wID0gMDtcclxuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gMDtcclxuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7XHJcbiAgfVxyXG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcclxuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XHJcbiAgfVxyXG4gIF9jYWxsSG9va3MobmFtZSkge1xyXG4gICAgdGhpcy5jaGFydC5ub3RpZnlQbHVnaW5zKG5hbWUsIHRoaXMuZ2V0Q29udGV4dCgpKTtcclxuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9uc1tuYW1lXSwgW3RoaXNdKTtcclxuICB9XHJcbiAgYmVmb3JlRGF0YUxpbWl0cygpIHtcclxuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlRGF0YUxpbWl0cycpO1xyXG4gIH1cclxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge31cclxuICBhZnRlckRhdGFMaW1pdHMoKSB7XHJcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyRGF0YUxpbWl0cycpO1xyXG4gIH1cclxuICBiZWZvcmVCdWlsZFRpY2tzKCkge1xyXG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVCdWlsZFRpY2tzJyk7XHJcbiAgfVxyXG4gIGJ1aWxkVGlja3MoKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIGFmdGVyQnVpbGRUaWNrcygpIHtcclxuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJCdWlsZFRpY2tzJyk7XHJcbiAgfVxyXG4gIGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcclxuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XHJcbiAgfVxyXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xyXG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XHJcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcclxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcclxuICAgICAgdGljayA9IHRpY2tzW2ldO1xyXG4gICAgICB0aWNrLmxhYmVsID0gY2FsbGJhY2sodGlja09wdHMuY2FsbGJhY2ssIFt0aWNrLnZhbHVlLCBpLCB0aWNrc10sIHRoaXMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcclxuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcclxuICB9XHJcbiAgYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcclxuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xyXG4gIH1cclxuICBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcclxuICAgIGNvbnN0IG51bVRpY2tzID0gdGhpcy50aWNrcy5sZW5ndGg7XHJcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XHJcbiAgICBjb25zdCBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xyXG4gICAgbGV0IGxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcclxuICAgIGxldCB0aWNrV2lkdGgsIG1heEhlaWdodCwgbWF4TGFiZWxEaWFnb25hbDtcclxuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xyXG4gICAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcclxuICAgIGNvbnN0IG1heExhYmVsV2lkdGggPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcclxuICAgIGNvbnN0IG1heExhYmVsSGVpZ2h0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodDtcclxuICAgIGNvbnN0IG1heFdpZHRoID0gX2xpbWl0VmFsdWUodGhpcy5jaGFydC53aWR0aCAtIG1heExhYmVsV2lkdGgsIDAsIHRoaXMubWF4V2lkdGgpO1xyXG4gICAgdGlja1dpZHRoID0gb3B0aW9ucy5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gbnVtVGlja3MgOiBtYXhXaWR0aCAvIChudW1UaWNrcyAtIDEpO1xyXG4gICAgaWYgKG1heExhYmVsV2lkdGggKyA2ID4gdGlja1dpZHRoKSB7XHJcbiAgICAgIHRpY2tXaWR0aCA9IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gKG9wdGlvbnMub2Zmc2V0ID8gMC41IDogMSkpO1xyXG4gICAgICBtYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZClcclxuXHRcdFx0XHQtIHRpY2tPcHRzLnBhZGRpbmcgLSBnZXRUaXRsZUhlaWdodChvcHRpb25zLnRpdGxlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuZm9udCk7XHJcbiAgICAgIG1heExhYmVsRGlhZ29uYWwgPSBNYXRoLnNxcnQobWF4TGFiZWxXaWR0aCAqIG1heExhYmVsV2lkdGggKyBtYXhMYWJlbEhlaWdodCAqIG1heExhYmVsSGVpZ2h0KTtcclxuICAgICAgbGFiZWxSb3RhdGlvbiA9IHRvRGVncmVlcyhNYXRoLm1pbihcclxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUoKGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyA2KSAvIHRpY2tXaWR0aCwgLTEsIDEpKSxcclxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4SGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKSAtIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhMYWJlbEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSlcclxuICAgICAgKSk7XHJcbiAgICAgIGxhYmVsUm90YXRpb24gPSBNYXRoLm1heChtaW5Sb3RhdGlvbiwgTWF0aC5taW4obWF4Um90YXRpb24sIGxhYmVsUm90YXRpb24pKTtcclxuICAgIH1cclxuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XHJcbiAgfVxyXG4gIGFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcclxuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XHJcbiAgfVxyXG4gIGFmdGVyQXV0b1NraXAoKSB7fVxyXG4gIGJlZm9yZUZpdCgpIHtcclxuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XHJcbiAgfVxyXG4gIGZpdCgpIHtcclxuICAgIGNvbnN0IG1pblNpemUgPSB7XHJcbiAgICAgIHdpZHRoOiAwLFxyXG4gICAgICBoZWlnaHQ6IDBcclxuICAgIH07XHJcbiAgICBjb25zdCB7Y2hhcnQsIG9wdGlvbnM6IHt0aWNrczogdGlja09wdHMsIHRpdGxlOiB0aXRsZU9wdHMsIGdyaWQ6IGdyaWRPcHRzfX0gPSB0aGlzO1xyXG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMuX2lzVmlzaWJsZSgpO1xyXG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcclxuICAgIGlmIChkaXNwbGF5KSB7XHJcbiAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gZ2V0VGl0bGVIZWlnaHQodGl0bGVPcHRzLCBjaGFydC5vcHRpb25zLmZvbnQpO1xyXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IHRoaXMubWF4V2lkdGg7XHJcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtaW5TaXplLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xyXG4gICAgICAgIG1pblNpemUud2lkdGggPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiB0aGlzLnRpY2tzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgd2lkZXN0LCBoaWdoZXN0fSA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcclxuICAgICAgICBjb25zdCB0aWNrUGFkZGluZyA9IHRpY2tPcHRzLnBhZGRpbmcgKiAyO1xyXG4gICAgICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xyXG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XHJcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcclxuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICBjb25zdCBsYWJlbEhlaWdodCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBzaW4gKiB3aWRlc3Qud2lkdGggKyBjb3MgKiBoaWdoZXN0LmhlaWdodDtcclxuICAgICAgICAgIG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogY29zICogd2lkZXN0LndpZHRoICsgc2luICogaGlnaGVzdC5oZWlnaHQ7XHJcbiAgICAgICAgICBtaW5TaXplLndpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhYmVsV2lkdGggKyB0aWNrUGFkZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5faGFuZGxlTWFyZ2lucygpO1xyXG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0O1xyXG4gICAgICB0aGlzLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy53aWR0aCA9IG1pblNpemUud2lkdGg7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQuaGVpZ2h0IC0gdGhpcy5fbWFyZ2lucy50b3AgLSB0aGlzLl9tYXJnaW5zLmJvdHRvbTtcclxuICAgIH1cclxuICB9XHJcbiAgX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKSB7XHJcbiAgICBjb25zdCB7dGlja3M6IHthbGlnbiwgcGFkZGluZ30sIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IGlzUm90YXRlZCA9IHRoaXMubGFiZWxSb3RhdGlvbiAhPT0gMDtcclxuICAgIGNvbnN0IGxhYmVsc0JlbG93VGlja3MgPSBwb3NpdGlvbiAhPT0gJ3RvcCcgJiYgdGhpcy5heGlzID09PSAneCc7XHJcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xyXG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gdGhpcy5nZXRQaXhlbEZvclRpY2soMCkgLSB0aGlzLmxlZnQ7XHJcbiAgICAgIGNvbnN0IG9mZnNldFJpZ2h0ID0gdGhpcy5yaWdodCAtIHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKHRoaXMudGlja3MubGVuZ3RoIC0gMSk7XHJcbiAgICAgIGxldCBwYWRkaW5nTGVmdCA9IDA7XHJcbiAgICAgIGxldCBwYWRkaW5nUmlnaHQgPSAwO1xyXG4gICAgICBpZiAoaXNSb3RhdGVkKSB7XHJcbiAgICAgICAgaWYgKGxhYmVsc0JlbG93VGlja3MpIHtcclxuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XHJcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBzaW4gKiBsYXN0LmhlaWdodDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XHJcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBjb3MgKiBsYXN0LndpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xyXG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGg7XHJcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XHJcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aDtcclxuICAgICAgfSBlbHNlIGlmIChhbGlnbiAhPT0gJ2lubmVyJykge1xyXG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGggLyAyO1xyXG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGggLyAyO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMucGFkZGluZ0xlZnQgPSBNYXRoLm1heCgocGFkZGluZ0xlZnQgLSBvZmZzZXRMZWZ0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRMZWZ0KSwgMCk7XHJcbiAgICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRSaWdodCksIDApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodCAvIDI7XHJcbiAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0IC8gMjtcclxuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XHJcbiAgICAgICAgcGFkZGluZ1RvcCA9IDA7XHJcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodDtcclxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcclxuICAgICAgICBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQ7XHJcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcCArIHBhZGRpbmc7XHJcbiAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b20gKyBwYWRkaW5nO1xyXG4gICAgfVxyXG4gIH1cclxuICBfaGFuZGxlTWFyZ2lucygpIHtcclxuICAgIGlmICh0aGlzLl9tYXJnaW5zKSB7XHJcbiAgICAgIHRoaXMuX21hcmdpbnMubGVmdCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0xlZnQsIHRoaXMuX21hcmdpbnMubGVmdCk7XHJcbiAgICAgIHRoaXMuX21hcmdpbnMudG9wID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nVG9wLCB0aGlzLl9tYXJnaW5zLnRvcCk7XHJcbiAgICAgIHRoaXMuX21hcmdpbnMucmlnaHQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdSaWdodCwgdGhpcy5fbWFyZ2lucy5yaWdodCk7XHJcbiAgICAgIHRoaXMuX21hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nQm90dG9tLCB0aGlzLl9tYXJnaW5zLmJvdHRvbSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGFmdGVyRml0KCkge1xyXG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbdGhpc10pO1xyXG4gIH1cclxuICBpc0hvcml6b250YWwoKSB7XHJcbiAgICBjb25zdCB7YXhpcywgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgYXhpcyA9PT0gJ3gnO1xyXG4gIH1cclxuICBpc0Z1bGxTaXplKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsU2l6ZTtcclxuICB9XHJcbiAgX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB7XHJcbiAgICB0aGlzLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xyXG4gICAgdGhpcy5nZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpO1xyXG4gICAgbGV0IGksIGlsZW47XHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XHJcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHRpY2tzW2ldLmxhYmVsKSkge1xyXG4gICAgICAgIHRpY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgICBpbGVuLS07XHJcbiAgICAgICAgaS0tO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XHJcbiAgfVxyXG4gIF9nZXRMYWJlbFNpemVzKCkge1xyXG4gICAgbGV0IGxhYmVsU2l6ZXMgPSB0aGlzLl9sYWJlbFNpemVzO1xyXG4gICAgaWYgKCFsYWJlbFNpemVzKSB7XHJcbiAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcclxuICAgICAgbGV0IHRpY2tzID0gdGhpcy50aWNrcztcclxuICAgICAgaWYgKHNhbXBsZVNpemUgPCB0aWNrcy5sZW5ndGgpIHtcclxuICAgICAgICB0aWNrcyA9IHNhbXBsZSh0aWNrcywgc2FtcGxlU2l6ZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IGxhYmVsU2l6ZXMgPSB0aGlzLl9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgdGlja3MubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsYWJlbFNpemVzO1xyXG4gIH1cclxuICBfY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIGxlbmd0aCkge1xyXG4gICAgY29uc3Qge2N0eCwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlc30gPSB0aGlzO1xyXG4gICAgY29uc3Qgd2lkdGhzID0gW107XHJcbiAgICBjb25zdCBoZWlnaHRzID0gW107XHJcbiAgICBsZXQgd2lkZXN0TGFiZWxTaXplID0gMDtcclxuICAgIGxldCBoaWdoZXN0TGFiZWxTaXplID0gMDtcclxuICAgIGxldCBpLCBqLCBqbGVuLCBsYWJlbCwgdGlja0ZvbnQsIGZvbnRTdHJpbmcsIGNhY2hlLCBsaW5lSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBuZXN0ZWRMYWJlbDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICBsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xyXG4gICAgICB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XHJcbiAgICAgIGN0eC5mb250ID0gZm9udFN0cmluZyA9IHRpY2tGb250LnN0cmluZztcclxuICAgICAgY2FjaGUgPSBjYWNoZXNbZm9udFN0cmluZ10gPSBjYWNoZXNbZm9udFN0cmluZ10gfHwge2RhdGE6IHt9LCBnYzogW119O1xyXG4gICAgICBsaW5lSGVpZ2h0ID0gdGlja0ZvbnQubGluZUhlaWdodDtcclxuICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xyXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobGFiZWwpICYmICFpc0FycmF5KGxhYmVsKSkge1xyXG4gICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBsYWJlbCk7XHJcbiAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcclxuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGxhYmVsKSkge1xyXG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbC5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcclxuICAgICAgICAgIG5lc3RlZExhYmVsID0gbGFiZWxbal07XHJcbiAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobmVzdGVkTGFiZWwpICYmICFpc0FycmF5KG5lc3RlZExhYmVsKSkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbmVzdGVkTGFiZWwpO1xyXG4gICAgICAgICAgICBoZWlnaHQgKz0gbGluZUhlaWdodDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgd2lkdGhzLnB1c2god2lkdGgpO1xyXG4gICAgICBoZWlnaHRzLnB1c2goaGVpZ2h0KTtcclxuICAgICAgd2lkZXN0TGFiZWxTaXplID0gTWF0aC5tYXgod2lkdGgsIHdpZGVzdExhYmVsU2l6ZSk7XHJcbiAgICAgIGhpZ2hlc3RMYWJlbFNpemUgPSBNYXRoLm1heChoZWlnaHQsIGhpZ2hlc3RMYWJlbFNpemUpO1xyXG4gICAgfVxyXG4gICAgZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpO1xyXG4gICAgY29uc3Qgd2lkZXN0ID0gd2lkdGhzLmluZGV4T2Yod2lkZXN0TGFiZWxTaXplKTtcclxuICAgIGNvbnN0IGhpZ2hlc3QgPSBoZWlnaHRzLmluZGV4T2YoaGlnaGVzdExhYmVsU2l6ZSk7XHJcbiAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCkgPT4gKHt3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCwgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZmlyc3Q6IHZhbHVlQXQoMCksXHJcbiAgICAgIGxhc3Q6IHZhbHVlQXQobGVuZ3RoIC0gMSksXHJcbiAgICAgIHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxyXG4gICAgICBoaWdoZXN0OiB2YWx1ZUF0KGhpZ2hlc3QpLFxyXG4gICAgICB3aWR0aHMsXHJcbiAgICAgIGhlaWdodHMsXHJcbiAgICB9O1xyXG4gIH1cclxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUsIGluZGV4KSB7XHJcbiAgICByZXR1cm4gTmFOO1xyXG4gIH1cclxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7fVxyXG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xyXG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xyXG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XHJcbiAgfVxyXG4gIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XHJcbiAgICBpZiAodGhpcy5fcmV2ZXJzZVBpeGVscykge1xyXG4gICAgICBkZWNpbWFsID0gMSAtIGRlY2ltYWw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwaXhlbCA9IHRoaXMuX3N0YXJ0UGl4ZWwgKyBkZWNpbWFsICogdGhpcy5fbGVuZ3RoO1xyXG4gICAgcmV0dXJuIF9pbnQxNlJhbmdlKHRoaXMuX2FsaWduVG9QaXhlbHMgPyBfYWxpZ25QaXhlbCh0aGlzLmNoYXJ0LCBwaXhlbCwgMCkgOiBwaXhlbCk7XHJcbiAgfVxyXG4gIGdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkge1xyXG4gICAgY29uc3QgZGVjaW1hbCA9IChwaXhlbCAtIHRoaXMuX3N0YXJ0UGl4ZWwpIC8gdGhpcy5fbGVuZ3RoO1xyXG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XHJcbiAgfVxyXG4gIGdldEJhc2VQaXhlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XHJcbiAgfVxyXG4gIGdldEJhc2VWYWx1ZSgpIHtcclxuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xyXG4gICAgcmV0dXJuIG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XHJcbiAgICAgIG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XHJcbiAgICAgIDA7XHJcbiAgfVxyXG4gIGdldENvbnRleHQoaW5kZXgpIHtcclxuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyB8fCBbXTtcclxuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XHJcbiAgICAgIHJldHVybiB0aWNrLiRjb250ZXh0IHx8XHJcblx0XHRcdFx0KHRpY2suJGNvbnRleHQgPSBjcmVhdGVUaWNrQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHRpY2spKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XHJcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlU2NhbGVDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzKSk7XHJcbiAgfVxyXG4gIF90aWNrU2l6ZSgpIHtcclxuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xyXG4gICAgY29uc3Qgcm90ID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XHJcbiAgICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcclxuICAgIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKHJvdCkpO1xyXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcclxuICAgIGNvbnN0IHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcclxuICAgIGNvbnN0IHcgPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy53aWRlc3Qud2lkdGggKyBwYWRkaW5nIDogMDtcclxuICAgIGNvbnN0IGggPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIHBhZGRpbmcgOiAwO1xyXG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKClcclxuICAgICAgPyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXHJcbiAgICAgIDogaCAqIHNpbiA8IHcgKiBjb3MgPyBoIC8gY29zIDogdyAvIHNpbjtcclxuICB9XHJcbiAgX2lzVmlzaWJsZSgpIHtcclxuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLm9wdGlvbnMuZGlzcGxheTtcclxuICAgIGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcclxuICAgICAgcmV0dXJuICEhZGlzcGxheTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCkubGVuZ3RoID4gMDtcclxuICB9XHJcbiAgX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkge1xyXG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcclxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCB7Z3JpZCwgcG9zaXRpb259ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IG9mZnNldCA9IGdyaWQub2Zmc2V0O1xyXG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcclxuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcclxuICAgIGNvbnN0IHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldCA/IDEgOiAwKTtcclxuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZCk7XHJcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xyXG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XHJcbiAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXJPcHRzLmRyYXdCb3JkZXIgPyBib3JkZXJPcHRzLmJvcmRlcldpZHRoIDogMDtcclxuICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xyXG4gICAgY29uc3QgYWxpZ25Cb3JkZXJWYWx1ZSA9IGZ1bmN0aW9uKHBpeGVsKSB7XHJcbiAgICAgIHJldHVybiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIGF4aXNXaWR0aCk7XHJcbiAgICB9O1xyXG4gICAgbGV0IGJvcmRlclZhbHVlLCBpLCBsaW5lVmFsdWUsIGFsaWduZWRMaW5lVmFsdWU7XHJcbiAgICBsZXQgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MjtcclxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcclxuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuYm90dG9tKTtcclxuICAgICAgdHkxID0gdGhpcy5ib3R0b20gLSB0bDtcclxuICAgICAgdHkyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xyXG4gICAgICB5MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnRvcCkgKyBheGlzSGFsZldpZHRoO1xyXG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XHJcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xyXG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy50b3ApO1xyXG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XHJcbiAgICAgIHkyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEuYm90dG9tKSAtIGF4aXNIYWxmV2lkdGg7XHJcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcclxuICAgICAgdHkyID0gdGhpcy50b3AgKyB0bDtcclxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xyXG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5yaWdodCk7XHJcbiAgICAgIHR4MSA9IHRoaXMucmlnaHQgLSB0bDtcclxuICAgICAgdHgyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xyXG4gICAgICB4MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmxlZnQpICsgYXhpc0hhbGZXaWR0aDtcclxuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XHJcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XHJcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmxlZnQpO1xyXG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xyXG4gICAgICB4MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnJpZ2h0KSAtIGF4aXNIYWxmV2lkdGg7XHJcbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcclxuICAgICAgdHgyID0gdGhpcy5sZWZ0ICsgdGw7XHJcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xyXG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyICsgMC41KTtcclxuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcclxuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcclxuICAgICAgfVxyXG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XHJcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcclxuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xyXG4gICAgICB0eTIgPSB0eTEgKyB0bDtcclxuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XHJcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xyXG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcclxuICAgICAgdHgyID0gdHgxIC0gdGw7XHJcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XHJcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGltaXQgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQsIHRpY2tzTGVuZ3RoKTtcclxuICAgIGNvbnN0IHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGlja3NMZW5ndGggLyBsaW1pdCkpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHRpY2tzTGVuZ3RoOyBpICs9IHN0ZXApIHtcclxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGkpKTtcclxuICAgICAgY29uc3QgbGluZVdpZHRoID0gb3B0c0F0SW5kZXgubGluZVdpZHRoO1xyXG4gICAgICBjb25zdCBsaW5lQ29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcclxuICAgICAgY29uc3QgYm9yZGVyRGFzaCA9IGdyaWQuYm9yZGVyRGFzaCB8fCBbXTtcclxuICAgICAgY29uc3QgYm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XHJcbiAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IG9wdHNBdEluZGV4LnRpY2tXaWR0aDtcclxuICAgICAgY29uc3QgdGlja0NvbG9yID0gb3B0c0F0SW5kZXgudGlja0NvbG9yO1xyXG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoIHx8IFtdO1xyXG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoT2Zmc2V0O1xyXG4gICAgICBsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKHRoaXMsIGksIG9mZnNldCk7XHJcbiAgICAgIGlmIChsaW5lVmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGFsaWduZWRMaW5lVmFsdWUgPSBfYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xyXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgdHgxID0gdHgyID0geDEgPSB4MiA9IGFsaWduZWRMaW5lVmFsdWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduZWRMaW5lVmFsdWU7XHJcbiAgICAgIH1cclxuICAgICAgaXRlbXMucHVzaCh7XHJcbiAgICAgICAgdHgxLFxyXG4gICAgICAgIHR5MSxcclxuICAgICAgICB0eDIsXHJcbiAgICAgICAgdHkyLFxyXG4gICAgICAgIHgxLFxyXG4gICAgICAgIHkxLFxyXG4gICAgICAgIHgyLFxyXG4gICAgICAgIHkyLFxyXG4gICAgICAgIHdpZHRoOiBsaW5lV2lkdGgsXHJcbiAgICAgICAgY29sb3I6IGxpbmVDb2xvcixcclxuICAgICAgICBib3JkZXJEYXNoLFxyXG4gICAgICAgIGJvcmRlckRhc2hPZmZzZXQsXHJcbiAgICAgICAgdGlja1dpZHRoLFxyXG4gICAgICAgIHRpY2tDb2xvcixcclxuICAgICAgICB0aWNrQm9yZGVyRGFzaCxcclxuICAgICAgICB0aWNrQm9yZGVyRGFzaE9mZnNldCxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IHRpY2tzTGVuZ3RoO1xyXG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSBib3JkZXJWYWx1ZTtcclxuICAgIHJldHVybiBpdGVtcztcclxuICB9XHJcbiAgX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkge1xyXG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiBvcHRpb25UaWNrc30gPSBvcHRpb25zO1xyXG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcclxuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcclxuICAgIGNvbnN0IHthbGlnbiwgY3Jvc3NBbGlnbiwgcGFkZGluZywgbWlycm9yfSA9IG9wdGlvblRpY2tzO1xyXG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpO1xyXG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XHJcbiAgICBjb25zdCBoVGlja0FuZFBhZGRpbmcgPSBtaXJyb3IgPyAtcGFkZGluZyA6IHRpY2tBbmRQYWRkaW5nO1xyXG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XHJcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xyXG4gICAgbGV0IGksIGlsZW4sIHRpY2ssIGxhYmVsLCB4LCB5LCB0ZXh0QWxpZ24sIHBpeGVsLCBmb250LCBsaW5lSGVpZ2h0LCBsaW5lQ291bnQsIHRleHRPZmZzZXQ7XHJcbiAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XHJcbiAgICAgIHkgPSB0aGlzLmJvdHRvbSAtIGhUaWNrQW5kUGFkZGluZztcclxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xyXG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcclxuICAgICAgeSA9IHRoaXMudG9wICsgaFRpY2tBbmRQYWRkaW5nO1xyXG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XHJcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcclxuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XHJcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XHJcbiAgICAgIHggPSByZXQueDtcclxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcclxuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XHJcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XHJcbiAgICAgIHggPSByZXQueDtcclxuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XHJcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICB5ID0gKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyKSArIHRpY2tBbmRQYWRkaW5nO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xyXG4gICAgICAgIHkgPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyB0aWNrQW5kUGFkZGluZztcclxuICAgICAgfVxyXG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XHJcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xyXG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgeCA9ICgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMikgLSB0aWNrQW5kUGFkZGluZztcclxuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcclxuICAgICAgICB4ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpLnRleHRBbGlnbjtcclxuICAgIH1cclxuICAgIGlmIChheGlzID09PSAneScpIHtcclxuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XHJcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XHJcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XHJcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcclxuICAgICAgbGFiZWwgPSB0aWNrLmxhYmVsO1xyXG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IG9wdGlvblRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGkpKTtcclxuICAgICAgcGl4ZWwgPSB0aGlzLmdldFBpeGVsRm9yVGljayhpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xyXG4gICAgICBmb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcclxuICAgICAgbGluZUhlaWdodCA9IGZvbnQubGluZUhlaWdodDtcclxuICAgICAgbGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xyXG4gICAgICBjb25zdCBoYWxmQ291bnQgPSBsaW5lQ291bnQgLyAyO1xyXG4gICAgICBjb25zdCBjb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xyXG4gICAgICBjb25zdCBzdHJva2VDb2xvciA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcjtcclxuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGg7XHJcbiAgICAgIGxldCB0aWNrVGV4dEFsaWduID0gdGV4dEFsaWduO1xyXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgeCA9IHBpeGVsO1xyXG4gICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdpbm5lcicpIHtcclxuICAgICAgICAgIGlmIChpID09PSBpbGVuIC0gMSkge1xyXG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ3JpZ2h0JyA6ICdsZWZ0JztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ2xlZnQnIDogJ3JpZ2h0JztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xyXG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xyXG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxpbmVDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcclxuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxpbmVIZWlnaHQgLyAyO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLSBsaW5lQ291bnQgKiBsaW5lSGVpZ2h0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWlycm9yKSB7XHJcbiAgICAgICAgICB0ZXh0T2Zmc2V0ICo9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB5ID0gcGl4ZWw7XHJcbiAgICAgICAgdGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBiYWNrZHJvcDtcclxuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XHJcbiAgICAgICAgY29uc3QgbGFiZWxQYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplcy5oZWlnaHRzW2ldO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gbGFiZWxTaXplcy53aWR0aHNbaV07XHJcbiAgICAgICAgbGV0IHRvcCA9IHkgKyB0ZXh0T2Zmc2V0IC0gbGFiZWxQYWRkaW5nLnRvcDtcclxuICAgICAgICBsZXQgbGVmdCA9IHggLSBsYWJlbFBhZGRpbmcubGVmdDtcclxuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xyXG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XHJcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC8gMjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XHJcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcclxuICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiYWNrZHJvcCA9IHtcclxuICAgICAgICAgIGxlZnQsXHJcbiAgICAgICAgICB0b3AsXHJcbiAgICAgICAgICB3aWR0aDogd2lkdGggKyBsYWJlbFBhZGRpbmcud2lkdGgsXHJcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArIGxhYmVsUGFkZGluZy5oZWlnaHQsXHJcbiAgICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcixcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIGl0ZW1zLnB1c2goe1xyXG4gICAgICAgIHJvdGF0aW9uLFxyXG4gICAgICAgIGxhYmVsLFxyXG4gICAgICAgIGZvbnQsXHJcbiAgICAgICAgY29sb3IsXHJcbiAgICAgICAgc3Ryb2tlQ29sb3IsXHJcbiAgICAgICAgc3Ryb2tlV2lkdGgsXHJcbiAgICAgICAgdGV4dE9mZnNldCxcclxuICAgICAgICB0ZXh0QWxpZ246IHRpY2tUZXh0QWxpZ24sXHJcbiAgICAgICAgdGV4dEJhc2VsaW5lLFxyXG4gICAgICAgIHRyYW5zbGF0aW9uOiBbeCwgeV0sXHJcbiAgICAgICAgYmFja2Ryb3AsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGl0ZW1zO1xyXG4gIH1cclxuICBfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpIHtcclxuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3N9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XHJcbiAgICBpZiAocm90YXRpb24pIHtcclxuICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyA/ICdsZWZ0JyA6ICdyaWdodCc7XHJcbiAgICB9XHJcbiAgICBsZXQgYWxpZ24gPSAnY2VudGVyJztcclxuICAgIGlmICh0aWNrcy5hbGlnbiA9PT0gJ3N0YXJ0Jykge1xyXG4gICAgICBhbGlnbiA9ICdsZWZ0JztcclxuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdlbmQnKSB7XHJcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcclxuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdpbm5lcicpIHtcclxuICAgICAgYWxpZ24gPSAnaW5uZXInO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFsaWduO1xyXG4gIH1cclxuICBfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkge1xyXG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczoge2Nyb3NzQWxpZ24sIG1pcnJvciwgcGFkZGluZ319ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcclxuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xyXG4gICAgY29uc3Qgd2lkZXN0ID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XHJcbiAgICBsZXQgdGV4dEFsaWduO1xyXG4gICAgbGV0IHg7XHJcbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xyXG4gICAgICBpZiAobWlycm9yKSB7XHJcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgKyBwYWRkaW5nO1xyXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcclxuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcclxuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgIHggKz0gKHdpZGVzdCAvIDIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xyXG4gICAgICAgICAgeCArPSB3aWRlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHggPSB0aGlzLnJpZ2h0IC0gdGlja0FuZFBhZGRpbmc7XHJcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xyXG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcclxuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XHJcbiAgICAgICAgICB4ID0gdGhpcy5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICBpZiAobWlycm9yKSB7XHJcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHBhZGRpbmc7XHJcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xyXG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcclxuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XHJcbiAgICAgICAgICB4IC09IHdpZGVzdDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHRpY2tBbmRQYWRkaW5nO1xyXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcclxuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcclxuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgIHggKz0gd2lkZXN0IC8gMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcclxuICAgICAgICAgIHggPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcclxuICAgIH1cclxuICAgIHJldHVybiB7dGV4dEFsaWduLCB4fTtcclxuICB9XHJcbiAgX2NvbXB1dGVMYWJlbEFyZWEoKSB7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnRpY2tzLm1pcnJvcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XHJcbiAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiB0aGlzLmxlZnQsIGJvdHRvbTogY2hhcnQuaGVpZ2h0LCByaWdodDogdGhpcy5yaWdodH07XHJcbiAgICB9IGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XHJcbiAgICAgIHJldHVybiB7dG9wOiB0aGlzLnRvcCwgbGVmdDogMCwgYm90dG9tOiB0aGlzLmJvdHRvbSwgcmlnaHQ6IGNoYXJ0LndpZHRofTtcclxuICAgIH1cclxuICB9XHJcbiAgZHJhd0JhY2tncm91bmQoKSB7XHJcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7YmFja2dyb3VuZENvbG9yfSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fSA9IHRoaXM7XHJcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XHJcbiAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh2YWx1ZSkge1xyXG4gICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xyXG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZ3JpZC5kaXNwbGF5KSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xyXG4gICAgY29uc3QgaW5kZXggPSB0aWNrcy5maW5kSW5kZXgodCA9PiB0LnZhbHVlID09PSB2YWx1ZSk7XHJcbiAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICBjb25zdCBvcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xyXG4gICAgICByZXR1cm4gb3B0cy5saW5lV2lkdGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgZHJhd0dyaWQoY2hhcnRBcmVhKSB7XHJcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XHJcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcclxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ3JpZExpbmVJdGVtcyB8fCAodGhpcy5fZ3JpZExpbmVJdGVtcyA9IHRoaXMuX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkpO1xyXG4gICAgbGV0IGksIGlsZW47XHJcbiAgICBjb25zdCBkcmF3TGluZSA9IChwMSwgcDIsIHN0eWxlKSA9PiB7XHJcbiAgICAgIGlmICghc3R5bGUud2lkdGggfHwgIXN0eWxlLmNvbG9yKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS53aWR0aDtcclxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XHJcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChzdHlsZS5ib3JkZXJEYXNoIHx8IFtdKTtcclxuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gc3R5bGUuYm9yZGVyRGFzaE9mZnNldDtcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xyXG4gICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkpO1xyXG4gICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICB9O1xyXG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xyXG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xyXG4gICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xyXG4gICAgICAgICAgZHJhd0xpbmUoXHJcbiAgICAgICAgICAgIHt4OiBpdGVtLngxLCB5OiBpdGVtLnkxfSxcclxuICAgICAgICAgICAge3g6IGl0ZW0ueDIsIHk6IGl0ZW0ueTJ9LFxyXG4gICAgICAgICAgICBpdGVtXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ3JpZC5kcmF3VGlja3MpIHtcclxuICAgICAgICAgIGRyYXdMaW5lKFxyXG4gICAgICAgICAgICB7eDogaXRlbS50eDEsIHk6IGl0ZW0udHkxfSxcclxuICAgICAgICAgICAge3g6IGl0ZW0udHgyLCB5OiBpdGVtLnR5Mn0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBjb2xvcjogaXRlbS50aWNrQ29sb3IsXHJcbiAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0udGlja1dpZHRoLFxyXG4gICAgICAgICAgICAgIGJvcmRlckRhc2g6IGl0ZW0udGlja0JvcmRlckRhc2gsXHJcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogaXRlbS50aWNrQm9yZGVyRGFzaE9mZnNldFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBkcmF3Qm9yZGVyKCkge1xyXG4gICAgY29uc3Qge2NoYXJ0LCBjdHgsIG9wdGlvbnM6IHtncmlkfX0gPSB0aGlzO1xyXG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XHJcbiAgICBjb25zdCBheGlzV2lkdGggPSBncmlkLmRyYXdCb3JkZXIgPyBib3JkZXJPcHRzLmJvcmRlcldpZHRoIDogMDtcclxuICAgIGlmICghYXhpc1dpZHRoKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGxhc3RMaW5lV2lkdGggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KDApKS5saW5lV2lkdGg7XHJcbiAgICBjb25zdCBib3JkZXJWYWx1ZSA9IHRoaXMuX2JvcmRlclZhbHVlO1xyXG4gICAgbGV0IHgxLCB4MiwgeTEsIHkyO1xyXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcclxuICAgICAgeDEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5sZWZ0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcclxuICAgICAgeDIgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5yaWdodCwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcclxuICAgICAgeTEgPSB5MiA9IGJvcmRlclZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeTEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy50b3AsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xyXG4gICAgICB5MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcclxuICAgICAgeDEgPSB4MiA9IGJvcmRlclZhbHVlO1xyXG4gICAgfVxyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJPcHRzLmJvcmRlcldpZHRoO1xyXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyT3B0cy5ib3JkZXJDb2xvcjtcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcclxuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcclxuICAgIGN0eC5zdHJva2UoKTtcclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgfVxyXG4gIGRyYXdMYWJlbHMoY2hhcnRBcmVhKSB7XHJcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcclxuICAgIGlmICghb3B0aW9uVGlja3MuZGlzcGxheSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcclxuICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9jb21wdXRlTGFiZWxBcmVhKCk7XHJcbiAgICBpZiAoYXJlYSkge1xyXG4gICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9sYWJlbEl0ZW1zIHx8ICh0aGlzLl9sYWJlbEl0ZW1zID0gdGhpcy5fY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSk7XHJcbiAgICBsZXQgaSwgaWxlbjtcclxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xyXG4gICAgICBjb25zdCB0aWNrRm9udCA9IGl0ZW0uZm9udDtcclxuICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xyXG4gICAgICBpZiAoaXRlbS5iYWNrZHJvcCkge1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBpdGVtLmJhY2tkcm9wLmNvbG9yO1xyXG4gICAgICAgIGN0eC5maWxsUmVjdChpdGVtLmJhY2tkcm9wLmxlZnQsIGl0ZW0uYmFja2Ryb3AudG9wLCBpdGVtLmJhY2tkcm9wLndpZHRoLCBpdGVtLmJhY2tkcm9wLmhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IHkgPSBpdGVtLnRleHRPZmZzZXQ7XHJcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIGl0ZW0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGFyZWEpIHtcclxuICAgICAgdW5jbGlwQXJlYShjdHgpO1xyXG4gICAgfVxyXG4gIH1cclxuICBkcmF3VGl0bGUoKSB7XHJcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9zaXRpb24sIHRpdGxlLCByZXZlcnNlfX0gPSB0aGlzO1xyXG4gICAgaWYgKCF0aXRsZS5kaXNwbGF5KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGZvbnQgPSB0b0ZvbnQodGl0bGUuZm9udCk7XHJcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlLnBhZGRpbmcpO1xyXG4gICAgY29uc3QgYWxpZ24gPSB0aXRsZS5hbGlnbjtcclxuICAgIGxldCBvZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLyAyO1xyXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHwgaXNPYmplY3QocG9zaXRpb24pKSB7XHJcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLmJvdHRvbTtcclxuICAgICAgaWYgKGlzQXJyYXkodGl0bGUudGV4dCkpIHtcclxuICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLnRvcDtcclxuICAgIH1cclxuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRpdGxlQXJncyh0aGlzLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbik7XHJcbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGUudGV4dCwgMCwgMCwgZm9udCwge1xyXG4gICAgICBjb2xvcjogdGl0bGUuY29sb3IsXHJcbiAgICAgIG1heFdpZHRoLFxyXG4gICAgICByb3RhdGlvbixcclxuICAgICAgdGV4dEFsaWduOiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSksXHJcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXHJcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGRyYXcoY2hhcnRBcmVhKSB7XHJcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcclxuICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcclxuICAgIHRoaXMuZHJhd0JvcmRlcigpO1xyXG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcclxuICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xyXG4gIH1cclxuICBfbGF5ZXJzKCkge1xyXG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHR6ID0gb3B0cy50aWNrcyAmJiBvcHRzLnRpY2tzLnogfHwgMDtcclxuICAgIGNvbnN0IGd6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ncmlkICYmIG9wdHMuZ3JpZC56LCAtMSk7XHJcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8IHRoaXMuZHJhdyAhPT0gU2NhbGUucHJvdG90eXBlLmRyYXcpIHtcclxuICAgICAgcmV0dXJuIFt7XHJcbiAgICAgICAgejogdHosXHJcbiAgICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5kcmF3KGNoYXJ0QXJlYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XTtcclxuICAgIH1cclxuICAgIHJldHVybiBbe1xyXG4gICAgICB6OiBneixcclxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xyXG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcclxuICAgICAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XHJcbiAgICAgICAgdGhpcy5kcmF3VGl0bGUoKTtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICB6OiBneiArIDEsXHJcbiAgICAgIGRyYXc6ICgpID0+IHtcclxuICAgICAgICB0aGlzLmRyYXdCb3JkZXIoKTtcclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICB6OiB0eixcclxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xyXG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xyXG4gICAgICB9XHJcbiAgICB9XTtcclxuICB9XHJcbiAgZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkge1xyXG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcclxuICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuYXhpcyArICdBeGlzSUQnO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBsZXQgaSwgaWxlbjtcclxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xyXG4gICAgICBpZiAobWV0YVtheGlzSURdID09PSB0aGlzLmlkICYmICghdHlwZSB8fCBtZXRhLnR5cGUgPT09IHR5cGUpKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIF9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGluZGV4KSB7XHJcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XHJcbiAgICByZXR1cm4gdG9Gb250KG9wdHMuZm9udCk7XHJcbiAgfVxyXG4gIF9tYXhEaWdpdHMoKSB7XHJcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkubGluZUhlaWdodDtcclxuICAgIHJldHVybiAodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodCkgLyBmb250U2l6ZTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFR5cGVkUmVnaXN0cnkge1xyXG4gIGNvbnN0cnVjdG9yKHR5cGUsIHNjb3BlLCBvdmVycmlkZSkge1xyXG4gICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcclxuICAgIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZTtcclxuICAgIHRoaXMuaXRlbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gIH1cclxuICBpc0ZvclR5cGUodHlwZSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKHRoaXMudHlwZS5wcm90b3R5cGUsIHR5cGUucHJvdG90eXBlKTtcclxuICB9XHJcbiAgcmVnaXN0ZXIoaXRlbSkge1xyXG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaXRlbSk7XHJcbiAgICBsZXQgcGFyZW50U2NvcGU7XHJcbiAgICBpZiAoaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pKSB7XHJcbiAgICAgIHBhcmVudFNjb3BlID0gdGhpcy5yZWdpc3Rlcihwcm90byk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XHJcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XHJcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGUgKyAnLicgKyBpZDtcclxuICAgIGlmICghaWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBkb2VzIG5vdCBoYXZlIGlkOiAnICsgaXRlbSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaWQgaW4gaXRlbXMpIHtcclxuICAgICAgcmV0dXJuIHNjb3BlO1xyXG4gICAgfVxyXG4gICAgaXRlbXNbaWRdID0gaXRlbTtcclxuICAgIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKTtcclxuICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XHJcbiAgICAgIGRlZmF1bHRzLm92ZXJyaWRlKGl0ZW0uaWQsIGl0ZW0ub3ZlcnJpZGVzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzY29wZTtcclxuICB9XHJcbiAgZ2V0KGlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pdGVtc1tpZF07XHJcbiAgfVxyXG4gIHVucmVnaXN0ZXIoaXRlbSkge1xyXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xyXG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xyXG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xyXG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XHJcbiAgICAgIGRlbGV0ZSBpdGVtc1tpZF07XHJcbiAgICB9XHJcbiAgICBpZiAoc2NvcGUgJiYgaWQgaW4gZGVmYXVsdHNbc2NvcGVdKSB7XHJcbiAgICAgIGRlbGV0ZSBkZWZhdWx0c1tzY29wZV1baWRdO1xyXG4gICAgICBpZiAodGhpcy5vdmVycmlkZSkge1xyXG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNbaWRdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKSB7XHJcbiAgY29uc3QgaXRlbURlZmF1bHRzID0gbWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xyXG4gICAgcGFyZW50U2NvcGUgPyBkZWZhdWx0cy5nZXQocGFyZW50U2NvcGUpIDoge30sXHJcbiAgICBkZWZhdWx0cy5nZXQoc2NvcGUpLFxyXG4gICAgaXRlbS5kZWZhdWx0c1xyXG4gIF0pO1xyXG4gIGRlZmF1bHRzLnNldChzY29wZSwgaXRlbURlZmF1bHRzKTtcclxuICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XHJcbiAgICByb3V0ZURlZmF1bHRzKHNjb3BlLCBpdGVtLmRlZmF1bHRSb3V0ZXMpO1xyXG4gIH1cclxuICBpZiAoaXRlbS5kZXNjcmlwdG9ycykge1xyXG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoc2NvcGUsIGl0ZW0uZGVzY3JpcHRvcnMpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiByb3V0ZURlZmF1bHRzKHNjb3BlLCByb3V0ZXMpIHtcclxuICBPYmplY3Qua2V5cyhyb3V0ZXMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xyXG4gICAgY29uc3QgcHJvcGVydHlQYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XHJcbiAgICBjb25zdCBzb3VyY2VOYW1lID0gcHJvcGVydHlQYXJ0cy5wb3AoKTtcclxuICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gW3Njb3BlXS5jb25jYXQocHJvcGVydHlQYXJ0cykuam9pbignLicpO1xyXG4gICAgY29uc3QgcGFydHMgPSByb3V0ZXNbcHJvcGVydHldLnNwbGl0KCcuJyk7XHJcbiAgICBjb25zdCB0YXJnZXROYW1lID0gcGFydHMucG9wKCk7XHJcbiAgICBjb25zdCB0YXJnZXRTY29wZSA9IHBhcnRzLmpvaW4oJy4nKTtcclxuICAgIGRlZmF1bHRzLnJvdXRlKHNvdXJjZVNjb3BlLCBzb3VyY2VOYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSk7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pIHtcclxuICByZXR1cm4gJ2lkJyBpbiBwcm90byAmJiAnZGVmYXVsdHMnIGluIHByb3RvO1xyXG59XHJcblxyXG5jbGFzcyBSZWdpc3RyeSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IFR5cGVkUmVnaXN0cnkoRGF0YXNldENvbnRyb2xsZXIsICdkYXRhc2V0cycsIHRydWUpO1xyXG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KEVsZW1lbnQsICdlbGVtZW50cycpO1xyXG4gICAgdGhpcy5wbHVnaW5zID0gbmV3IFR5cGVkUmVnaXN0cnkoT2JqZWN0LCAncGx1Z2lucycpO1xyXG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgVHlwZWRSZWdpc3RyeShTY2FsZSwgJ3NjYWxlcycpO1xyXG4gICAgdGhpcy5fdHlwZWRSZWdpc3RyaWVzID0gW3RoaXMuY29udHJvbGxlcnMsIHRoaXMuc2NhbGVzLCB0aGlzLmVsZW1lbnRzXTtcclxuICB9XHJcbiAgYWRkKC4uLmFyZ3MpIHtcclxuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncyk7XHJcbiAgfVxyXG4gIHJlbW92ZSguLi5hcmdzKSB7XHJcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncyk7XHJcbiAgfVxyXG4gIGFkZENvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcclxuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XHJcbiAgfVxyXG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcclxuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5lbGVtZW50cyk7XHJcbiAgfVxyXG4gIGFkZFBsdWdpbnMoLi4uYXJncykge1xyXG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xyXG4gIH1cclxuICBhZGRTY2FsZXMoLi4uYXJncykge1xyXG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XHJcbiAgfVxyXG4gIGdldENvbnRyb2xsZXIoaWQpIHtcclxuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuY29udHJvbGxlcnMsICdjb250cm9sbGVyJyk7XHJcbiAgfVxyXG4gIGdldEVsZW1lbnQoaWQpIHtcclxuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuZWxlbWVudHMsICdlbGVtZW50Jyk7XHJcbiAgfVxyXG4gIGdldFBsdWdpbihpZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5wbHVnaW5zLCAncGx1Z2luJyk7XHJcbiAgfVxyXG4gIGdldFNjYWxlKGlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnNjYWxlcywgJ3NjYWxlJyk7XHJcbiAgfVxyXG4gIHJlbW92ZUNvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcclxuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcclxuICB9XHJcbiAgcmVtb3ZlRWxlbWVudHMoLi4uYXJncykge1xyXG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xyXG4gIH1cclxuICByZW1vdmVQbHVnaW5zKC4uLmFyZ3MpIHtcclxuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xyXG4gIH1cclxuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xyXG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcclxuICB9XHJcbiAgX2VhY2gobWV0aG9kLCBhcmdzLCB0eXBlZFJlZ2lzdHJ5KSB7XHJcbiAgICBbLi4uYXJnc10uZm9yRWFjaChhcmcgPT4ge1xyXG4gICAgICBjb25zdCByZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShhcmcpO1xyXG4gICAgICBpZiAodHlwZWRSZWdpc3RyeSB8fCByZWcuaXNGb3JUeXBlKGFyZykgfHwgKHJlZyA9PT0gdGhpcy5wbHVnaW5zICYmIGFyZy5pZCkpIHtcclxuICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgcmVnLCBhcmcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVhY2goYXJnLCBpdGVtID0+IHtcclxuICAgICAgICAgIGNvbnN0IGl0ZW1SZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShpdGVtKTtcclxuICAgICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCBpdGVtUmVnLCBpdGVtKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIF9leGVjKG1ldGhvZCwgcmVnaXN0cnksIGNvbXBvbmVudCkge1xyXG4gICAgY29uc3QgY2FtZWxNZXRob2QgPSBfY2FwaXRhbGl6ZShtZXRob2QpO1xyXG4gICAgY2FsbGJhY2soY29tcG9uZW50WydiZWZvcmUnICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcclxuICAgIHJlZ2lzdHJ5W21ldGhvZF0oY29tcG9uZW50KTtcclxuICAgIGNhbGxiYWNrKGNvbXBvbmVudFsnYWZ0ZXInICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcclxuICB9XHJcbiAgX2dldFJlZ2lzdHJ5Rm9yVHlwZSh0eXBlKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCByZWcgPSB0aGlzLl90eXBlZFJlZ2lzdHJpZXNbaV07XHJcbiAgICAgIGlmIChyZWcuaXNGb3JUeXBlKHR5cGUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucztcclxuICB9XHJcbiAgX2dldChpZCwgdHlwZWRSZWdpc3RyeSwgdHlwZSkge1xyXG4gICAgY29uc3QgaXRlbSA9IHR5cGVkUmVnaXN0cnkuZ2V0KGlkKTtcclxuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBpZCArICdcIiBpcyBub3QgYSByZWdpc3RlcmVkICcgKyB0eXBlICsgJy4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpdGVtO1xyXG4gIH1cclxufVxyXG52YXIgcmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkoKTtcclxuXHJcbmNsYXNzIFBsdWdpblNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5faW5pdCA9IFtdO1xyXG4gIH1cclxuICBub3RpZnkoY2hhcnQsIGhvb2ssIGFyZ3MsIGZpbHRlcikge1xyXG4gICAgaWYgKGhvb2sgPT09ICdiZWZvcmVJbml0Jykge1xyXG4gICAgICB0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHRydWUpO1xyXG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICdpbnN0YWxsJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IGZpbHRlciA/IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KS5maWx0ZXIoZmlsdGVyKSA6IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xyXG4gICAgaWYgKGhvb2sgPT09ICdhZnRlckRlc3Ryb3knKSB7XHJcbiAgICAgIHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsICdzdG9wJyk7XHJcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ3VuaW5zdGFsbCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpIHtcclxuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xyXG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XHJcbiAgICAgIGNvbnN0IHBsdWdpbiA9IGRlc2NyaXB0b3IucGx1Z2luO1xyXG4gICAgICBjb25zdCBtZXRob2QgPSBwbHVnaW5baG9va107XHJcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtjaGFydCwgYXJncywgZGVzY3JpcHRvci5vcHRpb25zXTtcclxuICAgICAgaWYgKGNhbGxiYWNrKG1ldGhvZCwgcGFyYW1zLCBwbHVnaW4pID09PSBmYWxzZSAmJiBhcmdzLmNhbmNlbGFibGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBpbnZhbGlkYXRlKCkge1xyXG4gICAgaWYgKCFpc051bGxPclVuZGVmKHRoaXMuX2NhY2hlKSkge1xyXG4gICAgICB0aGlzLl9vbGRDYWNoZSA9IHRoaXMuX2NhY2hlO1xyXG4gICAgICB0aGlzLl9jYWNoZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9XHJcbiAgX2Rlc2NyaXB0b3JzKGNoYXJ0KSB7XHJcbiAgICBpZiAodGhpcy5fY2FjaGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0KTtcclxuICAgIHRoaXMuX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCk7XHJcbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XHJcbiAgfVxyXG4gIF9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgYWxsKSB7XHJcbiAgICBjb25zdCBjb25maWcgPSBjaGFydCAmJiBjaGFydC5jb25maWc7XHJcbiAgICBjb25zdCBvcHRpb25zID0gdmFsdWVPckRlZmF1bHQoY29uZmlnLm9wdGlvbnMgJiYgY29uZmlnLm9wdGlvbnMucGx1Z2lucywge30pO1xyXG4gICAgY29uc3QgcGx1Z2lucyA9IGFsbFBsdWdpbnMoY29uZmlnKTtcclxuICAgIHJldHVybiBvcHRpb25zID09PSBmYWxzZSAmJiAhYWxsID8gW10gOiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgcGx1Z2lucywgb3B0aW9ucywgYWxsKTtcclxuICB9XHJcbiAgX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xyXG4gICAgY29uc3QgcHJldmlvdXNEZXNjcmlwdG9ycyA9IHRoaXMuX29sZENhY2hlIHx8IFtdO1xyXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZTtcclxuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5wbHVnaW4uaWQgPT09IHkucGx1Z2luLmlkKSk7XHJcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihwcmV2aW91c0Rlc2NyaXB0b3JzLCBkZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RvcCcpO1xyXG4gICAgdGhpcy5fbm90aWZ5KGRpZmYoZGVzY3JpcHRvcnMsIHByZXZpb3VzRGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0YXJ0Jyk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGFsbFBsdWdpbnMoY29uZmlnKSB7XHJcbiAgY29uc3QgcGx1Z2lucyA9IFtdO1xyXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyZWdpc3RyeS5wbHVnaW5zLml0ZW1zKTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHBsdWdpbnMucHVzaChyZWdpc3RyeS5nZXRQbHVnaW4oa2V5c1tpXSkpO1xyXG4gIH1cclxuICBjb25zdCBsb2NhbCA9IGNvbmZpZy5wbHVnaW5zIHx8IFtdO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IHBsdWdpbiA9IGxvY2FsW2ldO1xyXG4gICAgaWYgKHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xyXG4gICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHBsdWdpbnM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0T3B0cyhvcHRpb25zLCBhbGwpIHtcclxuICBpZiAoIWFsbCAmJiBvcHRpb25zID09PSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIGlmIChvcHRpb25zID09PSB0cnVlKSB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfVxyXG4gIHJldHVybiBvcHRpb25zO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBwbHVnaW5zLCBvcHRpb25zLCBhbGwpIHtcclxuICBjb25zdCByZXN1bHQgPSBbXTtcclxuICBjb25zdCBjb250ZXh0ID0gY2hhcnQuZ2V0Q29udGV4dCgpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcclxuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xyXG4gICAgY29uc3Qgb3B0cyA9IGdldE9wdHMob3B0aW9uc1tpZF0sIGFsbCk7XHJcbiAgICBpZiAob3B0cyA9PT0gbnVsbCkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgcGx1Z2luLFxyXG4gICAgICBvcHRpb25zOiBwbHVnaW5PcHRzKGNoYXJ0LmNvbmZpZywgcGx1Z2luLCBvcHRzLCBjb250ZXh0KVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gcGx1Z2luT3B0cyhjb25maWcsIHBsdWdpbiwgb3B0cywgY29udGV4dCkge1xyXG4gIGNvbnN0IGtleXMgPSBjb25maWcucGx1Z2luU2NvcGVLZXlzKHBsdWdpbik7XHJcbiAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3BlcyhvcHRzLCBrZXlzKTtcclxuICByZXR1cm4gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgWycnXSwge3NjcmlwdGFibGU6IGZhbHNlLCBpbmRleGFibGU6IGZhbHNlLCBhbGxLZXlzOiB0cnVlfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKSB7XHJcbiAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge307XHJcbiAgY29uc3QgZGF0YXNldE9wdGlvbnMgPSAob3B0aW9ucy5kYXRhc2V0cyB8fCB7fSlbdHlwZV0gfHwge307XHJcbiAgcmV0dXJuIGRhdGFzZXRPcHRpb25zLmluZGV4QXhpcyB8fCBvcHRpb25zLmluZGV4QXhpcyB8fCBkYXRhc2V0RGVmYXVsdHMuaW5kZXhBeGlzIHx8ICd4JztcclxufVxyXG5mdW5jdGlvbiBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGlkLCBpbmRleEF4aXMpIHtcclxuICBsZXQgYXhpcyA9IGlkO1xyXG4gIGlmIChpZCA9PT0gJ19pbmRleF8nKSB7XHJcbiAgICBheGlzID0gaW5kZXhBeGlzO1xyXG4gIH0gZWxzZSBpZiAoaWQgPT09ICdfdmFsdWVfJykge1xyXG4gICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xyXG4gIH1cclxuICByZXR1cm4gYXhpcztcclxufVxyXG5mdW5jdGlvbiBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGluZGV4QXhpcykge1xyXG4gIHJldHVybiBheGlzID09PSBpbmRleEF4aXMgPyAnX2luZGV4XycgOiAnX3ZhbHVlXyc7XHJcbn1cclxuZnVuY3Rpb24gYXhpc0Zyb21Qb3NpdGlvbihwb3NpdGlvbikge1xyXG4gIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XHJcbiAgICByZXR1cm4gJ3gnO1xyXG4gIH1cclxuICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgcmV0dXJuICd5JztcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKSB7XHJcbiAgaWYgKGlkID09PSAneCcgfHwgaWQgPT09ICd5Jykge1xyXG4gICAgcmV0dXJuIGlkO1xyXG4gIH1cclxuICByZXR1cm4gc2NhbGVPcHRpb25zLmF4aXMgfHwgYXhpc0Zyb21Qb3NpdGlvbihzY2FsZU9wdGlvbnMucG9zaXRpb24pIHx8IGlkLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKSB7XHJcbiAgY29uc3QgY2hhcnREZWZhdWx0cyA9IG92ZXJyaWRlc1tjb25maWcudHlwZV0gfHwge3NjYWxlczoge319O1xyXG4gIGNvbnN0IGNvbmZpZ1NjYWxlcyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xyXG4gIGNvbnN0IGNoYXJ0SW5kZXhBeGlzID0gZ2V0SW5kZXhBeGlzKGNvbmZpZy50eXBlLCBvcHRpb25zKTtcclxuICBjb25zdCBmaXJzdElEcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgY29uc3Qgc2NhbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goaWQgPT4ge1xyXG4gICAgY29uc3Qgc2NhbGVDb25mID0gY29uZmlnU2NhbGVzW2lkXTtcclxuICAgIGlmICghaXNPYmplY3Qoc2NhbGVDb25mKSkge1xyXG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgSW52YWxpZCBzY2FsZSBjb25maWd1cmF0aW9uIGZvciBzY2FsZTogJHtpZH1gKTtcclxuICAgIH1cclxuICAgIGlmIChzY2FsZUNvbmYuX3Byb3h5KSB7XHJcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYElnbm9yaW5nIHJlc29sdmVyIHBhc3NlZCBhcyBvcHRpb25zIGZvciBzY2FsZTogJHtpZH1gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZUNvbmYpO1xyXG4gICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XHJcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gY2hhcnREZWZhdWx0cy5zY2FsZXMgfHwge307XHJcbiAgICBmaXJzdElEc1theGlzXSA9IGZpcnN0SURzW2F4aXNdIHx8IGlkO1xyXG4gICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW3theGlzfSwgc2NhbGVDb25mLCBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJZF1dKTtcclxuICB9KTtcclxuICBjb25maWcuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGRhdGFzZXQgPT4ge1xyXG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBjb25maWcudHlwZTtcclxuICAgIGNvbnN0IGluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKTtcclxuICAgIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IG92ZXJyaWRlc1t0eXBlXSB8fCB7fTtcclxuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBkYXRhc2V0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xyXG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdFNjYWxlT3B0aW9ucykuZm9yRWFjaChkZWZhdWx0SUQgPT4ge1xyXG4gICAgICBjb25zdCBheGlzID0gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChkZWZhdWx0SUQsIGluZGV4QXhpcyk7XHJcbiAgICAgIGNvbnN0IGlkID0gZGF0YXNldFtheGlzICsgJ0F4aXNJRCddIHx8IGZpcnN0SURzW2F4aXNdIHx8IGF4aXM7XHJcbiAgICAgIHNjYWxlc1tpZF0gPSBzY2FsZXNbaWRdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgIG1lcmdlSWYoc2NhbGVzW2lkXSwgW3theGlzfSwgY29uZmlnU2NhbGVzW2lkXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SURdXSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICBPYmplY3Qua2V5cyhzY2FsZXMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgIGNvbnN0IHNjYWxlID0gc2NhbGVzW2tleV07XHJcbiAgICBtZXJnZUlmKHNjYWxlLCBbZGVmYXVsdHMuc2NhbGVzW3NjYWxlLnR5cGVdLCBkZWZhdWx0cy5zY2FsZV0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiBzY2FsZXM7XHJcbn1cclxuZnVuY3Rpb24gaW5pdE9wdGlvbnMoY29uZmlnKSB7XHJcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zIHx8IChjb25maWcub3B0aW9ucyA9IHt9KTtcclxuICBvcHRpb25zLnBsdWdpbnMgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnBsdWdpbnMsIHt9KTtcclxuICBvcHRpb25zLnNjYWxlcyA9IG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBpbml0RGF0YShkYXRhKSB7XHJcbiAgZGF0YSA9IGRhdGEgfHwge307XHJcbiAgZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XHJcbiAgZGF0YS5sYWJlbHMgPSBkYXRhLmxhYmVscyB8fCBbXTtcclxuICByZXR1cm4gZGF0YTtcclxufVxyXG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xyXG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcclxuICBpbml0T3B0aW9ucyhjb25maWcpO1xyXG4gIHJldHVybiBjb25maWc7XHJcbn1cclxuY29uc3Qga2V5Q2FjaGUgPSBuZXcgTWFwKCk7XHJcbmNvbnN0IGtleXNDYWNoZWQgPSBuZXcgU2V0KCk7XHJcbmZ1bmN0aW9uIGNhY2hlZEtleXMoY2FjaGVLZXksIGdlbmVyYXRlKSB7XHJcbiAgbGV0IGtleXMgPSBrZXlDYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG4gIGlmICgha2V5cykge1xyXG4gICAga2V5cyA9IGdlbmVyYXRlKCk7XHJcbiAgICBrZXlDYWNoZS5zZXQoY2FjaGVLZXksIGtleXMpO1xyXG4gICAga2V5c0NhY2hlZC5hZGQoa2V5cyk7XHJcbiAgfVxyXG4gIHJldHVybiBrZXlzO1xyXG59XHJcbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSkgPT4ge1xyXG4gIGNvbnN0IG9wdHMgPSByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KTtcclxuICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBzZXQuYWRkKG9wdHMpO1xyXG4gIH1cclxufTtcclxuY2xhc3MgQ29uZmlnIHtcclxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgIHRoaXMuX2NvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcclxuICAgIHRoaXMuX3Njb3BlQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlID0gbmV3IE1hcCgpO1xyXG4gIH1cclxuICBnZXQgcGxhdGZvcm0oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xyXG4gIH1cclxuICBnZXQgdHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb25maWcudHlwZTtcclxuICB9XHJcbiAgc2V0IHR5cGUodHlwZSkge1xyXG4gICAgdGhpcy5fY29uZmlnLnR5cGUgPSB0eXBlO1xyXG4gIH1cclxuICBnZXQgZGF0YSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcclxuICB9XHJcbiAgc2V0IGRhdGEoZGF0YSkge1xyXG4gICAgdGhpcy5fY29uZmlnLmRhdGEgPSBpbml0RGF0YShkYXRhKTtcclxuICB9XHJcbiAgZ2V0IG9wdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm9wdGlvbnM7XHJcbiAgfVxyXG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcclxuICB9XHJcbiAgZ2V0IHBsdWdpbnMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsdWdpbnM7XHJcbiAgfVxyXG4gIHVwZGF0ZSgpIHtcclxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2NvbmZpZztcclxuICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xyXG4gICAgaW5pdE9wdGlvbnMoY29uZmlnKTtcclxuICB9XHJcbiAgY2xlYXJDYWNoZSgpIHtcclxuICAgIHRoaXMuX3Njb3BlQ2FjaGUuY2xlYXIoKTtcclxuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcclxuICB9XHJcbiAgZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xyXG4gICAgcmV0dXJuIGNhY2hlZEtleXMoZGF0YXNldFR5cGUsXHJcbiAgICAgICgpID0+IFtbXHJcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcclxuICAgICAgICAnJ1xyXG4gICAgICBdXSk7XHJcbiAgfVxyXG4gIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXMoZGF0YXNldFR5cGUsIHRyYW5zaXRpb24pIHtcclxuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9uLiR7dHJhbnNpdGlvbn1gLFxyXG4gICAgICAoKSA9PiBbXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxyXG4gICAgICAgICAgYHRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcclxuICAgICAgICAgICcnXHJcbiAgICAgICAgXVxyXG4gICAgICBdKTtcclxuICB9XHJcbiAgZGF0YXNldEVsZW1lbnRTY29wZUtleXMoZGF0YXNldFR5cGUsIGVsZW1lbnRUeXBlKSB7XHJcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0tJHtlbGVtZW50VHlwZX1gLFxyXG4gICAgICAoKSA9PiBbW1xyXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS5lbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXHJcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcclxuICAgICAgICBgZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxyXG4gICAgICAgICcnXHJcbiAgICAgIF1dKTtcclxuICB9XHJcbiAgcGx1Z2luU2NvcGVLZXlzKHBsdWdpbikge1xyXG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XHJcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlO1xyXG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7dHlwZX0tcGx1Z2luLSR7aWR9YCxcclxuICAgICAgKCkgPT4gW1tcclxuICAgICAgICBgcGx1Z2lucy4ke2lkfWAsXHJcbiAgICAgICAgLi4ucGx1Z2luLmFkZGl0aW9uYWxPcHRpb25TY29wZXMgfHwgW10sXHJcbiAgICAgIF1dKTtcclxuICB9XHJcbiAgX2NhY2hlZFNjb3BlcyhtYWluU2NvcGUsIHJlc2V0Q2FjaGUpIHtcclxuICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcclxuICAgIGxldCBjYWNoZSA9IF9zY29wZUNhY2hlLmdldChtYWluU2NvcGUpO1xyXG4gICAgaWYgKCFjYWNoZSB8fCByZXNldENhY2hlKSB7XHJcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgICBfc2NvcGVDYWNoZS5zZXQobWFpblNjb3BlLCBjYWNoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FjaGU7XHJcbiAgfVxyXG4gIGdldE9wdGlvblNjb3BlcyhtYWluU2NvcGUsIGtleUxpc3RzLCByZXNldENhY2hlKSB7XHJcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xyXG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKTtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXlMaXN0cyk7XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzY29wZXMgPSBuZXcgU2V0KCk7XHJcbiAgICBrZXlMaXN0cy5mb3JFYWNoKGtleXMgPT4ge1xyXG4gICAgICBpZiAobWFpblNjb3BlKSB7XHJcbiAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xyXG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG1haW5TY29wZSwga2V5KSk7XHJcbiAgICAgIH1cclxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3B0aW9ucywga2V5KSk7XHJcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSwga2V5KSk7XHJcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlZmF1bHRzLCBrZXkpKTtcclxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVzY3JpcHRvcnMsIGtleSkpO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBhcnJheSA9IEFycmF5LmZyb20oc2NvcGVzKTtcclxuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcclxuICAgICAgYXJyYXkucHVzaChPYmplY3QuY3JlYXRlKG51bGwpKTtcclxuICAgIH1cclxuICAgIGlmIChrZXlzQ2FjaGVkLmhhcyhrZXlMaXN0cykpIHtcclxuICAgICAgY2FjaGUuc2V0KGtleUxpc3RzLCBhcnJheSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbiAgfVxyXG4gIGNoYXJ0T3B0aW9uU2NvcGVzKCkge1xyXG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcclxuICAgIHJldHVybiBbXHJcbiAgICAgIG9wdGlvbnMsXHJcbiAgICAgIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSxcclxuICAgICAgZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge30sXHJcbiAgICAgIHt0eXBlfSxcclxuICAgICAgZGVmYXVsdHMsXHJcbiAgICAgIGRlc2NyaXB0b3JzXHJcbiAgICBdO1xyXG4gIH1cclxuICByZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0geyRzaGFyZWQ6IHRydWV9O1xyXG4gICAgY29uc3Qge3Jlc29sdmVyLCBzdWJQcmVmaXhlc30gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcclxuICAgIGxldCBvcHRpb25zID0gcmVzb2x2ZXI7XHJcbiAgICBpZiAobmVlZENvbnRleHQocmVzb2x2ZXIsIG5hbWVzKSkge1xyXG4gICAgICByZXN1bHQuJHNoYXJlZCA9IGZhbHNlO1xyXG4gICAgICBjb250ZXh0ID0gaXNGdW5jdGlvbihjb250ZXh0KSA/IGNvbnRleHQoKSA6IGNvbnRleHQ7XHJcbiAgICAgIGNvbnN0IHN1YlJlc29sdmVyID0gdGhpcy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHN1YlByZWZpeGVzKTtcclxuICAgICAgb3B0aW9ucyA9IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCBzdWJSZXNvbHZlcik7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcclxuICAgICAgcmVzdWx0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIGNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddLCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcclxuICAgIGNvbnN0IHtyZXNvbHZlcn0gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcclxuICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KVxyXG4gICAgICA/IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCB1bmRlZmluZWQsIGRlc2NyaXB0b3JEZWZhdWx0cylcclxuICAgICAgOiByZXNvbHZlcjtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIocmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcykge1xyXG4gIGxldCBjYWNoZSA9IHJlc29sdmVyQ2FjaGUuZ2V0KHNjb3Blcyk7XHJcbiAgaWYgKCFjYWNoZSkge1xyXG4gICAgY2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICByZXNvbHZlckNhY2hlLnNldChzY29wZXMsIGNhY2hlKTtcclxuICB9XHJcbiAgY29uc3QgY2FjaGVLZXkgPSBwcmVmaXhlcy5qb2luKCk7XHJcbiAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChjYWNoZUtleSk7XHJcbiAgaWYgKCFjYWNoZWQpIHtcclxuICAgIGNvbnN0IHJlc29sdmVyID0gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMpO1xyXG4gICAgY2FjaGVkID0ge1xyXG4gICAgICByZXNvbHZlcixcclxuICAgICAgc3ViUHJlZml4ZXM6IHByZWZpeGVzLmZpbHRlcihwID0+ICFwLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2hvdmVyJykpXHJcbiAgICB9O1xyXG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBjYWNoZWQpO1xyXG4gIH1cclxuICByZXR1cm4gY2FjaGVkO1xyXG59XHJcbmNvbnN0IGhhc0Z1bmN0aW9uID0gdmFsdWUgPT4gaXNPYmplY3QodmFsdWUpXHJcbiAgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjYyB8fCBpc0Z1bmN0aW9uKHZhbHVlW2tleV0pLCBmYWxzZSk7XHJcbmZ1bmN0aW9uIG5lZWRDb250ZXh0KHByb3h5LCBuYW1lcykge1xyXG4gIGNvbnN0IHtpc1NjcmlwdGFibGUsIGlzSW5kZXhhYmxlfSA9IF9kZXNjcmlwdG9ycyhwcm94eSk7XHJcbiAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XHJcbiAgICBjb25zdCBzY3JpcHRhYmxlID0gaXNTY3JpcHRhYmxlKHByb3ApO1xyXG4gICAgY29uc3QgaW5kZXhhYmxlID0gaXNJbmRleGFibGUocHJvcCk7XHJcbiAgICBjb25zdCB2YWx1ZSA9IChpbmRleGFibGUgfHwgc2NyaXB0YWJsZSkgJiYgcHJveHlbcHJvcF07XHJcbiAgICBpZiAoKHNjcmlwdGFibGUgJiYgKGlzRnVuY3Rpb24odmFsdWUpIHx8IGhhc0Z1bmN0aW9uKHZhbHVlKSkpXHJcbiAgICAgIHx8IChpbmRleGFibGUgJiYgaXNBcnJheSh2YWx1ZSkpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbnZhciB2ZXJzaW9uID0gXCIzLjguMFwiO1xyXG5cclxuY29uc3QgS05PV05fUE9TSVRJT05TID0gWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnLCAnY2hhcnRBcmVhJ107XHJcbmZ1bmN0aW9uIHBvc2l0aW9uSXNIb3Jpem9udGFsKHBvc2l0aW9uLCBheGlzKSB7XHJcbiAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgKEtOT1dOX1BPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA9PT0gLTEgJiYgYXhpcyA9PT0gJ3gnKTtcclxufVxyXG5mdW5jdGlvbiBjb21wYXJlMkxldmVsKGwxLCBsMikge1xyXG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICByZXR1cm4gYVtsMV0gPT09IGJbbDFdXHJcbiAgICAgID8gYVtsMl0gLSBiW2wyXVxyXG4gICAgICA6IGFbbDFdIC0gYltsMV07XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBvbkFuaW1hdGlvbnNDb21wbGV0ZShjb250ZXh0KSB7XHJcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xyXG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcclxuICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclJlbmRlcicpO1xyXG4gIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbY29udGV4dF0sIGNoYXJ0KTtcclxufVxyXG5mdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGNvbnRleHQpIHtcclxuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XHJcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xyXG4gIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLCBbY29udGV4dF0sIGNoYXJ0KTtcclxufVxyXG5mdW5jdGlvbiBnZXRDYW52YXMoaXRlbSkge1xyXG4gIGlmIChfaXNEb21TdXBwb3J0ZWQoKSAmJiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcclxuICAgIGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcclxuICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGgpIHtcclxuICAgIGl0ZW0gPSBpdGVtWzBdO1xyXG4gIH1cclxuICBpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xyXG4gICAgaXRlbSA9IGl0ZW0uY2FudmFzO1xyXG4gIH1cclxuICByZXR1cm4gaXRlbTtcclxufVxyXG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcclxuY29uc3QgZ2V0Q2hhcnQgPSAoa2V5KSA9PiB7XHJcbiAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKGtleSk7XHJcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaW5zdGFuY2VzKS5maWx0ZXIoKGMpID0+IGMuY2FudmFzID09PSBjYW52YXMpLnBvcCgpO1xyXG59O1xyXG5mdW5jdGlvbiBtb3ZlTnVtZXJpY0tleXMob2JqLCBzdGFydCwgbW92ZSkge1xyXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xyXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcclxuICAgIGNvbnN0IGludEtleSA9ICtrZXk7XHJcbiAgICBpZiAoaW50S2V5ID49IHN0YXJ0KSB7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XHJcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcclxuICAgICAgaWYgKG1vdmUgPiAwIHx8IGludEtleSA+IHN0YXJ0KSB7XHJcbiAgICAgICAgb2JqW2ludEtleSArIG1vdmVdID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIGxhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spIHtcclxuICBpZiAoIWluQ2hhcnRBcmVhIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIGlmIChpc0NsaWNrKSB7XHJcbiAgICByZXR1cm4gbGFzdEV2ZW50O1xyXG4gIH1cclxuICByZXR1cm4gZTtcclxufVxyXG5jbGFzcyBDaGFydCB7XHJcbiAgY29uc3RydWN0b3IoaXRlbSwgdXNlckNvbmZpZykge1xyXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKHVzZXJDb25maWcpO1xyXG4gICAgY29uc3QgaW5pdGlhbENhbnZhcyA9IGdldENhbnZhcyhpdGVtKTtcclxuICAgIGNvbnN0IGV4aXN0aW5nQ2hhcnQgPSBnZXRDaGFydChpbml0aWFsQ2FudmFzKTtcclxuICAgIGlmIChleGlzdGluZ0NoYXJ0KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAnQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmlkICsgJ1xcJycgK1xyXG5cdFx0XHRcdCcgbXVzdCBiZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjYW52YXMgY2FuIGJlIHJldXNlZC4nXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XHJcbiAgICB0aGlzLnBsYXRmb3JtID0gbmV3IChjb25maWcucGxhdGZvcm0gfHwgX2RldGVjdFBsYXRmb3JtKGluaXRpYWxDYW52YXMpKSgpO1xyXG4gICAgdGhpcy5wbGF0Zm9ybS51cGRhdGVDb25maWcoY29uZmlnKTtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGluaXRpYWxDYW52YXMsIG9wdGlvbnMuYXNwZWN0UmF0aW8pO1xyXG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcclxuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcyAmJiBjYW52YXMuaGVpZ2h0O1xyXG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMgJiYgY2FudmFzLndpZHRoO1xyXG4gICAgdGhpcy5pZCA9IHVpZCgpO1xyXG4gICAgdGhpcy5jdHggPSBjb250ZXh0O1xyXG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgdGhpcy5fbGF5ZXJzID0gW107XHJcbiAgICB0aGlzLl9tZXRhc2V0cyA9IFtdO1xyXG4gICAgdGhpcy5fc3RhY2tzID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5ib3hlcyA9IFtdO1xyXG4gICAgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuY2hhcnRBcmVhID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fYWN0aXZlID0gW107XHJcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IFtdO1xyXG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcclxuICAgIHRoaXMuX3BsdWdpbnMgPSBuZXcgUGx1Z2luU2VydmljZSgpO1xyXG4gICAgdGhpcy4kcHJveGllcyA9IHt9O1xyXG4gICAgdGhpcy5faGlkZGVuSW5kaWNlcyA9IHt9O1xyXG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX2RvUmVzaXplID0gZGVib3VuY2UobW9kZSA9PiB0aGlzLnVwZGF0ZShtb2RlKSwgb3B0aW9ucy5yZXNpemVEZWxheSB8fCAwKTtcclxuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XHJcbiAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSB0aGlzO1xyXG4gICAgaWYgKCFjb250ZXh0IHx8ICFjYW52YXMpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ2NvbXBsZXRlJywgb25BbmltYXRpb25zQ29tcGxldGUpO1xyXG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdwcm9ncmVzcycsIG9uQW5pbWF0aW9uUHJvZ3Jlc3MpO1xyXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xyXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcclxuICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0IGFzcGVjdFJhdGlvKCkge1xyXG4gICAgY29uc3Qge29wdGlvbnM6IHthc3BlY3RSYXRpbywgbWFpbnRhaW5Bc3BlY3RSYXRpb30sIHdpZHRoLCBoZWlnaHQsIF9hc3BlY3RSYXRpb30gPSB0aGlzO1xyXG4gICAgaWYgKCFpc051bGxPclVuZGVmKGFzcGVjdFJhdGlvKSkge1xyXG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XHJcbiAgICB9XHJcbiAgICBpZiAobWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBfYXNwZWN0UmF0aW8pIHtcclxuICAgICAgcmV0dXJuIF9hc3BlY3RSYXRpbztcclxuICAgIH1cclxuICAgIHJldHVybiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IG51bGw7XHJcbiAgfVxyXG4gIGdldCBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XHJcbiAgfVxyXG4gIHNldCBkYXRhKGRhdGEpIHtcclxuICAgIHRoaXMuY29uZmlnLmRhdGEgPSBkYXRhO1xyXG4gIH1cclxuICBnZXQgb3B0aW9ucygpIHtcclxuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xyXG4gIH1cclxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcclxuICB9XHJcbiAgX2luaXRpYWxpemUoKSB7XHJcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUluaXQnKTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xyXG4gICAgICB0aGlzLnJlc2l6ZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0aW5hU2NhbGUodGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XHJcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVySW5pdCcpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIGNsZWFyKCkge1xyXG4gICAgY2xlYXJDYW52YXModGhpcy5jYW52YXMsIHRoaXMuY3R4KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICBzdG9wKCkge1xyXG4gICAgYW5pbWF0b3Iuc3RvcCh0aGlzKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgaWYgKCFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XHJcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSB7d2lkdGgsIGhlaWdodH07XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9yZXNpemUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xyXG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSBvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgdGhpcy5hc3BlY3RSYXRpbztcclxuICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLnBsYXRmb3JtLmdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xyXG4gICAgY29uc3QgbmV3UmF0aW8gPSBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8gfHwgdGhpcy5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XHJcbiAgICBjb25zdCBtb2RlID0gdGhpcy53aWR0aCA/ICdyZXNpemUnIDogJ2F0dGFjaCc7XHJcbiAgICB0aGlzLndpZHRoID0gbmV3U2l6ZS53aWR0aDtcclxuICAgIHRoaXMuaGVpZ2h0ID0gbmV3U2l6ZS5oZWlnaHQ7XHJcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XHJcbiAgICBpZiAoIXJldGluYVNjYWxlKHRoaXMsIG5ld1JhdGlvLCB0cnVlKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2l6ZScsIHtzaXplOiBuZXdTaXplfSk7XHJcbiAgICBjYWxsYmFjayhvcHRpb25zLm9uUmVzaXplLCBbdGhpcywgbmV3U2l6ZV0sIHRoaXMpO1xyXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcclxuICAgICAgaWYgKHRoaXMuX2RvUmVzaXplKG1vZGUpKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBlbnN1cmVTY2FsZXNIYXZlSURzKCkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcclxuICAgIGVhY2goc2NhbGVzT3B0aW9ucywgKGF4aXNPcHRpb25zLCBheGlzSUQpID0+IHtcclxuICAgICAgYXhpc09wdGlvbnMuaWQgPSBheGlzSUQ7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgYnVpbGRPclVwZGF0ZVNjYWxlcygpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCBzY2FsZU9wdHMgPSBvcHRpb25zLnNjYWxlcztcclxuICAgIGNvbnN0IHNjYWxlcyA9IHRoaXMuc2NhbGVzO1xyXG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKChvYmosIGlkKSA9PiB7XHJcbiAgICAgIG9ialtpZF0gPSBmYWxzZTtcclxuICAgICAgcmV0dXJuIG9iajtcclxuICAgIH0sIHt9KTtcclxuICAgIGxldCBpdGVtcyA9IFtdO1xyXG4gICAgaWYgKHNjYWxlT3B0cykge1xyXG4gICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChcclxuICAgICAgICBPYmplY3Qua2V5cyhzY2FsZU9wdHMpLm1hcCgoaWQpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHNjYWxlT3B0c1tpZF07XHJcbiAgICAgICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcclxuICAgICAgICAgIGNvbnN0IGlzUmFkaWFsID0gYXhpcyA9PT0gJ3InO1xyXG4gICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ3gnO1xyXG4gICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3B0aW9uczogc2NhbGVPcHRpb25zLFxyXG4gICAgICAgICAgICBkcG9zaXRpb246IGlzUmFkaWFsID8gJ2NoYXJ0QXJlYScgOiBpc0hvcml6b250YWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcclxuICAgICAgICAgICAgZHR5cGU6IGlzUmFkaWFsID8gJ3JhZGlhbExpbmVhcicgOiBpc0hvcml6b250YWwgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcidcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSlcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIGVhY2goaXRlbXMsIChpdGVtKSA9PiB7XHJcbiAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcclxuICAgICAgY29uc3QgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XHJcbiAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xyXG4gICAgICBjb25zdCBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XHJcbiAgICAgIGlmIChzY2FsZU9wdGlvbnMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24sIGF4aXMpICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcclxuICAgICAgICBzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgICB1cGRhdGVkW2lkXSA9IHRydWU7XHJcbiAgICAgIGxldCBzY2FsZSA9IG51bGw7XHJcbiAgICAgIGlmIChpZCBpbiBzY2FsZXMgJiYgc2NhbGVzW2lkXS50eXBlID09PSBzY2FsZVR5cGUpIHtcclxuICAgICAgICBzY2FsZSA9IHNjYWxlc1tpZF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVDbGFzcyA9IHJlZ2lzdHJ5LmdldFNjYWxlKHNjYWxlVHlwZSk7XHJcbiAgICAgICAgc2NhbGUgPSBuZXcgc2NhbGVDbGFzcyh7XHJcbiAgICAgICAgICBpZCxcclxuICAgICAgICAgIHR5cGU6IHNjYWxlVHlwZSxcclxuICAgICAgICAgIGN0eDogdGhpcy5jdHgsXHJcbiAgICAgICAgICBjaGFydDogdGhpc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNjYWxlc1tzY2FsZS5pZF0gPSBzY2FsZTtcclxuICAgICAgfVxyXG4gICAgICBzY2FsZS5pbml0KHNjYWxlT3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICB9KTtcclxuICAgIGVhY2godXBkYXRlZCwgKGhhc1VwZGF0ZWQsIGlkKSA9PiB7XHJcbiAgICAgIGlmICghaGFzVXBkYXRlZCkge1xyXG4gICAgICAgIGRlbGV0ZSBzY2FsZXNbaWRdO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGVhY2goc2NhbGVzLCAoc2NhbGUpID0+IHtcclxuICAgICAgbGF5b3V0cy5jb25maWd1cmUodGhpcywgc2NhbGUsIHNjYWxlLm9wdGlvbnMpO1xyXG4gICAgICBsYXlvdXRzLmFkZEJveCh0aGlzLCBzY2FsZSk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgX3VwZGF0ZU1ldGFzZXRzKCkge1xyXG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcclxuICAgIGNvbnN0IG51bURhdGEgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xyXG4gICAgY29uc3QgbnVtTWV0YSA9IG1ldGFzZXRzLmxlbmd0aDtcclxuICAgIG1ldGFzZXRzLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KTtcclxuICAgIGlmIChudW1NZXRhID4gbnVtRGF0YSkge1xyXG4gICAgICBmb3IgKGxldCBpID0gbnVtRGF0YTsgaSA8IG51bU1ldGE7ICsraSkge1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcclxuICAgICAgfVxyXG4gICAgICBtZXRhc2V0cy5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBtZXRhc2V0cy5zbGljZSgwKS5zb3J0KGNvbXBhcmUyTGV2ZWwoJ29yZGVyJywgJ2luZGV4JykpO1xyXG4gIH1cclxuICBfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKSB7XHJcbiAgICBjb25zdCB7X21ldGFzZXRzOiBtZXRhc2V0cywgZGF0YToge2RhdGFzZXRzfX0gPSB0aGlzO1xyXG4gICAgaWYgKG1ldGFzZXRzLmxlbmd0aCA+IGRhdGFzZXRzLmxlbmd0aCkge1xyXG4gICAgICBkZWxldGUgdGhpcy5fc3RhY2tzO1xyXG4gICAgfVxyXG4gICAgbWV0YXNldHMuZm9yRWFjaCgobWV0YSwgaW5kZXgpID0+IHtcclxuICAgICAgaWYgKGRhdGFzZXRzLmZpbHRlcih4ID0+IHggPT09IG1ldGEuX2RhdGFzZXQpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpbmRleCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XHJcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IFtdO1xyXG4gICAgY29uc3QgZGF0YXNldHMgPSB0aGlzLmRhdGEuZGF0YXNldHM7XHJcbiAgICBsZXQgaSwgaWxlbjtcclxuICAgIHRoaXMuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCk7XHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tpXTtcclxuICAgICAgbGV0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xyXG4gICAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IHRoaXMuY29uZmlnLnR5cGU7XHJcbiAgICAgIGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xyXG4gICAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xyXG4gICAgICB9XHJcbiAgICAgIG1ldGEudHlwZSA9IHR5cGU7XHJcbiAgICAgIG1ldGEuaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgIG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XHJcbiAgICAgIG1ldGEuaW5kZXggPSBpO1xyXG4gICAgICBtZXRhLmxhYmVsID0gJycgKyBkYXRhc2V0LmxhYmVsO1xyXG4gICAgICBtZXRhLnZpc2libGUgPSB0aGlzLmlzRGF0YXNldFZpc2libGUoaSk7XHJcbiAgICAgIGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcclxuICAgICAgICBtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoaSk7XHJcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBDb250cm9sbGVyQ2xhc3MgPSByZWdpc3RyeS5nZXRDb250cm9sbGVyKHR5cGUpO1xyXG4gICAgICAgIGNvbnN0IHtkYXRhc2V0RWxlbWVudFR5cGUsIGRhdGFFbGVtZW50VHlwZX0gPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKENvbnRyb2xsZXJDbGFzcy5wcm90b3R5cGUsIHtcclxuICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhRWxlbWVudFR5cGUpLFxyXG4gICAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBkYXRhc2V0RWxlbWVudFR5cGUgJiYgcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhc2V0RWxlbWVudFR5cGUpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBpKTtcclxuICAgICAgICBuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCk7XHJcbiAgICByZXR1cm4gbmV3Q29udHJvbGxlcnM7XHJcbiAgfVxyXG4gIF9yZXNldEVsZW1lbnRzKCkge1xyXG4gICAgZWFjaCh0aGlzLmRhdGEuZGF0YXNldHMsIChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcclxuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIucmVzZXQoKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gIH1cclxuICByZXNldCgpIHtcclxuICAgIHRoaXMuX3Jlc2V0RWxlbWVudHMoKTtcclxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzZXQnKTtcclxuICB9XHJcbiAgdXBkYXRlKG1vZGUpIHtcclxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xyXG4gICAgY29uZmlnLnVwZGF0ZSgpO1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcclxuICAgIGNvbnN0IGFuaW1zRGlzYWJsZWQgPSB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSAhb3B0aW9ucy5hbmltYXRpb247XHJcbiAgICB0aGlzLl91cGRhdGVTY2FsZXMoKTtcclxuICAgIHRoaXMuX2NoZWNrRXZlbnRCaW5kaW5ncygpO1xyXG4gICAgdGhpcy5fdXBkYXRlSGlkZGVuSW5kaWNlcygpO1xyXG4gICAgdGhpcy5fcGx1Z2lucy5pbnZhbGlkYXRlKCk7XHJcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IHRoaXMuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XHJcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUVsZW1lbnRzVXBkYXRlJyk7XHJcbiAgICBsZXQgbWluUGFkZGluZyA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcclxuICAgICAgY29uc3Qge2NvbnRyb2xsZXJ9ID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcclxuICAgICAgY29uc3QgcmVzZXQgPSAhYW5pbXNEaXNhYmxlZCAmJiBuZXdDb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpID09PSAtMTtcclxuICAgICAgY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXQpO1xyXG4gICAgICBtaW5QYWRkaW5nID0gTWF0aC5tYXgoK2NvbnRyb2xsZXIuZ2V0TWF4T3ZlcmZsb3coKSwgbWluUGFkZGluZyk7XHJcbiAgICB9XHJcbiAgICBtaW5QYWRkaW5nID0gdGhpcy5fbWluUGFkZGluZyA9IG9wdGlvbnMubGF5b3V0LmF1dG9QYWRkaW5nID8gbWluUGFkZGluZyA6IDA7XHJcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQobWluUGFkZGluZyk7XHJcbiAgICBpZiAoIWFuaW1zRGlzYWJsZWQpIHtcclxuICAgICAgZWFjaChuZXdDb250cm9sbGVycywgKGNvbnRyb2xsZXIpID0+IHtcclxuICAgICAgICBjb250cm9sbGVyLnJlc2V0KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fdXBkYXRlRGF0YXNldHMobW9kZSk7XHJcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyVXBkYXRlJywge21vZGV9KTtcclxuICAgIHRoaXMuX2xheWVycy5zb3J0KGNvbXBhcmUyTGV2ZWwoJ3onLCAnX2lkeCcpKTtcclxuICAgIGNvbnN0IHtfYWN0aXZlLCBfbGFzdEV2ZW50fSA9IHRoaXM7XHJcbiAgICBpZiAoX2xhc3RFdmVudCkge1xyXG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoX2xhc3RFdmVudCwgdHJ1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKF9hY3RpdmUubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKF9hY3RpdmUsIF9hY3RpdmUsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZW5kZXIoKTtcclxuICB9XHJcbiAgX3VwZGF0ZVNjYWxlcygpIHtcclxuICAgIGVhY2godGhpcy5zY2FsZXMsIChzY2FsZSkgPT4ge1xyXG4gICAgICBsYXlvdXRzLnJlbW92ZUJveCh0aGlzLCBzY2FsZSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xyXG4gICAgdGhpcy5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XHJcbiAgfVxyXG4gIF9jaGVja0V2ZW50QmluZGluZ3MoKSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3QgZXhpc3RpbmdFdmVudHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuX2xpc3RlbmVycykpO1xyXG4gICAgY29uc3QgbmV3RXZlbnRzID0gbmV3IFNldChvcHRpb25zLmV2ZW50cyk7XHJcbiAgICBpZiAoIXNldHNFcXVhbChleGlzdGluZ0V2ZW50cywgbmV3RXZlbnRzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IG9wdGlvbnMucmVzcG9uc2l2ZSkge1xyXG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xyXG4gICAgICB0aGlzLmJpbmRFdmVudHMoKTtcclxuICAgIH1cclxuICB9XHJcbiAgX3VwZGF0ZUhpZGRlbkluZGljZXMoKSB7XHJcbiAgICBjb25zdCB7X2hpZGRlbkluZGljZXN9ID0gdGhpcztcclxuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB8fCBbXTtcclxuICAgIGZvciAoY29uc3Qge21ldGhvZCwgc3RhcnQsIGNvdW50fSBvZiBjaGFuZ2VzKSB7XHJcbiAgICAgIGNvbnN0IG1vdmUgPSBtZXRob2QgPT09ICdfcmVtb3ZlRWxlbWVudHMnID8gLWNvdW50IDogY291bnQ7XHJcbiAgICAgIG1vdmVOdW1lcmljS2V5cyhfaGlkZGVuSW5kaWNlcywgc3RhcnQsIG1vdmUpO1xyXG4gICAgfVxyXG4gIH1cclxuICBfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkge1xyXG4gICAgY29uc3QgX2RhdGFDaGFuZ2VzID0gdGhpcy5fZGF0YUNoYW5nZXM7XHJcbiAgICBpZiAoIV9kYXRhQ2hhbmdlcyB8fCAhX2RhdGFDaGFuZ2VzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xyXG4gICAgY29uc3QgZGF0YXNldENvdW50ID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcclxuICAgIGNvbnN0IG1ha2VTZXQgPSAoaWR4KSA9PiBuZXcgU2V0KFxyXG4gICAgICBfZGF0YUNoYW5nZXNcclxuICAgICAgICAuZmlsdGVyKGMgPT4gY1swXSA9PT0gaWR4KVxyXG4gICAgICAgIC5tYXAoKGMsIGkpID0+IGkgKyAnLCcgKyBjLnNwbGljZSgxKS5qb2luKCcsJykpXHJcbiAgICApO1xyXG4gICAgY29uc3QgY2hhbmdlU2V0ID0gbWFrZVNldCgwKTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YXNldENvdW50OyBpKyspIHtcclxuICAgICAgaWYgKCFzZXRzRXF1YWwoY2hhbmdlU2V0LCBtYWtlU2V0KGkpKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFycmF5LmZyb20oY2hhbmdlU2V0KVxyXG4gICAgICAubWFwKGMgPT4gYy5zcGxpdCgnLCcpKVxyXG4gICAgICAubWFwKGEgPT4gKHttZXRob2Q6IGFbMV0sIHN0YXJ0OiArYVsyXSwgY291bnQ6ICthWzNdfSkpO1xyXG4gIH1cclxuICBfdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpIHtcclxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUxheW91dCcsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBtaW5QYWRkaW5nKTtcclxuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcclxuICAgIGNvbnN0IG5vQXJlYSA9IGFyZWEud2lkdGggPD0gMCB8fCBhcmVhLmhlaWdodCA8PSAwO1xyXG4gICAgdGhpcy5fbGF5ZXJzID0gW107XHJcbiAgICBlYWNoKHRoaXMuYm94ZXMsIChib3gpID0+IHtcclxuICAgICAgaWYgKG5vQXJlYSAmJiBib3gucG9zaXRpb24gPT09ICdjaGFydEFyZWEnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChib3guY29uZmlndXJlKSB7XHJcbiAgICAgICAgYm94LmNvbmZpZ3VyZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2xheWVycy5wdXNoKC4uLmJveC5fbGF5ZXJzKCkpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICB0aGlzLl9sYXllcnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgaXRlbS5faWR4ID0gaW5kZXg7XHJcbiAgICB9KTtcclxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJMYXlvdXQnKTtcclxuICB9XHJcbiAgX3VwZGF0ZURhdGFzZXRzKG1vZGUpIHtcclxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci5jb25maWd1cmUoKTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICB0aGlzLl91cGRhdGVEYXRhc2V0KGksIGlzRnVuY3Rpb24obW9kZSkgPyBtb2RlKHtkYXRhc2V0SW5kZXg6IGl9KSA6IG1vZGUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzVXBkYXRlJywge21vZGV9KTtcclxuICB9XHJcbiAgX3VwZGF0ZURhdGFzZXQoaW5kZXgsIG1vZGUpIHtcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGluZGV4KTtcclxuICAgIGNvbnN0IGFyZ3MgPSB7bWV0YSwgaW5kZXgsIG1vZGUsIGNhbmNlbGFibGU6IHRydWV9O1xyXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldFVwZGF0ZScsIGFyZ3MpID09PSBmYWxzZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZShtb2RlKTtcclxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRVcGRhdGUnLCBhcmdzKTtcclxuICB9XHJcbiAgcmVuZGVyKCkge1xyXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlUmVuZGVyJywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGFuaW1hdG9yLmhhcyh0aGlzKSkge1xyXG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xyXG4gICAgICAgIGFuaW1hdG9yLnN0YXJ0KHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmRyYXcoKTtcclxuICAgICAgb25BbmltYXRpb25zQ29tcGxldGUoe2NoYXJ0OiB0aGlzfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGRyYXcoKSB7XHJcbiAgICBsZXQgaTtcclxuICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XHJcbiAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXc7XHJcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuX2xheWVycztcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoICYmIGxheWVyc1tpXS56IDw9IDA7ICsraSkge1xyXG4gICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9kcmF3RGF0YXNldHMoKTtcclxuICAgIGZvciAoOyBpIDwgbGF5ZXJzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcclxuICAgIH1cclxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEcmF3Jyk7XHJcbiAgfVxyXG4gIF9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSkge1xyXG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9zb3J0ZWRNZXRhc2V0cztcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgbGV0IGksIGlsZW47XHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc2V0c1tpXTtcclxuICAgICAgaWYgKCFmaWx0ZXJWaXNpYmxlIHx8IG1ldGEudmlzaWJsZSkge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuICBnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcclxuICB9XHJcbiAgX2RyYXdEYXRhc2V0cygpIHtcclxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XHJcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgdGhpcy5fZHJhd0RhdGFzZXQobWV0YXNldHNbaV0pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzRHJhdycpO1xyXG4gIH1cclxuICBfZHJhd0RhdGFzZXQobWV0YSkge1xyXG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XHJcbiAgICBjb25zdCBjbGlwID0gbWV0YS5fY2xpcDtcclxuICAgIGNvbnN0IHVzZUNsaXAgPSAhY2xpcC5kaXNhYmxlZDtcclxuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcclxuICAgIGNvbnN0IGFyZ3MgPSB7XHJcbiAgICAgIG1ldGEsXHJcbiAgICAgIGluZGV4OiBtZXRhLmluZGV4LFxyXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXHJcbiAgICB9O1xyXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHVzZUNsaXApIHtcclxuICAgICAgY2xpcEFyZWEoY3R4LCB7XHJcbiAgICAgICAgbGVmdDogY2xpcC5sZWZ0ID09PSBmYWxzZSA/IDAgOiBhcmVhLmxlZnQgLSBjbGlwLmxlZnQsXHJcbiAgICAgICAgcmlnaHQ6IGNsaXAucmlnaHQgPT09IGZhbHNlID8gdGhpcy53aWR0aCA6IGFyZWEucmlnaHQgKyBjbGlwLnJpZ2h0LFxyXG4gICAgICAgIHRvcDogY2xpcC50b3AgPT09IGZhbHNlID8gMCA6IGFyZWEudG9wIC0gY2xpcC50b3AsXHJcbiAgICAgICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyB0aGlzLmhlaWdodCA6IGFyZWEuYm90dG9tICsgY2xpcC5ib3R0b21cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBtZXRhLmNvbnRyb2xsZXIuZHJhdygpO1xyXG4gICAgaWYgKHVzZUNsaXApIHtcclxuICAgICAgdW5jbGlwQXJlYShjdHgpO1xyXG4gICAgfVxyXG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XHJcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldERyYXcnLCBhcmdzKTtcclxuICB9XHJcbiAgaXNQb2ludEluQXJlYShwb2ludCkge1xyXG4gICAgcmV0dXJuIF9pc1BvaW50SW5BcmVhKHBvaW50LCB0aGlzLmNoYXJ0QXJlYSwgdGhpcy5fbWluUGFkZGluZyk7XHJcbiAgfVxyXG4gIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgbW9kZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xyXG4gICAgY29uc3QgbWV0aG9kID0gSW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XHJcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuICBnZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcclxuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcclxuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XHJcbiAgICBsZXQgbWV0YSA9IG1ldGFzZXRzLmZpbHRlcih4ID0+IHggJiYgeC5fZGF0YXNldCA9PT0gZGF0YXNldCkucG9wKCk7XHJcbiAgICBpZiAoIW1ldGEpIHtcclxuICAgICAgbWV0YSA9IHtcclxuICAgICAgICB0eXBlOiBudWxsLFxyXG4gICAgICAgIGRhdGE6IFtdLFxyXG4gICAgICAgIGRhdGFzZXQ6IG51bGwsXHJcbiAgICAgICAgY29udHJvbGxlcjogbnVsbCxcclxuICAgICAgICBoaWRkZW46IG51bGwsXHJcbiAgICAgICAgeEF4aXNJRDogbnVsbCxcclxuICAgICAgICB5QXhpc0lEOiBudWxsLFxyXG4gICAgICAgIG9yZGVyOiBkYXRhc2V0ICYmIGRhdGFzZXQub3JkZXIgfHwgMCxcclxuICAgICAgICBpbmRleDogZGF0YXNldEluZGV4LFxyXG4gICAgICAgIF9kYXRhc2V0OiBkYXRhc2V0LFxyXG4gICAgICAgIF9wYXJzZWQ6IFtdLFxyXG4gICAgICAgIF9zb3J0ZWQ6IGZhbHNlXHJcbiAgICAgIH07XHJcbiAgICAgIG1ldGFzZXRzLnB1c2gobWV0YSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWV0YTtcclxuICB9XHJcbiAgZ2V0Q29udGV4dCgpIHtcclxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsLCB7Y2hhcnQ6IHRoaXMsIHR5cGU6ICdjaGFydCd9KSk7XHJcbiAgfVxyXG4gIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkubGVuZ3RoO1xyXG4gIH1cclxuICBpc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkge1xyXG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xyXG4gICAgaWYgKCFkYXRhc2V0KSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XHJcbiAgICByZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhZGF0YXNldC5oaWRkZW47XHJcbiAgfVxyXG4gIHNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSkge1xyXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcclxuICAgIG1ldGEuaGlkZGVuID0gIXZpc2libGU7XHJcbiAgfVxyXG4gIHRvZ2dsZURhdGFWaXNpYmlsaXR5KGluZGV4KSB7XHJcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XSA9ICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcclxuICB9XHJcbiAgZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcclxuICAgIHJldHVybiAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XHJcbiAgfVxyXG4gIF91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB2aXNpYmxlKSB7XHJcbiAgICBjb25zdCBtb2RlID0gdmlzaWJsZSA/ICdzaG93JyA6ICdoaWRlJztcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XHJcbiAgICBjb25zdCBhbmltcyA9IG1ldGEuY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKTtcclxuICAgIGlmIChkZWZpbmVkKGRhdGFJbmRleCkpIHtcclxuICAgICAgbWV0YS5kYXRhW2RhdGFJbmRleF0uaGlkZGVuID0gIXZpc2libGU7XHJcbiAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSk7XHJcbiAgICAgIGFuaW1zLnVwZGF0ZShtZXRhLCB7dmlzaWJsZX0pO1xyXG4gICAgICB0aGlzLnVwZGF0ZSgoY3R4KSA9PiBjdHguZGF0YXNldEluZGV4ID09PSBkYXRhc2V0SW5kZXggPyBtb2RlIDogdW5kZWZpbmVkKTtcclxuICAgIH1cclxuICB9XHJcbiAgaGlkZShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xyXG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgZmFsc2UpO1xyXG4gIH1cclxuICBzaG93KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XHJcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB0cnVlKTtcclxuICB9XHJcbiAgX2Rlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xyXG4gICAgaWYgKG1ldGEgJiYgbWV0YS5jb250cm9sbGVyKSB7XHJcbiAgICAgIG1ldGEuY29udHJvbGxlci5fZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlIHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XHJcbiAgfVxyXG4gIF9zdG9wKCkge1xyXG4gICAgbGV0IGksIGlsZW47XHJcbiAgICB0aGlzLnN0b3AoKTtcclxuICAgIGFuaW1hdG9yLnJlbW92ZSh0aGlzKTtcclxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcclxuICAgIH1cclxuICB9XHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGVzdHJveScpO1xyXG4gICAgY29uc3Qge2NhbnZhcywgY3R4fSA9IHRoaXM7XHJcbiAgICB0aGlzLl9zdG9wKCk7XHJcbiAgICB0aGlzLmNvbmZpZy5jbGVhckNhY2hlKCk7XHJcbiAgICBpZiAoY2FudmFzKSB7XHJcbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XHJcbiAgICAgIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KTtcclxuICAgICAgdGhpcy5wbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChjdHgpO1xyXG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XHJcbiAgICAgIHRoaXMuY3R4ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnZGVzdHJveScpO1xyXG4gICAgZGVsZXRlIGluc3RhbmNlc1t0aGlzLmlkXTtcclxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEZXN0cm95Jyk7XHJcbiAgfVxyXG4gIHRvQmFzZTY0SW1hZ2UoLi4uYXJncykge1xyXG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCguLi5hcmdzKTtcclxuICB9XHJcbiAgYmluZEV2ZW50cygpIHtcclxuICAgIHRoaXMuYmluZFVzZXJFdmVudHMoKTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xyXG4gICAgICB0aGlzLmJpbmRSZXNwb25zaXZlRXZlbnRzKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgYmluZFVzZXJFdmVudHMoKSB7XHJcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XHJcbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XHJcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xyXG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcclxuICAgIH07XHJcbiAgICBjb25zdCBsaXN0ZW5lciA9IChlLCB4LCB5KSA9PiB7XHJcbiAgICAgIGUub2Zmc2V0WCA9IHg7XHJcbiAgICAgIGUub2Zmc2V0WSA9IHk7XHJcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihlKTtcclxuICAgIH07XHJcbiAgICBlYWNoKHRoaXMub3B0aW9ucy5ldmVudHMsICh0eXBlKSA9PiBfYWRkKHR5cGUsIGxpc3RlbmVyKSk7XHJcbiAgfVxyXG4gIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xyXG4gICAgaWYgKCF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzKSB7XHJcbiAgICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB7fTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnM7XHJcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XHJcbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XHJcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xyXG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcclxuICAgIH07XHJcbiAgICBjb25zdCBfcmVtb3ZlID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XHJcbiAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0pIHtcclxuICAgICAgICBwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcclxuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW3R5cGVdO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbGlzdGVuZXIgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcclxuICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGxldCBkZXRhY2hlZDtcclxuICAgIGNvbnN0IGF0dGFjaGVkID0gKCkgPT4ge1xyXG4gICAgICBfcmVtb3ZlKCdhdHRhY2gnLCBhdHRhY2hlZCk7XHJcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLnJlc2l6ZSgpO1xyXG4gICAgICBfYWRkKCdyZXNpemUnLCBsaXN0ZW5lcik7XHJcbiAgICAgIF9hZGQoJ2RldGFjaCcsIGRldGFjaGVkKTtcclxuICAgIH07XHJcbiAgICBkZXRhY2hlZCA9ICgpID0+IHtcclxuICAgICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xyXG4gICAgICBfcmVtb3ZlKCdyZXNpemUnLCBsaXN0ZW5lcik7XHJcbiAgICAgIHRoaXMuX3N0b3AoKTtcclxuICAgICAgdGhpcy5fcmVzaXplKDAsIDApO1xyXG4gICAgICBfYWRkKCdhdHRhY2gnLCBhdHRhY2hlZCk7XHJcbiAgICB9O1xyXG4gICAgaWYgKHBsYXRmb3JtLmlzQXR0YWNoZWQodGhpcy5jYW52YXMpKSB7XHJcbiAgICAgIGF0dGFjaGVkKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZXRhY2hlZCgpO1xyXG4gICAgfVxyXG4gIH1cclxuICB1bmJpbmRFdmVudHMoKSB7XHJcbiAgICBlYWNoKHRoaXMuX2xpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XHJcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgZWFjaCh0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcclxuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgdXBkYXRlSG92ZXJTdHlsZShpdGVtcywgbW9kZSwgZW5hYmxlZCkge1xyXG4gICAgY29uc3QgcHJlZml4ID0gZW5hYmxlZCA/ICdzZXQnIDogJ3JlbW92ZSc7XHJcbiAgICBsZXQgbWV0YSwgaXRlbSwgaSwgaWxlbjtcclxuICAgIGlmIChtb2RlID09PSAnZGF0YXNldCcpIHtcclxuICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbXNbMF0uZGF0YXNldEluZGV4KTtcclxuICAgICAgbWV0YS5jb250cm9sbGVyWydfJyArIHByZWZpeCArICdEYXRhc2V0SG92ZXJTdHlsZSddKCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcclxuICAgICAgY29uc3QgY29udHJvbGxlciA9IGl0ZW0gJiYgdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtLmRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcclxuICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcclxuICAgICAgICBjb250cm9sbGVyW3ByZWZpeCArICdIb3ZlclN0eWxlJ10oaXRlbS5lbGVtZW50LCBpdGVtLmRhdGFzZXRJbmRleCwgaXRlbS5pbmRleCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xyXG4gIH1cclxuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cykge1xyXG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcclxuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XHJcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XHJcbiAgICAgIGlmICghbWV0YSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YXNldCBmb3VuZCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGRhdGFzZXRJbmRleCxcclxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxyXG4gICAgICAgIGluZGV4LFxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XHJcbiAgICBpZiAoY2hhbmdlZCkge1xyXG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XHJcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIG5vdGlmeVBsdWdpbnMoaG9vaywgYXJncywgZmlsdGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5ub3RpZnkodGhpcywgaG9vaywgYXJncywgZmlsdGVyKTtcclxuICB9XHJcbiAgX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KSB7XHJcbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XHJcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHguZGF0YXNldEluZGV4ID09PSB5LmRhdGFzZXRJbmRleCAmJiB4LmluZGV4ID09PSB5LmluZGV4KSk7XHJcbiAgICBjb25zdCBkZWFjdGl2YXRlZCA9IGRpZmYobGFzdEFjdGl2ZSwgYWN0aXZlKTtcclxuICAgIGNvbnN0IGFjdGl2YXRlZCA9IHJlcGxheSA/IGFjdGl2ZSA6IGRpZmYoYWN0aXZlLCBsYXN0QWN0aXZlKTtcclxuICAgIGlmIChkZWFjdGl2YXRlZC5sZW5ndGgpIHtcclxuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGRlYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKGFjdGl2YXRlZC5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcclxuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xyXG4gICAgfVxyXG4gIH1cclxuICBfZXZlbnRIYW5kbGVyKGUsIHJlcGxheSkge1xyXG4gICAgY29uc3QgYXJncyA9IHtcclxuICAgICAgZXZlbnQ6IGUsXHJcbiAgICAgIHJlcGxheSxcclxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcclxuICAgICAgaW5DaGFydEFyZWE6IHRoaXMuaXNQb2ludEluQXJlYShlKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGV2ZW50RmlsdGVyID0gKHBsdWdpbikgPT4gKHBsdWdpbi5vcHRpb25zLmV2ZW50cyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyhlLm5hdGl2ZS50eXBlKTtcclxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpID09PSBmYWxzZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5faGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBhcmdzLmluQ2hhcnRBcmVhKTtcclxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpO1xyXG4gICAgaWYgKGNoYW5nZWQgfHwgYXJncy5jaGFuZ2VkKSB7XHJcbiAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbiAgX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcclxuICAgIGNvbnN0IHtfYWN0aXZlOiBsYXN0QWN0aXZlID0gW10sIG9wdGlvbnN9ID0gdGhpcztcclxuICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSByZXBsYXk7XHJcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbik7XHJcbiAgICBjb25zdCBpc0NsaWNrID0gX2lzQ2xpY2tFdmVudChlKTtcclxuICAgIGNvbnN0IGxhc3RFdmVudCA9IGRldGVybWluZUxhc3RFdmVudChlLCB0aGlzLl9sYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKTtcclxuICAgIGlmIChpbkNoYXJ0QXJlYSkge1xyXG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xyXG4gICAgICBjYWxsYmFjayhvcHRpb25zLm9uSG92ZXIsIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcclxuICAgICAgaWYgKGlzQ2xpY2spIHtcclxuICAgICAgICBjYWxsYmFjayhvcHRpb25zLm9uQ2xpY2ssIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xyXG4gICAgaWYgKGNoYW5nZWQgfHwgcmVwbGF5KSB7XHJcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcclxuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbGFzdEV2ZW50O1xyXG4gICAgcmV0dXJuIGNoYW5nZWQ7XHJcbiAgfVxyXG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbikge1xyXG4gICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XHJcbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcclxuICB9XHJcbn1cclxuY29uc3QgaW52YWxpZGF0ZVBsdWdpbnMgPSAoKSA9PiBlYWNoKENoYXJ0Lmluc3RhbmNlcywgKGNoYXJ0KSA9PiBjaGFydC5fcGx1Z2lucy5pbnZhbGlkYXRlKCkpO1xyXG5jb25zdCBlbnVtZXJhYmxlID0gdHJ1ZTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2hhcnQsIHtcclxuICBkZWZhdWx0czoge1xyXG4gICAgZW51bWVyYWJsZSxcclxuICAgIHZhbHVlOiBkZWZhdWx0c1xyXG4gIH0sXHJcbiAgaW5zdGFuY2VzOiB7XHJcbiAgICBlbnVtZXJhYmxlLFxyXG4gICAgdmFsdWU6IGluc3RhbmNlc1xyXG4gIH0sXHJcbiAgb3ZlcnJpZGVzOiB7XHJcbiAgICBlbnVtZXJhYmxlLFxyXG4gICAgdmFsdWU6IG92ZXJyaWRlc1xyXG4gIH0sXHJcbiAgcmVnaXN0cnk6IHtcclxuICAgIGVudW1lcmFibGUsXHJcbiAgICB2YWx1ZTogcmVnaXN0cnlcclxuICB9LFxyXG4gIHZlcnNpb246IHtcclxuICAgIGVudW1lcmFibGUsXHJcbiAgICB2YWx1ZTogdmVyc2lvblxyXG4gIH0sXHJcbiAgZ2V0Q2hhcnQ6IHtcclxuICAgIGVudW1lcmFibGUsXHJcbiAgICB2YWx1ZTogZ2V0Q2hhcnRcclxuICB9LFxyXG4gIHJlZ2lzdGVyOiB7XHJcbiAgICBlbnVtZXJhYmxlLFxyXG4gICAgdmFsdWU6ICguLi5pdGVtcykgPT4ge1xyXG4gICAgICByZWdpc3RyeS5hZGQoLi4uaXRlbXMpO1xyXG4gICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgdW5yZWdpc3Rlcjoge1xyXG4gICAgZW51bWVyYWJsZSxcclxuICAgIHZhbHVlOiAoLi4uaXRlbXMpID0+IHtcclxuICAgICAgcmVnaXN0cnkucmVtb3ZlKC4uLml0ZW1zKTtcclxuICAgICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gYWJzdHJhY3QoKSB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQ6IENoZWNrIHRoYXQgYSBjb21wbGV0ZSBkYXRlIGFkYXB0ZXIgaXMgcHJvdmlkZWQuJyk7XHJcbn1cclxuY2xhc3MgRGF0ZUFkYXB0ZXIge1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgfVxyXG4gIGZvcm1hdHMoKSB7XHJcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcclxuICB9XHJcbiAgcGFyc2UodmFsdWUsIGZvcm1hdCkge1xyXG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XHJcbiAgfVxyXG4gIGZvcm1hdCh0aW1lc3RhbXAsIGZvcm1hdCkge1xyXG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XHJcbiAgfVxyXG4gIGFkZCh0aW1lc3RhbXAsIGFtb3VudCwgdW5pdCkge1xyXG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XHJcbiAgfVxyXG4gIGRpZmYoYSwgYiwgdW5pdCkge1xyXG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XHJcbiAgfVxyXG4gIHN0YXJ0T2YodGltZXN0YW1wLCB1bml0LCB3ZWVrZGF5KSB7XHJcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcclxuICB9XHJcbiAgZW5kT2YodGltZXN0YW1wLCB1bml0KSB7XHJcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcclxuICB9XHJcbn1cclxuRGF0ZUFkYXB0ZXIub3ZlcnJpZGUgPSBmdW5jdGlvbihtZW1iZXJzKSB7XHJcbiAgT2JqZWN0LmFzc2lnbihEYXRlQWRhcHRlci5wcm90b3R5cGUsIG1lbWJlcnMpO1xyXG59O1xyXG52YXIgX2FkYXB0ZXJzID0ge1xyXG4gIF9kYXRlOiBEYXRlQWRhcHRlclxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIHR5cGUpIHtcclxuICBpZiAoIXNjYWxlLl9jYWNoZS4kYmFyKSB7XHJcbiAgICBjb25zdCB2aXNpYmxlTWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKTtcclxuICAgIGxldCB2YWx1ZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdmlzaWJsZU1ldGFzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xyXG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHZpc2libGVNZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkpO1xyXG4gICAgfVxyXG4gICAgc2NhbGUuX2NhY2hlLiRiYXIgPSBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKSk7XHJcbiAgfVxyXG4gIHJldHVybiBzY2FsZS5fY2FjaGUuJGJhcjtcclxufVxyXG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKSB7XHJcbiAgY29uc3Qgc2NhbGUgPSBtZXRhLmlTY2FsZTtcclxuICBjb25zdCB2YWx1ZXMgPSBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgbWV0YS50eXBlKTtcclxuICBsZXQgbWluID0gc2NhbGUuX2xlbmd0aDtcclxuICBsZXQgaSwgaWxlbiwgY3VyciwgcHJldjtcclxuICBjb25zdCB1cGRhdGVNaW5BbmRQcmV2ID0gKCkgPT4ge1xyXG4gICAgaWYgKGN1cnIgPT09IDMyNzY3IHx8IGN1cnIgPT09IC0zMjc2OCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoZGVmaW5lZChwcmV2KSkge1xyXG4gICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguYWJzKGN1cnIgLSBwcmV2KSB8fCBtaW4pO1xyXG4gICAgfVxyXG4gICAgcHJldiA9IGN1cnI7XHJcbiAgfTtcclxuICBmb3IgKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodmFsdWVzW2ldKTtcclxuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcclxuICB9XHJcbiAgcHJldiA9IHVuZGVmaW5lZDtcclxuICBmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGkpO1xyXG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xyXG4gIH1cclxuICByZXR1cm4gbWluO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcclxuICBjb25zdCB0aGlja25lc3MgPSBvcHRpb25zLmJhclRoaWNrbmVzcztcclxuICBsZXQgc2l6ZSwgcmF0aW87XHJcbiAgaWYgKGlzTnVsbE9yVW5kZWYodGhpY2tuZXNzKSkge1xyXG4gICAgc2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xyXG4gICAgcmF0aW8gPSBvcHRpb25zLmJhclBlcmNlbnRhZ2U7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNpemUgPSB0aGlja25lc3MgKiBzdGFja0NvdW50O1xyXG4gICAgcmF0aW8gPSAxO1xyXG4gIH1cclxuICByZXR1cm4ge1xyXG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxyXG4gICAgcmF0aW8sXHJcbiAgICBzdGFydDogcnVsZXIucGl4ZWxzW2luZGV4XSAtIChzaXplIC8gMilcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XHJcbiAgY29uc3QgcGl4ZWxzID0gcnVsZXIucGl4ZWxzO1xyXG4gIGNvbnN0IGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xyXG4gIGxldCBwcmV2ID0gaW5kZXggPiAwID8gcGl4ZWxzW2luZGV4IC0gMV0gOiBudWxsO1xyXG4gIGxldCBuZXh0ID0gaW5kZXggPCBwaXhlbHMubGVuZ3RoIC0gMSA/IHBpeGVsc1tpbmRleCArIDFdIDogbnVsbDtcclxuICBjb25zdCBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XHJcbiAgaWYgKHByZXYgPT09IG51bGwpIHtcclxuICAgIHByZXYgPSBjdXJyIC0gKG5leHQgPT09IG51bGwgPyBydWxlci5lbmQgLSBydWxlci5zdGFydCA6IG5leHQgLSBjdXJyKTtcclxuICB9XHJcbiAgaWYgKG5leHQgPT09IG51bGwpIHtcclxuICAgIG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XHJcbiAgfVxyXG4gIGNvbnN0IHN0YXJ0ID0gY3VyciAtIChjdXJyIC0gTWF0aC5taW4ocHJldiwgbmV4dCkpIC8gMiAqIHBlcmNlbnQ7XHJcbiAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKG5leHQgLSBwcmV2KSAvIDIgKiBwZXJjZW50O1xyXG4gIHJldHVybiB7XHJcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXHJcbiAgICByYXRpbzogb3B0aW9ucy5iYXJQZXJjZW50YWdlLFxyXG4gICAgc3RhcnRcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xyXG4gIGNvbnN0IHN0YXJ0VmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMF0sIGkpO1xyXG4gIGNvbnN0IGVuZFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzFdLCBpKTtcclxuICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XHJcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xyXG4gIGxldCBiYXJTdGFydCA9IG1pbjtcclxuICBsZXQgYmFyRW5kID0gbWF4O1xyXG4gIGlmIChNYXRoLmFicyhtaW4pID4gTWF0aC5hYnMobWF4KSkge1xyXG4gICAgYmFyU3RhcnQgPSBtYXg7XHJcbiAgICBiYXJFbmQgPSBtaW47XHJcbiAgfVxyXG4gIGl0ZW1bdlNjYWxlLmF4aXNdID0gYmFyRW5kO1xyXG4gIGl0ZW0uX2N1c3RvbSA9IHtcclxuICAgIGJhclN0YXJ0LFxyXG4gICAgYmFyRW5kLFxyXG4gICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXHJcbiAgICBlbmQ6IGVuZFZhbHVlLFxyXG4gICAgbWluLFxyXG4gICAgbWF4XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcclxuICBpZiAoaXNBcnJheShlbnRyeSkpIHtcclxuICAgIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gdlNjYWxlLnBhcnNlKGVudHJ5LCBpKTtcclxuICB9XHJcbiAgcmV0dXJuIGl0ZW07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xyXG4gIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xyXG4gIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xyXG4gIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcclxuICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xyXG4gIGNvbnN0IHBhcnNlZCA9IFtdO1xyXG4gIGxldCBpLCBpbGVuLCBpdGVtLCBlbnRyeTtcclxuICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcclxuICAgIGVudHJ5ID0gZGF0YVtpXTtcclxuICAgIGl0ZW0gPSB7fTtcclxuICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XHJcbiAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpKTtcclxuICB9XHJcbiAgcmV0dXJuIHBhcnNlZDtcclxufVxyXG5mdW5jdGlvbiBpc0Zsb2F0QmFyKGN1c3RvbSkge1xyXG4gIHJldHVybiBjdXN0b20gJiYgY3VzdG9tLmJhclN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgY3VzdG9tLmJhckVuZCAhPT0gdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSB7XHJcbiAgaWYgKHNpemUgIT09IDApIHtcclxuICAgIHJldHVybiBzaWduKHNpemUpO1xyXG4gIH1cclxuICByZXR1cm4gKHZTY2FsZS5pc0hvcml6b250YWwoKSA/IDEgOiAtMSkgKiAodlNjYWxlLm1pbiA+PSBhY3R1YWxCYXNlID8gMSA6IC0xKTtcclxufVxyXG5mdW5jdGlvbiBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKSB7XHJcbiAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xyXG4gIGlmIChwcm9wZXJ0aWVzLmhvcml6b250YWwpIHtcclxuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPiBwcm9wZXJ0aWVzLng7XHJcbiAgICBzdGFydCA9ICdsZWZ0JztcclxuICAgIGVuZCA9ICdyaWdodCc7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XHJcbiAgICBzdGFydCA9ICdib3R0b20nO1xyXG4gICAgZW5kID0gJ3RvcCc7XHJcbiAgfVxyXG4gIGlmIChyZXZlcnNlKSB7XHJcbiAgICB0b3AgPSAnZW5kJztcclxuICAgIGJvdHRvbSA9ICdzdGFydCc7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRvcCA9ICdzdGFydCc7XHJcbiAgICBib3R0b20gPSAnZW5kJztcclxuICB9XHJcbiAgcmV0dXJuIHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX07XHJcbn1cclxuZnVuY3Rpb24gc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpIHtcclxuICBsZXQgZWRnZSA9IG9wdGlvbnMuYm9yZGVyU2tpcHBlZDtcclxuICBjb25zdCByZXMgPSB7fTtcclxuICBpZiAoIWVkZ2UpIHtcclxuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3Qge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfSA9IGJvcmRlclByb3BzKHByb3BlcnRpZXMpO1xyXG4gIGlmIChlZGdlID09PSAnbWlkZGxlJyAmJiBzdGFjaykge1xyXG4gICAgcHJvcGVydGllcy5lbmFibGVCb3JkZXJSYWRpdXMgPSB0cnVlO1xyXG4gICAgaWYgKChzdGFjay5fdG9wIHx8IDApID09PSBpbmRleCkge1xyXG4gICAgICBlZGdlID0gdG9wO1xyXG4gICAgfSBlbHNlIGlmICgoc3RhY2suX2JvdHRvbSB8fCAwKSA9PT0gaW5kZXgpIHtcclxuICAgICAgZWRnZSA9IGJvdHRvbTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc1twYXJzZUVkZ2UoYm90dG9tLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xyXG4gICAgICBlZGdlID0gdG9wO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXNbcGFyc2VFZGdlKGVkZ2UsIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XHJcbiAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlRWRnZShlZGdlLCBhLCBiLCByZXZlcnNlKSB7XHJcbiAgaWYgKHJldmVyc2UpIHtcclxuICAgIGVkZ2UgPSBzd2FwKGVkZ2UsIGEsIGIpO1xyXG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGIsIGEpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYSwgYik7XHJcbiAgfVxyXG4gIHJldHVybiBlZGdlO1xyXG59XHJcbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XHJcbiAgcmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcclxufVxyXG5mdW5jdGlvbiBzdGFydEVuZCh2LCBzdGFydCwgZW5kKSB7XHJcbiAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcclxufVxyXG5mdW5jdGlvbiBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIHtpbmZsYXRlQW1vdW50fSwgcmF0aW8pIHtcclxuICBwcm9wZXJ0aWVzLmluZmxhdGVBbW91bnQgPSBpbmZsYXRlQW1vdW50ID09PSAnYXV0bydcclxuICAgID8gcmF0aW8gPT09IDEgPyAwLjMzIDogMFxyXG4gICAgOiBpbmZsYXRlQW1vdW50O1xyXG59XHJcbmNsYXNzIEJhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XHJcbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xyXG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xyXG4gIH1cclxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcclxuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcclxuICB9XHJcbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xyXG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XHJcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XHJcbiAgICBjb25zdCBpQXhpc0tleSA9IGlTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xyXG4gICAgY29uc3QgdkF4aXNLZXkgPSB2U2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcclxuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xyXG4gICAgbGV0IGksIGlsZW4sIGl0ZW0sIG9iajtcclxuICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICBvYmogPSBkYXRhW2ldO1xyXG4gICAgICBpdGVtID0ge307XHJcbiAgICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gaVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkob2JqLCBpQXhpc0tleSksIGkpO1xyXG4gICAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKHJlc29sdmVPYmplY3RLZXkob2JqLCB2QXhpc0tleSksIGl0ZW0sIHZTY2FsZSwgaSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnNlZDtcclxuICB9XHJcbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xyXG4gICAgc3VwZXIudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XHJcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcclxuICAgIGlmIChjdXN0b20gJiYgc2NhbGUgPT09IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlKSB7XHJcbiAgICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgY3VzdG9tLm1pbik7XHJcbiAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgY3VzdG9tLm1heCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldE1heE92ZXJmbG93KCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xyXG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XHJcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XHJcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcclxuICAgIGNvbnN0IHZhbHVlID0gaXNGbG9hdEJhcihjdXN0b20pXHJcbiAgICAgID8gJ1snICsgY3VzdG9tLnN0YXJ0ICsgJywgJyArIGN1c3RvbS5lbmQgKyAnXSdcclxuICAgICAgOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGFiZWw6ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSksXHJcbiAgICAgIHZhbHVlXHJcbiAgICB9O1xyXG4gIH1cclxuICBpbml0aWFsaXplKCkge1xyXG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcclxuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xyXG4gICAgbWV0YS5zdGFjayA9IHRoaXMuZ2V0RGF0YXNldCgpLnN0YWNrO1xyXG4gIH1cclxuICB1cGRhdGUobW9kZSkge1xyXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XHJcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKG1ldGEuZGF0YSwgMCwgbWV0YS5kYXRhLmxlbmd0aCwgbW9kZSk7XHJcbiAgfVxyXG4gIHVwZGF0ZUVsZW1lbnRzKGJhcnMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xyXG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xyXG4gICAgY29uc3Qge2luZGV4LCBfY2FjaGVkTWV0YToge3ZTY2FsZX19ID0gdGhpcztcclxuICAgIGNvbnN0IGJhc2UgPSB2U2NhbGUuZ2V0QmFzZVBpeGVsKCk7XHJcbiAgICBjb25zdCBob3Jpem9udGFsID0gdlNjYWxlLmlzSG9yaXpvbnRhbCgpO1xyXG4gICAgY29uc3QgcnVsZXIgPSB0aGlzLl9nZXRSdWxlcigpO1xyXG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcclxuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcclxuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcclxuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xyXG4gICAgICBjb25zdCB2cGl4ZWxzID0gcmVzZXQgfHwgaXNOdWxsT3JVbmRlZihwYXJzZWRbdlNjYWxlLmF4aXNdKSA/IHtiYXNlLCBoZWFkOiBiYXNlfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGkpO1xyXG4gICAgICBjb25zdCBpcGl4ZWxzID0gdGhpcy5fY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaSwgcnVsZXIpO1xyXG4gICAgICBjb25zdCBzdGFjayA9IChwYXJzZWQuX3N0YWNrcyB8fCB7fSlbdlNjYWxlLmF4aXNdO1xyXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgIGhvcml6b250YWwsXHJcbiAgICAgICAgYmFzZTogdnBpeGVscy5iYXNlLFxyXG4gICAgICAgIGVuYWJsZUJvcmRlclJhZGl1czogIXN0YWNrIHx8IGlzRmxvYXRCYXIocGFyc2VkLl9jdXN0b20pIHx8IChpbmRleCA9PT0gc3RhY2suX3RvcCB8fCBpbmRleCA9PT0gc3RhY2suX2JvdHRvbSksXHJcbiAgICAgICAgeDogaG9yaXpvbnRhbCA/IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyLFxyXG4gICAgICAgIHk6IGhvcml6b250YWwgPyBpcGl4ZWxzLmNlbnRlciA6IHZwaXhlbHMuaGVhZCxcclxuICAgICAgICBoZWlnaHQ6IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiBNYXRoLmFicyh2cGl4ZWxzLnNpemUpLFxyXG4gICAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gTWF0aC5hYnModnBpeGVscy5zaXplKSA6IGlwaXhlbHMuc2l6ZVxyXG4gICAgICB9O1xyXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcclxuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBiYXJzW2ldLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHByb3BlcnRpZXMub3B0aW9ucyB8fCBiYXJzW2ldLm9wdGlvbnM7XHJcbiAgICAgIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KTtcclxuICAgICAgc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCBvcHRpb25zLCBydWxlci5yYXRpbyk7XHJcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChiYXJzW2ldLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcclxuICAgIH1cclxuICB9XHJcbiAgX2dldFN0YWNrcyhsYXN0LCBkYXRhSW5kZXgpIHtcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xyXG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XHJcbiAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0aGlzLl90eXBlKTtcclxuICAgIGNvbnN0IHN0YWNrZWQgPSBpU2NhbGUub3B0aW9ucy5zdGFja2VkO1xyXG4gICAgY29uc3QgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDtcclxuICAgIGNvbnN0IHN0YWNrcyA9IFtdO1xyXG4gICAgbGV0IGksIGl0ZW07XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIGl0ZW0gPSBtZXRhc2V0c1tpXTtcclxuICAgICAgaWYgKCFpdGVtLmNvbnRyb2xsZXIub3B0aW9ucy5ncm91cGVkKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBkYXRhSW5kZXggIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgY29uc3QgdmFsID0gaXRlbS5jb250cm9sbGVyLmdldFBhcnNlZChkYXRhSW5kZXgpW1xyXG4gICAgICAgICAgaXRlbS5jb250cm9sbGVyLl9jYWNoZWRNZXRhLnZTY2FsZS5heGlzXHJcbiAgICAgICAgXTtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWwpIHx8IGlzTmFOKHZhbCkpIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RhY2tlZCA9PT0gZmFsc2UgfHwgc3RhY2tzLmluZGV4T2YoaXRlbS5zdGFjaykgPT09IC0xIHx8XHJcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBpdGVtLnN0YWNrID09PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgc3RhY2tzLnB1c2goaXRlbS5zdGFjayk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGl0ZW0uaW5kZXggPT09IGxhc3QpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFzdGFja3MubGVuZ3RoKSB7XHJcbiAgICAgIHN0YWNrcy5wdXNoKHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3RhY2tzO1xyXG4gIH1cclxuICBfZ2V0U3RhY2tDb3VudChpbmRleCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2dldFN0YWNrcyh1bmRlZmluZWQsIGluZGV4KS5sZW5ndGg7XHJcbiAgfVxyXG4gIF9nZXRTdGFja0luZGV4KGRhdGFzZXRJbmRleCwgbmFtZSwgZGF0YUluZGV4KSB7XHJcbiAgICBjb25zdCBzdGFja3MgPSB0aGlzLl9nZXRTdGFja3MoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpO1xyXG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICA/IHN0YWNrcy5pbmRleE9mKG5hbWUpXHJcbiAgICAgIDogLTE7XHJcbiAgICByZXR1cm4gKGluZGV4ID09PSAtMSlcclxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxyXG4gICAgICA6IGluZGV4O1xyXG4gIH1cclxuICBfZ2V0UnVsZXIoKSB7XHJcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XHJcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcclxuICAgIGNvbnN0IHBpeGVscyA9IFtdO1xyXG4gICAgbGV0IGksIGlsZW47XHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICBwaXhlbHMucHVzaChpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKVtpU2NhbGUuYXhpc10sIGkpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGJhclRoaWNrbmVzcyA9IG9wdHMuYmFyVGhpY2tuZXNzO1xyXG4gICAgY29uc3QgbWluID0gYmFyVGhpY2tuZXNzIHx8IGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbWluLFxyXG4gICAgICBwaXhlbHMsXHJcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXHJcbiAgICAgIGVuZDogaVNjYWxlLl9lbmRQaXhlbCxcclxuICAgICAgc3RhY2tDb3VudDogdGhpcy5fZ2V0U3RhY2tDb3VudCgpLFxyXG4gICAgICBzY2FsZTogaVNjYWxlLFxyXG4gICAgICBncm91cGVkOiBvcHRzLmdyb3VwZWQsXHJcbiAgICAgIHJhdGlvOiBiYXJUaGlja25lc3MgPyAxIDogb3B0cy5jYXRlZ29yeVBlcmNlbnRhZ2UgKiBvcHRzLmJhclBlcmNlbnRhZ2VcclxuICAgIH07XHJcbiAgfVxyXG4gIF9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpbmRleCkge1xyXG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcclxuICAgIGNvbnN0IGFjdHVhbEJhc2UgPSBiYXNlVmFsdWUgfHwgMDtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcclxuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xyXG4gICAgY29uc3QgZmxvYXRpbmcgPSBpc0Zsb2F0QmFyKGN1c3RvbSk7XHJcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRbdlNjYWxlLmF4aXNdO1xyXG4gICAgbGV0IHN0YXJ0ID0gMDtcclxuICAgIGxldCBsZW5ndGggPSBfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogdmFsdWU7XHJcbiAgICBsZXQgaGVhZCwgc2l6ZTtcclxuICAgIGlmIChsZW5ndGggIT09IHZhbHVlKSB7XHJcbiAgICAgIHN0YXJ0ID0gbGVuZ3RoIC0gdmFsdWU7XHJcbiAgICAgIGxlbmd0aCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGZsb2F0aW5nKSB7XHJcbiAgICAgIHZhbHVlID0gY3VzdG9tLmJhclN0YXJ0O1xyXG4gICAgICBsZW5ndGggPSBjdXN0b20uYmFyRW5kIC0gY3VzdG9tLmJhclN0YXJ0O1xyXG4gICAgICBpZiAodmFsdWUgIT09IDAgJiYgc2lnbih2YWx1ZSkgIT09IHNpZ24oY3VzdG9tLmJhckVuZCkpIHtcclxuICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgc3RhcnQgKz0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGFydFZhbHVlID0gIWlzTnVsbE9yVW5kZWYoYmFzZVZhbHVlKSAmJiAhZmxvYXRpbmcgPyBiYXNlVmFsdWUgOiBzdGFydDtcclxuICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XHJcbiAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcclxuICAgICAgaGVhZCA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgbGVuZ3RoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGhlYWQgPSBiYXNlO1xyXG4gICAgfVxyXG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xyXG4gICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XHJcbiAgICAgIHNpemUgPSBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkgKiBtaW5CYXJMZW5ndGg7XHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gYWN0dWFsQmFzZSkge1xyXG4gICAgICAgIGJhc2UgLT0gc2l6ZSAvIDI7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc3RhcnRQaXhlbCA9IHZTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMCk7XHJcbiAgICAgIGNvbnN0IGVuZFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgxKTtcclxuICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xyXG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFBpeGVsLCBlbmRQaXhlbCk7XHJcbiAgICAgIGJhc2UgPSBNYXRoLm1heChNYXRoLm1pbihiYXNlLCBtYXgpLCBtaW4pO1xyXG4gICAgICBoZWFkID0gYmFzZSArIHNpemU7XHJcbiAgICB9XHJcbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcclxuICAgICAgY29uc3QgaGFsZkdyaWQgPSBzaWduKHNpemUpICogdlNjYWxlLmdldExpbmVXaWR0aEZvclZhbHVlKGFjdHVhbEJhc2UpIC8gMjtcclxuICAgICAgYmFzZSArPSBoYWxmR3JpZDtcclxuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNpemUsXHJcbiAgICAgIGJhc2UsXHJcbiAgICAgIGhlYWQsXHJcbiAgICAgIGNlbnRlcjogaGVhZCArIHNpemUgLyAyXHJcbiAgICB9O1xyXG4gIH1cclxuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XHJcbiAgICBjb25zdCBzY2FsZSA9IHJ1bGVyLnNjYWxlO1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHNraXBOdWxsID0gb3B0aW9ucy5za2lwTnVsbDtcclxuICAgIGNvbnN0IG1heEJhclRoaWNrbmVzcyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubWF4QmFyVGhpY2tuZXNzLCBJbmZpbml0eSk7XHJcbiAgICBsZXQgY2VudGVyLCBzaXplO1xyXG4gICAgaWYgKHJ1bGVyLmdyb3VwZWQpIHtcclxuICAgICAgY29uc3Qgc3RhY2tDb3VudCA9IHNraXBOdWxsID8gdGhpcy5fZ2V0U3RhY2tDb3VudChpbmRleCkgOiBydWxlci5zdGFja0NvdW50O1xyXG4gICAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzID09PSAnZmxleCdcclxuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KVxyXG4gICAgICAgIDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCk7XHJcbiAgICAgIGNvbnN0IHN0YWNrSW5kZXggPSB0aGlzLl9nZXRTdGFja0luZGV4KHRoaXMuaW5kZXgsIHRoaXMuX2NhY2hlZE1ldGEuc3RhY2ssIHNraXBOdWxsID8gaW5kZXggOiB1bmRlZmluZWQpO1xyXG4gICAgICBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XHJcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJhbmdlLmNodW5rICogcmFuZ2UucmF0aW8pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2VudGVyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpbmRleClbc2NhbGUuYXhpc10sIGluZGV4KTtcclxuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcnVsZXIubWluICogcnVsZXIucmF0aW8pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYmFzZTogY2VudGVyIC0gc2l6ZSAvIDIsXHJcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxyXG4gICAgICBjZW50ZXIsXHJcbiAgICAgIHNpemVcclxuICAgIH07XHJcbiAgfVxyXG4gIGRyYXcoKSB7XHJcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcclxuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xyXG4gICAgY29uc3QgcmVjdHMgPSBtZXRhLmRhdGE7XHJcbiAgICBjb25zdCBpbGVuID0gcmVjdHMubGVuZ3RoO1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgZm9yICg7IGkgPCBpbGVuOyArK2kpIHtcclxuICAgICAgaWYgKHRoaXMuZ2V0UGFyc2VkKGkpW3ZTY2FsZS5heGlzXSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJlY3RzW2ldLmRyYXcodGhpcy5fY3R4KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5CYXJDb250cm9sbGVyLmlkID0gJ2Jhcic7XHJcbkJhckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XHJcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcclxuICBkYXRhRWxlbWVudFR5cGU6ICdiYXInLFxyXG4gIGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxyXG4gIGJhclBlcmNlbnRhZ2U6IDAuOSxcclxuICBncm91cGVkOiB0cnVlLFxyXG4gIGFuaW1hdGlvbnM6IHtcclxuICAgIG51bWJlcnM6IHtcclxuICAgICAgdHlwZTogJ251bWJlcicsXHJcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J11cclxuICAgIH1cclxuICB9XHJcbn07XHJcbkJhckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xyXG4gIHNjYWxlczoge1xyXG4gICAgX2luZGV4Xzoge1xyXG4gICAgICB0eXBlOiAnY2F0ZWdvcnknLFxyXG4gICAgICBvZmZzZXQ6IHRydWUsXHJcbiAgICAgIGdyaWQ6IHtcclxuICAgICAgICBvZmZzZXQ6IHRydWVcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIF92YWx1ZV86IHtcclxuICAgICAgdHlwZTogJ2xpbmVhcicsXHJcbiAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmNsYXNzIEJ1YmJsZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XHJcbiAgaW5pdGlhbGl6ZSgpIHtcclxuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XHJcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XHJcbiAgfVxyXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFyc2VkO1xyXG4gIH1cclxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xyXG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW1bMl0sIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFyc2VkO1xyXG4gIH1cclxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XHJcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XHJcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbSAmJiBpdGVtLnIgJiYgK2l0ZW0uciwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJzZWQ7XHJcbiAgfVxyXG4gIGdldE1heE92ZXJmbG93KCkge1xyXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcclxuICAgIGxldCBtYXggPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xyXG4gIH1cclxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XHJcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcclxuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xyXG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xyXG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcclxuICAgIGNvbnN0IHkgPSB5U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueSk7XHJcbiAgICBjb25zdCByID0gcGFyc2VkLl9jdXN0b207XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsYWJlbDogbWV0YS5sYWJlbCxcclxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArIChyID8gJywgJyArIHIgOiAnJykgKyAnKSdcclxuICAgIH07XHJcbiAgfVxyXG4gIHVwZGF0ZShtb2RlKSB7XHJcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XHJcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XHJcbiAgfVxyXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XHJcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XHJcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcclxuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XHJcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XHJcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XHJcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xyXG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcclxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xyXG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcclxuICAgICAgY29uc3QgcGFyc2VkID0gIXJlc2V0ICYmIHRoaXMuZ2V0UGFyc2VkKGkpO1xyXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XHJcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gcmVzZXQgPyBpU2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdKTtcclxuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFt2QXhpc10pO1xyXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCk7XHJcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xyXG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xyXG4gICAgICAgIGlmIChyZXNldCkge1xyXG4gICAgICAgICAgcHJvcGVydGllcy5vcHRpb25zLnJhZGl1cyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcclxuICB9XHJcbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xyXG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xyXG4gICAgbGV0IHZhbHVlcyA9IHN1cGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpO1xyXG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XHJcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlcywgeyRzaGFyZWQ6IGZhbHNlfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYWRpdXMgPSB2YWx1ZXMucmFkaXVzO1xyXG4gICAgaWYgKG1vZGUgIT09ICdhY3RpdmUnKSB7XHJcbiAgICAgIHZhbHVlcy5yYWRpdXMgPSAwO1xyXG4gICAgfVxyXG4gICAgdmFsdWVzLnJhZGl1cyArPSB2YWx1ZU9yRGVmYXVsdChwYXJzZWQgJiYgcGFyc2VkLl9jdXN0b20sIHJhZGl1cyk7XHJcbiAgICByZXR1cm4gdmFsdWVzO1xyXG4gIH1cclxufVxyXG5CdWJibGVDb250cm9sbGVyLmlkID0gJ2J1YmJsZSc7XHJcbkJ1YmJsZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XHJcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcclxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXHJcbiAgYW5pbWF0aW9uczoge1xyXG4gICAgbnVtYmVyczoge1xyXG4gICAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJ11cclxuICAgIH1cclxuICB9XHJcbn07XHJcbkJ1YmJsZUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xyXG4gIHNjYWxlczoge1xyXG4gICAgeDoge1xyXG4gICAgICB0eXBlOiAnbGluZWFyJ1xyXG4gICAgfSxcclxuICAgIHk6IHtcclxuICAgICAgdHlwZTogJ2xpbmVhcidcclxuICAgIH1cclxuICB9LFxyXG4gIHBsdWdpbnM6IHtcclxuICAgIHRvb2x0aXA6IHtcclxuICAgICAgY2FsbGJhY2tzOiB7XHJcbiAgICAgICAgdGl0bGUoKSB7XHJcbiAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCkge1xyXG4gIGxldCByYXRpb1ggPSAxO1xyXG4gIGxldCByYXRpb1kgPSAxO1xyXG4gIGxldCBvZmZzZXRYID0gMDtcclxuICBsZXQgb2Zmc2V0WSA9IDA7XHJcbiAgaWYgKGNpcmN1bWZlcmVuY2UgPCBUQVUpIHtcclxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcclxuICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XHJcbiAgICBjb25zdCBzdGFydFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcclxuICAgIGNvbnN0IHN0YXJ0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xyXG4gICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcclxuICAgIGNvbnN0IGVuZFkgPSBNYXRoLnNpbihlbmRBbmdsZSk7XHJcbiAgICBjb25zdCBjYWxjTWF4ID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAxIDogTWF0aC5tYXgoYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XHJcbiAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAtMSA6IE1hdGgubWluKGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xyXG4gICAgY29uc3QgbWF4WCA9IGNhbGNNYXgoMCwgc3RhcnRYLCBlbmRYKTtcclxuICAgIGNvbnN0IG1heFkgPSBjYWxjTWF4KEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XHJcbiAgICBjb25zdCBtaW5YID0gY2FsY01pbihQSSwgc3RhcnRYLCBlbmRYKTtcclxuICAgIGNvbnN0IG1pblkgPSBjYWxjTWluKFBJICsgSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcclxuICAgIHJhdGlvWCA9IChtYXhYIC0gbWluWCkgLyAyO1xyXG4gICAgcmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XHJcbiAgICBvZmZzZXRYID0gLShtYXhYICsgbWluWCkgLyAyO1xyXG4gICAgb2Zmc2V0WSA9IC0obWF4WSArIG1pblkpIC8gMjtcclxuICB9XHJcbiAgcmV0dXJuIHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX07XHJcbn1cclxuY2xhc3MgRG91Z2hudXRDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xyXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcclxuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xyXG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcclxuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5vZmZzZXRYID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5vZmZzZXRZID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBsaW5rU2NhbGVzKCkge31cclxuICBwYXJzZShzdGFydCwgY291bnQpIHtcclxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFzZXQoKS5kYXRhO1xyXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XHJcbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcclxuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxldCBnZXR0ZXIgPSAoaSkgPT4gK2RhdGFbaV07XHJcbiAgICAgIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcclxuICAgICAgICBjb25zdCB7a2V5ID0gJ3ZhbHVlJ30gPSB0aGlzLl9wYXJzaW5nO1xyXG4gICAgICAgIGdldHRlciA9IChpKSA9PiArcmVzb2x2ZU9iamVjdEtleShkYXRhW2ldLCBrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBpLCBpbGVuO1xyXG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcclxuICAgICAgICBtZXRhLl9wYXJzZWRbaV0gPSBnZXR0ZXIoaSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgX2dldFJvdGF0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMucm90YXRpb24gLSA5MCk7XHJcbiAgfVxyXG4gIF9nZXRDaXJjdW1mZXJlbmNlKCkge1xyXG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSk7XHJcbiAgfVxyXG4gIF9nZXRSb3RhdGlvbkV4dGVudHMoKSB7XHJcbiAgICBsZXQgbWluID0gVEFVO1xyXG4gICAgbGV0IG1heCA9IC1UQVU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XHJcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlcjtcclxuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGNvbnRyb2xsZXIuX2dldFJvdGF0aW9uKCk7XHJcbiAgICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IGNvbnRyb2xsZXIuX2dldENpcmN1bWZlcmVuY2UoKTtcclxuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJvdGF0aW9uKTtcclxuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJvdGF0aW9uICsgY2lyY3VtZmVyZW5jZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJvdGF0aW9uOiBtaW4sXHJcbiAgICAgIGNpcmN1bWZlcmVuY2U6IG1heCAtIG1pbixcclxuICAgIH07XHJcbiAgfVxyXG4gIHVwZGF0ZShtb2RlKSB7XHJcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICBjb25zdCB7Y2hhcnRBcmVhfSA9IGNoYXJ0O1xyXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XHJcbiAgICBjb25zdCBhcmNzID0gbWV0YS5kYXRhO1xyXG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMuZ2V0TWF4Qm9yZGVyV2lkdGgoKSArIHRoaXMuZ2V0TWF4T2Zmc2V0KGFyY3MpICsgdGhpcy5vcHRpb25zLnNwYWNpbmc7XHJcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoKE1hdGgubWluKGNoYXJ0QXJlYS53aWR0aCwgY2hhcnRBcmVhLmhlaWdodCkgLSBzcGFjaW5nKSAvIDIsIDApO1xyXG4gICAgY29uc3QgY3V0b3V0ID0gTWF0aC5taW4odG9QZXJjZW50YWdlKHRoaXMub3B0aW9ucy5jdXRvdXQsIG1heFNpemUpLCAxKTtcclxuICAgIGNvbnN0IGNoYXJ0V2VpZ2h0ID0gdGhpcy5fZ2V0UmluZ1dlaWdodCh0aGlzLmluZGV4KTtcclxuICAgIGNvbnN0IHtjaXJjdW1mZXJlbmNlLCByb3RhdGlvbn0gPSB0aGlzLl9nZXRSb3RhdGlvbkV4dGVudHMoKTtcclxuICAgIGNvbnN0IHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX0gPSBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KTtcclxuICAgIGNvbnN0IG1heFdpZHRoID0gKGNoYXJ0QXJlYS53aWR0aCAtIHNwYWNpbmcpIC8gcmF0aW9YO1xyXG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gKGNoYXJ0QXJlYS5oZWlnaHQgLSBzcGFjaW5nKSAvIHJhdGlvWTtcclxuICAgIGNvbnN0IG1heFJhZGl1cyA9IE1hdGgubWF4KE1hdGgubWluKG1heFdpZHRoLCBtYXhIZWlnaHQpIC8gMiwgMCk7XHJcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IHRvRGltZW5zaW9uKHRoaXMub3B0aW9ucy5yYWRpdXMsIG1heFJhZGl1cyk7XHJcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG91dGVyUmFkaXVzICogY3V0b3V0LCAwKTtcclxuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIHRoaXMuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcclxuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFggKiBvdXRlclJhZGl1cztcclxuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFkgKiBvdXRlclJhZGl1cztcclxuICAgIG1ldGEudG90YWwgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsKCk7XHJcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuaW5kZXgpO1xyXG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IE1hdGgubWF4KHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiBjaGFydFdlaWdodCwgMCk7XHJcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcclxuICB9XHJcbiAgX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpIHtcclxuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcclxuICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9nZXRDaXJjdW1mZXJlbmNlKCk7XHJcbiAgICBpZiAoKHJlc2V0ICYmIG9wdHMuYW5pbWF0aW9uLmFuaW1hdGVSb3RhdGUpIHx8ICF0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpIHx8IG1ldGEuX3BhcnNlZFtpXSA9PT0gbnVsbCB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShtZXRhLl9wYXJzZWRbaV0gKiBjaXJjdW1mZXJlbmNlIC8gVEFVKTtcclxuICB9XHJcbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XHJcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XHJcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XHJcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcclxuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcclxuICAgIGNvbnN0IGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcclxuICAgIGNvbnN0IGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcclxuICAgIGNvbnN0IGFuaW1hdGVTY2FsZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlO1xyXG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5pbm5lclJhZGl1cztcclxuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMub3V0ZXJSYWRpdXM7XHJcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xyXG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xyXG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xyXG4gICAgbGV0IHN0YXJ0QW5nbGUgPSB0aGlzLl9nZXRSb3RhdGlvbigpO1xyXG4gICAgbGV0IGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xyXG4gICAgICBzdGFydEFuZ2xlICs9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcclxuICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xyXG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xyXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgIHg6IGNlbnRlclggKyB0aGlzLm9mZnNldFgsXHJcbiAgICAgICAgeTogY2VudGVyWSArIHRoaXMub2Zmc2V0WSxcclxuICAgICAgICBzdGFydEFuZ2xlLFxyXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZSxcclxuICAgICAgICBjaXJjdW1mZXJlbmNlLFxyXG4gICAgICAgIG91dGVyUmFkaXVzLFxyXG4gICAgICAgIGlubmVyUmFkaXVzXHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xyXG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xyXG4gICAgICB9XHJcbiAgICAgIHN0YXJ0QW5nbGUgKz0gY2lyY3VtZmVyZW5jZTtcclxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcclxuICB9XHJcbiAgY2FsY3VsYXRlVG90YWwoKSB7XHJcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcclxuICAgIGNvbnN0IG1ldGFEYXRhID0gbWV0YS5kYXRhO1xyXG4gICAgbGV0IHRvdGFsID0gMDtcclxuICAgIGxldCBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGFEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gbWV0YS5fcGFyc2VkW2ldO1xyXG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIWlzTmFOKHZhbHVlKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFtZXRhRGF0YVtpXS5oaWRkZW4pIHtcclxuICAgICAgICB0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0b3RhbDtcclxuICB9XHJcbiAgY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh2YWx1ZSkge1xyXG4gICAgY29uc3QgdG90YWwgPSB0aGlzLl9jYWNoZWRNZXRhLnRvdGFsO1xyXG4gICAgaWYgKHRvdGFsID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiBUQVUgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xyXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XHJcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcclxuICAgICAgdmFsdWUsXHJcbiAgICB9O1xyXG4gIH1cclxuICBnZXRNYXhCb3JkZXJXaWR0aChhcmNzKSB7XHJcbiAgICBsZXQgbWF4ID0gMDtcclxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgIGxldCBpLCBpbGVuLCBtZXRhLCBjb250cm9sbGVyLCBvcHRpb25zO1xyXG4gICAgaWYgKCFhcmNzKSB7XHJcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICAgIGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XHJcbiAgICAgICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XHJcbiAgICAgICAgICBhcmNzID0gbWV0YS5kYXRhO1xyXG4gICAgICAgICAgY29udHJvbGxlciA9IG1ldGEuY29udHJvbGxlcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFhcmNzKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIG9wdGlvbnMgPSBjb250cm9sbGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XHJcbiAgICAgIGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XHJcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDAsIG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCB8fCAwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1heDtcclxuICB9XHJcbiAgZ2V0TWF4T2Zmc2V0KGFyY3MpIHtcclxuICAgIGxldCBtYXggPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xyXG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMub2Zmc2V0IHx8IDAsIG9wdGlvbnMuaG92ZXJPZmZzZXQgfHwgMCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF4O1xyXG4gIH1cclxuICBfZ2V0UmluZ1dlaWdodE9mZnNldChkYXRhc2V0SW5kZXgpIHtcclxuICAgIGxldCByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcclxuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xyXG4gICAgICAgIHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJpbmdXZWlnaHRPZmZzZXQ7XHJcbiAgfVxyXG4gIF9nZXRSaW5nV2VpZ2h0KGRhdGFzZXRJbmRleCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlT3JEZWZhdWx0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xyXG4gIH1cclxuICBfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHx8IDE7XHJcbiAgfVxyXG59XHJcbkRvdWdobnV0Q29udHJvbGxlci5pZCA9ICdkb3VnaG51dCc7XHJcbkRvdWdobnV0Q29udHJvbGxlci5kZWZhdWx0cyA9IHtcclxuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxyXG4gIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXHJcbiAgYW5pbWF0aW9uOiB7XHJcbiAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxyXG4gICAgYW5pbWF0ZVNjYWxlOiBmYWxzZVxyXG4gIH0sXHJcbiAgYW5pbWF0aW9uczoge1xyXG4gICAgbnVtYmVyczoge1xyXG4gICAgICB0eXBlOiAnbnVtYmVyJyxcclxuICAgICAgcHJvcGVydGllczogWydjaXJjdW1mZXJlbmNlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAneCcsICd5JywgJ29mZnNldCcsICdib3JkZXJXaWR0aCcsICdzcGFjaW5nJ11cclxuICAgIH0sXHJcbiAgfSxcclxuICBjdXRvdXQ6ICc1MCUnLFxyXG4gIHJvdGF0aW9uOiAwLFxyXG4gIGNpcmN1bWZlcmVuY2U6IDM2MCxcclxuICByYWRpdXM6ICcxMDAlJyxcclxuICBzcGFjaW5nOiAwLFxyXG4gIGluZGV4QXhpczogJ3InLFxyXG59O1xyXG5Eb3VnaG51dENvbnRyb2xsZXIuZGVzY3JpcHRvcnMgPSB7XHJcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycsXHJcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcclxufTtcclxuRG91Z2hudXRDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcclxuICBhc3BlY3RSYXRpbzogMSxcclxuICBwbHVnaW5zOiB7XHJcbiAgICBsZWdlbmQ6IHtcclxuICAgICAgbGFiZWxzOiB7XHJcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcclxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xyXG4gICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZX19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xyXG4gICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xyXG4gICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcclxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcclxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXHJcbiAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcclxuICAgICAgICAgICAgICAgIGluZGV4OiBpXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xyXG4gICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcclxuICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB0b29sdGlwOiB7XHJcbiAgICAgIGNhbGxiYWNrczoge1xyXG4gICAgICAgIHRpdGxlKCkge1xyXG4gICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFiZWwodG9vbHRpcEl0ZW0pIHtcclxuICAgICAgICAgIGxldCBkYXRhTGFiZWwgPSB0b29sdGlwSXRlbS5sYWJlbDtcclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xyXG4gICAgICAgICAgaWYgKGlzQXJyYXkoZGF0YUxhYmVsKSkge1xyXG4gICAgICAgICAgICBkYXRhTGFiZWwgPSBkYXRhTGFiZWwuc2xpY2UoKTtcclxuICAgICAgICAgICAgZGF0YUxhYmVsWzBdICs9IHZhbHVlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGF0YUxhYmVsICs9IHZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGRhdGFMYWJlbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5jbGFzcyBMaW5lQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcclxuICBpbml0aWFsaXplKCkge1xyXG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcclxuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gdHJ1ZTtcclxuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcclxuICB9XHJcbiAgdXBkYXRlKG1vZGUpIHtcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xyXG4gICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIGRhdGE6IHBvaW50cyA9IFtdLCBfZGF0YXNldH0gPSBtZXRhO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xyXG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XHJcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcclxuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xyXG4gICAgaWYgKHNjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xyXG4gICAgICBzdGFydCA9IDA7XHJcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XHJcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XHJcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xyXG4gICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcclxuICAgIH1cclxuICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xyXG4gICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xyXG4gICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcclxuICAgICAgb3B0aW9uc1xyXG4gICAgfSwgbW9kZSk7XHJcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcclxuICB9XHJcbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcclxuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcclxuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3N0YWNrZWQsIF9kYXRhc2V0fSA9IHRoaXMuX2NhY2hlZE1ldGE7XHJcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xyXG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xyXG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xyXG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcclxuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XHJcbiAgICBjb25zdCB7c3BhbkdhcHMsIHNlZ21lbnR9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xyXG4gICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xyXG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcclxuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XHJcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xyXG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XHJcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XHJcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XHJcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcclxuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xyXG4gICAgICBpZiAoc2VnbWVudCkge1xyXG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xyXG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcclxuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcclxuICAgICAgfVxyXG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xyXG4gICAgfVxyXG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XHJcbiAgfVxyXG4gIGdldE1heE92ZXJmbG93KCkge1xyXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XHJcbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xyXG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xyXG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcclxuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIGJvcmRlcjtcclxuICAgIH1cclxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcclxuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcclxuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xyXG4gIH1cclxuICBkcmF3KCkge1xyXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XHJcbiAgICBtZXRhLmRhdGFzZXQudXBkYXRlQ29udHJvbFBvaW50cyh0aGlzLmNoYXJ0LmNoYXJ0QXJlYSwgbWV0YS5pU2NhbGUuYXhpcyk7XHJcbiAgICBzdXBlci5kcmF3KCk7XHJcbiAgfVxyXG59XHJcbkxpbmVDb250cm9sbGVyLmlkID0gJ2xpbmUnO1xyXG5MaW5lQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcclxuICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcclxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXHJcbiAgc2hvd0xpbmU6IHRydWUsXHJcbiAgc3BhbkdhcHM6IGZhbHNlLFxyXG59O1xyXG5MaW5lQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XHJcbiAgc2NhbGVzOiB7XHJcbiAgICBfaW5kZXhfOiB7XHJcbiAgICAgIHR5cGU6ICdjYXRlZ29yeScsXHJcbiAgICB9LFxyXG4gICAgX3ZhbHVlXzoge1xyXG4gICAgICB0eXBlOiAnbGluZWFyJyxcclxuICAgIH0sXHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKSB7XHJcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XHJcbiAgbGV0IHN0YXJ0ID0gMDtcclxuICBsZXQgY291bnQgPSBwb2ludENvdW50O1xyXG4gIGlmIChtZXRhLl9zb3J0ZWQpIHtcclxuICAgIGNvbnN0IHtpU2NhbGUsIF9wYXJzZWR9ID0gbWV0YTtcclxuICAgIGNvbnN0IGF4aXMgPSBpU2NhbGUuYXhpcztcclxuICAgIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xyXG4gICAgaWYgKG1pbkRlZmluZWQpIHtcclxuICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShNYXRoLm1pbihcclxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1pbikubG8sXHJcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gcG9pbnRDb3VudCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1pbikpLmxvKSxcclxuICAgICAgMCwgcG9pbnRDb3VudCAtIDEpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1heERlZmluZWQpIHtcclxuICAgICAgY291bnQgPSBfbGltaXRWYWx1ZShNYXRoLm1heChcclxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1heCkuaGkgKyAxLFxyXG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IDAgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtYXgpKS5oaSArIDEpLFxyXG4gICAgICBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4ge3N0YXJ0LCBjb3VudH07XHJcbn1cclxuZnVuY3Rpb24gc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpIHtcclxuICBjb25zdCB7eFNjYWxlLCB5U2NhbGUsIF9zY2FsZVJhbmdlc30gPSBtZXRhO1xyXG4gIGNvbnN0IG5ld1JhbmdlcyA9IHtcclxuICAgIHhtaW46IHhTY2FsZS5taW4sXHJcbiAgICB4bWF4OiB4U2NhbGUubWF4LFxyXG4gICAgeW1pbjogeVNjYWxlLm1pbixcclxuICAgIHltYXg6IHlTY2FsZS5tYXhcclxuICB9O1xyXG4gIGlmICghX3NjYWxlUmFuZ2VzKSB7XHJcbiAgICBtZXRhLl9zY2FsZVJhbmdlcyA9IG5ld1JhbmdlcztcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBjb25zdCBjaGFuZ2VkID0gX3NjYWxlUmFuZ2VzLnhtaW4gIT09IHhTY2FsZS5taW5cclxuXHRcdHx8IF9zY2FsZVJhbmdlcy54bWF4ICE9PSB4U2NhbGUubWF4XHJcblx0XHR8fCBfc2NhbGVSYW5nZXMueW1pbiAhPT0geVNjYWxlLm1pblxyXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltYXggIT09IHlTY2FsZS5tYXg7XHJcbiAgT2JqZWN0LmFzc2lnbihfc2NhbGVSYW5nZXMsIG5ld1Jhbmdlcyk7XHJcbiAgcmV0dXJuIGNoYW5nZWQ7XHJcbn1cclxuXHJcbmNsYXNzIFBvbGFyQXJlYUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XHJcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xyXG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XHJcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xyXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XHJcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcclxuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0uciwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgfTtcclxuICB9XHJcbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xyXG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XHJcbiAgfVxyXG4gIHVwZGF0ZShtb2RlKSB7XHJcbiAgICBjb25zdCBhcmNzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xyXG4gICAgdGhpcy5fdXBkYXRlUmFkaXVzKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcclxuICB9XHJcbiAgZ2V0TWluTWF4KCkge1xyXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XHJcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xyXG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yO1xyXG4gICAgICBpZiAoIWlzTmFOKHBhcnNlZCkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcclxuICAgICAgICBpZiAocGFyc2VkIDwgcmFuZ2UubWluKSB7XHJcbiAgICAgICAgICByYW5nZS5taW4gPSBwYXJzZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJzZWQgPiByYW5nZS5tYXgpIHtcclxuICAgICAgICAgIHJhbmdlLm1heCA9IHBhcnNlZDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJhbmdlO1xyXG4gIH1cclxuICBfdXBkYXRlUmFkaXVzKCkge1xyXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xyXG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XHJcbiAgICBjb25zdCBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcclxuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgobWluU2l6ZSAvIDIsIDApO1xyXG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAob3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcclxuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcclxuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIChyYWRpdXNMZW5ndGggKiB0aGlzLmluZGV4KTtcclxuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoO1xyXG4gIH1cclxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcclxuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcclxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xyXG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcclxuICAgIGNvbnN0IGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xyXG4gICAgY29uc3QgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XHJcbiAgICBjb25zdCBkYXRhc2V0U3RhcnRBbmdsZSA9IHNjYWxlLmdldEluZGV4QW5nbGUoMCkgLSAwLjUgKiBQSTtcclxuICAgIGxldCBhbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xyXG4gICAgbGV0IGk7XHJcbiAgICBjb25zdCBkZWZhdWx0QW5nbGUgPSAzNjAgLyB0aGlzLmNvdW50VmlzaWJsZUVsZW1lbnRzKCk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xyXG4gICAgICBhbmdsZSArPSB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XHJcbiAgICAgIGxldCBzdGFydEFuZ2xlID0gYW5nbGU7XHJcbiAgICAgIGxldCBlbmRBbmdsZSA9IGFuZ2xlICsgdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XHJcbiAgICAgIGxldCBvdXRlclJhZGl1cyA9IGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpID8gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSkucikgOiAwO1xyXG4gICAgICBhbmdsZSA9IGVuZEFuZ2xlO1xyXG4gICAgICBpZiAocmVzZXQpIHtcclxuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUpIHtcclxuICAgICAgICAgIG91dGVyUmFkaXVzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xyXG4gICAgICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XHJcbiAgICAgICAgeDogY2VudGVyWCxcclxuICAgICAgICB5OiBjZW50ZXJZLFxyXG4gICAgICAgIGlubmVyUmFkaXVzOiAwLFxyXG4gICAgICAgIG91dGVyUmFkaXVzLFxyXG4gICAgICAgIHN0YXJ0QW5nbGUsXHJcbiAgICAgICAgZW5kQW5nbGUsXHJcbiAgICAgICAgb3B0aW9uczogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xyXG4gICAgfVxyXG4gIH1cclxuICBjb3VudFZpc2libGVFbGVtZW50cygpIHtcclxuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuICAgIG1ldGEuZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xyXG4gICAgICBpZiAoIWlzTmFOKHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xyXG4gICAgICAgIGNvdW50Kys7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNvdW50O1xyXG4gIH1cclxuICBfY29tcHV0ZUFuZ2xlKGluZGV4LCBtb2RlLCBkZWZhdWx0QW5nbGUpIHtcclxuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KVxyXG4gICAgICA/IHRvUmFkaWFucyh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpLmFuZ2xlIHx8IGRlZmF1bHRBbmdsZSlcclxuICAgICAgOiAwO1xyXG4gIH1cclxufVxyXG5Qb2xhckFyZWFDb250cm9sbGVyLmlkID0gJ3BvbGFyQXJlYSc7XHJcblBvbGFyQXJlYUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XHJcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcclxuICBhbmltYXRpb246IHtcclxuICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXHJcbiAgICBhbmltYXRlU2NhbGU6IHRydWVcclxuICB9LFxyXG4gIGFuaW1hdGlvbnM6IHtcclxuICAgIG51bWJlcnM6IHtcclxuICAgICAgdHlwZTogJ251bWJlcicsXHJcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnXVxyXG4gICAgfSxcclxuICB9LFxyXG4gIGluZGV4QXhpczogJ3InLFxyXG4gIHN0YXJ0QW5nbGU6IDAsXHJcbn07XHJcblBvbGFyQXJlYUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xyXG4gIGFzcGVjdFJhdGlvOiAxLFxyXG4gIHBsdWdpbnM6IHtcclxuICAgIGxlZ2VuZDoge1xyXG4gICAgICBsYWJlbHM6IHtcclxuICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xyXG4gICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XHJcbiAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxyXG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcclxuICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IGlcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XHJcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xyXG4gICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRvb2x0aXA6IHtcclxuICAgICAgY2FsbGJhY2tzOiB7XHJcbiAgICAgICAgdGl0bGUoKSB7XHJcbiAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYWJlbChjb250ZXh0KSB7XHJcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jaGFydC5kYXRhLmxhYmVsc1tjb250ZXh0LmRhdGFJbmRleF0gKyAnOiAnICsgY29udGV4dC5mb3JtYXR0ZWRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIHNjYWxlczoge1xyXG4gICAgcjoge1xyXG4gICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcclxuICAgICAgYW5nbGVMaW5lczoge1xyXG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXHJcbiAgICAgIH0sXHJcbiAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxyXG4gICAgICBncmlkOiB7XHJcbiAgICAgICAgY2lyY3VsYXI6IHRydWVcclxuICAgICAgfSxcclxuICAgICAgcG9pbnRMYWJlbHM6IHtcclxuICAgICAgICBkaXNwbGF5OiBmYWxzZVxyXG4gICAgICB9LFxyXG4gICAgICBzdGFydEFuZ2xlOiAwXHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuY2xhc3MgUGllQ29udHJvbGxlciBleHRlbmRzIERvdWdobnV0Q29udHJvbGxlciB7XHJcbn1cclxuUGllQ29udHJvbGxlci5pZCA9ICdwaWUnO1xyXG5QaWVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xyXG4gIGN1dG91dDogMCxcclxuICByb3RhdGlvbjogMCxcclxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXHJcbiAgcmFkaXVzOiAnMTAwJSdcclxufTtcclxuXHJcbmNsYXNzIFJhZGFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcclxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XHJcbiAgICBjb25zdCB2U2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZTtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxhYmVsOiB2U2NhbGUuZ2V0TGFiZWxzKClbaW5kZXhdLFxyXG4gICAgICB2YWx1ZTogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKVxyXG4gICAgfTtcclxuICB9XHJcbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xyXG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XHJcbiAgfVxyXG4gIHVwZGF0ZShtb2RlKSB7XHJcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcclxuICAgIGNvbnN0IGxpbmUgPSBtZXRhLmRhdGFzZXQ7XHJcbiAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XHJcbiAgICBjb25zdCBsYWJlbHMgPSBtZXRhLmlTY2FsZS5nZXRMYWJlbHMoKTtcclxuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xyXG4gICAgaWYgKG1vZGUgIT09ICdyZXNpemUnKSB7XHJcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XHJcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XHJcbiAgICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcclxuICAgICAgICBfbG9vcDogdHJ1ZSxcclxuICAgICAgICBfZnVsbExvb3A6IGxhYmVscy5sZW5ndGggPT09IHBvaW50cy5sZW5ndGgsXHJcbiAgICAgICAgb3B0aW9uc1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCBwcm9wZXJ0aWVzLCBtb2RlKTtcclxuICAgIH1cclxuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcclxuICB9XHJcbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcclxuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XHJcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XHJcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcclxuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XHJcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcclxuICAgICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB0aGlzLmdldFBhcnNlZChpKS5yKTtcclxuICAgICAgY29uc3QgeCA9IHJlc2V0ID8gc2NhbGUueENlbnRlciA6IHBvaW50UG9zaXRpb24ueDtcclxuICAgICAgY29uc3QgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcclxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcclxuICAgICAgICB4LFxyXG4gICAgICAgIHksXHJcbiAgICAgICAgYW5nbGU6IHBvaW50UG9zaXRpb24uYW5nbGUsXHJcbiAgICAgICAgc2tpcDogaXNOYU4oeCkgfHwgaXNOYU4oeSksXHJcbiAgICAgICAgb3B0aW9uc1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5SYWRhckNvbnRyb2xsZXIuaWQgPSAncmFkYXInO1xyXG5SYWRhckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XHJcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXHJcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxyXG4gIGluZGV4QXhpczogJ3InLFxyXG4gIHNob3dMaW5lOiB0cnVlLFxyXG4gIGVsZW1lbnRzOiB7XHJcbiAgICBsaW5lOiB7XHJcbiAgICAgIGZpbGw6ICdzdGFydCdcclxuICAgIH1cclxuICB9LFxyXG59O1xyXG5SYWRhckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xyXG4gIGFzcGVjdFJhdGlvOiAxLFxyXG4gIHNjYWxlczoge1xyXG4gICAgcjoge1xyXG4gICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5jbGFzcyBTY2F0dGVyQ29udHJvbGxlciBleHRlbmRzIExpbmVDb250cm9sbGVyIHtcclxufVxyXG5TY2F0dGVyQ29udHJvbGxlci5pZCA9ICdzY2F0dGVyJztcclxuU2NhdHRlckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XHJcbiAgc2hvd0xpbmU6IGZhbHNlLFxyXG4gIGZpbGw6IGZhbHNlXHJcbn07XHJcblNjYXR0ZXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcclxuICBpbnRlcmFjdGlvbjoge1xyXG4gICAgbW9kZTogJ3BvaW50J1xyXG4gIH0sXHJcbiAgcGx1Z2luczoge1xyXG4gICAgdG9vbHRpcDoge1xyXG4gICAgICBjYWxsYmFja3M6IHtcclxuICAgICAgICB0aXRsZSgpIHtcclxuICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhYmVsKGl0ZW0pIHtcclxuICAgICAgICAgIHJldHVybiAnKCcgKyBpdGVtLmxhYmVsICsgJywgJyArIGl0ZW0uZm9ybWF0dGVkVmFsdWUgKyAnKSc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBzY2FsZXM6IHtcclxuICAgIHg6IHtcclxuICAgICAgdHlwZTogJ2xpbmVhcidcclxuICAgIH0sXHJcbiAgICB5OiB7XHJcbiAgICAgIHR5cGU6ICdsaW5lYXInXHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGNvbnRyb2xsZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xyXG5fX3Byb3RvX186IG51bGwsXHJcbkJhckNvbnRyb2xsZXI6IEJhckNvbnRyb2xsZXIsXHJcbkJ1YmJsZUNvbnRyb2xsZXI6IEJ1YmJsZUNvbnRyb2xsZXIsXHJcbkRvdWdobnV0Q29udHJvbGxlcjogRG91Z2hudXRDb250cm9sbGVyLFxyXG5MaW5lQ29udHJvbGxlcjogTGluZUNvbnRyb2xsZXIsXHJcblBvbGFyQXJlYUNvbnRyb2xsZXI6IFBvbGFyQXJlYUNvbnRyb2xsZXIsXHJcblBpZUNvbnRyb2xsZXI6IFBpZUNvbnRyb2xsZXIsXHJcblJhZGFyQ29udHJvbGxlcjogUmFkYXJDb250cm9sbGVyLFxyXG5TY2F0dGVyQ29udHJvbGxlcjogU2NhdHRlckNvbnRyb2xsZXJcclxufSk7XHJcblxyXG5mdW5jdGlvbiBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpIHtcclxuICBjb25zdCB7c3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIHgsIHksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1c30gPSBlbGVtZW50O1xyXG4gIGxldCBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gb3V0ZXJSYWRpdXM7XHJcbiAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbik7XHJcbiAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcclxuICAgIGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBpbm5lclJhZGl1cztcclxuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4sIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgdHJ1ZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGN0eC5hcmMoeCwgeSwgcGl4ZWxNYXJnaW4sIGVuZEFuZ2xlICsgSEFMRl9QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xyXG4gIH1cclxuICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgY3R4LmNsaXAoKTtcclxufVxyXG5mdW5jdGlvbiB0b1JhZGl1c0Nvcm5lcnModmFsdWUpIHtcclxuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsnb3V0ZXJTdGFydCcsICdvdXRlckVuZCcsICdpbm5lclN0YXJ0JywgJ2lubmVyRW5kJ10pO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzJDEoYXJjLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGFuZ2xlRGVsdGEpIHtcclxuICBjb25zdCBvID0gdG9SYWRpdXNDb3JuZXJzKGFyYy5vcHRpb25zLmJvcmRlclJhZGl1cyk7XHJcbiAgY29uc3QgaGFsZlRoaWNrbmVzcyA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIDI7XHJcbiAgY29uc3QgaW5uZXJMaW1pdCA9IE1hdGgubWluKGhhbGZUaGlja25lc3MsIGFuZ2xlRGVsdGEgKiBpbm5lclJhZGl1cyAvIDIpO1xyXG4gIGNvbnN0IGNvbXB1dGVPdXRlckxpbWl0ID0gKHZhbCkgPT4ge1xyXG4gICAgY29uc3Qgb3V0ZXJBcmNMaW1pdCA9IChvdXRlclJhZGl1cyAtIE1hdGgubWluKGhhbGZUaGlja25lc3MsIHZhbCkpICogYW5nbGVEZWx0YSAvIDI7XHJcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XHJcbiAgfTtcclxuICByZXR1cm4ge1xyXG4gICAgb3V0ZXJTdGFydDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlclN0YXJ0KSxcclxuICAgIG91dGVyRW5kOiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyRW5kKSxcclxuICAgIGlubmVyU3RhcnQ6IF9saW1pdFZhbHVlKG8uaW5uZXJTdGFydCwgMCwgaW5uZXJMaW1pdCksXHJcbiAgICBpbm5lckVuZDogX2xpbWl0VmFsdWUoby5pbm5lckVuZCwgMCwgaW5uZXJMaW1pdCksXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiByVGhldGFUb1hZKHIsIHRoZXRhLCB4LCB5KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHg6IHggKyByICogTWF0aC5jb3ModGhldGEpLFxyXG4gICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSksXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmQpIHtcclxuICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZTogc3RhcnQsIHBpeGVsTWFyZ2luLCBpbm5lclJhZGl1czogaW5uZXJSfSA9IGVsZW1lbnQ7XHJcbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCAtIHBpeGVsTWFyZ2luLCAwKTtcclxuICBjb25zdCBpbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgKyBzcGFjaW5nICsgb2Zmc2V0ICsgcGl4ZWxNYXJnaW4gOiAwO1xyXG4gIGxldCBzcGFjaW5nT2Zmc2V0ID0gMDtcclxuICBjb25zdCBhbHBoYSA9IGVuZCAtIHN0YXJ0O1xyXG4gIGlmIChzcGFjaW5nKSB7XHJcbiAgICBjb25zdCBub1NwYWNpbmdJbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgLSBzcGFjaW5nIDogMDtcclxuICAgIGNvbnN0IG5vU3BhY2luZ091dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgPiAwID8gb3V0ZXJSYWRpdXMgLSBzcGFjaW5nIDogMDtcclxuICAgIGNvbnN0IGF2Tm9nU3BhY2luZ1JhZGl1cyA9IChub1NwYWNpbmdJbm5lclJhZGl1cyArIG5vU3BhY2luZ091dGVyUmFkaXVzKSAvIDI7XHJcbiAgICBjb25zdCBhZGp1c3RlZEFuZ2xlID0gYXZOb2dTcGFjaW5nUmFkaXVzICE9PSAwID8gKGFscGhhICogYXZOb2dTcGFjaW5nUmFkaXVzKSAvIChhdk5vZ1NwYWNpbmdSYWRpdXMgKyBzcGFjaW5nKSA6IGFscGhhO1xyXG4gICAgc3BhY2luZ09mZnNldCA9IChhbHBoYSAtIGFkanVzdGVkQW5nbGUpIC8gMjtcclxuICB9XHJcbiAgY29uc3QgYmV0YSA9IE1hdGgubWF4KDAuMDAxLCBhbHBoYSAqIG91dGVyUmFkaXVzIC0gb2Zmc2V0IC8gUEkpIC8gb3V0ZXJSYWRpdXM7XHJcbiAgY29uc3QgYW5nbGVPZmZzZXQgPSAoYWxwaGEgLSBiZXRhKSAvIDI7XHJcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IHN0YXJ0ICsgYW5nbGVPZmZzZXQgKyBzcGFjaW5nT2Zmc2V0O1xyXG4gIGNvbnN0IGVuZEFuZ2xlID0gZW5kIC0gYW5nbGVPZmZzZXQgLSBzcGFjaW5nT2Zmc2V0O1xyXG4gIGNvbnN0IHtvdXRlclN0YXJ0LCBvdXRlckVuZCwgaW5uZXJTdGFydCwgaW5uZXJFbmR9ID0gcGFyc2VCb3JkZXJSYWRpdXMkMShlbGVtZW50LCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XHJcbiAgY29uc3Qgb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlclN0YXJ0O1xyXG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyRW5kO1xyXG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIG91dGVyU3RhcnQgLyBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XHJcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBvdXRlckVuZCAvIG91dGVyRW5kQWRqdXN0ZWRSYWRpdXM7XHJcbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lclN0YXJ0O1xyXG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyRW5kO1xyXG4gIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XHJcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBpbm5lckVuZCAvIGlubmVyRW5kQWRqdXN0ZWRSYWRpdXM7XHJcbiAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCBvdXRlckVuZEFkanVzdGVkQW5nbGUpO1xyXG4gIGlmIChvdXRlckVuZCA+IDApIHtcclxuICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XHJcbiAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlckVuZCwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCBlbmRBbmdsZSArIEhBTEZfUEkpO1xyXG4gIH1cclxuICBjb25zdCBwNCA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgZW5kQW5nbGUsIHgsIHkpO1xyXG4gIGN0eC5saW5lVG8ocDQueCwgcDQueSk7XHJcbiAgaWYgKGlubmVyRW5kID4gMCkge1xyXG4gICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcclxuICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyRW5kLCBlbmRBbmdsZSArIEhBTEZfUEksIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSArIE1hdGguUEkpO1xyXG4gIH1cclxuICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSAtIChpbm5lckVuZCAvIGlubmVyUmFkaXVzKSwgc3RhcnRBbmdsZSArIChpbm5lclN0YXJ0IC8gaW5uZXJSYWRpdXMpLCB0cnVlKTtcclxuICBpZiAoaW5uZXJTdGFydCA+IDApIHtcclxuICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cywgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xyXG4gICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJTdGFydCwgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XHJcbiAgfVxyXG4gIGNvbnN0IHA4ID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIHN0YXJ0QW5nbGUsIHgsIHkpO1xyXG4gIGN0eC5saW5lVG8ocDgueCwgcDgueSk7XHJcbiAgaWYgKG91dGVyU3RhcnQgPiAwKSB7XHJcbiAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcclxuICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyU3RhcnQsIHN0YXJ0QW5nbGUgLSBIQUxGX1BJLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSk7XHJcbiAgfVxyXG4gIGN0eC5jbG9zZVBhdGgoKTtcclxufVxyXG5mdW5jdGlvbiBkcmF3QXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nKSB7XHJcbiAgY29uc3Qge2Z1bGxDaXJjbGVzLCBzdGFydEFuZ2xlLCBjaXJjdW1mZXJlbmNlfSA9IGVsZW1lbnQ7XHJcbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcclxuICBpZiAoZnVsbENpcmNsZXMpIHtcclxuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIHN0YXJ0QW5nbGUgKyBUQVUpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XHJcbiAgICAgIGN0eC5maWxsKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XHJcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UgJSBUQVU7XHJcbiAgICAgIGlmIChjaXJjdW1mZXJlbmNlICUgVEFVID09PSAwKSB7XHJcbiAgICAgICAgZW5kQW5nbGUgKz0gVEFVO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlKTtcclxuICBjdHguZmlsbCgpO1xyXG4gIHJldHVybiBlbmRBbmdsZTtcclxufVxyXG5mdW5jdGlvbiBkcmF3RnVsbENpcmNsZUJvcmRlcnMoY3R4LCBlbGVtZW50LCBpbm5lcikge1xyXG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgZnVsbENpcmNsZXN9ID0gZWxlbWVudDtcclxuICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KGVsZW1lbnQub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCk7XHJcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSBlbGVtZW50LmlubmVyUmFkaXVzICsgcGl4ZWxNYXJnaW47XHJcbiAgbGV0IGk7XHJcbiAgaWYgKGlubmVyKSB7XHJcbiAgICBjbGlwQXJjKGN0eCwgZWxlbWVudCwgc3RhcnRBbmdsZSArIFRBVSk7XHJcbiAgfVxyXG4gIGN0eC5iZWdpblBhdGgoKTtcclxuICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBzdGFydEFuZ2xlICsgVEFVLCBzdGFydEFuZ2xlLCB0cnVlKTtcclxuICBmb3IgKGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG4gIH1cclxuICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgc3RhcnRBbmdsZSArIFRBVSk7XHJcbiAgZm9yIChpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcclxuICAgIGN0eC5zdHJva2UoKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZHJhd0JvcmRlcihjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUpIHtcclxuICBjb25zdCB7b3B0aW9uc30gPSBlbGVtZW50O1xyXG4gIGNvbnN0IHtib3JkZXJXaWR0aCwgYm9yZGVySm9pblN0eWxlfSA9IG9wdGlvbnM7XHJcbiAgY29uc3QgaW5uZXIgPSBvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInO1xyXG4gIGlmICghYm9yZGVyV2lkdGgpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgaWYgKGlubmVyKSB7XHJcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGggKiAyO1xyXG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdyb3VuZCc7XHJcbiAgfSBlbHNlIHtcclxuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcclxuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAnYmV2ZWwnO1xyXG4gIH1cclxuICBpZiAoZWxlbWVudC5mdWxsQ2lyY2xlcykge1xyXG4gICAgZHJhd0Z1bGxDaXJjbGVCb3JkZXJzKGN0eCwgZWxlbWVudCwgaW5uZXIpO1xyXG4gIH1cclxuICBpZiAoaW5uZXIpIHtcclxuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XHJcbiAgfVxyXG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlKTtcclxuICBjdHguc3Ryb2tlKCk7XHJcbn1cclxuY2xhc3MgQXJjRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xyXG4gIGNvbnN0cnVjdG9yKGNmZykge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuY2lyY3VtZmVyZW5jZSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuc3RhcnRBbmdsZSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuZW5kQW5nbGUgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAwO1xyXG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IDA7XHJcbiAgICBpZiAoY2ZnKSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcclxuICAgIH1cclxuICB9XHJcbiAgaW5SYW5nZShjaGFydFgsIGNoYXJ0WSwgdXNlRmluYWxQb3NpdGlvbikge1xyXG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xyXG4gICAgY29uc3Qge2FuZ2xlLCBkaXN0YW5jZX0gPSBnZXRBbmdsZUZyb21Qb2ludChwb2ludCwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XHJcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzLmdldFByb3BzKFtcclxuICAgICAgJ3N0YXJ0QW5nbGUnLFxyXG4gICAgICAnZW5kQW5nbGUnLFxyXG4gICAgICAnaW5uZXJSYWRpdXMnLFxyXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxyXG4gICAgICAnY2lyY3VtZmVyZW5jZSdcclxuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xyXG4gICAgY29uc3QgckFkanVzdCA9IHRoaXMub3B0aW9ucy5zcGFjaW5nIC8gMjtcclxuICAgIGNvbnN0IF9jaXJjdW1mZXJlbmNlID0gdmFsdWVPckRlZmF1bHQoY2lyY3VtZmVyZW5jZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcclxuICAgIGNvbnN0IGJldHdlZW5BbmdsZXMgPSBfY2lyY3VtZmVyZW5jZSA+PSBUQVUgfHwgX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpO1xyXG4gICAgY29uc3Qgd2l0aGluUmFkaXVzID0gX2lzQmV0d2VlbihkaXN0YW5jZSwgaW5uZXJSYWRpdXMgKyByQWRqdXN0LCBvdXRlclJhZGl1cyArIHJBZGp1c3QpO1xyXG4gICAgcmV0dXJuIChiZXR3ZWVuQW5nbGVzICYmIHdpdGhpblJhZGl1cyk7XHJcbiAgfVxyXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcclxuICAgIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzfSA9IHRoaXMuZ2V0UHJvcHMoW1xyXG4gICAgICAneCcsXHJcbiAgICAgICd5JyxcclxuICAgICAgJ3N0YXJ0QW5nbGUnLFxyXG4gICAgICAnZW5kQW5nbGUnLFxyXG4gICAgICAnaW5uZXJSYWRpdXMnLFxyXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxyXG4gICAgICAnY2lyY3VtZmVyZW5jZScsXHJcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcclxuICAgIGNvbnN0IHtvZmZzZXQsIHNwYWNpbmd9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBlbmRBbmdsZSkgLyAyO1xyXG4gICAgY29uc3QgaGFsZlJhZGl1cyA9IChpbm5lclJhZGl1cyArIG91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCkgLyAyO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogeCArIE1hdGguY29zKGhhbGZBbmdsZSkgKiBoYWxmUmFkaXVzLFxyXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcclxuICAgIH07XHJcbiAgfVxyXG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcclxuICB9XHJcbiAgZHJhdyhjdHgpIHtcclxuICAgIGNvbnN0IHtvcHRpb25zLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXM7XHJcbiAgICBjb25zdCBvZmZzZXQgPSAob3B0aW9ucy5vZmZzZXQgfHwgMCkgLyAyO1xyXG4gICAgY29uc3Qgc3BhY2luZyA9IChvcHRpb25zLnNwYWNpbmcgfHwgMCkgLyAyO1xyXG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IChvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xyXG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IGNpcmN1bWZlcmVuY2UgPiBUQVUgPyBNYXRoLmZsb29yKGNpcmN1bWZlcmVuY2UgLyBUQVUpIDogMDtcclxuICAgIGlmIChjaXJjdW1mZXJlbmNlID09PSAwIHx8IHRoaXMuaW5uZXJSYWRpdXMgPCAwIHx8IHRoaXMub3V0ZXJSYWRpdXMgPCAwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBsZXQgcmFkaXVzT2Zmc2V0ID0gMDtcclxuICAgIGlmIChvZmZzZXQpIHtcclxuICAgICAgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0IC8gMjtcclxuICAgICAgY29uc3QgaGFsZkFuZ2xlID0gKHRoaXMuc3RhcnRBbmdsZSArIHRoaXMuZW5kQW5nbGUpIC8gMjtcclxuICAgICAgY3R4LnRyYW5zbGF0ZShNYXRoLmNvcyhoYWxmQW5nbGUpICogcmFkaXVzT2Zmc2V0LCBNYXRoLnNpbihoYWxmQW5nbGUpICogcmFkaXVzT2Zmc2V0KTtcclxuICAgICAgaWYgKHRoaXMuY2lyY3VtZmVyZW5jZSA+PSBQSSkge1xyXG4gICAgICAgIHJhZGl1c09mZnNldCA9IG9mZnNldDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcclxuICAgIGNvbnN0IGVuZEFuZ2xlID0gZHJhd0FyYyhjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZyk7XHJcbiAgICBkcmF3Qm9yZGVyKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSk7XHJcbiAgICBjdHgucmVzdG9yZSgpO1xyXG4gIH1cclxufVxyXG5BcmNFbGVtZW50LmlkID0gJ2FyYyc7XHJcbkFyY0VsZW1lbnQuZGVmYXVsdHMgPSB7XHJcbiAgYm9yZGVyQWxpZ246ICdjZW50ZXInLFxyXG4gIGJvcmRlckNvbG9yOiAnI2ZmZicsXHJcbiAgYm9yZGVySm9pblN0eWxlOiB1bmRlZmluZWQsXHJcbiAgYm9yZGVyUmFkaXVzOiAwLFxyXG4gIGJvcmRlcldpZHRoOiAyLFxyXG4gIG9mZnNldDogMCxcclxuICBzcGFjaW5nOiAwLFxyXG4gIGFuZ2xlOiB1bmRlZmluZWQsXHJcbn07XHJcbkFyY0VsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcclxuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InXHJcbn07XHJcblxyXG5mdW5jdGlvbiBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHN0eWxlID0gb3B0aW9ucykge1xyXG4gIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ2FwU3R5bGUsIG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUpO1xyXG4gIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcclxuICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LCBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQpO1xyXG4gIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckpvaW5TdHlsZSwgb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUpO1xyXG4gIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XHJcbiAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ29sb3IsIG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xyXG59XHJcbmZ1bmN0aW9uIGxpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQpIHtcclxuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TGluZU1ldGhvZChvcHRpb25zKSB7XHJcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xyXG4gICAgcmV0dXJuIF9zdGVwcGVkTGluZVRvO1xyXG4gIH1cclxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xyXG4gICAgcmV0dXJuIF9iZXppZXJDdXJ2ZVRvO1xyXG4gIH1cclxuICByZXR1cm4gbGluZVRvO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zID0ge30pIHtcclxuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XHJcbiAgY29uc3Qge3N0YXJ0OiBwYXJhbXNTdGFydCA9IDAsIGVuZDogcGFyYW1zRW5kID0gY291bnQgLSAxfSA9IHBhcmFtcztcclxuICBjb25zdCB7c3RhcnQ6IHNlZ21lbnRTdGFydCwgZW5kOiBzZWdtZW50RW5kfSA9IHNlZ21lbnQ7XHJcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChwYXJhbXNTdGFydCwgc2VnbWVudFN0YXJ0KTtcclxuICBjb25zdCBlbmQgPSBNYXRoLm1pbihwYXJhbXNFbmQsIHNlZ21lbnRFbmQpO1xyXG4gIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XHJcbiAgcmV0dXJuIHtcclxuICAgIGNvdW50LFxyXG4gICAgc3RhcnQsXHJcbiAgICBsb29wOiBzZWdtZW50Lmxvb3AsXHJcbiAgICBpbGVuOiBlbmQgPCBzdGFydCAmJiAhb3V0c2lkZSA/IGNvdW50ICsgZW5kIC0gc3RhcnQgOiBlbmQgLSBzdGFydFxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gcGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcclxuICBjb25zdCB7cG9pbnRzLCBvcHRpb25zfSA9IGxpbmU7XHJcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgbG9vcCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XHJcbiAgY29uc3QgbGluZU1ldGhvZCA9IGdldExpbmVNZXRob2Qob3B0aW9ucyk7XHJcbiAgbGV0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XHJcbiAgbGV0IGksIHBvaW50LCBwcmV2O1xyXG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XHJcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpIDogaSkpICUgY291bnRdO1xyXG4gICAgaWYgKHBvaW50LnNraXApIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9IGVsc2UgaWYgKG1vdmUpIHtcclxuICAgICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcclxuICAgICAgbW92ZSA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xyXG4gICAgfVxyXG4gICAgcHJldiA9IHBvaW50O1xyXG4gIH1cclxuICBpZiAobG9vcCkge1xyXG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIDogMCkpICUgY291bnRdO1xyXG4gICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xyXG4gIH1cclxuICByZXR1cm4gISFsb29wO1xyXG59XHJcbmZ1bmN0aW9uIGZhc3RQYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xyXG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xyXG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xyXG4gIGNvbnN0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XHJcbiAgbGV0IGF2Z1ggPSAwO1xyXG4gIGxldCBjb3VudFggPSAwO1xyXG4gIGxldCBpLCBwb2ludCwgcHJldlgsIG1pblksIG1heFksIGxhc3RZO1xyXG4gIGNvbnN0IHBvaW50SW5kZXggPSAoaW5kZXgpID0+IChzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGluZGV4IDogaW5kZXgpKSAlIGNvdW50O1xyXG4gIGNvbnN0IGRyYXdYID0gKCkgPT4ge1xyXG4gICAgaWYgKG1pblkgIT09IG1heFkpIHtcclxuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtYXhZKTtcclxuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtaW5ZKTtcclxuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBsYXN0WSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBpZiAobW92ZSkge1xyXG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleCgwKV07XHJcbiAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xyXG4gIH1cclxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xyXG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleChpKV07XHJcbiAgICBpZiAocG9pbnQuc2tpcCkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHggPSBwb2ludC54O1xyXG4gICAgY29uc3QgeSA9IHBvaW50Lnk7XHJcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcclxuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XHJcbiAgICAgIGlmICh5IDwgbWluWSkge1xyXG4gICAgICAgIG1pblkgPSB5O1xyXG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XHJcbiAgICAgICAgbWF4WSA9IHk7XHJcbiAgICAgIH1cclxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgeCkgLyArK2NvdW50WDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRyYXdYKCk7XHJcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XHJcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xyXG4gICAgICBjb3VudFggPSAwO1xyXG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XHJcbiAgICB9XHJcbiAgICBsYXN0WSA9IHk7XHJcbiAgfVxyXG4gIGRyYXdYKCk7XHJcbn1cclxuZnVuY3Rpb24gX2dldFNlZ21lbnRNZXRob2QobGluZSkge1xyXG4gIGNvbnN0IG9wdHMgPSBsaW5lLm9wdGlvbnM7XHJcbiAgY29uc3QgYm9yZGVyRGFzaCA9IG9wdHMuYm9yZGVyRGFzaCAmJiBvcHRzLmJvcmRlckRhc2gubGVuZ3RoO1xyXG4gIGNvbnN0IHVzZUZhc3RQYXRoID0gIWxpbmUuX2RlY2ltYXRlZCAmJiAhbGluZS5fbG9vcCAmJiAhb3B0cy50ZW5zaW9uICYmIG9wdHMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSAhPT0gJ21vbm90b25lJyAmJiAhb3B0cy5zdGVwcGVkICYmICFib3JkZXJEYXNoO1xyXG4gIHJldHVybiB1c2VGYXN0UGF0aCA/IGZhc3RQYXRoU2VnbWVudCA6IHBhdGhTZWdtZW50O1xyXG59XHJcbmZ1bmN0aW9uIF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpIHtcclxuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XHJcbiAgICByZXR1cm4gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uO1xyXG4gIH1cclxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xyXG4gICAgcmV0dXJuIF9iZXppZXJJbnRlcnBvbGF0aW9uO1xyXG4gIH1cclxuICByZXR1cm4gX3BvaW50SW5MaW5lO1xyXG59XHJcbmZ1bmN0aW9uIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcclxuICBsZXQgcGF0aCA9IGxpbmUuX3BhdGg7XHJcbiAgaWYgKCFwYXRoKSB7XHJcbiAgICBwYXRoID0gbGluZS5fcGF0aCA9IG5ldyBQYXRoMkQoKTtcclxuICAgIGlmIChsaW5lLnBhdGgocGF0aCwgc3RhcnQsIGNvdW50KSkge1xyXG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xyXG4gICAgfVxyXG4gIH1cclxuICBzZXRTdHlsZShjdHgsIGxpbmUub3B0aW9ucyk7XHJcbiAgY3R4LnN0cm9rZShwYXRoKTtcclxufVxyXG5mdW5jdGlvbiBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XHJcbiAgY29uc3Qge3NlZ21lbnRzLCBvcHRpb25zfSA9IGxpbmU7XHJcbiAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpO1xyXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xyXG4gICAgc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzZWdtZW50LnN0eWxlKTtcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGlmIChzZWdtZW50TWV0aG9kKGN0eCwgbGluZSwgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSkpIHtcclxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgfVxyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG4gIH1cclxufVxyXG5jb25zdCB1c2VQYXRoMkQgPSB0eXBlb2YgUGF0aDJEID09PSAnZnVuY3Rpb24nO1xyXG5mdW5jdGlvbiBkcmF3KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XHJcbiAgaWYgKHVzZVBhdGgyRCAmJiAhbGluZS5vcHRpb25zLnNlZ21lbnQpIHtcclxuICAgIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcclxuICB9XHJcbn1cclxuY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcclxuICBjb25zdHJ1Y3RvcihjZmcpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLmFuaW1hdGVkID0gdHJ1ZTtcclxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX2NoYXJ0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fbG9vcCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX2Z1bGxMb29wID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX3BvaW50cyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX3NlZ21lbnRzID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fZGVjaW1hdGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9kYXRhc2V0SW5kZXggPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoY2ZnKSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcclxuICAgIH1cclxuICB9XHJcbiAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgIGlmICgob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykgJiYgIW9wdGlvbnMuc3RlcHBlZCAmJiAhdGhpcy5fcG9pbnRzVXBkYXRlZCkge1xyXG4gICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IHRoaXMuX2xvb3AgOiB0aGlzLl9mdWxsTG9vcDtcclxuICAgICAgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHModGhpcy5fcG9pbnRzLCBvcHRpb25zLCBjaGFydEFyZWEsIGxvb3AsIGluZGV4QXhpcyk7XHJcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICBzZXQgcG9pbnRzKHBvaW50cykge1xyXG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xyXG4gICAgZGVsZXRlIHRoaXMuX3NlZ21lbnRzO1xyXG4gICAgZGVsZXRlIHRoaXMuX3BhdGg7XHJcbiAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XHJcbiAgfVxyXG4gIGdldCBwb2ludHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xyXG4gIH1cclxuICBnZXQgc2VnbWVudHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xyXG4gIH1cclxuICBmaXJzdCgpIHtcclxuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcclxuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG4gICAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCAmJiBwb2ludHNbc2VnbWVudHNbMF0uc3RhcnRdO1xyXG4gIH1cclxuICBsYXN0KCkge1xyXG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xyXG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XHJcbiAgICBjb25zdCBjb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcclxuICAgIHJldHVybiBjb3VudCAmJiBwb2ludHNbc2VnbWVudHNbY291bnQgLSAxXS5lbmRdO1xyXG4gIH1cclxuICBpbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcclxuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG4gICAgY29uc3Qgc2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0aGlzLCB7cHJvcGVydHksIHN0YXJ0OiB2YWx1ZSwgZW5kOiB2YWx1ZX0pO1xyXG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBjb25zdCBfaW50ZXJwb2xhdGUgPSBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKTtcclxuICAgIGxldCBpLCBpbGVuO1xyXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50c1tpXTtcclxuICAgICAgY29uc3QgcDEgPSBwb2ludHNbc3RhcnRdO1xyXG4gICAgICBjb25zdCBwMiA9IHBvaW50c1tlbmRdO1xyXG4gICAgICBpZiAocDEgPT09IHAyKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2gocDEpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHQgPSBNYXRoLmFicygodmFsdWUgLSBwMVtwcm9wZXJ0eV0pIC8gKHAyW3Byb3BlcnR5XSAtIHAxW3Byb3BlcnR5XSkpO1xyXG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWQgPSBfaW50ZXJwb2xhdGUocDEsIHAyLCB0LCBvcHRpb25zLnN0ZXBwZWQpO1xyXG4gICAgICBpbnRlcnBvbGF0ZWRbcHJvcGVydHldID0gcG9pbnRbcHJvcGVydHldO1xyXG4gICAgICByZXN1bHQucHVzaChpbnRlcnBvbGF0ZWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XHJcbiAgfVxyXG4gIHBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwgcGFyYW1zKSB7XHJcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XHJcbiAgICByZXR1cm4gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHBhcmFtcyk7XHJcbiAgfVxyXG4gIHBhdGgoY3R4LCBzdGFydCwgY291bnQpIHtcclxuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcclxuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcclxuICAgIGxldCBsb29wID0gdGhpcy5fbG9vcDtcclxuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcclxuICAgIGNvdW50ID0gY291bnQgfHwgKHRoaXMucG9pbnRzLmxlbmd0aCAtIHN0YXJ0KTtcclxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xyXG4gICAgICBsb29wICY9IHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KTtcclxuICAgIH1cclxuICAgIHJldHVybiAhIWxvb3A7XHJcbiAgfVxyXG4gIGRyYXcoY3R4LCBjaGFydEFyZWEsIHN0YXJ0LCBjb3VudCkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcclxuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzIHx8IFtdO1xyXG4gICAgaWYgKHBvaW50cy5sZW5ndGggJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xyXG4gICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICBkcmF3KGN0eCwgdGhpcywgc3RhcnQsIGNvdW50KTtcclxuICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmFuaW1hdGVkKSB7XHJcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuTGluZUVsZW1lbnQuaWQgPSAnbGluZSc7XHJcbkxpbmVFbGVtZW50LmRlZmF1bHRzID0ge1xyXG4gIGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXHJcbiAgYm9yZGVyRGFzaDogW10sXHJcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcclxuICBib3JkZXJKb2luU3R5bGU6ICdtaXRlcicsXHJcbiAgYm9yZGVyV2lkdGg6IDMsXHJcbiAgY2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxyXG4gIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6ICdkZWZhdWx0JyxcclxuICBmaWxsOiBmYWxzZSxcclxuICBzcGFuR2FwczogZmFsc2UsXHJcbiAgc3RlcHBlZDogZmFsc2UsXHJcbiAgdGVuc2lvbjogMCxcclxufTtcclxuTGluZUVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcclxuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxyXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXHJcbn07XHJcbkxpbmVFbGVtZW50LmRlc2NyaXB0b3JzID0ge1xyXG4gIF9zY3JpcHRhYmxlOiB0cnVlLFxyXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2ZpbGwnLFxyXG59O1xyXG5cclxuZnVuY3Rpb24gaW5SYW5nZSQxKGVsLCBwb3MsIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIHtcclxuICBjb25zdCBvcHRpb25zID0gZWwub3B0aW9ucztcclxuICBjb25zdCB7W2F4aXNdOiB2YWx1ZX0gPSBlbC5nZXRQcm9wcyhbYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pO1xyXG4gIHJldHVybiAoTWF0aC5hYnMocG9zIC0gdmFsdWUpIDwgb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cyk7XHJcbn1cclxuY2xhc3MgUG9pbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XHJcbiAgY29uc3RydWN0b3IoY2ZnKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5wYXJzZWQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnNraXAgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnN0b3AgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoY2ZnKSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcclxuICAgIH1cclxuICB9XHJcbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XHJcbiAgICByZXR1cm4gKChNYXRoLnBvdyhtb3VzZVggLSB4LCAyKSArIE1hdGgucG93KG1vdXNlWSAtIHksIDIpKSA8IE1hdGgucG93KG9wdGlvbnMuaGl0UmFkaXVzICsgb3B0aW9ucy5yYWRpdXMsIDIpKTtcclxuICB9XHJcbiAgaW5YUmFuZ2UobW91c2VYLCB1c2VGaW5hbFBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gaW5SYW5nZSQxKHRoaXMsIG1vdXNlWCwgJ3gnLCB1c2VGaW5hbFBvc2l0aW9uKTtcclxuICB9XHJcbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gaW5SYW5nZSQxKHRoaXMsIG1vdXNlWSwgJ3knLCB1c2VGaW5hbFBvc2l0aW9uKTtcclxuICB9XHJcbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xyXG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcclxuICAgIHJldHVybiB7eCwgeX07XHJcbiAgfVxyXG4gIHNpemUob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xyXG4gICAgbGV0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDA7XHJcbiAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIHJhZGl1cyAmJiBvcHRpb25zLmhvdmVyUmFkaXVzIHx8IDApO1xyXG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xyXG4gICAgcmV0dXJuIChyYWRpdXMgKyBib3JkZXJXaWR0aCkgKiAyO1xyXG4gIH1cclxuICBkcmF3KGN0eCwgYXJlYSkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgIGlmICh0aGlzLnNraXAgfHwgb3B0aW9ucy5yYWRpdXMgPCAwLjEgfHwgIV9pc1BvaW50SW5BcmVhKHRoaXMsIGFyZWEsIHRoaXMuc2l6ZShvcHRpb25zKSAvIDIpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XHJcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcclxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcclxuICAgIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHRoaXMueCwgdGhpcy55KTtcclxuICB9XHJcbiAgZ2V0UmFuZ2UoKSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xyXG4gICAgcmV0dXJuIG9wdGlvbnMucmFkaXVzICsgb3B0aW9ucy5oaXRSYWRpdXM7XHJcbiAgfVxyXG59XHJcblBvaW50RWxlbWVudC5pZCA9ICdwb2ludCc7XHJcblBvaW50RWxlbWVudC5kZWZhdWx0cyA9IHtcclxuICBib3JkZXJXaWR0aDogMSxcclxuICBoaXRSYWRpdXM6IDEsXHJcbiAgaG92ZXJCb3JkZXJXaWR0aDogMSxcclxuICBob3ZlclJhZGl1czogNCxcclxuICBwb2ludFN0eWxlOiAnY2lyY2xlJyxcclxuICByYWRpdXM6IDMsXHJcbiAgcm90YXRpb246IDBcclxufTtcclxuUG9pbnRFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XHJcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcclxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbikge1xyXG4gIGNvbnN0IHt4LCB5LCBiYXNlLCB3aWR0aCwgaGVpZ2h0fSA9IGJhci5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddLCB1c2VGaW5hbFBvc2l0aW9uKTtcclxuICBsZXQgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBoYWxmO1xyXG4gIGlmIChiYXIuaG9yaXpvbnRhbCkge1xyXG4gICAgaGFsZiA9IGhlaWdodCAvIDI7XHJcbiAgICBsZWZ0ID0gTWF0aC5taW4oeCwgYmFzZSk7XHJcbiAgICByaWdodCA9IE1hdGgubWF4KHgsIGJhc2UpO1xyXG4gICAgdG9wID0geSAtIGhhbGY7XHJcbiAgICBib3R0b20gPSB5ICsgaGFsZjtcclxuICB9IGVsc2Uge1xyXG4gICAgaGFsZiA9IHdpZHRoIC8gMjtcclxuICAgIGxlZnQgPSB4IC0gaGFsZjtcclxuICAgIHJpZ2h0ID0geCArIGhhbGY7XHJcbiAgICB0b3AgPSBNYXRoLm1pbih5LCBiYXNlKTtcclxuICAgIGJvdHRvbSA9IE1hdGgubWF4KHksIGJhc2UpO1xyXG4gIH1cclxuICByZXR1cm4ge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX07XHJcbn1cclxuZnVuY3Rpb24gc2tpcE9yTGltaXQoc2tpcCwgdmFsdWUsIG1pbiwgbWF4KSB7XHJcbiAgcmV0dXJuIHNraXAgPyAwIDogX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKGJhciwgbWF4VywgbWF4SCkge1xyXG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyV2lkdGg7XHJcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xyXG4gIGNvbnN0IG8gPSB0b1RSQkwodmFsdWUpO1xyXG4gIHJldHVybiB7XHJcbiAgICB0OiBza2lwT3JMaW1pdChza2lwLnRvcCwgby50b3AsIDAsIG1heEgpLFxyXG4gICAgcjogc2tpcE9yTGltaXQoc2tpcC5yaWdodCwgby5yaWdodCwgMCwgbWF4VyksXHJcbiAgICBiOiBza2lwT3JMaW1pdChza2lwLmJvdHRvbSwgby5ib3R0b20sIDAsIG1heEgpLFxyXG4gICAgbDogc2tpcE9yTGltaXQoc2tpcC5sZWZ0LCBvLmxlZnQsIDAsIG1heFcpXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIG1heFcsIG1heEgpIHtcclxuICBjb25zdCB7ZW5hYmxlQm9yZGVyUmFkaXVzfSA9IGJhci5nZXRQcm9wcyhbJ2VuYWJsZUJvcmRlclJhZGl1cyddKTtcclxuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlclJhZGl1cztcclxuICBjb25zdCBvID0gdG9UUkJMQ29ybmVycyh2YWx1ZSk7XHJcbiAgY29uc3QgbWF4UiA9IE1hdGgubWluKG1heFcsIG1heEgpO1xyXG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcclxuICBjb25zdCBlbmFibGVCb3JkZXIgPSBlbmFibGVCb3JkZXJSYWRpdXMgfHwgaXNPYmplY3QodmFsdWUpO1xyXG4gIHJldHVybiB7XHJcbiAgICB0b3BMZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAubGVmdCwgby50b3BMZWZ0LCAwLCBtYXhSKSxcclxuICAgIHRvcFJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAucmlnaHQsIG8udG9wUmlnaHQsIDAsIG1heFIpLFxyXG4gICAgYm90dG9tTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLmxlZnQsIG8uYm90dG9tTGVmdCwgMCwgbWF4UiksXHJcbiAgICBib3R0b21SaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLnJpZ2h0LCBvLmJvdHRvbVJpZ2h0LCAwLCBtYXhSKVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhiYXIpIHtcclxuICBjb25zdCBib3VuZHMgPSBnZXRCYXJCb3VuZHMoYmFyKTtcclxuICBjb25zdCB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xyXG4gIGNvbnN0IGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xyXG4gIGNvbnN0IGJvcmRlciA9IHBhcnNlQm9yZGVyV2lkdGgoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xyXG4gIGNvbnN0IHJhZGl1cyA9IHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcclxuICByZXR1cm4ge1xyXG4gICAgb3V0ZXI6IHtcclxuICAgICAgeDogYm91bmRzLmxlZnQsXHJcbiAgICAgIHk6IGJvdW5kcy50b3AsXHJcbiAgICAgIHc6IHdpZHRoLFxyXG4gICAgICBoOiBoZWlnaHQsXHJcbiAgICAgIHJhZGl1c1xyXG4gICAgfSxcclxuICAgIGlubmVyOiB7XHJcbiAgICAgIHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXHJcbiAgICAgIHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcclxuICAgICAgdzogd2lkdGggLSBib3JkZXIubCAtIGJvcmRlci5yLFxyXG4gICAgICBoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iLFxyXG4gICAgICByYWRpdXM6IHtcclxuICAgICAgICB0b3BMZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wTGVmdCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIubCkpLFxyXG4gICAgICAgIHRvcFJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wUmlnaHQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLnIpKSxcclxuICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tTGVmdCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIubCkpLFxyXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tUmlnaHQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLnIpKSxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gaW5SYW5nZShiYXIsIHgsIHksIHVzZUZpbmFsUG9zaXRpb24pIHtcclxuICBjb25zdCBza2lwWCA9IHggPT09IG51bGw7XHJcbiAgY29uc3Qgc2tpcFkgPSB5ID09PSBudWxsO1xyXG4gIGNvbnN0IHNraXBCb3RoID0gc2tpcFggJiYgc2tpcFk7XHJcbiAgY29uc3QgYm91bmRzID0gYmFyICYmICFza2lwQm90aCAmJiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKTtcclxuICByZXR1cm4gYm91bmRzXHJcblx0XHQmJiAoc2tpcFggfHwgX2lzQmV0d2Vlbih4LCBib3VuZHMubGVmdCwgYm91bmRzLnJpZ2h0KSlcclxuXHRcdCYmIChza2lwWSB8fCBfaXNCZXR3ZWVuKHksIGJvdW5kcy50b3AsIGJvdW5kcy5ib3R0b20pKTtcclxufVxyXG5mdW5jdGlvbiBoYXNSYWRpdXMocmFkaXVzKSB7XHJcbiAgcmV0dXJuIHJhZGl1cy50b3BMZWZ0IHx8IHJhZGl1cy50b3BSaWdodCB8fCByYWRpdXMuYm90dG9tTGVmdCB8fCByYWRpdXMuYm90dG9tUmlnaHQ7XHJcbn1cclxuZnVuY3Rpb24gYWRkTm9ybWFsUmVjdFBhdGgoY3R4LCByZWN0KSB7XHJcbiAgY3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcclxufVxyXG5mdW5jdGlvbiBpbmZsYXRlUmVjdChyZWN0LCBhbW91bnQsIHJlZlJlY3QgPSB7fSkge1xyXG4gIGNvbnN0IHggPSByZWN0LnggIT09IHJlZlJlY3QueCA/IC1hbW91bnQgOiAwO1xyXG4gIGNvbnN0IHkgPSByZWN0LnkgIT09IHJlZlJlY3QueSA/IC1hbW91bnQgOiAwO1xyXG4gIGNvbnN0IHcgPSAocmVjdC54ICsgcmVjdC53ICE9PSByZWZSZWN0LnggKyByZWZSZWN0LncgPyBhbW91bnQgOiAwKSAtIHg7XHJcbiAgY29uc3QgaCA9IChyZWN0LnkgKyByZWN0LmggIT09IHJlZlJlY3QueSArIHJlZlJlY3QuaCA/IGFtb3VudCA6IDApIC0geTtcclxuICByZXR1cm4ge1xyXG4gICAgeDogcmVjdC54ICsgeCxcclxuICAgIHk6IHJlY3QueSArIHksXHJcbiAgICB3OiByZWN0LncgKyB3LFxyXG4gICAgaDogcmVjdC5oICsgaCxcclxuICAgIHJhZGl1czogcmVjdC5yYWRpdXNcclxuICB9O1xyXG59XHJcbmNsYXNzIEJhckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcclxuICBjb25zdHJ1Y3RvcihjZmcpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmhvcml6b250YWwgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmJhc2UgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmluZmxhdGVBbW91bnQgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoY2ZnKSB7XHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcclxuICAgIH1cclxuICB9XHJcbiAgZHJhdyhjdHgpIHtcclxuICAgIGNvbnN0IHtpbmZsYXRlQW1vdW50LCBvcHRpb25zOiB7Ym9yZGVyQ29sb3IsIGJhY2tncm91bmRDb2xvcn19ID0gdGhpcztcclxuICAgIGNvbnN0IHtpbm5lciwgb3V0ZXJ9ID0gYm91bmRpbmdSZWN0cyh0aGlzKTtcclxuICAgIGNvbnN0IGFkZFJlY3RQYXRoID0gaGFzUmFkaXVzKG91dGVyLnJhZGl1cykgPyBhZGRSb3VuZGVkUmVjdFBhdGggOiBhZGROb3JtYWxSZWN0UGF0aDtcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBpZiAob3V0ZXIudyAhPT0gaW5uZXIudyB8fCBvdXRlci5oICE9PSBpbm5lci5oKSB7XHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChvdXRlciwgaW5mbGF0ZUFtb3VudCwgaW5uZXIpKTtcclxuICAgICAgY3R4LmNsaXAoKTtcclxuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgLWluZmxhdGVBbW91bnQsIG91dGVyKSk7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBib3JkZXJDb2xvcjtcclxuICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcclxuICAgIH1cclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIGluZmxhdGVBbW91bnQpKTtcclxuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICBjdHguZmlsbCgpO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICB9XHJcbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xyXG4gIH1cclxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcclxuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbnVsbCwgdXNlRmluYWxQb3NpdGlvbik7XHJcbiAgfVxyXG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbnVsbCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcclxuICB9XHJcbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xyXG4gICAgY29uc3Qge3gsIHksIGJhc2UsIGhvcml6b250YWx9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ2hvcml6b250YWwnXSwgdXNlRmluYWxQb3NpdGlvbik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiBob3Jpem9udGFsID8gKHggKyBiYXNlKSAvIDIgOiB4LFxyXG4gICAgICB5OiBob3Jpem9udGFsID8geSA6ICh5ICsgYmFzZSkgLyAyXHJcbiAgICB9O1xyXG4gIH1cclxuICBnZXRSYW5nZShheGlzKSB7XHJcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gdGhpcy53aWR0aCAvIDIgOiB0aGlzLmhlaWdodCAvIDI7XHJcbiAgfVxyXG59XHJcbkJhckVsZW1lbnQuaWQgPSAnYmFyJztcclxuQmFyRWxlbWVudC5kZWZhdWx0cyA9IHtcclxuICBib3JkZXJTa2lwcGVkOiAnc3RhcnQnLFxyXG4gIGJvcmRlcldpZHRoOiAwLFxyXG4gIGJvcmRlclJhZGl1czogMCxcclxuICBpbmZsYXRlQW1vdW50OiAnYXV0bycsXHJcbiAgcG9pbnRTdHlsZTogdW5kZWZpbmVkXHJcbn07XHJcbkJhckVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcclxuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxyXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXHJcbn07XHJcblxyXG52YXIgZWxlbWVudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbl9fcHJvdG9fXzogbnVsbCxcclxuQXJjRWxlbWVudDogQXJjRWxlbWVudCxcclxuTGluZUVsZW1lbnQ6IExpbmVFbGVtZW50LFxyXG5Qb2ludEVsZW1lbnQ6IFBvaW50RWxlbWVudCxcclxuQmFyRWxlbWVudDogQmFyRWxlbWVudFxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpIHtcclxuICBjb25zdCBzYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzIHx8IGF2YWlsYWJsZVdpZHRoO1xyXG4gIGlmIChzYW1wbGVzID49IGNvdW50KSB7XHJcbiAgICByZXR1cm4gZGF0YS5zbGljZShzdGFydCwgc3RhcnQgKyBjb3VudCk7XHJcbiAgfVxyXG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xyXG4gIGNvbnN0IGJ1Y2tldFdpZHRoID0gKGNvdW50IC0gMikgLyAoc2FtcGxlcyAtIDIpO1xyXG4gIGxldCBzYW1wbGVkSW5kZXggPSAwO1xyXG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XHJcbiAgbGV0IGEgPSBzdGFydDtcclxuICBsZXQgaSwgbWF4QXJlYVBvaW50LCBtYXhBcmVhLCBhcmVhLCBuZXh0QTtcclxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVthXTtcclxuICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcyAtIDI7IGkrKykge1xyXG4gICAgbGV0IGF2Z1ggPSAwO1xyXG4gICAgbGV0IGF2Z1kgPSAwO1xyXG4gICAgbGV0IGo7XHJcbiAgICBjb25zdCBhdmdSYW5nZVN0YXJ0ID0gTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xyXG4gICAgY29uc3QgYXZnUmFuZ2VFbmQgPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMikgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcclxuICAgIGNvbnN0IGF2Z1JhbmdlTGVuZ3RoID0gYXZnUmFuZ2VFbmQgLSBhdmdSYW5nZVN0YXJ0O1xyXG4gICAgZm9yIChqID0gYXZnUmFuZ2VTdGFydDsgaiA8IGF2Z1JhbmdlRW5kOyBqKyspIHtcclxuICAgICAgYXZnWCArPSBkYXRhW2pdLng7XHJcbiAgICAgIGF2Z1kgKz0gZGF0YVtqXS55O1xyXG4gICAgfVxyXG4gICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcclxuICAgIGF2Z1kgLz0gYXZnUmFuZ2VMZW5ndGg7XHJcbiAgICBjb25zdCByYW5nZU9mZnMgPSBNYXRoLmZsb29yKGkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XHJcbiAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XHJcbiAgICBjb25zdCB7eDogcG9pbnRBeCwgeTogcG9pbnRBeX0gPSBkYXRhW2FdO1xyXG4gICAgbWF4QXJlYSA9IGFyZWEgPSAtMTtcclxuICAgIGZvciAoaiA9IHJhbmdlT2ZmczsgaiA8IHJhbmdlVG87IGorKykge1xyXG4gICAgICBhcmVhID0gMC41ICogTWF0aC5hYnMoXHJcbiAgICAgICAgKHBvaW50QXggLSBhdmdYKSAqIChkYXRhW2pdLnkgLSBwb2ludEF5KSAtXHJcbiAgICAgICAgKHBvaW50QXggLSBkYXRhW2pdLngpICogKGF2Z1kgLSBwb2ludEF5KVxyXG4gICAgICApO1xyXG4gICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcclxuICAgICAgICBtYXhBcmVhID0gYXJlYTtcclxuICAgICAgICBtYXhBcmVhUG9pbnQgPSBkYXRhW2pdO1xyXG4gICAgICAgIG5leHRBID0gajtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IG1heEFyZWFQb2ludDtcclxuICAgIGEgPSBuZXh0QTtcclxuICB9XHJcbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbZW5kSW5kZXhdO1xyXG4gIHJldHVybiBkZWNpbWF0ZWQ7XHJcbn1cclxuZnVuY3Rpb24gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKSB7XHJcbiAgbGV0IGF2Z1ggPSAwO1xyXG4gIGxldCBjb3VudFggPSAwO1xyXG4gIGxldCBpLCBwb2ludCwgeCwgeSwgcHJldlgsIG1pbkluZGV4LCBtYXhJbmRleCwgc3RhcnRJbmRleCwgbWluWSwgbWF4WTtcclxuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcclxuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xyXG4gIGNvbnN0IHhNaW4gPSBkYXRhW3N0YXJ0XS54O1xyXG4gIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xyXG4gIGNvbnN0IGR4ID0geE1heCAtIHhNaW47XHJcbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcclxuICAgIHBvaW50ID0gZGF0YVtpXTtcclxuICAgIHggPSAocG9pbnQueCAtIHhNaW4pIC8gZHggKiBhdmFpbGFibGVXaWR0aDtcclxuICAgIHkgPSBwb2ludC55O1xyXG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XHJcbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xyXG4gICAgICBpZiAoeSA8IG1pblkpIHtcclxuICAgICAgICBtaW5ZID0geTtcclxuICAgICAgICBtaW5JbmRleCA9IGk7XHJcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcclxuICAgICAgICBtYXhZID0geTtcclxuICAgICAgICBtYXhJbmRleCA9IGk7XHJcbiAgICAgIH1cclxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgcG9pbnQueCkgLyArK2NvdW50WDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGkgLSAxO1xyXG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobWluSW5kZXgpICYmICFpc051bGxPclVuZGVmKG1heEluZGV4KSkge1xyXG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MSA9IE1hdGgubWluKG1pbkluZGV4LCBtYXhJbmRleCk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgyID0gTWF0aC5tYXgobWluSW5kZXgsIG1heEluZGV4KTtcclxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MSAhPT0gbGFzdEluZGV4KSB7XHJcbiAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XHJcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgxXSxcclxuICAgICAgICAgICAgeDogYXZnWCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XHJcbiAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XHJcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgyXSxcclxuICAgICAgICAgICAgeDogYXZnWFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChpID4gMCAmJiBsYXN0SW5kZXggIT09IHN0YXJ0SW5kZXgpIHtcclxuICAgICAgICBkZWNpbWF0ZWQucHVzaChkYXRhW2xhc3RJbmRleF0pO1xyXG4gICAgICB9XHJcbiAgICAgIGRlY2ltYXRlZC5wdXNoKHBvaW50KTtcclxuICAgICAgcHJldlggPSB0cnVuY1g7XHJcbiAgICAgIGNvdW50WCA9IDA7XHJcbiAgICAgIG1pblkgPSBtYXhZID0geTtcclxuICAgICAgbWluSW5kZXggPSBtYXhJbmRleCA9IHN0YXJ0SW5kZXggPSBpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZGVjaW1hdGVkO1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KSB7XHJcbiAgaWYgKGRhdGFzZXQuX2RlY2ltYXRlZCkge1xyXG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XHJcbiAgICBkZWxldGUgZGF0YXNldC5fZGVjaW1hdGVkO1xyXG4gICAgZGVsZXRlIGRhdGFzZXQuX2RhdGE7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7dmFsdWU6IGRhdGF9KTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KSB7XHJcbiAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0KSA9PiB7XHJcbiAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XHJcbiAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgcG9pbnRzKSB7XHJcbiAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XHJcbiAgbGV0IHN0YXJ0ID0gMDtcclxuICBsZXQgY291bnQ7XHJcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xyXG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xyXG4gIGlmIChtaW5EZWZpbmVkKSB7XHJcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtaW4pLmxvLCAwLCBwb2ludENvdW50IC0gMSk7XHJcbiAgfVxyXG4gIGlmIChtYXhEZWZpbmVkKSB7XHJcbiAgICBjb3VudCA9IF9saW1pdFZhbHVlKF9sb29rdXBCeUtleShwb2ludHMsIGlTY2FsZS5heGlzLCBtYXgpLmhpICsgMSwgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xyXG4gIH1cclxuICByZXR1cm4ge3N0YXJ0LCBjb3VudH07XHJcbn1cclxudmFyIHBsdWdpbl9kZWNpbWF0aW9uID0ge1xyXG4gIGlkOiAnZGVjaW1hdGlvbicsXHJcbiAgZGVmYXVsdHM6IHtcclxuICAgIGFsZ29yaXRobTogJ21pbi1tYXgnLFxyXG4gICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgfSxcclxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSA9PiB7XHJcbiAgICBpZiAoIW9wdGlvbnMuZW5hYmxlZCkge1xyXG4gICAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0LndpZHRoO1xyXG4gICAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcclxuICAgICAgY29uc3Qge19kYXRhLCBpbmRleEF4aXN9ID0gZGF0YXNldDtcclxuICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBfZGF0YSB8fCBkYXRhc2V0LmRhdGE7XHJcbiAgICAgIGlmIChyZXNvbHZlKFtpbmRleEF4aXMsIGNoYXJ0Lm9wdGlvbnMuaW5kZXhBeGlzXSkgPT09ICd5Jykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIW1ldGEuY29udHJvbGxlci5zdXBwb3J0c0RlY2ltYXRpb24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgeEF4aXMgPSBjaGFydC5zY2FsZXNbbWV0YS54QXhpc0lEXTtcclxuICAgICAgaWYgKHhBeGlzLnR5cGUgIT09ICdsaW5lYXInICYmIHhBeGlzLnR5cGUgIT09ICd0aW1lJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoY2hhcnQub3B0aW9ucy5wYXJzaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIGRhdGEpO1xyXG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XHJcbiAgICAgIGlmIChjb3VudCA8PSB0aHJlc2hvbGQpIHtcclxuICAgICAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc051bGxPclVuZGVmKF9kYXRhKSkge1xyXG4gICAgICAgIGRhdGFzZXQuX2RhdGEgPSBkYXRhO1xyXG4gICAgICAgIGRlbGV0ZSBkYXRhc2V0LmRhdGE7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xyXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNpbWF0ZWQ7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBkZWNpbWF0ZWQ7XHJcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5hbGdvcml0aG0pIHtcclxuICAgICAgY2FzZSAnbHR0Yic6XHJcbiAgICAgICAgZGVjaW1hdGVkID0gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ21pbi1tYXgnOlxyXG4gICAgICAgIGRlY2ltYXRlZCA9IG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZWNpbWF0aW9uIGFsZ29yaXRobSAnJHtvcHRpb25zLmFsZ29yaXRobX0nYCk7XHJcbiAgICAgIH1cclxuICAgICAgZGF0YXNldC5fZGVjaW1hdGVkID0gZGVjaW1hdGVkO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuICBkZXN0cm95KGNoYXJ0KSB7XHJcbiAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KSB7XHJcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xyXG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xyXG4gIGNvbnN0IHRwb2ludHMgPSB0YXJnZXQucG9pbnRzO1xyXG4gIGNvbnN0IHBhcnRzID0gW107XHJcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XHJcbiAgICBsZXQge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcclxuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpO1xyXG4gICAgY29uc3QgYm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgcG9pbnRzW3N0YXJ0XSwgcG9pbnRzW2VuZF0sIHNlZ21lbnQubG9vcCk7XHJcbiAgICBpZiAoIXRhcmdldC5zZWdtZW50cykge1xyXG4gICAgICBwYXJ0cy5wdXNoKHtcclxuICAgICAgICBzb3VyY2U6IHNlZ21lbnQsXHJcbiAgICAgICAgdGFyZ2V0OiBib3VuZHMsXHJcbiAgICAgICAgc3RhcnQ6IHBvaW50c1tzdGFydF0sXHJcbiAgICAgICAgZW5kOiBwb2ludHNbZW5kXVxyXG4gICAgICB9KTtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0YXJnZXRTZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRhcmdldCwgYm91bmRzKTtcclxuICAgIGZvciAoY29uc3QgdGd0IG9mIHRhcmdldFNlZ21lbnRzKSB7XHJcbiAgICAgIGNvbnN0IHN1YkJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHRwb2ludHNbdGd0LnN0YXJ0XSwgdHBvaW50c1t0Z3QuZW5kXSwgdGd0Lmxvb3ApO1xyXG4gICAgICBjb25zdCBmaWxsU291cmNlcyA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBzdWJCb3VuZHMpO1xyXG4gICAgICBmb3IgKGNvbnN0IGZpbGxTb3VyY2Ugb2YgZmlsbFNvdXJjZXMpIHtcclxuICAgICAgICBwYXJ0cy5wdXNoKHtcclxuICAgICAgICAgIHNvdXJjZTogZmlsbFNvdXJjZSxcclxuICAgICAgICAgIHRhcmdldDogdGd0LFxyXG4gICAgICAgICAgc3RhcnQ6IHtcclxuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdzdGFydCcsIE1hdGgubWF4KVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGVuZDoge1xyXG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ2VuZCcsIE1hdGgubWluKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBwYXJ0cztcclxufVxyXG5mdW5jdGlvbiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBmaXJzdCwgbGFzdCwgbG9vcCkge1xyXG4gIGlmIChsb29wKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGxldCBzdGFydCA9IGZpcnN0W3Byb3BlcnR5XTtcclxuICBsZXQgZW5kID0gbGFzdFtwcm9wZXJ0eV07XHJcbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XHJcbiAgICBzdGFydCA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XHJcbiAgICBlbmQgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcclxuICB9XHJcbiAgcmV0dXJuIHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH07XHJcbn1cclxuZnVuY3Rpb24gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSkge1xyXG4gIGNvbnN0IHt4ID0gbnVsbCwgeSA9IG51bGx9ID0gYm91bmRhcnkgfHwge307XHJcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xyXG4gIGNvbnN0IHBvaW50cyA9IFtdO1xyXG4gIGxpbmUuc2VnbWVudHMuZm9yRWFjaCgoe3N0YXJ0LCBlbmR9KSA9PiB7XHJcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgbGluZVBvaW50cyk7XHJcbiAgICBjb25zdCBmaXJzdCA9IGxpbmVQb2ludHNbc3RhcnRdO1xyXG4gICAgY29uc3QgbGFzdCA9IGxpbmVQb2ludHNbZW5kXTtcclxuICAgIGlmICh5ICE9PSBudWxsKSB7XHJcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBmaXJzdC54LCB5fSk7XHJcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBsYXN0LngsIHl9KTtcclxuICAgIH0gZWxzZSBpZiAoeCAhPT0gbnVsbCkge1xyXG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogZmlyc3QueX0pO1xyXG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogbGFzdC55fSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHBvaW50cztcclxufVxyXG5mdW5jdGlvbiBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKSB7XHJcbiAgZm9yICg7ZW5kID4gc3RhcnQ7IGVuZC0tKSB7XHJcbiAgICBjb25zdCBwb2ludCA9IHBvaW50c1tlbmRdO1xyXG4gICAgaWYgKCFpc05hTihwb2ludC54KSAmJiAhaXNOYU4ocG9pbnQueSkpIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBlbmQ7XHJcbn1cclxuZnVuY3Rpb24gX2dldEVkZ2UoYSwgYiwgcHJvcCwgZm4pIHtcclxuICBpZiAoYSAmJiBiKSB7XHJcbiAgICByZXR1cm4gZm4oYVtwcm9wXSwgYltwcm9wXSk7XHJcbiAgfVxyXG4gIHJldHVybiBhID8gYVtwcm9wXSA6IGIgPyBiW3Byb3BdIDogMDtcclxufVxyXG5cclxuZnVuY3Rpb24gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSkge1xyXG4gIGxldCBwb2ludHMgPSBbXTtcclxuICBsZXQgX2xvb3AgPSBmYWxzZTtcclxuICBpZiAoaXNBcnJheShib3VuZGFyeSkpIHtcclxuICAgIF9sb29wID0gdHJ1ZTtcclxuICAgIHBvaW50cyA9IGJvdW5kYXJ5O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBwb2ludHMgPSBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKTtcclxuICB9XHJcbiAgcmV0dXJuIHBvaW50cy5sZW5ndGggPyBuZXcgTGluZUVsZW1lbnQoe1xyXG4gICAgcG9pbnRzLFxyXG4gICAgb3B0aW9uczoge3RlbnNpb246IDB9LFxyXG4gICAgX2xvb3AsXHJcbiAgICBfZnVsbExvb3A6IF9sb29wXHJcbiAgfSkgOiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XHJcbiAgY29uc3Qgc291cmNlID0gc291cmNlc1tpbmRleF07XHJcbiAgbGV0IGZpbGwgPSBzb3VyY2UuZmlsbDtcclxuICBjb25zdCB2aXNpdGVkID0gW2luZGV4XTtcclxuICBsZXQgdGFyZ2V0O1xyXG4gIGlmICghcHJvcGFnYXRlKSB7XHJcbiAgICByZXR1cm4gZmlsbDtcclxuICB9XHJcbiAgd2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcclxuICAgIGlmICghaXNOdW1iZXJGaW5pdGUoZmlsbCkpIHtcclxuICAgICAgcmV0dXJuIGZpbGw7XHJcbiAgICB9XHJcbiAgICB0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xyXG4gICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldC52aXNpYmxlKSB7XHJcbiAgICAgIHJldHVybiBmaWxsO1xyXG4gICAgfVxyXG4gICAgdmlzaXRlZC5wdXNoKGZpbGwpO1xyXG4gICAgZmlsbCA9IHRhcmdldC5maWxsO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gX2RlY29kZUZpbGwobGluZSwgaW5kZXgsIGNvdW50KSB7XHJcbiAgY29uc3QgZmlsbCA9IHBhcnNlRmlsbE9wdGlvbihsaW5lKTtcclxuICBpZiAoaXNPYmplY3QoZmlsbCkpIHtcclxuICAgIHJldHVybiBpc05hTihmaWxsLnZhbHVlKSA/IGZhbHNlIDogZmlsbDtcclxuICB9XHJcbiAgbGV0IHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCk7XHJcbiAgaWYgKGlzTnVtYmVyRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcclxuICAgIHJldHVybiBkZWNvZGVUYXJnZXRJbmRleChmaWxsWzBdLCBpbmRleCwgdGFyZ2V0LCBjb3VudCk7XHJcbiAgfVxyXG4gIHJldHVybiBbJ29yaWdpbicsICdzdGFydCcsICdlbmQnLCAnc3RhY2snLCAnc2hhcGUnXS5pbmRleE9mKGZpbGwpID49IDAgJiYgZmlsbDtcclxufVxyXG5mdW5jdGlvbiBkZWNvZGVUYXJnZXRJbmRleChmaXJzdENoLCBpbmRleCwgdGFyZ2V0LCBjb3VudCkge1xyXG4gIGlmIChmaXJzdENoID09PSAnLScgfHwgZmlyc3RDaCA9PT0gJysnKSB7XHJcbiAgICB0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcclxuICB9XHJcbiAgaWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5mdW5jdGlvbiBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpIHtcclxuICBsZXQgcGl4ZWwgPSBudWxsO1xyXG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XHJcbiAgICBwaXhlbCA9IHNjYWxlLmJvdHRvbTtcclxuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XHJcbiAgICBwaXhlbCA9IHNjYWxlLnRvcDtcclxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XHJcbiAgICBwaXhlbCA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZmlsbC52YWx1ZSk7XHJcbiAgfSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcclxuICAgIHBpeGVsID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XHJcbiAgfVxyXG4gIHJldHVybiBwaXhlbDtcclxufVxyXG5mdW5jdGlvbiBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0VmFsdWUpIHtcclxuICBsZXQgdmFsdWU7XHJcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcclxuICAgIHZhbHVlID0gc3RhcnRWYWx1ZTtcclxuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XHJcbiAgICB2YWx1ZSA9IHNjYWxlLm9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heDtcclxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XHJcbiAgICB2YWx1ZSA9IGZpbGwudmFsdWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHZhbHVlID0gc2NhbGUuZ2V0QmFzZVZhbHVlKCk7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUZpbGxPcHRpb24obGluZSkge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBsaW5lLm9wdGlvbnM7XHJcbiAgY29uc3QgZmlsbE9wdGlvbiA9IG9wdGlvbnMuZmlsbDtcclxuICBsZXQgZmlsbCA9IHZhbHVlT3JEZWZhdWx0KGZpbGxPcHRpb24gJiYgZmlsbE9wdGlvbi50YXJnZXQsIGZpbGxPcHRpb24pO1xyXG4gIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcclxuICAgIGZpbGwgPSAhIW9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xyXG4gIH1cclxuICBpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAoZmlsbCA9PT0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuICdvcmlnaW4nO1xyXG4gIH1cclxuICByZXR1cm4gZmlsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSkge1xyXG4gIGNvbnN0IHtzY2FsZSwgaW5kZXgsIGxpbmV9ID0gc291cmNlO1xyXG4gIGNvbnN0IHBvaW50cyA9IFtdO1xyXG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcclxuICBjb25zdCBzb3VyY2VQb2ludHMgPSBsaW5lLnBvaW50cztcclxuICBjb25zdCBsaW5lc0JlbG93ID0gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpO1xyXG4gIGxpbmVzQmVsb3cucHVzaChfY3JlYXRlQm91bmRhcnlMaW5lKHt4OiBudWxsLCB5OiBzY2FsZS5ib3R0b219LCBsaW5lKSk7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xyXG4gICAgZm9yIChsZXQgaiA9IHNlZ21lbnQuc3RhcnQ7IGogPD0gc2VnbWVudC5lbmQ7IGorKykge1xyXG4gICAgICBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50c1tqXSwgbGluZXNCZWxvdyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgTGluZUVsZW1lbnQoe3BvaW50cywgb3B0aW9uczoge319KTtcclxufVxyXG5mdW5jdGlvbiBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCkge1xyXG4gIGNvbnN0IGJlbG93ID0gW107XHJcbiAgY29uc3QgbWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygnbGluZScpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcclxuICAgIGlmIChtZXRhLmluZGV4ID09PSBpbmRleCkge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGlmICghbWV0YS5oaWRkZW4pIHtcclxuICAgICAgYmVsb3cudW5zaGlmdChtZXRhLmRhdGFzZXQpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gYmVsb3c7XHJcbn1cclxuZnVuY3Rpb24gYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludCwgbGluZXNCZWxvdykge1xyXG4gIGNvbnN0IHBvc3Rwb25lZCA9IFtdO1xyXG4gIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXNCZWxvdy5sZW5ndGg7IGorKykge1xyXG4gICAgY29uc3QgbGluZSA9IGxpbmVzQmVsb3dbal07XHJcbiAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHBvaW50fSA9IGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgJ3gnKTtcclxuICAgIGlmICghcG9pbnQgfHwgKGZpcnN0ICYmIGxhc3QpKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgIHBvc3Rwb25lZC51bnNoaWZ0KHBvaW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcclxuICAgICAgaWYgKCFsYXN0KSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcG9pbnRzLnB1c2goLi4ucG9zdHBvbmVkKTtcclxufVxyXG5mdW5jdGlvbiBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsIHByb3BlcnR5KSB7XHJcbiAgY29uc3QgcG9pbnQgPSBsaW5lLmludGVycG9sYXRlKHNvdXJjZVBvaW50LCBwcm9wZXJ0eSk7XHJcbiAgaWYgKCFwb2ludCkge1xyXG4gICAgcmV0dXJuIHt9O1xyXG4gIH1cclxuICBjb25zdCBwb2ludFZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xyXG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcclxuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XHJcbiAgbGV0IGZpcnN0ID0gZmFsc2U7XHJcbiAgbGV0IGxhc3QgPSBmYWxzZTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XHJcbiAgICBjb25zdCBmaXJzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LnN0YXJ0XVtwcm9wZXJ0eV07XHJcbiAgICBjb25zdCBsYXN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuZW5kXVtwcm9wZXJ0eV07XHJcbiAgICBpZiAoX2lzQmV0d2Vlbihwb2ludFZhbHVlLCBmaXJzdFZhbHVlLCBsYXN0VmFsdWUpKSB7XHJcbiAgICAgIGZpcnN0ID0gcG9pbnRWYWx1ZSA9PT0gZmlyc3RWYWx1ZTtcclxuICAgICAgbGFzdCA9IHBvaW50VmFsdWUgPT09IGxhc3RWYWx1ZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB7Zmlyc3QsIGxhc3QsIHBvaW50fTtcclxufVxyXG5cclxuY2xhc3Mgc2ltcGxlQXJjIHtcclxuICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICB0aGlzLnggPSBvcHRzLng7XHJcbiAgICB0aGlzLnkgPSBvcHRzLnk7XHJcbiAgICB0aGlzLnJhZGl1cyA9IG9wdHMucmFkaXVzO1xyXG4gIH1cclxuICBwYXRoU2VnbWVudChjdHgsIGJvdW5kcywgb3B0cykge1xyXG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xyXG4gICAgYm91bmRzID0gYm91bmRzIHx8IHtzdGFydDogMCwgZW5kOiBUQVV9O1xyXG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIGJvdW5kcy5lbmQsIGJvdW5kcy5zdGFydCwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xyXG4gIH1cclxuICBpbnRlcnBvbGF0ZShwb2ludCkge1xyXG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xyXG4gICAgY29uc3QgYW5nbGUgPSBwb2ludC5hbmdsZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXHJcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXHJcbiAgICAgIGFuZ2xlXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX2dldFRhcmdldChzb3VyY2UpIHtcclxuICBjb25zdCB7Y2hhcnQsIGZpbGwsIGxpbmV9ID0gc291cmNlO1xyXG4gIGlmIChpc051bWJlckZpbml0ZShmaWxsKSkge1xyXG4gICAgcmV0dXJuIGdldExpbmVCeUluZGV4KGNoYXJ0LCBmaWxsKTtcclxuICB9XHJcbiAgaWYgKGZpbGwgPT09ICdzdGFjaycpIHtcclxuICAgIHJldHVybiBfYnVpbGRTdGFja0xpbmUoc291cmNlKTtcclxuICB9XHJcbiAgaWYgKGZpbGwgPT09ICdzaGFwZScpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBjb25zdCBib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xyXG4gIGlmIChib3VuZGFyeSBpbnN0YW5jZW9mIHNpbXBsZUFyYykge1xyXG4gICAgcmV0dXJuIGJvdW5kYXJ5O1xyXG4gIH1cclxuICByZXR1cm4gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XHJcbiAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcclxuICBjb25zdCB2aXNpYmxlID0gbWV0YSAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KTtcclxuICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSkge1xyXG4gIGNvbnN0IHNjYWxlID0gc291cmNlLnNjYWxlIHx8IHt9O1xyXG4gIGlmIChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUpIHtcclxuICAgIHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xyXG4gIH1cclxuICByZXR1cm4gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSk7XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSkge1xyXG4gIGNvbnN0IHtzY2FsZSA9IHt9LCBmaWxsfSA9IHNvdXJjZTtcclxuICBjb25zdCBwaXhlbCA9IF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSk7XHJcbiAgaWYgKGlzTnVtYmVyRmluaXRlKHBpeGVsKSkge1xyXG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogaG9yaXpvbnRhbCA/IHBpeGVsIDogbnVsbCxcclxuICAgICAgeTogaG9yaXpvbnRhbCA/IG51bGwgOiBwaXhlbFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKSB7XHJcbiAgY29uc3Qge3NjYWxlLCBmaWxsfSA9IHNvdXJjZTtcclxuICBjb25zdCBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcclxuICBjb25zdCBsZW5ndGggPSBzY2FsZS5nZXRMYWJlbHMoKS5sZW5ndGg7XHJcbiAgY29uc3Qgc3RhcnQgPSBvcHRpb25zLnJldmVyc2UgPyBzY2FsZS5tYXggOiBzY2FsZS5taW47XHJcbiAgY29uc3QgdmFsdWUgPSBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0KTtcclxuICBjb25zdCB0YXJnZXQgPSBbXTtcclxuICBpZiAob3B0aW9ucy5ncmlkLmNpcmN1bGFyKSB7XHJcbiAgICBjb25zdCBjZW50ZXIgPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCwgc3RhcnQpO1xyXG4gICAgcmV0dXJuIG5ldyBzaW1wbGVBcmMoe1xyXG4gICAgICB4OiBjZW50ZXIueCxcclxuICAgICAgeTogY2VudGVyLnksXHJcbiAgICAgIHJhZGl1czogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpXHJcbiAgICB9KTtcclxuICB9XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgdGFyZ2V0LnB1c2goc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHZhbHVlKSk7XHJcbiAgfVxyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9kcmF3ZmlsbChjdHgsIHNvdXJjZSwgYXJlYSkge1xyXG4gIGNvbnN0IHRhcmdldCA9IF9nZXRUYXJnZXQoc291cmNlKTtcclxuICBjb25zdCB7bGluZSwgc2NhbGUsIGF4aXN9ID0gc291cmNlO1xyXG4gIGNvbnN0IGxpbmVPcHRzID0gbGluZS5vcHRpb25zO1xyXG4gIGNvbnN0IGZpbGxPcHRpb24gPSBsaW5lT3B0cy5maWxsO1xyXG4gIGNvbnN0IGNvbG9yID0gbGluZU9wdHMuYmFja2dyb3VuZENvbG9yO1xyXG4gIGNvbnN0IHthYm92ZSA9IGNvbG9yLCBiZWxvdyA9IGNvbG9yfSA9IGZpbGxPcHRpb24gfHwge307XHJcbiAgaWYgKHRhcmdldCAmJiBsaW5lLnBvaW50cy5sZW5ndGgpIHtcclxuICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XHJcbiAgICBkb0ZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlLCBheGlzfSk7XHJcbiAgICB1bmNsaXBBcmVhKGN0eCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGRvRmlsbChjdHgsIGNmZykge1xyXG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGV9ID0gY2ZnO1xyXG4gIGNvbnN0IHByb3BlcnR5ID0gbGluZS5fbG9vcCA/ICdhbmdsZScgOiBjZmcuYXhpcztcclxuICBjdHguc2F2ZSgpO1xyXG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnICYmIGJlbG93ICE9PSBhYm92ZSkge1xyXG4gICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLnRvcCk7XHJcbiAgICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGFib3ZlLCBzY2FsZSwgcHJvcGVydHl9KTtcclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLmJvdHRvbSk7XHJcbiAgfVxyXG4gIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYmVsb3csIHNjYWxlLCBwcm9wZXJ0eX0pO1xyXG4gIGN0eC5yZXN0b3JlKCk7XHJcbn1cclxuZnVuY3Rpb24gY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBjbGlwWSkge1xyXG4gIGNvbnN0IHtzZWdtZW50cywgcG9pbnRzfSA9IHRhcmdldDtcclxuICBsZXQgZmlyc3QgPSB0cnVlO1xyXG4gIGxldCBsaW5lTG9vcCA9IGZhbHNlO1xyXG4gIGN0eC5iZWdpblBhdGgoKTtcclxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcclxuICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XHJcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gcG9pbnRzW3N0YXJ0XTtcclxuICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKV07XHJcbiAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XHJcbiAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgY2xpcFkpO1xyXG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgIH1cclxuICAgIGxpbmVMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCB7bW92ZTogbGluZUxvb3B9KTtcclxuICAgIGlmIChsaW5lTG9vcCkge1xyXG4gICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjdHgubGluZVRvKGxhc3RQb2ludC54LCBjbGlwWSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGN0eC5saW5lVG8odGFyZ2V0LmZpcnN0KCkueCwgY2xpcFkpO1xyXG4gIGN0eC5jbG9zZVBhdGgoKTtcclxuICBjdHguY2xpcCgpO1xyXG59XHJcbmZ1bmN0aW9uIGZpbGwoY3R4LCBjZmcpIHtcclxuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSwgY29sb3IsIHNjYWxlfSA9IGNmZztcclxuICBjb25zdCBzZWdtZW50cyA9IF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KTtcclxuICBmb3IgKGNvbnN0IHtzb3VyY2U6IHNyYywgdGFyZ2V0OiB0Z3QsIHN0YXJ0LCBlbmR9IG9mIHNlZ21lbnRzKSB7XHJcbiAgICBjb25zdCB7c3R5bGU6IHtiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcn0gPSB7fX0gPSBzcmM7XHJcbiAgICBjb25zdCBub3RTaGFwZSA9IHRhcmdldCAhPT0gdHJ1ZTtcclxuICAgIGN0eC5zYXZlKCk7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xyXG4gICAgY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBub3RTaGFwZSAmJiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBzdGFydCwgZW5kKSk7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjb25zdCBsaW5lTG9vcCA9ICEhbGluZS5wYXRoU2VnbWVudChjdHgsIHNyYyk7XHJcbiAgICBsZXQgbG9vcDtcclxuICAgIGlmIChub3RTaGFwZSkge1xyXG4gICAgICBpZiAobGluZUxvb3ApIHtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB0YXJnZXRMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCB0Z3QsIHttb3ZlOiBsaW5lTG9vcCwgcmV2ZXJzZTogdHJ1ZX0pO1xyXG4gICAgICBsb29wID0gbGluZUxvb3AgJiYgdGFyZ2V0TG9vcDtcclxuICAgICAgaWYgKCFsb29wKSB7XHJcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBzdGFydCwgcHJvcGVydHkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICBjdHguZmlsbChsb29wID8gJ2V2ZW5vZGQnIDogJ25vbnplcm8nKTtcclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgYm91bmRzKSB7XHJcbiAgY29uc3Qge3RvcCwgYm90dG9tfSA9IHNjYWxlLmNoYXJ0LmNoYXJ0QXJlYTtcclxuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0LCBlbmR9ID0gYm91bmRzIHx8IHt9O1xyXG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHgucmVjdChzdGFydCwgdG9wLCBlbmQgLSBzdGFydCwgYm90dG9tIC0gdG9wKTtcclxuICAgIGN0eC5jbGlwKCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgcG9pbnQsIHByb3BlcnR5KSB7XHJcbiAgY29uc3QgaW50ZXJwb2xhdGVkUG9pbnQgPSB0YXJnZXQuaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KTtcclxuICBpZiAoaW50ZXJwb2xhdGVkUG9pbnQpIHtcclxuICAgIGN0eC5saW5lVG8oaW50ZXJwb2xhdGVkUG9pbnQueCwgaW50ZXJwb2xhdGVkUG9pbnQueSk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgaW5kZXggPSB7XHJcbiAgaWQ6ICdmaWxsZXInLFxyXG4gIGFmdGVyRGF0YXNldHNVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XHJcbiAgICBjb25zdCBzb3VyY2VzID0gW107XHJcbiAgICBsZXQgbWV0YSwgaSwgbGluZSwgc291cmNlO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xyXG4gICAgICBsaW5lID0gbWV0YS5kYXRhc2V0O1xyXG4gICAgICBzb3VyY2UgPSBudWxsO1xyXG4gICAgICBpZiAobGluZSAmJiBsaW5lLm9wdGlvbnMgJiYgbGluZSBpbnN0YW5jZW9mIExpbmVFbGVtZW50KSB7XHJcbiAgICAgICAgc291cmNlID0ge1xyXG4gICAgICAgICAgdmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcclxuICAgICAgICAgIGluZGV4OiBpLFxyXG4gICAgICAgICAgZmlsbDogX2RlY29kZUZpbGwobGluZSwgaSwgY291bnQpLFxyXG4gICAgICAgICAgY2hhcnQsXHJcbiAgICAgICAgICBheGlzOiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXHJcbiAgICAgICAgICBzY2FsZTogbWV0YS52U2NhbGUsXHJcbiAgICAgICAgICBsaW5lLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgbWV0YS4kZmlsbGVyID0gc291cmNlO1xyXG4gICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XHJcbiAgICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5maWxsID09PSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHNvdXJjZS5maWxsID0gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaSwgb3B0aW9ucy5wcm9wYWdhdGUpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGRyYXcgPSBvcHRpb25zLmRyYXdUaW1lID09PSAnYmVmb3JlRHJhdyc7XHJcbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcclxuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XHJcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcclxuICAgICAgaWYgKCFzb3VyY2UpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBzb3VyY2UubGluZS51cGRhdGVDb250cm9sUG9pbnRzKGFyZWEsIHNvdXJjZS5heGlzKTtcclxuICAgICAgaWYgKGRyYXcpIHtcclxuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGFyZWEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICBiZWZvcmVEYXRhc2V0c0RyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXRzRHJhdycpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XHJcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcclxuICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgYmVmb3JlRGF0YXNldERyYXcoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHNvdXJjZSA9IGFyZ3MubWV0YS4kZmlsbGVyO1xyXG4gICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlIHx8IG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0RHJhdycpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xyXG4gIH0sXHJcbiAgZGVmYXVsdHM6IHtcclxuICAgIHByb3BhZ2F0ZTogdHJ1ZSxcclxuICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldERyYXcnXHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgZ2V0Qm94U2l6ZSA9IChsYWJlbE9wdHMsIGZvbnRTaXplKSA9PiB7XHJcbiAgbGV0IHtib3hIZWlnaHQgPSBmb250U2l6ZSwgYm94V2lkdGggPSBmb250U2l6ZX0gPSBsYWJlbE9wdHM7XHJcbiAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XHJcbiAgICBib3hIZWlnaHQgPSBNYXRoLm1pbihib3hIZWlnaHQsIGZvbnRTaXplKTtcclxuICAgIGJveFdpZHRoID0gTWF0aC5taW4oYm94V2lkdGgsIGZvbnRTaXplKTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIGJveFdpZHRoLFxyXG4gICAgYm94SGVpZ2h0LFxyXG4gICAgaXRlbUhlaWdodDogTWF0aC5tYXgoZm9udFNpemUsIGJveEhlaWdodClcclxuICB9O1xyXG59O1xyXG5jb25zdCBpdGVtc0VxdWFsID0gKGEsIGIpID0+IGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmRhdGFzZXRJbmRleCA9PT0gYi5kYXRhc2V0SW5kZXggJiYgYS5pbmRleCA9PT0gYi5pbmRleDtcclxuY2xhc3MgTGVnZW5kIGV4dGVuZHMgRWxlbWVudCB7XHJcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcclxuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcclxuICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gbnVsbDtcclxuICAgIHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XHJcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xyXG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XHJcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XHJcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5jb2x1bW5TaXplcyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubGluZVdpZHRocyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fbWFyZ2lucyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XHJcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XHJcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcclxuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zO1xyXG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XHJcbiAgICB0aGlzLmJ1aWxkTGFiZWxzKCk7XHJcbiAgICB0aGlzLmZpdCgpO1xyXG4gIH1cclxuICBzZXREaW1lbnNpb25zKCkge1xyXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcclxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XHJcbiAgICAgIHRoaXMubGVmdCA9IHRoaXMuX21hcmdpbnMubGVmdDtcclxuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xyXG4gICAgICB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wO1xyXG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgfVxyXG4gIH1cclxuICBidWlsZExhYmVscygpIHtcclxuICAgIGNvbnN0IGxhYmVsT3B0cyA9IHRoaXMub3B0aW9ucy5sYWJlbHMgfHwge307XHJcbiAgICBsZXQgbGVnZW5kSXRlbXMgPSBjYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFt0aGlzLmNoYXJ0XSwgdGhpcykgfHwgW107XHJcbiAgICBpZiAobGFiZWxPcHRzLmZpbHRlcikge1xyXG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCB0aGlzLmNoYXJ0LmRhdGEpKTtcclxuICAgIH1cclxuICAgIGlmIChsYWJlbE9wdHMuc29ydCkge1xyXG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLnNvcnQoKGEsIGIpID0+IGxhYmVsT3B0cy5zb3J0KGEsIGIsIHRoaXMuY2hhcnQuZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XHJcbiAgICAgIGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcclxuICAgIH1cclxuICAgIHRoaXMubGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcztcclxuICB9XHJcbiAgZml0KCkge1xyXG4gICAgY29uc3Qge29wdGlvbnMsIGN0eH0gPSB0aGlzO1xyXG4gICAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcclxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGFiZWxPcHRzID0gb3B0aW9ucy5sYWJlbHM7XHJcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xyXG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcclxuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XHJcbiAgICBjb25zdCB7Ym94V2lkdGgsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcclxuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xyXG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xyXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcclxuICAgICAgd2lkdGggPSB0aGlzLm1heFdpZHRoO1xyXG4gICAgICBoZWlnaHQgPSB0aGlzLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBoZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcclxuICAgICAgd2lkdGggPSB0aGlzLl9maXRDb2xzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XHJcbiAgICB9XHJcbiAgICB0aGlzLndpZHRoID0gTWF0aC5taW4od2lkdGgsIG9wdGlvbnMubWF4V2lkdGggfHwgdGhpcy5tYXhXaWR0aCk7XHJcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgb3B0aW9ucy5tYXhIZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpO1xyXG4gIH1cclxuICBfZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XHJcbiAgICBjb25zdCB7Y3R4LCBtYXhXaWR0aCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xyXG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XHJcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gdGhpcy5saW5lV2lkdGhzID0gWzBdO1xyXG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xyXG4gICAgbGV0IHRvdGFsSGVpZ2h0ID0gdGl0bGVIZWlnaHQ7XHJcbiAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xyXG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgbGV0IHJvdyA9IC0xO1xyXG4gICAgbGV0IHRvcCA9IC1saW5lSGVpZ2h0O1xyXG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XHJcbiAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcclxuICAgICAgaWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgaXRlbVdpZHRoICsgMiAqIHBhZGRpbmcgPiBtYXhXaWR0aCkge1xyXG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XHJcbiAgICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIChpID4gMCA/IDAgOiAxKV0gPSAwO1xyXG4gICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xyXG4gICAgICAgIHJvdysrO1xyXG4gICAgICB9XHJcbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQ6IDAsIHRvcCwgcm93LCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xyXG4gICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gaXRlbVdpZHRoICsgcGFkZGluZztcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xyXG4gIH1cclxuICBfZml0Q29scyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XHJcbiAgICBjb25zdCB7Y3R4LCBtYXhIZWlnaHQsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcclxuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xyXG4gICAgY29uc3QgY29sdW1uU2l6ZXMgPSB0aGlzLmNvbHVtblNpemVzID0gW107XHJcbiAgICBjb25zdCBoZWlnaHRMaW1pdCA9IG1heEhlaWdodCAtIHRpdGxlSGVpZ2h0O1xyXG4gICAgbGV0IHRvdGFsV2lkdGggPSBwYWRkaW5nO1xyXG4gICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IDA7XHJcbiAgICBsZXQgY3VycmVudENvbEhlaWdodCA9IDA7XHJcbiAgICBsZXQgbGVmdCA9IDA7XHJcbiAgICBsZXQgY29sID0gMDtcclxuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xyXG4gICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XHJcbiAgICAgIGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCArIDIgKiBwYWRkaW5nID4gaGVpZ2h0TGltaXQpIHtcclxuICAgICAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XHJcbiAgICAgICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7XHJcbiAgICAgICAgbGVmdCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xyXG4gICAgICAgIGNvbCsrO1xyXG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQsIHRvcDogY3VycmVudENvbEhlaWdodCwgY29sLCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xyXG4gICAgICBjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XHJcbiAgICAgIGN1cnJlbnRDb2xIZWlnaHQgKz0gaXRlbUhlaWdodCArIHBhZGRpbmc7XHJcbiAgICB9KTtcclxuICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xyXG4gICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7XHJcbiAgICByZXR1cm4gdG90YWxXaWR0aDtcclxuICB9XHJcbiAgYWRqdXN0SGl0Qm94ZXMoKSB7XHJcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XHJcbiAgICBjb25zdCB7bGVnZW5kSGl0Qm94ZXM6IGhpdGJveGVzLCBvcHRpb25zOiB7YWxpZ24sIGxhYmVsczoge3BhZGRpbmd9LCBydGx9fSA9IHRoaXM7XHJcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKHJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcclxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XHJcbiAgICAgIGxldCByb3cgPSAwO1xyXG4gICAgICBsZXQgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xyXG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xyXG4gICAgICAgIGlmIChyb3cgIT09IGhpdGJveC5yb3cpIHtcclxuICAgICAgICAgIHJvdyA9IGhpdGJveC5yb3c7XHJcbiAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhpdGJveC50b3AgKz0gdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmc7XHJcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChsZWZ0KSwgaGl0Ym94LndpZHRoKTtcclxuICAgICAgICBsZWZ0ICs9IGhpdGJveC53aWR0aCArIHBhZGRpbmc7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxldCBjb2wgPSAwO1xyXG4gICAgICBsZXQgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xyXG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xyXG4gICAgICAgIGlmIChoaXRib3guY29sICE9PSBjb2wpIHtcclxuICAgICAgICAgIGNvbCA9IGhpdGJveC5jb2w7XHJcbiAgICAgICAgICB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhpdGJveC50b3AgPSB0b3A7XHJcbiAgICAgICAgaGl0Ym94LmxlZnQgKz0gdGhpcy5sZWZ0ICsgcGFkZGluZztcclxuICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGhpdGJveC5sZWZ0KSwgaGl0Ym94LndpZHRoKTtcclxuICAgICAgICB0b3AgKz0gaGl0Ym94LmhlaWdodCArIHBhZGRpbmc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaXNIb3Jpem9udGFsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcclxuICB9XHJcbiAgZHJhdygpIHtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xyXG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcclxuICAgICAgY2xpcEFyZWEoY3R4LCB0aGlzKTtcclxuICAgICAgdGhpcy5fZHJhdygpO1xyXG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9kcmF3KCkge1xyXG4gICAgY29uc3Qge29wdGlvbnM6IG9wdHMsIGNvbHVtblNpemVzLCBsaW5lV2lkdGhzLCBjdHh9ID0gdGhpcztcclxuICAgIGNvbnN0IHthbGlnbiwgbGFiZWxzOiBsYWJlbE9wdHN9ID0gb3B0cztcclxuICAgIGNvbnN0IGRlZmF1bHRDb2xvciA9IGRlZmF1bHRzLmNvbG9yO1xyXG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcclxuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XHJcbiAgICBjb25zdCB7Y29sb3I6IGZvbnRDb2xvciwgcGFkZGluZ30gPSBsYWJlbE9wdHM7XHJcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xyXG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xyXG4gICAgbGV0IGN1cnNvcjtcclxuICAgIHRoaXMuZHJhd1RpdGxlKCk7XHJcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xyXG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcclxuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcclxuICAgIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0LCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XHJcbiAgICBjb25zdCBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xyXG4gICAgICBpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDAgfHwgaXNOYU4oYm94SGVpZ2h0KSB8fCBib3hIZWlnaHQgPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCAxKTtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xyXG4gICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcclxuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaE9mZnNldCwgMCk7XHJcbiAgICAgIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUpvaW4sICdtaXRlcicpO1xyXG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xyXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLnN0cm9rZVN0eWxlLCBkZWZhdWx0Q29sb3IpO1xyXG4gICAgICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaCwgW10pKTtcclxuICAgICAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XHJcbiAgICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XHJcbiAgICAgICAgICByYWRpdXM6IGJveFdpZHRoICogTWF0aC5TUVJUMiAvIDIsXHJcbiAgICAgICAgICBwb2ludFN0eWxlOiBsZWdlbmRJdGVtLnBvaW50U3R5bGUsXHJcbiAgICAgICAgICByb3RhdGlvbjogbGVnZW5kSXRlbS5yb3RhdGlvbixcclxuICAgICAgICAgIGJvcmRlcldpZHRoOiBsaW5lV2lkdGhcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIueFBsdXMoeCwgYm94V2lkdGggLyAyKTtcclxuICAgICAgICBjb25zdCBjZW50ZXJZID0geSArIGhhbGZGb250U2l6ZTtcclxuICAgICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgeUJveFRvcCA9IHkgKyBNYXRoLm1heCgoZm9udFNpemUgLSBib3hIZWlnaHQpIC8gMiwgMCk7XHJcbiAgICAgICAgY29uc3QgeEJveExlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCk7XHJcbiAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsZWdlbmRJdGVtLmJvcmRlclJhZGl1cyk7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XHJcbiAgICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XHJcbiAgICAgICAgICAgIHg6IHhCb3hMZWZ0LFxyXG4gICAgICAgICAgICB5OiB5Qm94VG9wLFxyXG4gICAgICAgICAgICB3OiBib3hXaWR0aCxcclxuICAgICAgICAgICAgaDogYm94SGVpZ2h0LFxyXG4gICAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjdHgucmVjdCh4Qm94TGVmdCwgeUJveFRvcCwgYm94V2lkdGgsIGJveEhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgaWYgKGxpbmVXaWR0aCAhPT0gMCkge1xyXG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xyXG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGVnZW5kSXRlbS50ZXh0LCB4LCB5ICsgKGl0ZW1IZWlnaHQgLyAyKSwgbGFiZWxGb250LCB7XHJcbiAgICAgICAgc3RyaWtldGhyb3VnaDogbGVnZW5kSXRlbS5oaWRkZW4sXHJcbiAgICAgICAgdGV4dEFsaWduOiBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduKVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xyXG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcclxuICAgIGlmIChpc0hvcml6b250YWwpIHtcclxuICAgICAgY3Vyc29yID0ge1xyXG4gICAgICAgIHg6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1swXSksXHJcbiAgICAgICAgeTogdGhpcy50b3AgKyBwYWRkaW5nICsgdGl0bGVIZWlnaHQsXHJcbiAgICAgICAgbGluZTogMFxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3Vyc29yID0ge1xyXG4gICAgICAgIHg6IHRoaXMubGVmdCArIHBhZGRpbmcsXHJcbiAgICAgICAgeTogX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIGNvbHVtblNpemVzWzBdLmhlaWdodCksXHJcbiAgICAgICAgbGluZTogMFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xyXG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xyXG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XHJcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yIHx8IGZvbnRDb2xvcjtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yIHx8IGZvbnRDb2xvcjtcclxuICAgICAgY29uc3QgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XHJcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24gfHwgKGxlZ2VuZEl0ZW0udGV4dEFsaWduID0gbGFiZWxPcHRzLnRleHRBbGlnbikpO1xyXG4gICAgICBjb25zdCB3aWR0aCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgdGV4dFdpZHRoO1xyXG4gICAgICBsZXQgeCA9IGN1cnNvci54O1xyXG4gICAgICBsZXQgeSA9IGN1cnNvci55O1xyXG4gICAgICBydGxIZWxwZXIuc2V0V2lkdGgodGhpcy53aWR0aCk7XHJcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcclxuICAgICAgICBpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgcGFkZGluZyA+IHRoaXMucmlnaHQpIHtcclxuICAgICAgICAgIHkgPSBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xyXG4gICAgICAgICAgY3Vyc29yLmxpbmUrKztcclxuICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChpID4gMCAmJiB5ICsgbGluZUhlaWdodCA+IHRoaXMuYm90dG9tKSB7XHJcbiAgICAgICAgeCA9IGN1cnNvci54ID0geCArIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS53aWR0aCArIHBhZGRpbmc7XHJcbiAgICAgICAgY3Vyc29yLmxpbmUrKztcclxuICAgICAgICB5ID0gY3Vyc29yLnkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLmhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcmVhbFggPSBydGxIZWxwZXIueCh4KTtcclxuICAgICAgZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XHJcbiAgICAgIHggPSBfdGV4dFgodGV4dEFsaWduLCB4ICsgYm94V2lkdGggKyBoYWxmRm9udFNpemUsIGlzSG9yaXpvbnRhbCA/IHggKyB3aWR0aCA6IHRoaXMucmlnaHQsIG9wdHMucnRsKTtcclxuICAgICAgZmlsbFRleHQocnRsSGVscGVyLngoeCksIHksIGxlZ2VuZEl0ZW0pO1xyXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgY3Vyc29yLnggKz0gd2lkdGggKyBwYWRkaW5nO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmVzdG9yZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XHJcbiAgfVxyXG4gIGRyYXdUaXRsZSgpIHtcclxuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCB0aXRsZU9wdHMgPSBvcHRzLnRpdGxlO1xyXG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcclxuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XHJcbiAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XHJcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcclxuICAgIGNvbnN0IHBvc2l0aW9uID0gdGl0bGVPcHRzLnBvc2l0aW9uO1xyXG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gdGl0bGVGb250LnNpemUgLyAyO1xyXG4gICAgY29uc3QgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgPSB0aXRsZVBhZGRpbmcudG9wICsgaGFsZkZvbnRTaXplO1xyXG4gICAgbGV0IHk7XHJcbiAgICBsZXQgbGVmdCA9IHRoaXMubGVmdDtcclxuICAgIGxldCBtYXhXaWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xyXG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRoaXMubGluZVdpZHRocyk7XHJcbiAgICAgIHkgPSB0aGlzLnRvcCArIHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplO1xyXG4gICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgbGVmdCwgdGhpcy5yaWdodCAtIG1heFdpZHRoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuY29sdW1uU2l6ZXMucmVkdWNlKChhY2MsIHNpemUpID0+IE1hdGgubWF4KGFjYywgc2l6ZS5oZWlnaHQpLCAwKTtcclxuICAgICAgeSA9IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplICsgX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgdGhpcy50b3AsIHRoaXMuYm90dG9tIC0gbWF4SGVpZ2h0IC0gb3B0cy5sYWJlbHMucGFkZGluZyAtIHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHggPSBfYWxpZ25TdGFydEVuZChwb3NpdGlvbiwgbGVmdCwgbGVmdCArIG1heFdpZHRoKTtcclxuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKF90b0xlZnRSaWdodENlbnRlcihwb3NpdGlvbikpO1xyXG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcclxuICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcclxuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZU9wdHMudGV4dCwgeCwgeSwgdGl0bGVGb250KTtcclxuICB9XHJcbiAgX2NvbXB1dGVUaXRsZUhlaWdodCgpIHtcclxuICAgIGNvbnN0IHRpdGxlT3B0cyA9IHRoaXMub3B0aW9ucy50aXRsZTtcclxuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XHJcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xyXG4gICAgcmV0dXJuIHRpdGxlT3B0cy5kaXNwbGF5ID8gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVBhZGRpbmcuaGVpZ2h0IDogMDtcclxuICB9XHJcbiAgX2dldExlZ2VuZEl0ZW1BdCh4LCB5KSB7XHJcbiAgICBsZXQgaSwgaGl0Qm94LCBsaDtcclxuICAgIGlmIChfaXNCZXR3ZWVuKHgsIHRoaXMubGVmdCwgdGhpcy5yaWdodClcclxuICAgICAgJiYgX2lzQmV0d2Vlbih5LCB0aGlzLnRvcCwgdGhpcy5ib3R0b20pKSB7XHJcbiAgICAgIGxoID0gdGhpcy5sZWdlbmRIaXRCb3hlcztcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgaGl0Qm94ID0gbGhbaV07XHJcbiAgICAgICAgaWYgKF9pc0JldHdlZW4oeCwgaGl0Qm94LmxlZnQsIGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoKVxyXG4gICAgICAgICAgJiYgX2lzQmV0d2Vlbih5LCBoaXRCb3gudG9wLCBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIGhhbmRsZUV2ZW50KGUpIHtcclxuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBpZiAoIWlzTGlzdGVuZWQoZS50eXBlLCBvcHRzKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBob3ZlcmVkSXRlbSA9IHRoaXMuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XHJcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcclxuICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9ob3ZlcmVkSXRlbTtcclxuICAgICAgY29uc3Qgc2FtZUl0ZW0gPSBpdGVtc0VxdWFsKHByZXZpb3VzLCBob3ZlcmVkSXRlbSk7XHJcbiAgICAgIGlmIChwcmV2aW91cyAmJiAhc2FtZUl0ZW0pIHtcclxuICAgICAgICBjYWxsYmFjayhvcHRzLm9uTGVhdmUsIFtlLCBwcmV2aW91cywgdGhpc10sIHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XHJcbiAgICAgIGlmIChob3ZlcmVkSXRlbSAmJiAhc2FtZUl0ZW0pIHtcclxuICAgICAgICBjYWxsYmFjayhvcHRzLm9uSG92ZXIsIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtKSB7XHJcbiAgICAgIGNhbGxiYWNrKG9wdHMub25DbGljaywgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzTGlzdGVuZWQodHlwZSwgb3B0cykge1xyXG4gIGlmICgodHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgdHlwZSA9PT0gJ21vdXNlb3V0JykgJiYgKG9wdHMub25Ib3ZlciB8fCBvcHRzLm9uTGVhdmUpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKG9wdHMub25DbGljayAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnbW91c2V1cCcpKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbnZhciBwbHVnaW5fbGVnZW5kID0ge1xyXG4gIGlkOiAnbGVnZW5kJyxcclxuICBfZWxlbWVudDogTGVnZW5kLFxyXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xyXG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kID0gbmV3IExlZ2VuZCh7Y3R4OiBjaGFydC5jdHgsIG9wdGlvbnMsIGNoYXJ0fSk7XHJcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcclxuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xyXG4gIH0sXHJcbiAgc3RvcChjaGFydCkge1xyXG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIGNoYXJ0LmxlZ2VuZCk7XHJcbiAgICBkZWxldGUgY2hhcnQubGVnZW5kO1xyXG4gIH0sXHJcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xyXG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xyXG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XHJcbiAgICBsZWdlbmQub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgfSxcclxuICBhZnRlclVwZGF0ZShjaGFydCkge1xyXG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xyXG4gICAgbGVnZW5kLmJ1aWxkTGFiZWxzKCk7XHJcbiAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcclxuICB9LFxyXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcclxuICAgIGlmICghYXJncy5yZXBsYXkpIHtcclxuICAgICAgY2hhcnQubGVnZW5kLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgZGVmYXVsdHM6IHtcclxuICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgICBwb3NpdGlvbjogJ3RvcCcsXHJcbiAgICBhbGlnbjogJ2NlbnRlcicsXHJcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcclxuICAgIHJldmVyc2U6IGZhbHNlLFxyXG4gICAgd2VpZ2h0OiAxMDAwLFxyXG4gICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcclxuICAgICAgY29uc3QgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcclxuICAgICAgY29uc3QgY2kgPSBsZWdlbmQuY2hhcnQ7XHJcbiAgICAgIGlmIChjaS5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KSkge1xyXG4gICAgICAgIGNpLmhpZGUoaW5kZXgpO1xyXG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjaS5zaG93KGluZGV4KTtcclxuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgb25Ib3ZlcjogbnVsbCxcclxuICAgIG9uTGVhdmU6IG51bGwsXHJcbiAgICBsYWJlbHM6IHtcclxuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxyXG4gICAgICBib3hXaWR0aDogNDAsXHJcbiAgICAgIHBhZGRpbmc6IDEwLFxyXG4gICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcclxuICAgICAgICBjb25zdCB7bGFiZWxzOiB7dXNlUG9pbnRTdHlsZSwgcG9pbnRTdHlsZSwgdGV4dEFsaWduLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XHJcbiAgICAgICAgcmV0dXJuIGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoKG1ldGEpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHVzZVBvaW50U3R5bGUgPyAwIDogdW5kZWZpbmVkKTtcclxuICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdG9QYWRkaW5nKHN0eWxlLmJvcmRlcldpZHRoKTtcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxyXG4gICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcclxuICAgICAgICAgICAgaGlkZGVuOiAhbWV0YS52aXNpYmxlLFxyXG4gICAgICAgICAgICBsaW5lQ2FwOiBzdHlsZS5ib3JkZXJDYXBTdHlsZSxcclxuICAgICAgICAgICAgbGluZURhc2g6IHN0eWxlLmJvcmRlckRhc2gsXHJcbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxyXG4gICAgICAgICAgICBsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxyXG4gICAgICAgICAgICBsaW5lV2lkdGg6IChib3JkZXJXaWR0aC53aWR0aCArIGJvcmRlcldpZHRoLmhlaWdodCkgLyA0LFxyXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXHJcbiAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUgfHwgc3R5bGUucG9pbnRTdHlsZSxcclxuICAgICAgICAgICAgcm90YXRpb246IHN0eWxlLnJvdGF0aW9uLFxyXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ24sXHJcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcclxuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgdGl0bGU6IHtcclxuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxyXG4gICAgICBkaXNwbGF5OiBmYWxzZSxcclxuICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxyXG4gICAgICB0ZXh0OiAnJyxcclxuICAgIH1cclxuICB9LFxyXG4gIGRlc2NyaXB0b3JzOiB7XHJcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXHJcbiAgICBsYWJlbHM6IHtcclxuICAgICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhWydnZW5lcmF0ZUxhYmVscycsICdmaWx0ZXInLCAnc29ydCddLmluY2x1ZGVzKG5hbWUpLFxyXG4gICAgfVxyXG4gIH0sXHJcbn07XHJcblxyXG5jbGFzcyBUaXRsZSBleHRlbmRzIEVsZW1lbnQge1xyXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcclxuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcclxuICAgIHRoaXMuX3BhZGRpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XHJcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xyXG4gICAgdGhpcy5sZWZ0ID0gMDtcclxuICAgIHRoaXMudG9wID0gMDtcclxuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XHJcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IHRoaXMucmlnaHQgPSB0aGlzLmJvdHRvbSA9IDA7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0ID0gbWF4V2lkdGg7XHJcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuYm90dG9tID0gbWF4SGVpZ2h0O1xyXG4gICAgY29uc3QgbGluZUNvdW50ID0gaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XHJcbiAgICB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKG9wdHMucGFkZGluZyk7XHJcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IGxpbmVDb3VudCAqIHRvRm9udChvcHRzLmZvbnQpLmxpbmVIZWlnaHQgKyB0aGlzLl9wYWRkaW5nLmhlaWdodDtcclxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGV4dFNpemU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLndpZHRoID0gdGV4dFNpemU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlzSG9yaXpvbnRhbCgpIHtcclxuICAgIGNvbnN0IHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuICAgIHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XHJcbiAgfVxyXG4gIF9kcmF3QXJncyhvZmZzZXQpIHtcclxuICAgIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIG9wdGlvbnN9ID0gdGhpcztcclxuICAgIGNvbnN0IGFsaWduID0gb3B0aW9ucy5hbGlnbjtcclxuICAgIGxldCByb3RhdGlvbiA9IDA7XHJcbiAgICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xyXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcclxuICAgICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcclxuICAgICAgdGl0bGVZID0gdG9wICsgb2Zmc2V0O1xyXG4gICAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcclxuICAgICAgICB0aXRsZVggPSBsZWZ0ICsgb2Zmc2V0O1xyXG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XHJcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIC0wLjU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGl0bGVYID0gcmlnaHQgLSBvZmZzZXQ7XHJcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRvcCwgYm90dG9tKTtcclxuICAgICAgICByb3RhdGlvbiA9IFBJICogMC41O1xyXG4gICAgICB9XHJcbiAgICAgIG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcclxuICB9XHJcbiAgZHJhdygpIHtcclxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xyXG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcclxuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGZvbnRPcHRzID0gdG9Gb250KG9wdHMuZm9udCk7XHJcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcclxuICAgIGNvbnN0IG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgdGhpcy5fcGFkZGluZy50b3A7XHJcbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aGlzLl9kcmF3QXJncyhvZmZzZXQpO1xyXG4gICAgcmVuZGVyVGV4dChjdHgsIG9wdHMudGV4dCwgMCwgMCwgZm9udE9wdHMsIHtcclxuICAgICAgY29sb3I6IG9wdHMuY29sb3IsXHJcbiAgICAgIG1heFdpZHRoLFxyXG4gICAgICByb3RhdGlvbixcclxuICAgICAgdGV4dEFsaWduOiBfdG9MZWZ0UmlnaHRDZW50ZXIob3B0cy5hbGlnbiksXHJcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXHJcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVRpdGxlKGNoYXJ0LCB0aXRsZU9wdHMpIHtcclxuICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XHJcbiAgICBjdHg6IGNoYXJ0LmN0eCxcclxuICAgIG9wdGlvbnM6IHRpdGxlT3B0cyxcclxuICAgIGNoYXJ0XHJcbiAgfSk7XHJcbiAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xyXG4gIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XHJcbiAgY2hhcnQudGl0bGVCbG9jayA9IHRpdGxlO1xyXG59XHJcbnZhciBwbHVnaW5fdGl0bGUgPSB7XHJcbiAgaWQ6ICd0aXRsZScsXHJcbiAgX2VsZW1lbnQ6IFRpdGxlLFxyXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xyXG4gICAgY3JlYXRlVGl0bGUoY2hhcnQsIG9wdGlvbnMpO1xyXG4gIH0sXHJcbiAgc3RvcChjaGFydCkge1xyXG4gICAgY29uc3QgdGl0bGVCbG9jayA9IGNoYXJ0LnRpdGxlQmxvY2s7XHJcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XHJcbiAgICBkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcclxuICB9LFxyXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHRpdGxlID0gY2hhcnQudGl0bGVCbG9jaztcclxuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XHJcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcclxuICB9LFxyXG4gIGRlZmF1bHRzOiB7XHJcbiAgICBhbGlnbjogJ2NlbnRlcicsXHJcbiAgICBkaXNwbGF5OiBmYWxzZSxcclxuICAgIGZvbnQ6IHtcclxuICAgICAgd2VpZ2h0OiAnYm9sZCcsXHJcbiAgICB9LFxyXG4gICAgZnVsbFNpemU6IHRydWUsXHJcbiAgICBwYWRkaW5nOiAxMCxcclxuICAgIHBvc2l0aW9uOiAndG9wJyxcclxuICAgIHRleHQ6ICcnLFxyXG4gICAgd2VpZ2h0OiAyMDAwXHJcbiAgfSxcclxuICBkZWZhdWx0Um91dGVzOiB7XHJcbiAgICBjb2xvcjogJ2NvbG9yJ1xyXG4gIH0sXHJcbiAgZGVzY3JpcHRvcnM6IHtcclxuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxyXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXHJcbiAgfSxcclxufTtcclxuXHJcbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbnZhciBwbHVnaW5fc3VidGl0bGUgPSB7XHJcbiAgaWQ6ICdzdWJ0aXRsZScsXHJcbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XHJcbiAgICAgIGN0eDogY2hhcnQuY3R4LFxyXG4gICAgICBvcHRpb25zLFxyXG4gICAgICBjaGFydFxyXG4gICAgfSk7XHJcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xyXG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcclxuICAgIG1hcC5zZXQoY2hhcnQsIHRpdGxlKTtcclxuICB9LFxyXG4gIHN0b3AoY2hhcnQpIHtcclxuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBtYXAuZ2V0KGNoYXJ0KSk7XHJcbiAgICBtYXAuZGVsZXRlKGNoYXJ0KTtcclxuICB9LFxyXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHRpdGxlID0gbWFwLmdldChjaGFydCk7XHJcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xyXG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgfSxcclxuICBkZWZhdWx0czoge1xyXG4gICAgYWxpZ246ICdjZW50ZXInLFxyXG4gICAgZGlzcGxheTogZmFsc2UsXHJcbiAgICBmb250OiB7XHJcbiAgICAgIHdlaWdodDogJ25vcm1hbCcsXHJcbiAgICB9LFxyXG4gICAgZnVsbFNpemU6IHRydWUsXHJcbiAgICBwYWRkaW5nOiAwLFxyXG4gICAgcG9zaXRpb246ICd0b3AnLFxyXG4gICAgdGV4dDogJycsXHJcbiAgICB3ZWlnaHQ6IDE1MDBcclxuICB9LFxyXG4gIGRlZmF1bHRSb3V0ZXM6IHtcclxuICAgIGNvbG9yOiAnY29sb3InXHJcbiAgfSxcclxuICBkZXNjcmlwdG9yczoge1xyXG4gICAgX3NjcmlwdGFibGU6IHRydWUsXHJcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcclxuICB9LFxyXG59O1xyXG5cclxuY29uc3QgcG9zaXRpb25lcnMgPSB7XHJcbiAgYXZlcmFnZShpdGVtcykge1xyXG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbGV0IGksIGxlbjtcclxuICAgIGxldCB4ID0gMDtcclxuICAgIGxldCB5ID0gMDtcclxuICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XHJcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XHJcbiAgICAgICAgY29uc3QgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XHJcbiAgICAgICAgeCArPSBwb3MueDtcclxuICAgICAgICB5ICs9IHBvcy55O1xyXG4gICAgICAgICsrY291bnQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IHggLyBjb3VudCxcclxuICAgICAgeTogeSAvIGNvdW50XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgbmVhcmVzdChpdGVtcywgZXZlbnRQb3NpdGlvbikge1xyXG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbGV0IHggPSBldmVudFBvc2l0aW9uLng7XHJcbiAgICBsZXQgeSA9IGV2ZW50UG9zaXRpb24ueTtcclxuICAgIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgIGxldCBpLCBsZW4sIG5lYXJlc3RFbGVtZW50O1xyXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xyXG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xyXG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XHJcbiAgICAgICAgY29uc3QgZCA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xyXG4gICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UpIHtcclxuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcclxuICAgICAgICAgIG5lYXJlc3RFbGVtZW50ID0gZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobmVhcmVzdEVsZW1lbnQpIHtcclxuICAgICAgY29uc3QgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcclxuICAgICAgeCA9IHRwLng7XHJcbiAgICAgIHkgPSB0cC55O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeCxcclxuICAgICAgeVxyXG4gICAgfTtcclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIHB1c2hPckNvbmNhdChiYXNlLCB0b1B1c2gpIHtcclxuICBpZiAodG9QdXNoKSB7XHJcbiAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XHJcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBiYXNlLnB1c2godG9QdXNoKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGJhc2U7XHJcbn1cclxuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcclxuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcclxuICAgIHJldHVybiBzdHIuc3BsaXQoJ1xcbicpO1xyXG4gIH1cclxuICByZXR1cm4gc3RyO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGNoYXJ0LCBpdGVtKSB7XHJcbiAgY29uc3Qge2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9ID0gaXRlbTtcclxuICBjb25zdCBjb250cm9sbGVyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xyXG4gIGNvbnN0IHtsYWJlbCwgdmFsdWV9ID0gY29udHJvbGxlci5nZXRMYWJlbEFuZFZhbHVlKGluZGV4KTtcclxuICByZXR1cm4ge1xyXG4gICAgY2hhcnQsXHJcbiAgICBsYWJlbCxcclxuICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxyXG4gICAgcmF3OiBjaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0sXHJcbiAgICBmb3JtYXR0ZWRWYWx1ZTogdmFsdWUsXHJcbiAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcclxuICAgIGRhdGFJbmRleDogaW5kZXgsXHJcbiAgICBkYXRhc2V0SW5kZXgsXHJcbiAgICBlbGVtZW50XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBvcHRpb25zKSB7XHJcbiAgY29uc3QgY3R4ID0gdG9vbHRpcC5jaGFydC5jdHg7XHJcbiAgY29uc3Qge2JvZHksIGZvb3RlciwgdGl0bGV9ID0gdG9vbHRpcDtcclxuICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodH0gPSBvcHRpb25zO1xyXG4gIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xyXG4gIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XHJcbiAgY29uc3QgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xyXG4gIGNvbnN0IHRpdGxlTGluZUNvdW50ID0gdGl0bGUubGVuZ3RoO1xyXG4gIGNvbnN0IGZvb3RlckxpbmVDb3VudCA9IGZvb3Rlci5sZW5ndGg7XHJcbiAgY29uc3QgYm9keUxpbmVJdGVtQ291bnQgPSBib2R5Lmxlbmd0aDtcclxuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XHJcbiAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xyXG4gIGxldCB3aWR0aCA9IDA7XHJcbiAgbGV0IGNvbWJpbmVkQm9keUxlbmd0aCA9IGJvZHkucmVkdWNlKChjb3VudCwgYm9keUl0ZW0pID0+IGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aCwgMCk7XHJcbiAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XHJcbiAgaWYgKHRpdGxlTGluZUNvdW50KSB7XHJcbiAgICBoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnQubGluZUhlaWdodFxyXG5cdFx0XHQrICh0aXRsZUxpbmVDb3VudCAtIDEpICogb3B0aW9ucy50aXRsZVNwYWNpbmdcclxuXHRcdFx0KyBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tO1xyXG4gIH1cclxuICBpZiAoY29tYmluZWRCb2R5TGVuZ3RoKSB7XHJcbiAgICBjb25zdCBib2R5TGluZUhlaWdodCA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IE1hdGgubWF4KGJveEhlaWdodCwgYm9keUZvbnQubGluZUhlaWdodCkgOiBib2R5Rm9udC5saW5lSGVpZ2h0O1xyXG4gICAgaGVpZ2h0ICs9IGJvZHlMaW5lSXRlbUNvdW50ICogYm9keUxpbmVIZWlnaHRcclxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gYm9keUxpbmVJdGVtQ291bnQpICogYm9keUZvbnQubGluZUhlaWdodFxyXG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG9wdGlvbnMuYm9keVNwYWNpbmc7XHJcbiAgfVxyXG4gIGlmIChmb290ZXJMaW5lQ291bnQpIHtcclxuICAgIGhlaWdodCArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcFxyXG5cdFx0XHQrIGZvb3RlckxpbmVDb3VudCAqIGZvb3RlckZvbnQubGluZUhlaWdodFxyXG5cdFx0XHQrIChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcclxuICB9XHJcbiAgbGV0IHdpZHRoUGFkZGluZyA9IDA7XHJcbiAgY29uc3QgbWF4TGluZVdpZHRoID0gZnVuY3Rpb24obGluZSkge1xyXG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcclxuICB9O1xyXG4gIGN0eC5zYXZlKCk7XHJcbiAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xyXG4gIGVhY2godG9vbHRpcC50aXRsZSwgbWF4TGluZVdpZHRoKTtcclxuICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcclxuICBlYWNoKHRvb2x0aXAuYmVmb3JlQm9keS5jb25jYXQodG9vbHRpcC5hZnRlckJvZHkpLCBtYXhMaW5lV2lkdGgpO1xyXG4gIHdpZHRoUGFkZGluZyA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IChib3hXaWR0aCArIDIgKyBvcHRpb25zLmJveFBhZGRpbmcpIDogMDtcclxuICBlYWNoKGJvZHksIChib2R5SXRlbSkgPT4ge1xyXG4gICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XHJcbiAgICBlYWNoKGJvZHlJdGVtLmxpbmVzLCBtYXhMaW5lV2lkdGgpO1xyXG4gICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcclxuICB9KTtcclxuICB3aWR0aFBhZGRpbmcgPSAwO1xyXG4gIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XHJcbiAgZWFjaCh0b29sdGlwLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcclxuICBjdHgucmVzdG9yZSgpO1xyXG4gIHdpZHRoICs9IHBhZGRpbmcud2lkdGg7XHJcbiAgcmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcclxufVxyXG5mdW5jdGlvbiBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpIHtcclxuICBjb25zdCB7eSwgaGVpZ2h0fSA9IHNpemU7XHJcbiAgaWYgKHkgPCBoZWlnaHQgLyAyKSB7XHJcbiAgICByZXR1cm4gJ3RvcCc7XHJcbiAgfSBlbHNlIGlmICh5ID4gKGNoYXJ0LmhlaWdodCAtIGhlaWdodCAvIDIpKSB7XHJcbiAgICByZXR1cm4gJ2JvdHRvbSc7XHJcbiAgfVxyXG4gIHJldHVybiAnY2VudGVyJztcclxufVxyXG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcclxuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcclxuICBjb25zdCBjYXJldCA9IG9wdGlvbnMuY2FyZXRTaXplICsgb3B0aW9ucy5jYXJldFBhZGRpbmc7XHJcbiAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBpZiAoeEFsaWduID09PSAncmlnaHQnICYmIHggLSB3aWR0aCAtIGNhcmV0IDwgMCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSB7XHJcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XHJcbiAgY29uc3Qge3dpZHRoOiBjaGFydFdpZHRoLCBjaGFydEFyZWE6IHtsZWZ0LCByaWdodH19ID0gY2hhcnQ7XHJcbiAgbGV0IHhBbGlnbiA9ICdjZW50ZXInO1xyXG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XHJcbiAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XHJcbiAgfSBlbHNlIGlmICh4IDw9IHdpZHRoIC8gMikge1xyXG4gICAgeEFsaWduID0gJ2xlZnQnO1xyXG4gIH0gZWxzZSBpZiAoeCA+PSBjaGFydFdpZHRoIC0gd2lkdGggLyAyKSB7XHJcbiAgICB4QWxpZ24gPSAncmlnaHQnO1xyXG4gIH1cclxuICBpZiAoZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSkge1xyXG4gICAgeEFsaWduID0gJ2NlbnRlcic7XHJcbiAgfVxyXG4gIHJldHVybiB4QWxpZ247XHJcbn1cclxuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XHJcbiAgY29uc3QgeUFsaWduID0gc2l6ZS55QWxpZ24gfHwgb3B0aW9ucy55QWxpZ24gfHwgZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKTtcclxuICByZXR1cm4ge1xyXG4gICAgeEFsaWduOiBzaXplLnhBbGlnbiB8fCBvcHRpb25zLnhBbGlnbiB8fCBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbiksXHJcbiAgICB5QWxpZ25cclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGFsaWduWChzaXplLCB4QWxpZ24pIHtcclxuICBsZXQge3gsIHdpZHRofSA9IHNpemU7XHJcbiAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgeCAtPSB3aWR0aDtcclxuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcclxuICAgIHggLT0gKHdpZHRoIC8gMik7XHJcbiAgfVxyXG4gIHJldHVybiB4O1xyXG59XHJcbmZ1bmN0aW9uIGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKSB7XHJcbiAgbGV0IHt5LCBoZWlnaHR9ID0gc2l6ZTtcclxuICBpZiAoeUFsaWduID09PSAndG9wJykge1xyXG4gICAgeSArPSBwYWRkaW5nQW5kU2l6ZTtcclxuICB9IGVsc2UgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcclxuICAgIHkgLT0gaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHkgLT0gKGhlaWdodCAvIDIpO1xyXG4gIH1cclxuICByZXR1cm4geTtcclxufVxyXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xyXG4gIGNvbnN0IHtjYXJldFNpemUsIGNhcmV0UGFkZGluZywgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XHJcbiAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IGFsaWdubWVudDtcclxuICBjb25zdCBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcclxuICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcclxuICBsZXQgeCA9IGFsaWduWChzaXplLCB4QWxpZ24pO1xyXG4gIGNvbnN0IHkgPSBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSk7XHJcbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcclxuICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xyXG4gICAgICB4ICs9IHBhZGRpbmdBbmRTaXplO1xyXG4gICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcclxuICAgICAgeCAtPSBwYWRkaW5nQW5kU2l6ZTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XHJcbiAgICB4IC09IE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgY2FyZXRTaXplO1xyXG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XHJcbiAgICB4ICs9IE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgKyBjYXJldFNpemU7XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICB4OiBfbGltaXRWYWx1ZSh4LCAwLCBjaGFydC53aWR0aCAtIHNpemUud2lkdGgpLFxyXG4gICAgeTogX2xpbWl0VmFsdWUoeSwgMCwgY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRBbGlnbmVkWCh0b29sdGlwLCBhbGlnbiwgb3B0aW9ucykge1xyXG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcclxuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXHJcbiAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLyAyXHJcbiAgICA6IGFsaWduID09PSAncmlnaHQnXHJcbiAgICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAtIHBhZGRpbmcucmlnaHRcclxuICAgICAgOiB0b29sdGlwLnggKyBwYWRkaW5nLmxlZnQ7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcclxuICByZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcENvbnRleHQocGFyZW50LCB0b29sdGlwLCB0b29sdGlwSXRlbXMpIHtcclxuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcclxuICAgIHRvb2x0aXAsXHJcbiAgICB0b29sdGlwSXRlbXMsXHJcbiAgICB0eXBlOiAndG9vbHRpcCdcclxuICB9KTtcclxufVxyXG5mdW5jdGlvbiBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpIHtcclxuICBjb25zdCBvdmVycmlkZSA9IGNvbnRleHQgJiYgY29udGV4dC5kYXRhc2V0ICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwLmNhbGxiYWNrcztcclxuICByZXR1cm4gb3ZlcnJpZGUgPyBjYWxsYmFja3Mub3ZlcnJpZGUob3ZlcnJpZGUpIDogY2FsbGJhY2tzO1xyXG59XHJcbmNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBFbGVtZW50IHtcclxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm9wYWNpdHkgPSAwO1xyXG4gICAgdGhpcy5fYWN0aXZlID0gW107XHJcbiAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fc2l6ZSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSBbXTtcclxuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydCB8fCBjb25maWcuX2NoYXJ0O1xyXG4gICAgdGhpcy5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xyXG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XHJcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnRpdGxlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5iZWZvcmVCb2R5ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5hZnRlckJvZHkgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmZvb3RlciA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMueEFsaWduID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy55QWxpZ24gPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLmNhcmV0WCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuY2FyZXRZID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuICBpbml0aWFsaXplKG9wdGlvbnMpIHtcclxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgX3Jlc29sdmVBbmltYXRpb25zKCkge1xyXG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcclxuICAgIGlmIChjYWNoZWQpIHtcclxuICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgIH1cclxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XHJcbiAgICBjb25zdCBvcHRzID0gb3B0aW9ucy5lbmFibGVkICYmIGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICYmIG9wdGlvbnMuYW5pbWF0aW9ucztcclxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyh0aGlzLmNoYXJ0LCBvcHRzKTtcclxuICAgIGlmIChvcHRzLl9jYWNoZWFibGUpIHtcclxuICAgICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IE9iamVjdC5mcmVlemUoYW5pbWF0aW9ucyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYW5pbWF0aW9ucztcclxuICB9XHJcbiAgZ2V0Q29udGV4dCgpIHtcclxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XHJcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlVG9vbHRpcENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMsIHRoaXMuX3Rvb2x0aXBJdGVtcykpO1xyXG4gIH1cclxuICBnZXRUaXRsZShjb250ZXh0LCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCBiZWZvcmVUaXRsZSA9IGNhbGxiYWNrcy5iZWZvcmVUaXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xyXG4gICAgY29uc3QgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcclxuICAgIGNvbnN0IGFmdGVyVGl0bGUgPSBjYWxsYmFja3MuYWZ0ZXJUaXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xyXG4gICAgbGV0IGxpbmVzID0gW107XHJcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVUaXRsZSkpO1xyXG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcclxuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyVGl0bGUpKTtcclxuICAgIHJldHVybiBsaW5lcztcclxuICB9XHJcbiAgZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhvcHRpb25zLmNhbGxiYWNrcy5iZWZvcmVCb2R5LmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKSk7XHJcbiAgfVxyXG4gIGdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCBib2R5SXRlbXMgPSBbXTtcclxuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xyXG4gICAgICBjb25zdCBib2R5SXRlbSA9IHtcclxuICAgICAgICBiZWZvcmU6IFtdLFxyXG4gICAgICAgIGxpbmVzOiBbXSxcclxuICAgICAgICBhZnRlcjogW11cclxuICAgICAgfTtcclxuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KTtcclxuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgc3BsaXROZXdsaW5lcyhzY29wZWQuYmVmb3JlTGFiZWwuY2FsbCh0aGlzLCBjb250ZXh0KSkpO1xyXG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIHNjb3BlZC5sYWJlbC5jYWxsKHRoaXMsIGNvbnRleHQpKTtcclxuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmFmdGVyLCBzcGxpdE5ld2xpbmVzKHNjb3BlZC5hZnRlckxhYmVsLmNhbGwodGhpcywgY29udGV4dCkpKTtcclxuICAgICAgYm9keUl0ZW1zLnB1c2goYm9keUl0ZW0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYm9keUl0ZW1zO1xyXG4gIH1cclxuICBnZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMob3B0aW9ucy5jYWxsYmFja3MuYWZ0ZXJCb2R5LmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKSk7XHJcbiAgfVxyXG4gIGdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IGJlZm9yZUZvb3RlciA9IGNhbGxiYWNrcy5iZWZvcmVGb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xyXG4gICAgY29uc3QgZm9vdGVyID0gY2FsbGJhY2tzLmZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XHJcbiAgICBjb25zdCBhZnRlckZvb3RlciA9IGNhbGxiYWNrcy5hZnRlckZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XHJcbiAgICBsZXQgbGluZXMgPSBbXTtcclxuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZUZvb3RlcikpO1xyXG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XHJcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlckZvb3RlcikpO1xyXG4gICAgcmV0dXJuIGxpbmVzO1xyXG4gIH1cclxuICBfY3JlYXRlSXRlbXMob3B0aW9ucykge1xyXG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xyXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcclxuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XHJcbiAgICBjb25zdCBsYWJlbFBvaW50U3R5bGVzID0gW107XHJcbiAgICBjb25zdCBsYWJlbFRleHRDb2xvcnMgPSBbXTtcclxuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcclxuICAgIGxldCBpLCBsZW47XHJcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBhY3RpdmUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgdG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0odGhpcy5jaGFydCwgYWN0aXZlW2ldKSk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcclxuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBvcHRpb25zLmZpbHRlcihlbGVtZW50LCBpbmRleCwgYXJyYXksIGRhdGEpKTtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLml0ZW1Tb3J0KSB7XHJcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KChhLCBiKSA9PiBvcHRpb25zLml0ZW1Tb3J0KGEsIGIsIGRhdGEpKTtcclxuICAgIH1cclxuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xyXG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhvcHRpb25zLmNhbGxiYWNrcywgY29udGV4dCk7XHJcbiAgICAgIGxhYmVsQ29sb3JzLnB1c2goc2NvcGVkLmxhYmVsQ29sb3IuY2FsbCh0aGlzLCBjb250ZXh0KSk7XHJcbiAgICAgIGxhYmVsUG9pbnRTdHlsZXMucHVzaChzY29wZWQubGFiZWxQb2ludFN0eWxlLmNhbGwodGhpcywgY29udGV4dCkpO1xyXG4gICAgICBsYWJlbFRleHRDb2xvcnMucHVzaChzY29wZWQubGFiZWxUZXh0Q29sb3IuY2FsbCh0aGlzLCBjb250ZXh0KSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMubGFiZWxDb2xvcnMgPSBsYWJlbENvbG9ycztcclxuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IGxhYmVsUG9pbnRTdHlsZXM7XHJcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcclxuICAgIHRoaXMuZGF0YVBvaW50cyA9IHRvb2x0aXBJdGVtcztcclxuICAgIHJldHVybiB0b29sdGlwSXRlbXM7XHJcbiAgfVxyXG4gIHVwZGF0ZShjaGFuZ2VkLCByZXBsYXkpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XHJcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XHJcbiAgICBsZXQgcHJvcGVydGllcztcclxuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcclxuICAgIGlmICghYWN0aXZlLmxlbmd0aCkge1xyXG4gICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSAwKSB7XHJcbiAgICAgICAgcHJvcGVydGllcyA9IHtcclxuICAgICAgICAgIG9wYWNpdHk6IDBcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcclxuICAgICAgdG9vbHRpcEl0ZW1zID0gdGhpcy5fY3JlYXRlSXRlbXMob3B0aW9ucyk7XHJcbiAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XHJcbiAgICAgIHRoaXMuYmVmb3JlQm9keSA9IHRoaXMuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xyXG4gICAgICB0aGlzLmJvZHkgPSB0aGlzLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcclxuICAgICAgdGhpcy5hZnRlckJvZHkgPSB0aGlzLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xyXG4gICAgICB0aGlzLmZvb3RlciA9IHRoaXMuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XHJcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCBzaXplKTtcclxuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMuY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XHJcbiAgICAgIGNvbnN0IGJhY2tncm91bmRQb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgdGhpcy5jaGFydCk7XHJcbiAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcclxuICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xyXG4gICAgICBwcm9wZXJ0aWVzID0ge1xyXG4gICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgeDogYmFja2dyb3VuZFBvaW50LngsXHJcbiAgICAgICAgeTogYmFja2dyb3VuZFBvaW50LnksXHJcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcclxuICAgICAgICBjYXJldFg6IHBvc2l0aW9uLngsXHJcbiAgICAgICAgY2FyZXRZOiBwb3NpdGlvbi55XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXM7XHJcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcclxuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcHJvcGVydGllcyk7XHJcbiAgICB9XHJcbiAgICBpZiAoY2hhbmdlZCAmJiBvcHRpb25zLmV4dGVybmFsKSB7XHJcbiAgICAgIG9wdGlvbnMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7Y2hhcnQ6IHRoaXMuY2hhcnQsIHRvb2x0aXA6IHRoaXMsIHJlcGxheX0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBkcmF3Q2FyZXQodG9vbHRpcFBvaW50LCBjdHgsIHNpemUsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKTtcclxuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XHJcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDIsIGNhcmV0UG9zaXRpb24ueTIpO1xyXG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcclxuICB9XHJcbiAgZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xyXG4gICAgY29uc3Qge2NhcmV0U2l6ZSwgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcclxuICAgIGNvbnN0IHt4OiBwdFgsIHk6IHB0WX0gPSB0b29sdGlwUG9pbnQ7XHJcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xyXG4gICAgbGV0IHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XHJcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xyXG4gICAgICB5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcclxuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgeDEgPSBwdFg7XHJcbiAgICAgICAgeDIgPSB4MSAtIGNhcmV0U2l6ZTtcclxuICAgICAgICB5MSA9IHkyICsgY2FyZXRTaXplO1xyXG4gICAgICAgIHkzID0geTIgLSBjYXJldFNpemU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeDEgPSBwdFggKyB3aWR0aDtcclxuICAgICAgICB4MiA9IHgxICsgY2FyZXRTaXplO1xyXG4gICAgICAgIHkxID0geTIgLSBjYXJldFNpemU7XHJcbiAgICAgICAgeTMgPSB5MiArIGNhcmV0U2l6ZTtcclxuICAgICAgfVxyXG4gICAgICB4MyA9IHgxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgeDIgPSBwdFggKyBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIChjYXJldFNpemUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgIHgyID0gcHRYICsgd2lkdGggLSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpIC0gY2FyZXRTaXplO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHgyID0gdGhpcy5jYXJldFg7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcclxuICAgICAgICB5MSA9IHB0WTtcclxuICAgICAgICB5MiA9IHkxIC0gY2FyZXRTaXplO1xyXG4gICAgICAgIHgxID0geDIgLSBjYXJldFNpemU7XHJcbiAgICAgICAgeDMgPSB4MiArIGNhcmV0U2l6ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB5MSA9IHB0WSArIGhlaWdodDtcclxuICAgICAgICB5MiA9IHkxICsgY2FyZXRTaXplO1xyXG4gICAgICAgIHgxID0geDIgKyBjYXJldFNpemU7XHJcbiAgICAgICAgeDMgPSB4MiAtIGNhcmV0U2l6ZTtcclxuICAgICAgfVxyXG4gICAgICB5MyA9IHkxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzfTtcclxuICB9XHJcbiAgZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHRpdGxlID0gdGhpcy50aXRsZTtcclxuICAgIGNvbnN0IGxlbmd0aCA9IHRpdGxlLmxlbmd0aDtcclxuICAgIGxldCB0aXRsZUZvbnQsIHRpdGxlU3BhY2luZywgaTtcclxuICAgIGlmIChsZW5ndGgpIHtcclxuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcclxuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMudGl0bGVBbGlnbiwgb3B0aW9ucyk7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMudGl0bGVBbGlnbik7XHJcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuICAgICAgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcclxuICAgICAgdGl0bGVTcGFjaW5nID0gb3B0aW9ucy50aXRsZVNwYWNpbmc7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLnRpdGxlQ29sb3I7XHJcbiAgICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udC5saW5lSGVpZ2h0IC8gMik7XHJcbiAgICAgICAgcHQueSArPSB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlU3BhY2luZztcclxuICAgICAgICBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xyXG4gICAgICAgICAgcHQueSArPSBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBfZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgbGFiZWxDb2xvcnMgPSB0aGlzLmxhYmVsQ29sb3JzW2ldO1xyXG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlID0gdGhpcy5sYWJlbFBvaW50U3R5bGVzW2ldO1xyXG4gICAgY29uc3Qge2JveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xyXG4gICAgY29uc3QgY29sb3JYID0gZ2V0QWxpZ25lZFgodGhpcywgJ2xlZnQnLCBvcHRpb25zKTtcclxuICAgIGNvbnN0IHJ0bENvbG9yWCA9IHJ0bEhlbHBlci54KGNvbG9yWCk7XHJcbiAgICBjb25zdCB5T2ZmU2V0ID0gYm94SGVpZ2h0IDwgYm9keUZvbnQubGluZUhlaWdodCA/IChib2R5Rm9udC5saW5lSGVpZ2h0IC0gYm94SGVpZ2h0KSAvIDIgOiAwO1xyXG4gICAgY29uc3QgY29sb3JZID0gcHQueSArIHlPZmZTZXQ7XHJcbiAgICBpZiAob3B0aW9ucy51c2VQb2ludFN0eWxlKSB7XHJcbiAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xyXG4gICAgICAgIHJhZGl1czogTWF0aC5taW4oYm94V2lkdGgsIGJveEhlaWdodCkgLyAyLFxyXG4gICAgICAgIHBvaW50U3R5bGU6IGxhYmVsUG9pbnRTdHlsZS5wb2ludFN0eWxlLFxyXG4gICAgICAgIHJvdGF0aW9uOiBsYWJlbFBvaW50U3R5bGUucm90YXRpb24sXHJcbiAgICAgICAgYm9yZGVyV2lkdGg6IDFcclxuICAgICAgfTtcclxuICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpICsgYm94V2lkdGggLyAyO1xyXG4gICAgICBjb25zdCBjZW50ZXJZID0gY29sb3JZICsgYm94SGVpZ2h0IC8gMjtcclxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcclxuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xyXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9ycy5ib3JkZXJDb2xvcjtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxhYmVsQ29sb3JzLmJvcmRlcldpZHRoIHx8IDE7XHJcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzLmJvcmRlckNvbG9yO1xyXG4gICAgICBjdHguc2V0TGluZURhc2gobGFiZWxDb2xvcnMuYm9yZGVyRGFzaCB8fCBbXSk7XHJcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxhYmVsQ29sb3JzLmJvcmRlckRhc2hPZmZzZXQgfHwgMDtcclxuICAgICAgY29uc3Qgb3V0ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCAtIGJveFBhZGRpbmcpO1xyXG4gICAgICBjb25zdCBpbm5lclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueFBsdXMocnRsQ29sb3JYLCAxKSwgYm94V2lkdGggLSBib3hQYWRkaW5nIC0gMik7XHJcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGFiZWxDb2xvcnMuYm9yZGVyUmFkaXVzKTtcclxuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xyXG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcclxuICAgICAgICAgIHg6IG91dGVyWCxcclxuICAgICAgICAgIHk6IGNvbG9yWSxcclxuICAgICAgICAgIHc6IGJveFdpZHRoLFxyXG4gICAgICAgICAgaDogYm94SGVpZ2h0LFxyXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xyXG4gICAgICAgICAgeDogaW5uZXJYLFxyXG4gICAgICAgICAgeTogY29sb3JZICsgMSxcclxuICAgICAgICAgIHc6IGJveFdpZHRoIC0gMixcclxuICAgICAgICAgIGg6IGJveEhlaWdodCAtIDIsXHJcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcclxuICAgICAgICBjdHguZmlsbFJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xyXG4gICAgICAgIGN0eC5zdHJva2VSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgIGN0eC5maWxsUmVjdChpbm5lclgsIGNvbG9yWSArIDEsIGJveFdpZHRoIC0gMiwgYm94SGVpZ2h0IC0gMik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcclxuICB9XHJcbiAgZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucykge1xyXG4gICAgY29uc3Qge2JvZHl9ID0gdGhpcztcclxuICAgIGNvbnN0IHtib2R5U3BhY2luZywgYm9keUFsaWduLCBkaXNwbGF5Q29sb3JzLCBib3hIZWlnaHQsIGJveFdpZHRoLCBib3hQYWRkaW5nfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcclxuICAgIGxldCBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XHJcbiAgICBsZXQgeExpbmVQYWRkaW5nID0gMDtcclxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XHJcbiAgICBjb25zdCBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcclxuICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIHJ0bEhlbHBlci54KHB0LnggKyB4TGluZVBhZGRpbmcpLCBwdC55ICsgYm9keUxpbmVIZWlnaHQgLyAyKTtcclxuICAgICAgcHQueSArPSBib2R5TGluZUhlaWdodCArIGJvZHlTcGFjaW5nO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uID0gcnRsSGVscGVyLnRleHRBbGlnbihib2R5QWxpZ24pO1xyXG4gICAgbGV0IGJvZHlJdGVtLCB0ZXh0Q29sb3IsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xyXG4gICAgY3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcclxuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuICAgIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xyXG4gICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uLCBvcHRpb25zKTtcclxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJvZHlDb2xvcjtcclxuICAgIGVhY2godGhpcy5iZWZvcmVCb2R5LCBmaWxsTGluZU9mVGV4dCk7XHJcbiAgICB4TGluZVBhZGRpbmcgPSBkaXNwbGF5Q29sb3JzICYmIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uICE9PSAncmlnaHQnXHJcbiAgICAgID8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib3hXaWR0aCAvIDIgKyBib3hQYWRkaW5nKSA6IChib3hXaWR0aCArIDIgKyBib3hQYWRkaW5nKVxyXG4gICAgICA6IDA7XHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYm9keS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuICAgICAgYm9keUl0ZW0gPSBib2R5W2ldO1xyXG4gICAgICB0ZXh0Q29sb3IgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcclxuICAgICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIGZpbGxMaW5lT2ZUZXh0KTtcclxuICAgICAgbGluZXMgPSBib2R5SXRlbS5saW5lcztcclxuICAgICAgaWYgKGRpc3BsYXlDb2xvcnMgJiYgbGluZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5fZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBNYXRoLm1heChib2R5Rm9udC5saW5lSGVpZ2h0LCBib3hIZWlnaHQpO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsaW5lcy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcclxuICAgICAgICBmaWxsTGluZU9mVGV4dChsaW5lc1tqXSk7XHJcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xyXG4gICAgICB9XHJcbiAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcclxuICAgIH1cclxuICAgIHhMaW5lUGFkZGluZyA9IDA7XHJcbiAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XHJcbiAgICBlYWNoKHRoaXMuYWZ0ZXJCb2R5LCBmaWxsTGluZU9mVGV4dCk7XHJcbiAgICBwdC55IC09IGJvZHlTcGFjaW5nO1xyXG4gIH1cclxuICBkcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGZvb3RlciA9IHRoaXMuZm9vdGVyO1xyXG4gICAgY29uc3QgbGVuZ3RoID0gZm9vdGVyLmxlbmd0aDtcclxuICAgIGxldCBmb290ZXJGb250LCBpO1xyXG4gICAgaWYgKGxlbmd0aCkge1xyXG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xyXG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy5mb290ZXJBbGlnbiwgb3B0aW9ucyk7XHJcbiAgICAgIHB0LnkgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3A7XHJcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMuZm9vdGVyQWxpZ24pO1xyXG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcbiAgICAgIGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZm9vdGVyQ29sb3I7XHJcbiAgICAgIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGN0eC5maWxsVGV4dChmb290ZXJbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgZm9vdGVyRm9udC5saW5lSGVpZ2h0IC8gMik7XHJcbiAgICAgICAgcHQueSArPSBmb290ZXJGb250LmxpbmVIZWlnaHQgKyBvcHRpb25zLmZvb3RlclNwYWNpbmc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xyXG4gICAgY29uc3Qge3gsIHl9ID0gcHQ7XHJcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0b29sdGlwU2l6ZTtcclxuICAgIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhvcHRpb25zLmNvcm5lclJhZGl1cyk7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xyXG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHgubW92ZVRvKHggKyB0b3BMZWZ0LCB5KTtcclxuICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XHJcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gdG9wUmlnaHQsIHkpO1xyXG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyB0b3BSaWdodCk7XHJcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcclxuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSBib3R0b21SaWdodCk7XHJcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIGJvdHRvbVJpZ2h0LCB5ICsgaGVpZ2h0KTtcclxuICAgIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XHJcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGN0eC5saW5lVG8oeCArIGJvdHRvbUxlZnQsIHkgKyBoZWlnaHQpO1xyXG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIGJvdHRvbUxlZnQpO1xyXG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcclxuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgdG9wTGVmdCk7XHJcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgdG9wTGVmdCwgeSk7XHJcbiAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICBjdHguZmlsbCgpO1xyXG4gICAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XHJcbiAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH1cclxuICB9XHJcbiAgX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKSB7XHJcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XHJcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XHJcbiAgICBjb25zdCBhbmltWCA9IGFuaW1zICYmIGFuaW1zLng7XHJcbiAgICBjb25zdCBhbmltWSA9IGFuaW1zICYmIGFuaW1zLnk7XHJcbiAgICBpZiAoYW5pbVggfHwgYW5pbVkpIHtcclxuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XHJcbiAgICAgIGlmICghcG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHRoaXMuX3NpemUpO1xyXG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XHJcbiAgICAgIGNvbnN0IHBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCBjaGFydCk7XHJcbiAgICAgIGlmIChhbmltWC5fdG8gIT09IHBvaW50LnggfHwgYW5pbVkuX3RvICE9PSBwb2ludC55KSB7XHJcbiAgICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xyXG4gICAgICAgIHRoaXMueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcclxuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuY2FyZXRYID0gcG9zaXRpb24ueDtcclxuICAgICAgICB0aGlzLmNhcmV0WSA9IHBvc2l0aW9uLnk7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcG9pbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIF93aWxsUmVuZGVyKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5vcGFjaXR5O1xyXG4gIH1cclxuICBkcmF3KGN0eCkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcclxuICAgIGxldCBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xyXG4gICAgaWYgKCFvcGFjaXR5KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKTtcclxuICAgIGNvbnN0IHRvb2x0aXBTaXplID0ge1xyXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxyXG4gICAgfTtcclxuICAgIGNvbnN0IHB0ID0ge1xyXG4gICAgICB4OiB0aGlzLngsXHJcbiAgICAgIHk6IHRoaXMueVxyXG4gICAgfTtcclxuICAgIG9wYWNpdHkgPSBNYXRoLmFicyhvcGFjaXR5KSA8IDFlLTMgPyAwIDogb3BhY2l0eTtcclxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcclxuICAgIGNvbnN0IGhhc1Rvb2x0aXBDb250ZW50ID0gdGhpcy50aXRsZS5sZW5ndGggfHwgdGhpcy5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB0aGlzLmJvZHkubGVuZ3RoIHx8IHRoaXMuYWZ0ZXJCb2R5Lmxlbmd0aCB8fCB0aGlzLmZvb3Rlci5sZW5ndGg7XHJcbiAgICBpZiAob3B0aW9ucy5lbmFibGVkICYmIGhhc1Rvb2x0aXBDb250ZW50KSB7XHJcbiAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XHJcbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xyXG4gICAgICBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xyXG4gICAgICBwdC55ICs9IHBhZGRpbmcudG9wO1xyXG4gICAgICB0aGlzLmRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKTtcclxuICAgICAgdGhpcy5kcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKTtcclxuICAgICAgdGhpcy5kcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpO1xyXG4gICAgICByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XHJcbiAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcclxuICB9XHJcbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcclxuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmU7XHJcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xyXG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xyXG4gICAgICBpZiAoIW1ldGEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGEgZGF0YXNldCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGRhdGFzZXRJbmRleCxcclxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxyXG4gICAgICAgIGluZGV4LFxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XHJcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBldmVudFBvc2l0aW9uKTtcclxuICAgIGlmIChjaGFuZ2VkIHx8IHBvc2l0aW9uQ2hhbmdlZCkge1xyXG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XHJcbiAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSBldmVudFBvc2l0aW9uO1xyXG4gICAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSB0cnVlO1xyXG4gICAgICB0aGlzLnVwZGF0ZSh0cnVlKTtcclxuICAgIH1cclxuICB9XHJcbiAgaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSA9IHRydWUpIHtcclxuICAgIGlmIChyZXBsYXkgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IGZhbHNlO1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XHJcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKTtcclxuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpO1xyXG4gICAgY29uc3QgY2hhbmdlZCA9IHJlcGxheSB8fCAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKSB8fCBwb3NpdGlvbkNoYW5nZWQ7XHJcbiAgICBpZiAoY2hhbmdlZCkge1xyXG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XHJcbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5leHRlcm5hbCkge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB7XHJcbiAgICAgICAgICB4OiBlLngsXHJcbiAgICAgICAgICB5OiBlLnlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudXBkYXRlKHRydWUsIHJlcGxheSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjaGFuZ2VkO1xyXG4gIH1cclxuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xyXG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMsIHJlcGxheSk7XHJcbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XHJcbiAgICAgIGFjdGl2ZS5yZXZlcnNlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWN0aXZlO1xyXG4gIH1cclxuICBfcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSkge1xyXG4gICAgY29uc3Qge2NhcmV0WCwgY2FyZXRZLCBvcHRpb25zfSA9IHRoaXM7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCBlKTtcclxuICAgIHJldHVybiBwb3NpdGlvbiAhPT0gZmFsc2UgJiYgKGNhcmV0WCAhPT0gcG9zaXRpb24ueCB8fCBjYXJldFkgIT09IHBvc2l0aW9uLnkpO1xyXG4gIH1cclxufVxyXG5Ub29sdGlwLnBvc2l0aW9uZXJzID0gcG9zaXRpb25lcnM7XHJcbnZhciBwbHVnaW5fdG9vbHRpcCA9IHtcclxuICBpZDogJ3Rvb2x0aXAnLFxyXG4gIF9lbGVtZW50OiBUb29sdGlwLFxyXG4gIHBvc2l0aW9uZXJzLFxyXG4gIGFmdGVySW5pdChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgIGNoYXJ0LnRvb2x0aXAgPSBuZXcgVG9vbHRpcCh7Y2hhcnQsIG9wdGlvbnN9KTtcclxuICAgIH1cclxuICB9LFxyXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcclxuICAgIGlmIChjaGFydC50b29sdGlwKSB7XHJcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcclxuICAgIH1cclxuICB9LFxyXG4gIHJlc2V0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xyXG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcclxuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgYWZ0ZXJEcmF3KGNoYXJ0KSB7XHJcbiAgICBjb25zdCB0b29sdGlwID0gY2hhcnQudG9vbHRpcDtcclxuICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuX3dpbGxSZW5kZXIoKSkge1xyXG4gICAgICBjb25zdCBhcmdzID0ge1xyXG4gICAgICAgIHRvb2x0aXBcclxuICAgICAgfTtcclxuICAgICAgaWYgKGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVRvb2x0aXBEcmF3JywgYXJncykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRvb2x0aXAuZHJhdyhjaGFydC5jdHgpO1xyXG4gICAgICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclRvb2x0aXBEcmF3JywgYXJncyk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XHJcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xyXG4gICAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gYXJncy5yZXBsYXk7XHJcbiAgICAgIGlmIChjaGFydC50b29sdGlwLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQsIHVzZUZpbmFsUG9zaXRpb24sIGFyZ3MuaW5DaGFydEFyZWEpKSB7XHJcbiAgICAgICAgYXJncy5jaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgZGVmYXVsdHM6IHtcclxuICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICBleHRlcm5hbDogbnVsbCxcclxuICAgIHBvc2l0aW9uOiAnYXZlcmFnZScsXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxyXG4gICAgdGl0bGVDb2xvcjogJyNmZmYnLFxyXG4gICAgdGl0bGVGb250OiB7XHJcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxyXG4gICAgfSxcclxuICAgIHRpdGxlU3BhY2luZzogMixcclxuICAgIHRpdGxlTWFyZ2luQm90dG9tOiA2LFxyXG4gICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxyXG4gICAgYm9keUNvbG9yOiAnI2ZmZicsXHJcbiAgICBib2R5U3BhY2luZzogMixcclxuICAgIGJvZHlGb250OiB7XHJcbiAgICB9LFxyXG4gICAgYm9keUFsaWduOiAnbGVmdCcsXHJcbiAgICBmb290ZXJDb2xvcjogJyNmZmYnLFxyXG4gICAgZm9vdGVyU3BhY2luZzogMixcclxuICAgIGZvb3Rlck1hcmdpblRvcDogNixcclxuICAgIGZvb3RlckZvbnQ6IHtcclxuICAgICAgd2VpZ2h0OiAnYm9sZCcsXHJcbiAgICB9LFxyXG4gICAgZm9vdGVyQWxpZ246ICdsZWZ0JyxcclxuICAgIHBhZGRpbmc6IDYsXHJcbiAgICBjYXJldFBhZGRpbmc6IDIsXHJcbiAgICBjYXJldFNpemU6IDUsXHJcbiAgICBjb3JuZXJSYWRpdXM6IDYsXHJcbiAgICBib3hIZWlnaHQ6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcclxuICAgIGJveFdpZHRoOiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXHJcbiAgICBtdWx0aUtleUJhY2tncm91bmQ6ICcjZmZmJyxcclxuICAgIGRpc3BsYXlDb2xvcnM6IHRydWUsXHJcbiAgICBib3hQYWRkaW5nOiAwLFxyXG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcclxuICAgIGJvcmRlcldpZHRoOiAwLFxyXG4gICAgYW5pbWF0aW9uOiB7XHJcbiAgICAgIGR1cmF0aW9uOiA0MDAsXHJcbiAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXHJcbiAgICB9LFxyXG4gICAgYW5pbWF0aW9uczoge1xyXG4gICAgICBudW1iZXJzOiB7XHJcbiAgICAgICAgdHlwZTogJ251bWJlcicsXHJcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2NhcmV0WCcsICdjYXJldFknXSxcclxuICAgICAgfSxcclxuICAgICAgb3BhY2l0eToge1xyXG4gICAgICAgIGVhc2luZzogJ2xpbmVhcicsXHJcbiAgICAgICAgZHVyYXRpb246IDIwMFxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsbGJhY2tzOiB7XHJcbiAgICAgIGJlZm9yZVRpdGxlOiBub29wLFxyXG4gICAgICB0aXRsZSh0b29sdGlwSXRlbXMpIHtcclxuICAgICAgICBpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XHJcbiAgICAgICAgICBjb25zdCBsYWJlbHMgPSBpdGVtLmNoYXJ0LmRhdGEubGFiZWxzO1xyXG4gICAgICAgICAgY29uc3QgbGFiZWxDb3VudCA9IGxhYmVscyA/IGxhYmVscy5sZW5ndGggOiAwO1xyXG4gICAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5sYWJlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbS5sYWJlbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5kYXRhSW5kZXggPCBsYWJlbENvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbHNbaXRlbS5kYXRhSW5kZXhdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgIH0sXHJcbiAgICAgIGFmdGVyVGl0bGU6IG5vb3AsXHJcbiAgICAgIGJlZm9yZUJvZHk6IG5vb3AsXHJcbiAgICAgIGJlZm9yZUxhYmVsOiBub29wLFxyXG4gICAgICBsYWJlbCh0b29sdGlwSXRlbSkge1xyXG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XHJcbiAgICAgICAgICByZXR1cm4gdG9vbHRpcEl0ZW0ubGFiZWwgKyAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWUgfHwgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsYWJlbCA9IHRvb2x0aXBJdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XHJcbiAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICBsYWJlbCArPSAnOiAnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xyXG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcclxuICAgICAgICAgIGxhYmVsICs9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGFiZWw7XHJcbiAgICAgIH0sXHJcbiAgICAgIGxhYmVsQ29sb3IodG9vbHRpcEl0ZW0pIHtcclxuICAgICAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxyXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxyXG4gICAgICAgICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxyXG4gICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxyXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIGxhYmVsVGV4dENvbG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xyXG4gICAgICB9LFxyXG4gICAgICBsYWJlbFBvaW50U3R5bGUodG9vbHRpcEl0ZW0pIHtcclxuICAgICAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcclxuICAgICAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIGFmdGVyTGFiZWw6IG5vb3AsXHJcbiAgICAgIGFmdGVyQm9keTogbm9vcCxcclxuICAgICAgYmVmb3JlRm9vdGVyOiBub29wLFxyXG4gICAgICBmb290ZXI6IG5vb3AsXHJcbiAgICAgIGFmdGVyRm9vdGVyOiBub29wXHJcbiAgICB9XHJcbiAgfSxcclxuICBkZWZhdWx0Um91dGVzOiB7XHJcbiAgICBib2R5Rm9udDogJ2ZvbnQnLFxyXG4gICAgZm9vdGVyRm9udDogJ2ZvbnQnLFxyXG4gICAgdGl0bGVGb250OiAnZm9udCdcclxuICB9LFxyXG4gIGRlc2NyaXB0b3JzOiB7XHJcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgIT09ICdpdGVtU29ydCcgJiYgbmFtZSAhPT0gJ2V4dGVybmFsJyxcclxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxyXG4gICAgY2FsbGJhY2tzOiB7XHJcbiAgICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcclxuICAgICAgX2luZGV4YWJsZTogZmFsc2UsXHJcbiAgICB9LFxyXG4gICAgYW5pbWF0aW9uOiB7XHJcbiAgICAgIF9mYWxsYmFjazogZmFsc2VcclxuICAgIH0sXHJcbiAgICBhbmltYXRpb25zOiB7XHJcbiAgICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbidcclxuICAgIH1cclxuICB9LFxyXG4gIGFkZGl0aW9uYWxPcHRpb25TY29wZXM6IFsnaW50ZXJhY3Rpb24nXVxyXG59O1xyXG5cclxudmFyIHBsdWdpbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XHJcbl9fcHJvdG9fXzogbnVsbCxcclxuRGVjaW1hdGlvbjogcGx1Z2luX2RlY2ltYXRpb24sXHJcbkZpbGxlcjogaW5kZXgsXHJcbkxlZ2VuZDogcGx1Z2luX2xlZ2VuZCxcclxuU3ViVGl0bGU6IHBsdWdpbl9zdWJ0aXRsZSxcclxuVGl0bGU6IHBsdWdpbl90aXRsZSxcclxuVG9vbHRpcDogcGx1Z2luX3Rvb2x0aXBcclxufSk7XHJcblxyXG5jb25zdCBhZGRJZlN0cmluZyA9IChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSA9PiB7XHJcbiAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBpbmRleCA9IGxhYmVscy5wdXNoKHJhdykgLSAxO1xyXG4gICAgYWRkZWRMYWJlbHMudW5zaGlmdCh7aW5kZXgsIGxhYmVsOiByYXd9KTtcclxuICB9IGVsc2UgaWYgKGlzTmFOKHJhdykpIHtcclxuICAgIGluZGV4ID0gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIGluZGV4O1xyXG59O1xyXG5mdW5jdGlvbiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSB7XHJcbiAgY29uc3QgZmlyc3QgPSBsYWJlbHMuaW5kZXhPZihyYXcpO1xyXG4gIGlmIChmaXJzdCA9PT0gLTEpIHtcclxuICAgIHJldHVybiBhZGRJZlN0cmluZyhsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKTtcclxuICB9XHJcbiAgY29uc3QgbGFzdCA9IGxhYmVscy5sYXN0SW5kZXhPZihyYXcpO1xyXG4gIHJldHVybiBmaXJzdCAhPT0gbGFzdCA/IGluZGV4IDogZmlyc3Q7XHJcbn1cclxuY29uc3QgdmFsaWRJbmRleCA9IChpbmRleCwgbWF4KSA9PiBpbmRleCA9PT0gbnVsbCA/IG51bGwgOiBfbGltaXRWYWx1ZShNYXRoLnJvdW5kKGluZGV4KSwgMCwgbWF4KTtcclxuY2xhc3MgQ2F0ZWdvcnlTY2FsZSBleHRlbmRzIFNjYWxlIHtcclxuICBjb25zdHJ1Y3RvcihjZmcpIHtcclxuICAgIHN1cGVyKGNmZyk7XHJcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XHJcbiAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xyXG4gIH1cclxuICBpbml0KHNjYWxlT3B0aW9ucykge1xyXG4gICAgY29uc3QgYWRkZWQgPSB0aGlzLl9hZGRlZExhYmVscztcclxuICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcclxuICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcclxuICAgICAgZm9yIChjb25zdCB7aW5kZXgsIGxhYmVsfSBvZiBhZGRlZCkge1xyXG4gICAgICAgIGlmIChsYWJlbHNbaW5kZXhdID09PSBsYWJlbCkge1xyXG4gICAgICAgICAgbGFiZWxzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XHJcbiAgICB9XHJcbiAgICBzdXBlci5pbml0KHNjYWxlT3B0aW9ucyk7XHJcbiAgfVxyXG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcclxuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xyXG4gICAgaW5kZXggPSBpc0Zpbml0ZShpbmRleCkgJiYgbGFiZWxzW2luZGV4XSA9PT0gcmF3ID8gaW5kZXhcclxuICAgICAgOiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgdmFsdWVPckRlZmF1bHQoaW5kZXgsIHJhdyksIHRoaXMuX2FkZGVkTGFiZWxzKTtcclxuICAgIHJldHVybiB2YWxpZEluZGV4KGluZGV4LCBsYWJlbHMubGVuZ3RoIC0gMSk7XHJcbiAgfVxyXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XHJcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcclxuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xyXG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcclxuICAgICAgICBtaW4gPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xyXG4gICAgICAgIG1heCA9IHRoaXMuZ2V0TGFiZWxzKCkubGVuZ3RoIC0gMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5taW4gPSBtaW47XHJcbiAgICB0aGlzLm1heCA9IG1heDtcclxuICB9XHJcbiAgYnVpbGRUaWNrcygpIHtcclxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xyXG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XHJcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9wdGlvbnMub2Zmc2V0O1xyXG4gICAgY29uc3QgdGlja3MgPSBbXTtcclxuICAgIGxldCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xyXG4gICAgbGFiZWxzID0gKG1pbiA9PT0gMCAmJiBtYXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtaW4sIG1heCArIDEpO1xyXG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IE1hdGgubWF4KGxhYmVscy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpLCAxKTtcclxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLm1pbiAtIChvZmZzZXQgPyAwLjUgOiAwKTtcclxuICAgIGZvciAobGV0IHZhbHVlID0gbWluOyB2YWx1ZSA8PSBtYXg7IHZhbHVlKyspIHtcclxuICAgICAgdGlja3MucHVzaCh7dmFsdWV9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aWNrcztcclxuICB9XHJcbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xyXG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcclxuICAgIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgbGFiZWxzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gbGFiZWxzW3ZhbHVlXTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgY29uZmlndXJlKCkge1xyXG4gICAgc3VwZXIuY29uZmlndXJlKCk7XHJcbiAgICBpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcclxuICAgICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9ICF0aGlzLl9yZXZlcnNlUGl4ZWxzO1xyXG4gICAgfVxyXG4gIH1cclxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xyXG4gICAgICB2YWx1ZSA9IHRoaXMucGFyc2UodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcclxuICB9XHJcbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XHJcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XHJcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcclxuICB9XHJcbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xyXG4gIH1cclxuICBnZXRCYXNlUGl4ZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ib3R0b207XHJcbiAgfVxyXG59XHJcbkNhdGVnb3J5U2NhbGUuaWQgPSAnY2F0ZWdvcnknO1xyXG5DYXRlZ29yeVNjYWxlLmRlZmF1bHRzID0ge1xyXG4gIHRpY2tzOiB7XHJcbiAgICBjYWxsYmFjazogQ2F0ZWdvcnlTY2FsZS5wcm90b3R5cGUuZ2V0TGFiZWxGb3JWYWx1ZVxyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XHJcbiAgY29uc3QgdGlja3MgPSBbXTtcclxuICBjb25zdCBNSU5fU1BBQ0lORyA9IDFlLTE0O1xyXG4gIGNvbnN0IHtib3VuZHMsIHN0ZXAsIG1pbiwgbWF4LCBwcmVjaXNpb24sIGNvdW50LCBtYXhUaWNrcywgbWF4RGlnaXRzLCBpbmNsdWRlQm91bmRzfSA9IGdlbmVyYXRpb25PcHRpb25zO1xyXG4gIGNvbnN0IHVuaXQgPSBzdGVwIHx8IDE7XHJcbiAgY29uc3QgbWF4U3BhY2VzID0gbWF4VGlja3MgLSAxO1xyXG4gIGNvbnN0IHttaW46IHJtaW4sIG1heDogcm1heH0gPSBkYXRhUmFuZ2U7XHJcbiAgY29uc3QgbWluRGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1pbik7XHJcbiAgY29uc3QgbWF4RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1heCk7XHJcbiAgY29uc3QgY291bnREZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYoY291bnQpO1xyXG4gIGNvbnN0IG1pblNwYWNpbmcgPSAocm1heCAtIHJtaW4pIC8gKG1heERpZ2l0cyArIDEpO1xyXG4gIGxldCBzcGFjaW5nID0gbmljZU51bSgocm1heCAtIHJtaW4pIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xyXG4gIGxldCBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcclxuICBpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmICFtaW5EZWZpbmVkICYmICFtYXhEZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gW3t2YWx1ZTogcm1pbn0sIHt2YWx1ZTogcm1heH1dO1xyXG4gIH1cclxuICBudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XHJcbiAgaWYgKG51bVNwYWNlcyA+IG1heFNwYWNlcykge1xyXG4gICAgc3BhY2luZyA9IG5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcclxuICB9XHJcbiAgaWYgKCFpc051bGxPclVuZGVmKHByZWNpc2lvbikpIHtcclxuICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xyXG4gICAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nICogZmFjdG9yKSAvIGZhY3RvcjtcclxuICB9XHJcbiAgaWYgKGJvdW5kcyA9PT0gJ3RpY2tzJykge1xyXG4gICAgbmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcclxuICAgIG5pY2VNYXggPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpICogc3BhY2luZztcclxuICB9IGVsc2Uge1xyXG4gICAgbmljZU1pbiA9IHJtaW47XHJcbiAgICBuaWNlTWF4ID0gcm1heDtcclxuICB9XHJcbiAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCAmJiBzdGVwICYmIGFsbW9zdFdob2xlKChtYXggLSBtaW4pIC8gc3RlcCwgc3BhY2luZyAvIDEwMDApKSB7XHJcbiAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKE1hdGgubWluKChtYXggLSBtaW4pIC8gc3BhY2luZywgbWF4VGlja3MpKTtcclxuICAgIHNwYWNpbmcgPSAobWF4IC0gbWluKSAvIG51bVNwYWNlcztcclxuICAgIG5pY2VNaW4gPSBtaW47XHJcbiAgICBuaWNlTWF4ID0gbWF4O1xyXG4gIH0gZWxzZSBpZiAoY291bnREZWZpbmVkKSB7XHJcbiAgICBuaWNlTWluID0gbWluRGVmaW5lZCA/IG1pbiA6IG5pY2VNaW47XHJcbiAgICBuaWNlTWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IG5pY2VNYXg7XHJcbiAgICBudW1TcGFjZXMgPSBjb3VudCAtIDE7XHJcbiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIG51bVNwYWNlcztcclxuICB9IGVsc2Uge1xyXG4gICAgbnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XHJcbiAgICBpZiAoYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcclxuICAgICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChudW1TcGFjZXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IGRlY2ltYWxQbGFjZXMgPSBNYXRoLm1heChcclxuICAgIF9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpLFxyXG4gICAgX2RlY2ltYWxQbGFjZXMobmljZU1pbilcclxuICApO1xyXG4gIGZhY3RvciA9IE1hdGgucG93KDEwLCBpc051bGxPclVuZGVmKHByZWNpc2lvbikgPyBkZWNpbWFsUGxhY2VzIDogcHJlY2lzaW9uKTtcclxuICBuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3RvcjtcclxuICBuaWNlTWF4ID0gTWF0aC5yb3VuZChuaWNlTWF4ICogZmFjdG9yKSAvIGZhY3RvcjtcclxuICBsZXQgaiA9IDA7XHJcbiAgaWYgKG1pbkRlZmluZWQpIHtcclxuICAgIGlmIChpbmNsdWRlQm91bmRzICYmIG5pY2VNaW4gIT09IG1pbikge1xyXG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWlufSk7XHJcbiAgICAgIGlmIChuaWNlTWluIDwgbWluKSB7XHJcbiAgICAgICAgaisrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhbG1vc3RFcXVhbHMoTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IsIG1pbiwgcmVsYXRpdmVMYWJlbFNpemUobWluLCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XHJcbiAgICAgICAgaisrO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG5pY2VNaW4gPCBtaW4pIHtcclxuICAgICAgaisrO1xyXG4gICAgfVxyXG4gIH1cclxuICBmb3IgKDsgaiA8IG51bVNwYWNlczsgKytqKSB7XHJcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3J9KTtcclxuICB9XHJcbiAgaWYgKG1heERlZmluZWQgJiYgaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWF4ICE9PSBtYXgpIHtcclxuICAgIGlmICh0aWNrcy5sZW5ndGggJiYgYWxtb3N0RXF1YWxzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlLCBtYXgsIHJlbGF0aXZlTGFiZWxTaXplKG1heCwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xyXG4gICAgICB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSA9IG1heDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtYXh9KTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKCFtYXhEZWZpbmVkIHx8IG5pY2VNYXggPT09IG1heCkge1xyXG4gICAgdGlja3MucHVzaCh7dmFsdWU6IG5pY2VNYXh9KTtcclxuICB9XHJcbiAgcmV0dXJuIHRpY2tzO1xyXG59XHJcbmZ1bmN0aW9uIHJlbGF0aXZlTGFiZWxTaXplKHZhbHVlLCBtaW5TcGFjaW5nLCB7aG9yaXpvbnRhbCwgbWluUm90YXRpb259KSB7XHJcbiAgY29uc3QgcmFkID0gdG9SYWRpYW5zKG1pblJvdGF0aW9uKTtcclxuICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4ocmFkKSA6IE1hdGguY29zKHJhZCkpIHx8IDAuMDAxO1xyXG4gIGNvbnN0IGxlbmd0aCA9IDAuNzUgKiBtaW5TcGFjaW5nICogKCcnICsgdmFsdWUpLmxlbmd0aDtcclxuICByZXR1cm4gTWF0aC5taW4obWluU3BhY2luZyAvIHJhdGlvLCBsZW5ndGgpO1xyXG59XHJcbmNsYXNzIExpbmVhclNjYWxlQmFzZSBleHRlbmRzIFNjYWxlIHtcclxuICBjb25zdHJ1Y3RvcihjZmcpIHtcclxuICAgIHN1cGVyKGNmZyk7XHJcbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fZW5kVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcclxuICB9XHJcbiAgcGFyc2UocmF3LCBpbmRleCkge1xyXG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmICgodHlwZW9mIHJhdyA9PT0gJ251bWJlcicgfHwgcmF3IGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUoK3JhdykpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gK3JhdztcclxuICB9XHJcbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcclxuICAgIGNvbnN0IHtiZWdpbkF0WmVyb30gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcclxuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcztcclxuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcclxuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcclxuICAgIGlmIChiZWdpbkF0WmVybykge1xyXG4gICAgICBjb25zdCBtaW5TaWduID0gc2lnbihtaW4pO1xyXG4gICAgICBjb25zdCBtYXhTaWduID0gc2lnbihtYXgpO1xyXG4gICAgICBpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcclxuICAgICAgICBzZXRNYXgoMCk7XHJcbiAgICAgIH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcclxuICAgICAgICBzZXRNaW4oMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChtaW4gPT09IG1heCkge1xyXG4gICAgICBsZXQgb2Zmc2V0ID0gMTtcclxuICAgICAgaWYgKG1heCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBtaW4gPD0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcclxuICAgICAgICBvZmZzZXQgPSBNYXRoLmFicyhtYXggKiAwLjA1KTtcclxuICAgICAgfVxyXG4gICAgICBzZXRNYXgobWF4ICsgb2Zmc2V0KTtcclxuICAgICAgaWYgKCFiZWdpbkF0WmVybykge1xyXG4gICAgICAgIHNldE1pbihtaW4gLSBvZmZzZXQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLm1pbiA9IG1pbjtcclxuICAgIHRoaXMubWF4ID0gbWF4O1xyXG4gIH1cclxuICBnZXRUaWNrTGltaXQoKSB7XHJcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcclxuICAgIGxldCB7bWF4VGlja3NMaW1pdCwgc3RlcFNpemV9ID0gdGlja09wdHM7XHJcbiAgICBsZXQgbWF4VGlja3M7XHJcbiAgICBpZiAoc3RlcFNpemUpIHtcclxuICAgICAgbWF4VGlja3MgPSBNYXRoLmNlaWwodGhpcy5tYXggLyBzdGVwU2l6ZSkgLSBNYXRoLmZsb29yKHRoaXMubWluIC8gc3RlcFNpemUpICsgMTtcclxuICAgICAgaWYgKG1heFRpY2tzID4gMTAwMCkge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybihgc2NhbGVzLiR7dGhpcy5pZH0udGlja3Muc3RlcFNpemU6ICR7c3RlcFNpemV9IHdvdWxkIHJlc3VsdCBnZW5lcmF0aW5nIHVwIHRvICR7bWF4VGlja3N9IHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLmApO1xyXG4gICAgICAgIG1heFRpY2tzID0gMTAwMDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWF4VGlja3MgPSB0aGlzLmNvbXB1dGVUaWNrTGltaXQoKTtcclxuICAgICAgbWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XHJcbiAgICB9XHJcbiAgICBpZiAobWF4VGlja3NMaW1pdCkge1xyXG4gICAgICBtYXhUaWNrcyA9IE1hdGgubWluKG1heFRpY2tzTGltaXQsIG1heFRpY2tzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXhUaWNrcztcclxuICB9XHJcbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcclxuICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgfVxyXG4gIGJ1aWxkVGlja3MoKSB7XHJcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xyXG4gICAgbGV0IG1heFRpY2tzID0gdGhpcy5nZXRUaWNrTGltaXQoKTtcclxuICAgIG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xyXG4gICAgY29uc3QgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XHJcbiAgICAgIG1heFRpY2tzLFxyXG4gICAgICBib3VuZHM6IG9wdHMuYm91bmRzLFxyXG4gICAgICBtaW46IG9wdHMubWluLFxyXG4gICAgICBtYXg6IG9wdHMubWF4LFxyXG4gICAgICBwcmVjaXNpb246IHRpY2tPcHRzLnByZWNpc2lvbixcclxuICAgICAgc3RlcDogdGlja09wdHMuc3RlcFNpemUsXHJcbiAgICAgIGNvdW50OiB0aWNrT3B0cy5jb3VudCxcclxuICAgICAgbWF4RGlnaXRzOiB0aGlzLl9tYXhEaWdpdHMoKSxcclxuICAgICAgaG9yaXpvbnRhbDogdGhpcy5pc0hvcml6b250YWwoKSxcclxuICAgICAgbWluUm90YXRpb246IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDAsXHJcbiAgICAgIGluY2x1ZGVCb3VuZHM6IHRpY2tPcHRzLmluY2x1ZGVCb3VuZHMgIT09IGZhbHNlXHJcbiAgICB9O1xyXG4gICAgY29uc3QgZGF0YVJhbmdlID0gdGhpcy5fcmFuZ2UgfHwgdGhpcztcclxuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyQxKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBkYXRhUmFuZ2UpO1xyXG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XHJcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XHJcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcclxuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xyXG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xyXG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRpY2tzO1xyXG4gIH1cclxuICBjb25maWd1cmUoKSB7XHJcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XHJcbiAgICBsZXQgc3RhcnQgPSB0aGlzLm1pbjtcclxuICAgIGxldCBlbmQgPSB0aGlzLm1heDtcclxuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XHJcbiAgICAgIGNvbnN0IG9mZnNldCA9IChlbmQgLSBzdGFydCkgLyBNYXRoLm1heCh0aWNrcy5sZW5ndGggLSAxLCAxKSAvIDI7XHJcbiAgICAgIHN0YXJ0IC09IG9mZnNldDtcclxuICAgICAgZW5kICs9IG9mZnNldDtcclxuICAgIH1cclxuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBzdGFydDtcclxuICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kO1xyXG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGVuZCAtIHN0YXJ0O1xyXG4gIH1cclxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcclxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xyXG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xyXG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pID8gbWluIDogMDtcclxuICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSA/IG1heCA6IDE7XHJcbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcclxuICB9XHJcbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcclxuICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xyXG4gICAgY29uc3QgbGVuZ3RoID0gaG9yaXpvbnRhbCA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodDtcclxuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy50aWNrcy5taW5Sb3RhdGlvbik7XHJcbiAgICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4obWluUm90YXRpb24pIDogTWF0aC5jb3MobWluUm90YXRpb24pKSB8fCAwLjAwMTtcclxuICAgIGNvbnN0IHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcclxuICAgIHJldHVybiBNYXRoLmNlaWwobGVuZ3RoIC8gTWF0aC5taW4oNDAsIHRpY2tGb250LmxpbmVIZWlnaHQgLyByYXRpbykpO1xyXG4gIH1cclxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xyXG4gIH1cclxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XHJcbiAgfVxyXG59XHJcbkxpbmVhclNjYWxlLmlkID0gJ2xpbmVhcic7XHJcbkxpbmVhclNjYWxlLmRlZmF1bHRzID0ge1xyXG4gIHRpY2tzOiB7XHJcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gaXNNYWpvcih0aWNrVmFsKSB7XHJcbiAgY29uc3QgcmVtYWluID0gdGlja1ZhbCAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsKSkpKTtcclxuICByZXR1cm4gcmVtYWluID09PSAxO1xyXG59XHJcbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xyXG4gIGNvbnN0IGVuZEV4cCA9IE1hdGguZmxvb3IobG9nMTAoZGF0YVJhbmdlLm1heCkpO1xyXG4gIGNvbnN0IGVuZFNpZ25pZmljYW5kID0gTWF0aC5jZWlsKGRhdGFSYW5nZS5tYXggLyBNYXRoLnBvdygxMCwgZW5kRXhwKSk7XHJcbiAgY29uc3QgdGlja3MgPSBbXTtcclxuICBsZXQgdGlja1ZhbCA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5taW4pKSkpO1xyXG4gIGxldCBleHAgPSBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWwpKTtcclxuICBsZXQgc2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgZXhwKSk7XHJcbiAgbGV0IHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xyXG4gIGRvIHtcclxuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiB0aWNrVmFsLCBtYWpvcjogaXNNYWpvcih0aWNrVmFsKX0pO1xyXG4gICAgKytzaWduaWZpY2FuZDtcclxuICAgIGlmIChzaWduaWZpY2FuZCA9PT0gMTApIHtcclxuICAgICAgc2lnbmlmaWNhbmQgPSAxO1xyXG4gICAgICArK2V4cDtcclxuICAgICAgcHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xyXG4gICAgfVxyXG4gICAgdGlja1ZhbCA9IE1hdGgucm91bmQoc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XHJcbiAgfSB3aGlsZSAoZXhwIDwgZW5kRXhwIHx8IChleHAgPT09IGVuZEV4cCAmJiBzaWduaWZpY2FuZCA8IGVuZFNpZ25pZmljYW5kKSk7XHJcbiAgY29uc3QgbGFzdFRpY2sgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB0aWNrVmFsKTtcclxuICB0aWNrcy5wdXNoKHt2YWx1ZTogbGFzdFRpY2ssIG1ham9yOiBpc01ham9yKHRpY2tWYWwpfSk7XHJcbiAgcmV0dXJuIHRpY2tzO1xyXG59XHJcbmNsYXNzIExvZ2FyaXRobWljU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XHJcbiAgY29uc3RydWN0b3IoY2ZnKSB7XHJcbiAgICBzdXBlcihjZmcpO1xyXG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xyXG4gIH1cclxuICBwYXJzZShyYXcsIGluZGV4KSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgW3JhdywgaW5kZXhdKTtcclxuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xyXG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHJldHVybiBpc051bWJlckZpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwID8gdmFsdWUgOiBudWxsO1xyXG4gIH1cclxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xyXG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xyXG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pID8gTWF0aC5tYXgoMCwgbWluKSA6IG51bGw7XHJcbiAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgPyBNYXRoLm1heCgwLCBtYXgpIDogbnVsbDtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmVnaW5BdFplcm8pIHtcclxuICAgICAgdGhpcy5femVybyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcclxuICB9XHJcbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcclxuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xyXG4gICAgbGV0IG1pbiA9IHRoaXMubWluO1xyXG4gICAgbGV0IG1heCA9IHRoaXMubWF4O1xyXG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xyXG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xyXG4gICAgY29uc3QgZXhwID0gKHYsIG0pID0+IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHYpKSArIG0pO1xyXG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XHJcbiAgICAgIGlmIChtaW4gPD0gMCkge1xyXG4gICAgICAgIHNldE1pbigxKTtcclxuICAgICAgICBzZXRNYXgoMTApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNldE1pbihleHAobWluLCAtMSkpO1xyXG4gICAgICAgIHNldE1heChleHAobWF4LCArMSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobWluIDw9IDApIHtcclxuICAgICAgc2V0TWluKGV4cChtYXgsIC0xKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobWF4IDw9IDApIHtcclxuICAgICAgc2V0TWF4KGV4cChtaW4sICsxKSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5femVybyAmJiB0aGlzLm1pbiAhPT0gdGhpcy5fc3VnZ2VzdGVkTWluICYmIG1pbiA9PT0gZXhwKHRoaXMubWluLCAwKSkge1xyXG4gICAgICBzZXRNaW4oZXhwKG1pbiwgLTEpKTtcclxuICAgIH1cclxuICAgIHRoaXMubWluID0gbWluO1xyXG4gICAgdGhpcy5tYXggPSBtYXg7XHJcbiAgfVxyXG4gIGJ1aWxkVGlja3MoKSB7XHJcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3QgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XHJcbiAgICAgIG1pbjogdGhpcy5fdXNlck1pbixcclxuICAgICAgbWF4OiB0aGlzLl91c2VyTWF4XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB0aGlzKTtcclxuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xyXG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xyXG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XHJcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcclxuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcclxuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aWNrcztcclxuICB9XHJcbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRcclxuICAgICAgPyAnMCdcclxuICAgICAgOiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xyXG4gIH1cclxuICBjb25maWd1cmUoKSB7XHJcbiAgICBjb25zdCBzdGFydCA9IHRoaXMubWluO1xyXG4gICAgc3VwZXIuY29uZmlndXJlKCk7XHJcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gbG9nMTAoc3RhcnQpO1xyXG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGxvZzEwKHRoaXMubWF4KSAtIGxvZzEwKHN0YXJ0KTtcclxuICB9XHJcbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IDApIHtcclxuICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBpc05hTih2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIE5hTjtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCh2YWx1ZSA9PT0gdGhpcy5taW5cclxuICAgICAgPyAwXHJcbiAgICAgIDogKGxvZzEwKHZhbHVlKSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XHJcbiAgfVxyXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcclxuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCk7XHJcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXJ0VmFsdWUgKyBkZWNpbWFsICogdGhpcy5fdmFsdWVSYW5nZSk7XHJcbiAgfVxyXG59XHJcbkxvZ2FyaXRobWljU2NhbGUuaWQgPSAnbG9nYXJpdGhtaWMnO1xyXG5Mb2dhcml0aG1pY1NjYWxlLmRlZmF1bHRzID0ge1xyXG4gIHRpY2tzOiB7XHJcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pYyxcclxuICAgIG1ham9yOiB7XHJcbiAgICAgIGVuYWJsZWQ6IHRydWVcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykge1xyXG4gIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcclxuICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcclxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGlja09wdHMuYmFja2Ryb3BQYWRkaW5nKTtcclxuICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250ICYmIHRpY2tPcHRzLmZvbnQuc2l6ZSwgZGVmYXVsdHMuZm9udC5zaXplKSArIHBhZGRpbmcuaGVpZ2h0O1xyXG4gIH1cclxuICByZXR1cm4gMDtcclxufVxyXG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgZm9udCwgbGFiZWwpIHtcclxuICBsYWJlbCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwgOiBbbGFiZWxdO1xyXG4gIHJldHVybiB7XHJcbiAgICB3OiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LnN0cmluZywgbGFiZWwpLFxyXG4gICAgaDogbGFiZWwubGVuZ3RoICogZm9udC5saW5lSGVpZ2h0XHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcclxuICBpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGFydDogcG9zIC0gKHNpemUgLyAyKSxcclxuICAgICAgZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXHJcbiAgICB9O1xyXG4gIH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0YXJ0OiBwb3MgLSBzaXplLFxyXG4gICAgICBlbmQ6IHBvc1xyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXJ0OiBwb3MsXHJcbiAgICBlbmQ6IHBvcyArIHNpemVcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xyXG4gIGNvbnN0IG9yaWcgPSB7XHJcbiAgICBsOiBzY2FsZS5sZWZ0ICsgc2NhbGUuX3BhZGRpbmcubGVmdCxcclxuICAgIHI6IHNjYWxlLnJpZ2h0IC0gc2NhbGUuX3BhZGRpbmcucmlnaHQsXHJcbiAgICB0OiBzY2FsZS50b3AgKyBzY2FsZS5fcGFkZGluZy50b3AsXHJcbiAgICBiOiBzY2FsZS5ib3R0b20gLSBzY2FsZS5fcGFkZGluZy5ib3R0b21cclxuICB9O1xyXG4gIGNvbnN0IGxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWcpO1xyXG4gIGNvbnN0IGxhYmVsU2l6ZXMgPSBbXTtcclxuICBjb25zdCBwYWRkaW5nID0gW107XHJcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XHJcbiAgY29uc3QgcG9pbnRMYWJlbE9wdHMgPSBzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzO1xyXG4gIGNvbnN0IGFkZGl0aW9uYWxBbmdsZSA9IHBvaW50TGFiZWxPcHRzLmNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMDtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xyXG4gICAgY29uc3Qgb3B0cyA9IHBvaW50TGFiZWxPcHRzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xyXG4gICAgcGFkZGluZ1tpXSA9IG9wdHMucGFkZGluZztcclxuICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgcGFkZGluZ1tpXSwgYWRkaXRpb25hbEFuZ2xlKTtcclxuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzLmZvbnQpO1xyXG4gICAgY29uc3QgdGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LCBzY2FsZS5fcG9pbnRMYWJlbHNbaV0pO1xyXG4gICAgbGFiZWxTaXplc1tpXSA9IHRleHRTaXplO1xyXG4gICAgY29uc3QgYW5nbGVSYWRpYW5zID0gX25vcm1hbGl6ZUFuZ2xlKHNjYWxlLmdldEluZGV4QW5nbGUoaSkgKyBhZGRpdGlvbmFsQW5nbGUpO1xyXG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhhbmdsZVJhZGlhbnMpKTtcclxuICAgIGNvbnN0IGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcclxuICAgIGNvbnN0IHZMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueSwgdGV4dFNpemUuaCwgOTAsIDI3MCk7XHJcbiAgICB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZVJhZGlhbnMsIGhMaW1pdHMsIHZMaW1pdHMpO1xyXG4gIH1cclxuICBzY2FsZS5zZXRDZW50ZXJQb2ludChcclxuICAgIG9yaWcubCAtIGxpbWl0cy5sLFxyXG4gICAgbGltaXRzLnIgLSBvcmlnLnIsXHJcbiAgICBvcmlnLnQgLSBsaW1pdHMudCxcclxuICAgIGxpbWl0cy5iIC0gb3JpZy5iXHJcbiAgKTtcclxuICBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zID0gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlLCBoTGltaXRzLCB2TGltaXRzKSB7XHJcbiAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpKTtcclxuICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZSkpO1xyXG4gIGxldCB4ID0gMDtcclxuICBsZXQgeSA9IDA7XHJcbiAgaWYgKGhMaW1pdHMuc3RhcnQgPCBvcmlnLmwpIHtcclxuICAgIHggPSAob3JpZy5sIC0gaExpbWl0cy5zdGFydCkgLyBzaW47XHJcbiAgICBsaW1pdHMubCA9IE1hdGgubWluKGxpbWl0cy5sLCBvcmlnLmwgLSB4KTtcclxuICB9IGVsc2UgaWYgKGhMaW1pdHMuZW5kID4gb3JpZy5yKSB7XHJcbiAgICB4ID0gKGhMaW1pdHMuZW5kIC0gb3JpZy5yKSAvIHNpbjtcclxuICAgIGxpbWl0cy5yID0gTWF0aC5tYXgobGltaXRzLnIsIG9yaWcuciArIHgpO1xyXG4gIH1cclxuICBpZiAodkxpbWl0cy5zdGFydCA8IG9yaWcudCkge1xyXG4gICAgeSA9IChvcmlnLnQgLSB2TGltaXRzLnN0YXJ0KSAvIGNvcztcclxuICAgIGxpbWl0cy50ID0gTWF0aC5taW4obGltaXRzLnQsIG9yaWcudCAtIHkpO1xyXG4gIH0gZWxzZSBpZiAodkxpbWl0cy5lbmQgPiBvcmlnLmIpIHtcclxuICAgIHkgPSAodkxpbWl0cy5lbmQgLSBvcmlnLmIpIC8gY29zO1xyXG4gICAgbGltaXRzLmIgPSBNYXRoLm1heChsaW1pdHMuYiwgb3JpZy5iICsgeSk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKSB7XHJcbiAgY29uc3QgaXRlbXMgPSBbXTtcclxuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcclxuICBjb25zdCBvcHRzID0gc2NhbGUub3B0aW9ucztcclxuICBjb25zdCBleHRyYSA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSAvIDI7XHJcbiAgY29uc3Qgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmRyYXdpbmdBcmVhO1xyXG4gIGNvbnN0IGFkZGl0aW9uYWxBbmdsZSA9IG9wdHMucG9pbnRMYWJlbHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XHJcbiAgICBjb25zdCBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UgKyBleHRyYSArIHBhZGRpbmdbaV0sIGFkZGl0aW9uYWxBbmdsZSk7XHJcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKF9ub3JtYWxpemVBbmdsZShwb2ludExhYmVsUG9zaXRpb24uYW5nbGUgKyBIQUxGX1BJKSkpO1xyXG4gICAgY29uc3Qgc2l6ZSA9IGxhYmVsU2l6ZXNbaV07XHJcbiAgICBjb25zdCB5ID0geUZvckFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi55LCBzaXplLmgsIGFuZ2xlKTtcclxuICAgIGNvbnN0IHRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcclxuICAgIGNvbnN0IGxlZnQgPSBsZWZ0Rm9yVGV4dEFsaWduKHBvaW50TGFiZWxQb3NpdGlvbi54LCBzaXplLncsIHRleHRBbGlnbik7XHJcbiAgICBpdGVtcy5wdXNoKHtcclxuICAgICAgeDogcG9pbnRMYWJlbFBvc2l0aW9uLngsXHJcbiAgICAgIHksXHJcbiAgICAgIHRleHRBbGlnbixcclxuICAgICAgbGVmdCxcclxuICAgICAgdG9wOiB5LFxyXG4gICAgICByaWdodDogbGVmdCArIHNpemUudyxcclxuICAgICAgYm90dG9tOiB5ICsgc2l6ZS5oXHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIGl0ZW1zO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XHJcbiAgaWYgKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApIHtcclxuICAgIHJldHVybiAnY2VudGVyJztcclxuICB9IGVsc2UgaWYgKGFuZ2xlIDwgMTgwKSB7XHJcbiAgICByZXR1cm4gJ2xlZnQnO1xyXG4gIH1cclxuICByZXR1cm4gJ3JpZ2h0JztcclxufVxyXG5mdW5jdGlvbiBsZWZ0Rm9yVGV4dEFsaWduKHgsIHcsIGFsaWduKSB7XHJcbiAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XHJcbiAgICB4IC09IHc7XHJcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcclxuICAgIHggLT0gKHcgLyAyKTtcclxuICB9XHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuZnVuY3Rpb24geUZvckFuZ2xlKHksIGgsIGFuZ2xlKSB7XHJcbiAgaWYgKGFuZ2xlID09PSA5MCB8fCBhbmdsZSA9PT0gMjcwKSB7XHJcbiAgICB5IC09IChoIC8gMik7XHJcbiAgfSBlbHNlIGlmIChhbmdsZSA+IDI3MCB8fCBhbmdsZSA8IDkwKSB7XHJcbiAgICB5IC09IGg7XHJcbiAgfVxyXG4gIHJldHVybiB5O1xyXG59XHJcbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSwgbGFiZWxDb3VudCkge1xyXG4gIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb2ludExhYmVsc319ID0gc2NhbGU7XHJcbiAgZm9yIChsZXQgaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgY29uc3Qgb3B0c0F0SW5kZXggPSBwb2ludExhYmVscy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcclxuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcclxuICAgIGNvbnN0IHt4LCB5LCB0ZXh0QWxpZ24sIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zW2ldO1xyXG4gICAgY29uc3Qge2JhY2tkcm9wQ29sb3J9ID0gb3B0c0F0SW5kZXg7XHJcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoYmFja2Ryb3BDb2xvcikpIHtcclxuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhvcHRzQXRJbmRleC5ib3JkZXJSYWRpdXMpO1xyXG4gICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcENvbG9yO1xyXG4gICAgICBjb25zdCBiYWNrZHJvcExlZnQgPSBsZWZ0IC0gcGFkZGluZy5sZWZ0O1xyXG4gICAgICBjb25zdCBiYWNrZHJvcFRvcCA9IHRvcCAtIHBhZGRpbmcudG9wO1xyXG4gICAgICBjb25zdCBiYWNrZHJvcFdpZHRoID0gcmlnaHQgLSBsZWZ0ICsgcGFkZGluZy53aWR0aDtcclxuICAgICAgY29uc3QgYmFja2Ryb3BIZWlnaHQgPSBib3R0b20gLSB0b3AgKyBwYWRkaW5nLmhlaWdodDtcclxuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xyXG4gICAgICAgICAgeDogYmFja2Ryb3BMZWZ0LFxyXG4gICAgICAgICAgeTogYmFja2Ryb3BUb3AsXHJcbiAgICAgICAgICB3OiBiYWNrZHJvcFdpZHRoLFxyXG4gICAgICAgICAgaDogYmFja2Ryb3BIZWlnaHQsXHJcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN0eC5maWxsUmVjdChiYWNrZHJvcExlZnQsIGJhY2tkcm9wVG9wLCBiYWNrZHJvcFdpZHRoLCBiYWNrZHJvcEhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbmRlclRleHQoXHJcbiAgICAgIGN0eCxcclxuICAgICAgc2NhbGUuX3BvaW50TGFiZWxzW2ldLFxyXG4gICAgICB4LFxyXG4gICAgICB5ICsgKHBsRm9udC5saW5lSGVpZ2h0IC8gMiksXHJcbiAgICAgIHBsRm9udCxcclxuICAgICAge1xyXG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcclxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcclxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnXHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KSB7XHJcbiAgY29uc3Qge2N0eH0gPSBzY2FsZTtcclxuICBpZiAoY2lyY3VsYXIpIHtcclxuICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsZXQgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcclxuICAgIGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcclxuICAgICAgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcclxuICAgICAgY3R4LmxpbmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGRyYXdSYWRpdXNMaW5lKHNjYWxlLCBncmlkTGluZU9wdHMsIHJhZGl1cywgbGFiZWxDb3VudCkge1xyXG4gIGNvbnN0IGN0eCA9IHNjYWxlLmN0eDtcclxuICBjb25zdCBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcclxuICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBncmlkTGluZU9wdHM7XHJcbiAgaWYgKCghY2lyY3VsYXIgJiYgIWxhYmVsQ291bnQpIHx8ICFjb2xvciB8fCAhbGluZVdpZHRoIHx8IHJhZGl1cyA8IDApIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY3R4LnNhdmUoKTtcclxuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xyXG4gIGN0eC5zZXRMaW5lRGFzaChncmlkTGluZU9wdHMuYm9yZGVyRGFzaCk7XHJcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZ3JpZExpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQ7XHJcbiAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KTtcclxuICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgY3R4LnN0cm9rZSgpO1xyXG4gIGN0eC5yZXN0b3JlKCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQocGFyZW50LCBpbmRleCwgbGFiZWwpIHtcclxuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcclxuICAgIGxhYmVsLFxyXG4gICAgaW5kZXgsXHJcbiAgICB0eXBlOiAncG9pbnRMYWJlbCdcclxuICB9KTtcclxufVxyXG5jbGFzcyBSYWRpYWxMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XHJcbiAgY29uc3RydWN0b3IoY2ZnKSB7XHJcbiAgICBzdXBlcihjZmcpO1xyXG4gICAgdGhpcy54Q2VudGVyID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy55Q2VudGVyID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gW107XHJcbiAgICB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcclxuICB9XHJcbiAgc2V0RGltZW5zaW9ucygpIHtcclxuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpIC8gMik7XHJcbiAgICBjb25zdCB3ID0gdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGggLSBwYWRkaW5nLndpZHRoO1xyXG4gICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBwYWRkaW5nLmhlaWdodDtcclxuICAgIHRoaXMueENlbnRlciA9IE1hdGguZmxvb3IodGhpcy5sZWZ0ICsgdyAvIDIgKyBwYWRkaW5nLmxlZnQpO1xyXG4gICAgdGhpcy55Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLnRvcCArIGggLyAyICsgcGFkZGluZy50b3ApO1xyXG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGguZmxvb3IoTWF0aC5taW4odywgaCkgLyAyKTtcclxuICB9XHJcbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcclxuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heChmYWxzZSk7XHJcbiAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiAwO1xyXG4gICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogMDtcclxuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xyXG4gIH1cclxuICBjb21wdXRlVGlja0xpbWl0KCkge1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xyXG4gIH1cclxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcclxuICAgIExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUuZ2VuZXJhdGVUaWNrTGFiZWxzLmNhbGwodGhpcywgdGlja3MpO1xyXG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSB0aGlzLmdldExhYmVscygpXHJcbiAgICAgIC5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGxhYmVsID0gY2FsbGJhY2sodGhpcy5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBbdmFsdWUsIGluZGV4XSwgdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcclxuICAgICAgfSlcclxuICAgICAgLmZpbHRlcigodiwgaSkgPT4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSk7XHJcbiAgfVxyXG4gIGZpdCgpIHtcclxuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xyXG4gICAgICBmaXRXaXRoUG9pbnRMYWJlbHModGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xyXG4gICAgfVxyXG4gIH1cclxuICBzZXRDZW50ZXJQb2ludChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xyXG4gICAgdGhpcy54Q2VudGVyICs9IE1hdGguZmxvb3IoKGxlZnRNb3ZlbWVudCAtIHJpZ2h0TW92ZW1lbnQpIC8gMik7XHJcbiAgICB0aGlzLnlDZW50ZXIgKz0gTWF0aC5mbG9vcigodG9wTW92ZW1lbnQgLSBib3R0b21Nb3ZlbWVudCkgLyAyKTtcclxuICAgIHRoaXMuZHJhd2luZ0FyZWEgLT0gTWF0aC5taW4odGhpcy5kcmF3aW5nQXJlYSAvIDIsIE1hdGgubWF4KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSk7XHJcbiAgfVxyXG4gIGdldEluZGV4QW5nbGUoaW5kZXgpIHtcclxuICAgIGNvbnN0IGFuZ2xlTXVsdGlwbGllciA9IFRBVSAvICh0aGlzLl9wb2ludExhYmVscy5sZW5ndGggfHwgMSk7XHJcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcclxuICAgIHJldHVybiBfbm9ybWFsaXplQW5nbGUoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyB0b1JhZGlhbnMoc3RhcnRBbmdsZSkpO1xyXG4gIH1cclxuICBnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkge1xyXG4gICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcbiAgICBjb25zdCBzY2FsaW5nRmFjdG9yID0gdGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xyXG4gICAgICByZXR1cm4gKHRoaXMubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3RvcjtcclxuICAgIH1cclxuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xyXG4gIH1cclxuICBnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlcihkaXN0YW5jZSkge1xyXG4gICAgaWYgKGlzTnVsbE9yVW5kZWYoZGlzdGFuY2UpKSB7XHJcbiAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcbiAgICBjb25zdCBzY2FsZWREaXN0YW5jZSA9IGRpc3RhbmNlIC8gKHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpO1xyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXZlcnNlID8gdGhpcy5tYXggLSBzY2FsZWREaXN0YW5jZSA6IHRoaXMubWluICsgc2NhbGVkRGlzdGFuY2U7XHJcbiAgfVxyXG4gIGdldFBvaW50TGFiZWxDb250ZXh0KGluZGV4KSB7XHJcbiAgICBjb25zdCBwb2ludExhYmVscyA9IHRoaXMuX3BvaW50TGFiZWxzIHx8IFtdO1xyXG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwb2ludExhYmVscy5sZW5ndGgpIHtcclxuICAgICAgY29uc3QgcG9pbnRMYWJlbCA9IHBvaW50TGFiZWxzW2luZGV4XTtcclxuICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgcG9pbnRMYWJlbCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldFBvaW50UG9zaXRpb24oaW5kZXgsIGRpc3RhbmNlRnJvbUNlbnRlciwgYWRkaXRpb25hbEFuZ2xlID0gMCkge1xyXG4gICAgY29uc3QgYW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gSEFMRl9QSSArIGFkZGl0aW9uYWxBbmdsZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueENlbnRlcixcclxuICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy55Q2VudGVyLFxyXG4gICAgICBhbmdsZVxyXG4gICAgfTtcclxuICB9XHJcbiAgZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xyXG4gIH1cclxuICBnZXRCYXNlUG9zaXRpb24oaW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLCB0aGlzLmdldEJhc2VWYWx1ZSgpKTtcclxuICB9XHJcbiAgZ2V0UG9pbnRMYWJlbFBvc2l0aW9uKGluZGV4KSB7XHJcbiAgICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHRoaXMuX3BvaW50TGFiZWxJdGVtc1tpbmRleF07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsZWZ0LFxyXG4gICAgICB0b3AsXHJcbiAgICAgIHJpZ2h0LFxyXG4gICAgICBib3R0b20sXHJcbiAgICB9O1xyXG4gIH1cclxuICBkcmF3QmFja2dyb3VuZCgpIHtcclxuICAgIGNvbnN0IHtiYWNrZ3JvdW5kQ29sb3IsIGdyaWQ6IHtjaXJjdWxhcn19ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xyXG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcclxuICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBwYXRoUmFkaXVzTGluZSh0aGlzLCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuX2VuZFZhbHVlKSwgY2lyY3VsYXIsIHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCk7XHJcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcclxuICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICB9XHJcbiAgZHJhd0dyaWQoKSB7XHJcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcclxuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCB7YW5nbGVMaW5lcywgZ3JpZH0gPSBvcHRzO1xyXG4gICAgY29uc3QgbGFiZWxDb3VudCA9IHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aDtcclxuICAgIGxldCBpLCBvZmZzZXQsIHBvc2l0aW9uO1xyXG4gICAgaWYgKG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xyXG4gICAgICBkcmF3UG9pbnRMYWJlbHModGhpcywgbGFiZWxDb3VudCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XHJcbiAgICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcclxuICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcclxuICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGljay52YWx1ZSk7XHJcbiAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXggLSAxKSk7XHJcbiAgICAgICAgICBkcmF3UmFkaXVzTGluZSh0aGlzLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGFuZ2xlTGluZXMuZGlzcGxheSkge1xyXG4gICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICBmb3IgKGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGFuZ2xlTGluZXMuc2V0Q29udGV4dCh0aGlzLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcclxuICAgICAgICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBvcHRzQXRJbmRleDtcclxuICAgICAgICBpZiAoIWxpbmVXaWR0aCB8fCAhY29sb3IpIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xyXG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChvcHRzQXRJbmRleC5ib3JkZXJEYXNoKTtcclxuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xyXG4gICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gdGhpcy5taW4gOiB0aGlzLm1heCk7XHJcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XHJcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgIH1cclxuICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICB9XHJcbiAgZHJhd0JvcmRlcigpIHt9XHJcbiAgZHJhd0xhYmVscygpIHtcclxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xyXG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcclxuICAgIGlmICghdGlja09wdHMuZGlzcGxheSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5nZXRJbmRleEFuZ2xlKDApO1xyXG4gICAgbGV0IG9mZnNldCwgd2lkdGg7XHJcbiAgICBjdHguc2F2ZSgpO1xyXG4gICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XHJcbiAgICBjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xyXG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xyXG4gICAgICBpZiAoaW5kZXggPT09IDAgJiYgIW9wdHMucmV2ZXJzZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IHRpY2tPcHRzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XHJcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xyXG4gICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLnZhbHVlKTtcclxuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XHJcbiAgICAgICAgY3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XHJcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3I7XHJcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xyXG4gICAgICAgIGN0eC5maWxsUmVjdChcclxuICAgICAgICAgIC13aWR0aCAvIDIgLSBwYWRkaW5nLmxlZnQsXHJcbiAgICAgICAgICAtb2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSBwYWRkaW5nLnRvcCxcclxuICAgICAgICAgIHdpZHRoICsgcGFkZGluZy53aWR0aCxcclxuICAgICAgICAgIHRpY2tGb250LnNpemUgKyBwYWRkaW5nLmhlaWdodFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgcmVuZGVyVGV4dChjdHgsIHRpY2subGFiZWwsIDAsIC1vZmZzZXQsIHRpY2tGb250LCB7XHJcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxuICB9XHJcbiAgZHJhd1RpdGxlKCkge31cclxufVxyXG5SYWRpYWxMaW5lYXJTY2FsZS5pZCA9ICdyYWRpYWxMaW5lYXInO1xyXG5SYWRpYWxMaW5lYXJTY2FsZS5kZWZhdWx0cyA9IHtcclxuICBkaXNwbGF5OiB0cnVlLFxyXG4gIGFuaW1hdGU6IHRydWUsXHJcbiAgcG9zaXRpb246ICdjaGFydEFyZWEnLFxyXG4gIGFuZ2xlTGluZXM6IHtcclxuICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgICBsaW5lV2lkdGg6IDEsXHJcbiAgICBib3JkZXJEYXNoOiBbXSxcclxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxyXG4gIH0sXHJcbiAgZ3JpZDoge1xyXG4gICAgY2lyY3VsYXI6IGZhbHNlXHJcbiAgfSxcclxuICBzdGFydEFuZ2xlOiAwLFxyXG4gIHRpY2tzOiB7XHJcbiAgICBzaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcclxuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcclxuICB9LFxyXG4gIHBvaW50TGFiZWxzOiB7XHJcbiAgICBiYWNrZHJvcENvbG9yOiB1bmRlZmluZWQsXHJcbiAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXHJcbiAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgZm9udDoge1xyXG4gICAgICBzaXplOiAxMFxyXG4gICAgfSxcclxuICAgIGNhbGxiYWNrKGxhYmVsKSB7XHJcbiAgICAgIHJldHVybiBsYWJlbDtcclxuICAgIH0sXHJcbiAgICBwYWRkaW5nOiA1LFxyXG4gICAgY2VudGVyUG9pbnRMYWJlbHM6IGZhbHNlXHJcbiAgfVxyXG59O1xyXG5SYWRpYWxMaW5lYXJTY2FsZS5kZWZhdWx0Um91dGVzID0ge1xyXG4gICdhbmdsZUxpbmVzLmNvbG9yJzogJ2JvcmRlckNvbG9yJyxcclxuICAncG9pbnRMYWJlbHMuY29sb3InOiAnY29sb3InLFxyXG4gICd0aWNrcy5jb2xvcic6ICdjb2xvcidcclxufTtcclxuUmFkaWFsTGluZWFyU2NhbGUuZGVzY3JpcHRvcnMgPSB7XHJcbiAgYW5nbGVMaW5lczoge1xyXG4gICAgX2ZhbGxiYWNrOiAnZ3JpZCdcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBJTlRFUlZBTFMgPSB7XHJcbiAgbWlsbGlzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEsIHN0ZXBzOiAxMDAwfSxcclxuICBzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEwMDAsIHN0ZXBzOiA2MH0sXHJcbiAgbWludXRlOiB7Y29tbW9uOiB0cnVlLCBzaXplOiA2MDAwMCwgc3RlcHM6IDYwfSxcclxuICBob3VyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzNjAwMDAwLCBzdGVwczogMjR9LFxyXG4gIGRheToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogODY0MDAwMDAsIHN0ZXBzOiAzMH0sXHJcbiAgd2Vlazoge2NvbW1vbjogZmFsc2UsIHNpemU6IDYwNDgwMDAwMCwgc3RlcHM6IDR9LFxyXG4gIG1vbnRoOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAyLjYyOGU5LCBzdGVwczogMTJ9LFxyXG4gIHF1YXJ0ZXI6IHtjb21tb246IGZhbHNlLCBzaXplOiA3Ljg4NGU5LCBzdGVwczogNH0sXHJcbiAgeWVhcjoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMy4xNTRlMTB9XHJcbn07XHJcbmNvbnN0IFVOSVRTID0gKE9iamVjdC5rZXlzKElOVEVSVkFMUykpO1xyXG5mdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xyXG4gIHJldHVybiBhIC0gYjtcclxufVxyXG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcclxuICBpZiAoaXNOdWxsT3JVbmRlZihpbnB1dCkpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XHJcbiAgY29uc3Qge3BhcnNlciwgcm91bmQsIGlzb1dlZWtkYXl9ID0gc2NhbGUuX3BhcnNlT3B0cztcclxuICBsZXQgdmFsdWUgPSBpbnB1dDtcclxuICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xyXG4gIH1cclxuICBpZiAoIWlzTnVtYmVyRmluaXRlKHZhbHVlKSkge1xyXG4gICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJ1xyXG4gICAgICA/IGFkYXB0ZXIucGFyc2UodmFsdWUsIHBhcnNlcilcclxuICAgICAgOiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcclxuICB9XHJcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgaWYgKHJvdW5kKSB7XHJcbiAgICB2YWx1ZSA9IHJvdW5kID09PSAnd2VlaycgJiYgKGlzTnVtYmVyKGlzb1dlZWtkYXkpIHx8IGlzb1dlZWtkYXkgPT09IHRydWUpXHJcbiAgICAgID8gYWRhcHRlci5zdGFydE9mKHZhbHVlLCAnaXNvV2VlaycsIGlzb1dlZWtkYXkpXHJcbiAgICAgIDogYWRhcHRlci5zdGFydE9mKHZhbHVlLCByb3VuZCk7XHJcbiAgfVxyXG4gIHJldHVybiArdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcclxuICBjb25zdCBpbGVuID0gVU5JVFMubGVuZ3RoO1xyXG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpIDwgaWxlbiAtIDE7ICsraSkge1xyXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xyXG4gICAgY29uc3QgZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xyXG4gICAgaWYgKGludGVydmFsLmNvbW1vbiAmJiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XHJcbiAgICAgIHJldHVybiBVTklUU1tpXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcclxufVxyXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgbnVtVGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XHJcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmxlbmd0aCAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XHJcbiAgICBjb25zdCB1bml0ID0gVU5JVFNbaV07XHJcbiAgICBpZiAoSU5URVJWQUxTW3VuaXRdLmNvbW1vbiAmJiBzY2FsZS5fYWRhcHRlci5kaWZmKG1heCwgbWluLCB1bml0KSA+PSBudW1UaWNrcyAtIDEpIHtcclxuICAgICAgcmV0dXJuIHVuaXQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBVTklUU1ttaW5Vbml0ID8gVU5JVFMuaW5kZXhPZihtaW5Vbml0KSA6IDBdO1xyXG59XHJcbmZ1bmN0aW9uIGRldGVybWluZU1ham9yVW5pdCh1bml0KSB7XHJcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICBpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcclxuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKSB7XHJcbiAgaWYgKCF0aW1lc3RhbXBzKSB7XHJcbiAgICB0aWNrc1t0aW1lXSA9IHRydWU7XHJcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xyXG4gICAgY29uc3Qge2xvLCBoaX0gPSBfbG9va3VwKHRpbWVzdGFtcHMsIHRpbWUpO1xyXG4gICAgY29uc3QgdGltZXN0YW1wID0gdGltZXN0YW1wc1tsb10gPj0gdGltZSA/IHRpbWVzdGFtcHNbbG9dIDogdGltZXN0YW1wc1toaV07XHJcbiAgICB0aWNrc1t0aW1lc3RhbXBdID0gdHJ1ZTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KSB7XHJcbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xyXG4gIGNvbnN0IGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZih0aWNrc1swXS52YWx1ZSwgbWFqb3JVbml0KTtcclxuICBjb25zdCBsYXN0ID0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWU7XHJcbiAgbGV0IG1ham9yLCBpbmRleDtcclxuICBmb3IgKG1ham9yID0gZmlyc3Q7IG1ham9yIDw9IGxhc3Q7IG1ham9yID0gK2FkYXB0ZXIuYWRkKG1ham9yLCAxLCBtYWpvclVuaXQpKSB7XHJcbiAgICBpbmRleCA9IG1hcFttYWpvcl07XHJcbiAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICB0aWNrc1tpbmRleF0ubWFqb3IgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGlja3M7XHJcbn1cclxuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcclxuICBjb25zdCB0aWNrcyA9IFtdO1xyXG4gIGNvbnN0IG1hcCA9IHt9O1xyXG4gIGNvbnN0IGlsZW4gPSB2YWx1ZXMubGVuZ3RoO1xyXG4gIGxldCBpLCB2YWx1ZTtcclxuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcclxuICAgIG1hcFt2YWx1ZV0gPSBpO1xyXG4gICAgdGlja3MucHVzaCh7XHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICBtYWpvcjogZmFsc2VcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gKGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCkgPyB0aWNrcyA6IHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCk7XHJcbn1cclxuY2xhc3MgVGltZVNjYWxlIGV4dGVuZHMgU2NhbGUge1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB0aGlzLl9jYWNoZSA9IHtcclxuICAgICAgZGF0YTogW10sXHJcbiAgICAgIGxhYmVsczogW10sXHJcbiAgICAgIGFsbDogW11cclxuICAgIH07XHJcbiAgICB0aGlzLl91bml0ID0gJ2RheSc7XHJcbiAgICB0aGlzLl9tYWpvclVuaXQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLl9vZmZzZXRzID0ge307XHJcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIGluaXQoc2NhbGVPcHRzLCBvcHRzKSB7XHJcbiAgICBjb25zdCB0aW1lID0gc2NhbGVPcHRzLnRpbWUgfHwgKHNjYWxlT3B0cy50aW1lID0ge30pO1xyXG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXIgPSBuZXcgX2FkYXB0ZXJzLl9kYXRlKHNjYWxlT3B0cy5hZGFwdGVycy5kYXRlKTtcclxuICAgIG1lcmdlSWYodGltZS5kaXNwbGF5Rm9ybWF0cywgYWRhcHRlci5mb3JtYXRzKCkpO1xyXG4gICAgdGhpcy5fcGFyc2VPcHRzID0ge1xyXG4gICAgICBwYXJzZXI6IHRpbWUucGFyc2VyLFxyXG4gICAgICByb3VuZDogdGltZS5yb3VuZCxcclxuICAgICAgaXNvV2Vla2RheTogdGltZS5pc29XZWVrZGF5XHJcbiAgICB9O1xyXG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdHMpO1xyXG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IG9wdHMubm9ybWFsaXplZDtcclxuICB9XHJcbiAgcGFyc2UocmF3LCBpbmRleCkge1xyXG4gICAgaWYgKHJhdyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnNlKHRoaXMsIHJhdyk7XHJcbiAgfVxyXG4gIGJlZm9yZUxheW91dCgpIHtcclxuICAgIHN1cGVyLmJlZm9yZUxheW91dCgpO1xyXG4gICAgdGhpcy5fY2FjaGUgPSB7XHJcbiAgICAgIGRhdGE6IFtdLFxyXG4gICAgICBsYWJlbHM6IFtdLFxyXG4gICAgICBhbGw6IFtdXHJcbiAgICB9O1xyXG4gIH1cclxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xyXG4gICAgY29uc3QgdW5pdCA9IG9wdGlvbnMudGltZS51bml0IHx8ICdkYXknO1xyXG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcclxuICAgIGZ1bmN0aW9uIF9hcHBseUJvdW5kcyhib3VuZHMpIHtcclxuICAgICAgaWYgKCFtaW5EZWZpbmVkICYmICFpc05hTihib3VuZHMubWluKSkge1xyXG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgYm91bmRzLm1pbik7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFtYXhEZWZpbmVkICYmICFpc05hTihib3VuZHMubWF4KSkge1xyXG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgYm91bmRzLm1heCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghbWluRGVmaW5lZCB8fCAhbWF4RGVmaW5lZCkge1xyXG4gICAgICBfYXBwbHlCb3VuZHModGhpcy5fZ2V0TGFiZWxCb3VuZHMoKSk7XHJcbiAgICAgIGlmIChvcHRpb25zLmJvdW5kcyAhPT0gJ3RpY2tzJyB8fCBvcHRpb25zLnRpY2tzLnNvdXJjZSAhPT0gJ2xhYmVscycpIHtcclxuICAgICAgICBfYXBwbHlCb3VuZHModGhpcy5nZXRNaW5NYXgoZmFsc2UpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWluID0gaXNOdW1iZXJGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6ICthZGFwdGVyLnN0YXJ0T2YoRGF0ZS5ub3coKSwgdW5pdCk7XHJcbiAgICBtYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxO1xyXG4gICAgdGhpcy5taW4gPSBNYXRoLm1pbihtaW4sIG1heCAtIDEpO1xyXG4gICAgdGhpcy5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xyXG4gIH1cclxuICBfZ2V0TGFiZWxCb3VuZHMoKSB7XHJcbiAgICBjb25zdCBhcnIgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xyXG4gICAgbGV0IG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgIGxldCBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcbiAgICBpZiAoYXJyLmxlbmd0aCkge1xyXG4gICAgICBtaW4gPSBhcnJbMF07XHJcbiAgICAgIG1heCA9IGFyclthcnIubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge21pbiwgbWF4fTtcclxuICB9XHJcbiAgYnVpbGRUaWNrcygpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcclxuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcclxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aWNrT3B0cy5zb3VyY2UgPT09ICdsYWJlbHMnID8gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKSA6IHRoaXMuX2dlbmVyYXRlKCk7XHJcbiAgICBpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5taW4gPSB0aGlzLl91c2VyTWluIHx8IHRpbWVzdGFtcHNbMF07XHJcbiAgICAgIHRoaXMubWF4ID0gdGhpcy5fdXNlck1heCB8fCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcclxuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xyXG4gICAgY29uc3QgdGlja3MgPSBfZmlsdGVyQmV0d2Vlbih0aW1lc3RhbXBzLCBtaW4sIG1heCk7XHJcbiAgICB0aGlzLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXBcclxuICAgICAgPyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKVxyXG4gICAgICA6IGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHRoaXMsIHRpY2tzLmxlbmd0aCwgdGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4KSk7XHJcbiAgICB0aGlzLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCB0aGlzLl91bml0ID09PSAneWVhcicgPyB1bmRlZmluZWRcclxuICAgICAgOiBkZXRlcm1pbmVNYWpvclVuaXQodGhpcy5fdW5pdCk7XHJcbiAgICB0aGlzLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xyXG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xyXG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCB0aWNrcywgdGhpcy5fbWFqb3JVbml0KTtcclxuICB9XHJcbiAgYWZ0ZXJBdXRvU2tpcCgpIHtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0QWZ0ZXJBdXRvc2tpcCkge1xyXG4gICAgICB0aGlzLmluaXRPZmZzZXRzKHRoaXMudGlja3MubWFwKHRpY2sgPT4gK3RpY2sudmFsdWUpKTtcclxuICAgIH1cclxuICB9XHJcbiAgaW5pdE9mZnNldHModGltZXN0YW1wcykge1xyXG4gICAgbGV0IHN0YXJ0ID0gMDtcclxuICAgIGxldCBlbmQgPSAwO1xyXG4gICAgbGV0IGZpcnN0LCBsYXN0O1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcclxuICAgICAgZmlyc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzBdKTtcclxuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgc3RhcnQgPSAxIC0gZmlyc3Q7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RhcnQgPSAodGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1sxXSkgLSBmaXJzdCkgLyAyO1xyXG4gICAgICB9XHJcbiAgICAgIGxhc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xyXG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBlbmQgPSBsYXN0O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGVuZCA9IChsYXN0IC0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdKSkgLyAyO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBsaW1pdCA9IHRpbWVzdGFtcHMubGVuZ3RoIDwgMyA/IDAuNSA6IDAuMjU7XHJcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBsaW1pdCk7XHJcbiAgICBlbmQgPSBfbGltaXRWYWx1ZShlbmQsIDAsIGxpbWl0KTtcclxuICAgIHRoaXMuX29mZnNldHMgPSB7c3RhcnQsIGVuZCwgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZCl9O1xyXG4gIH1cclxuICBfZ2VuZXJhdGUoKSB7XHJcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcclxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xyXG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XHJcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XHJcbiAgICBjb25zdCBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKTtcclxuICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQodGltZU9wdHMuc3RlcFNpemUsIDEpO1xyXG4gICAgY29uc3Qgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XHJcbiAgICBjb25zdCBoYXNXZWVrZGF5ID0gaXNOdW1iZXIod2Vla2RheSkgfHwgd2Vla2RheSA9PT0gdHJ1ZTtcclxuICAgIGNvbnN0IHRpY2tzID0ge307XHJcbiAgICBsZXQgZmlyc3QgPSBtaW47XHJcbiAgICBsZXQgdGltZSwgY291bnQ7XHJcbiAgICBpZiAoaGFzV2Vla2RheSkge1xyXG4gICAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XHJcbiAgICB9XHJcbiAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsIGhhc1dlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcclxuICAgIGlmIChhZGFwdGVyLmRpZmYobWF4LCBtaW4sIG1pbm9yKSA+IDEwMDAwMCAqIHN0ZXBTaXplKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihtaW4gKyAnIGFuZCAnICsgbWF4ICsgJyBhcmUgdG9vIGZhciBhcGFydCB3aXRoIHN0ZXBTaXplIG9mICcgKyBzdGVwU2l6ZSArICcgJyArIG1pbm9yKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBvcHRpb25zLnRpY2tzLnNvdXJjZSA9PT0gJ2RhdGEnICYmIHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcclxuICAgIGZvciAodGltZSA9IGZpcnN0LCBjb3VudCA9IDA7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSwgY291bnQrKykge1xyXG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcclxuICAgIH1cclxuICAgIGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgfHwgY291bnQgPT09IDEpIHtcclxuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoKGEsIGIpID0+IGEgLSBiKS5tYXAoeCA9PiAreCk7XHJcbiAgfVxyXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcclxuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xyXG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcclxuICAgIGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XHJcbiAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzLmRhdGV0aW1lKTtcclxuICB9XHJcbiAgX3RpY2tGb3JtYXRGdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgIGNvbnN0IGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XHJcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcclxuICAgIGNvbnN0IG1ham9yVW5pdCA9IHRoaXMuX21ham9yVW5pdDtcclxuICAgIGNvbnN0IG1pbm9yRm9ybWF0ID0gdW5pdCAmJiBmb3JtYXRzW3VuaXRdO1xyXG4gICAgY29uc3QgbWFqb3JGb3JtYXQgPSBtYWpvclVuaXQgJiYgZm9ybWF0c1ttYWpvclVuaXRdO1xyXG4gICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcclxuICAgIGNvbnN0IG1ham9yID0gbWFqb3JVbml0ICYmIG1ham9yRm9ybWF0ICYmIHRpY2sgJiYgdGljay5tYWpvcjtcclxuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcclxuICAgIGNvbnN0IGZvcm1hdHRlciA9IG9wdGlvbnMudGlja3MuY2FsbGJhY2s7XHJcbiAgICByZXR1cm4gZm9ybWF0dGVyID8gY2FsbGJhY2soZm9ybWF0dGVyLCBbbGFiZWwsIGluZGV4LCB0aWNrc10sIHRoaXMpIDogbGFiZWw7XHJcbiAgfVxyXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xyXG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcclxuICAgICAgdGljay5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbih0aWNrLnZhbHVlLCBpLCB0aWNrcyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xyXG4gIH1cclxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XHJcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcclxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKTtcclxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgob2Zmc2V0cy5zdGFydCArIHBvcykgKiBvZmZzZXRzLmZhY3Rvcik7XHJcbiAgfVxyXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcclxuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xyXG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcclxuICAgIHJldHVybiB0aGlzLm1pbiArIHBvcyAqICh0aGlzLm1heCAtIHRoaXMubWluKTtcclxuICB9XHJcbiAgX2dldExhYmVsU2l6ZShsYWJlbCkge1xyXG4gICAgY29uc3QgdGlja3NPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xyXG4gICAgY29uc3QgdGlja0xhYmVsV2lkdGggPSB0aGlzLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XHJcbiAgICBjb25zdCBhbmdsZSA9IHRvUmFkaWFucyh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcclxuICAgIGNvbnN0IGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICBjb25zdCB0aWNrRm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLnNpemU7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3OiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pLFxyXG4gICAgICBoOiAodGlja0xhYmVsV2lkdGggKiBzaW5Sb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogY29zUm90YXRpb24pXHJcbiAgICB9O1xyXG4gIH1cclxuICBfZ2V0TGFiZWxDYXBhY2l0eShleGFtcGxlVGltZSkge1xyXG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcclxuICAgIGNvbnN0IGRpc3BsYXlGb3JtYXRzID0gdGltZU9wdHMuZGlzcGxheUZvcm1hdHM7XHJcbiAgICBjb25zdCBmb3JtYXQgPSBkaXNwbGF5Rm9ybWF0c1t0aW1lT3B0cy51bml0XSB8fCBkaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcclxuICAgIGNvbnN0IGV4YW1wbGVMYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbihleGFtcGxlVGltZSwgMCwgdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCBbZXhhbXBsZVRpbWVdLCB0aGlzLl9tYWpvclVuaXQpLCBmb3JtYXQpO1xyXG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xyXG4gICAgY29uc3QgY2FwYWNpdHkgPSBNYXRoLmZsb29yKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIC8gc2l6ZS53IDogdGhpcy5oZWlnaHQgLyBzaXplLmgpIC0gMTtcclxuICAgIHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XHJcbiAgfVxyXG4gIGdldERhdGFUaW1lc3RhbXBzKCkge1xyXG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdO1xyXG4gICAgbGV0IGksIGlsZW47XHJcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcclxuICAgIGlmICh0aGlzLl9ub3JtYWxpemVkICYmIG1ldGFzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSBtZXRhc1swXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XHJcbiAgfVxyXG4gIGdldExhYmVsVGltZXN0YW1wcygpIHtcclxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5sYWJlbHMgfHwgW107XHJcbiAgICBsZXQgaSwgaWxlbjtcclxuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcclxuICAgIH1cclxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmxhYmVscyA9IHRoaXMuX25vcm1hbGl6ZWQgPyB0aW1lc3RhbXBzIDogdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xyXG4gIH1cclxuICBub3JtYWxpemUodmFsdWVzKSB7XHJcbiAgICByZXR1cm4gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KHNvcnRlcikpO1xyXG4gIH1cclxufVxyXG5UaW1lU2NhbGUuaWQgPSAndGltZSc7XHJcblRpbWVTY2FsZS5kZWZhdWx0cyA9IHtcclxuICBib3VuZHM6ICdkYXRhJyxcclxuICBhZGFwdGVyczoge30sXHJcbiAgdGltZToge1xyXG4gICAgcGFyc2VyOiBmYWxzZSxcclxuICAgIHVuaXQ6IGZhbHNlLFxyXG4gICAgcm91bmQ6IGZhbHNlLFxyXG4gICAgaXNvV2Vla2RheTogZmFsc2UsXHJcbiAgICBtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxyXG4gICAgZGlzcGxheUZvcm1hdHM6IHt9XHJcbiAgfSxcclxuICB0aWNrczoge1xyXG4gICAgc291cmNlOiAnYXV0bycsXHJcbiAgICBtYWpvcjoge1xyXG4gICAgICBlbmFibGVkOiBmYWxzZVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCB2YWwsIHJldmVyc2UpIHtcclxuICBsZXQgbG8gPSAwO1xyXG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XHJcbiAgbGV0IHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIHByZXZUYXJnZXQsIG5leHRUYXJnZXQ7XHJcbiAgaWYgKHJldmVyc2UpIHtcclxuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnBvcyAmJiB2YWwgPD0gdGFibGVbaGldLnBvcykge1xyXG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICdwb3MnLCB2YWwpKTtcclxuICAgIH1cclxuICAgICh7cG9zOiBwcmV2U291cmNlLCB0aW1lOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XHJcbiAgICAoe3BvczogbmV4dFNvdXJjZSwgdGltZTogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS50aW1lICYmIHZhbCA8PSB0YWJsZVtoaV0udGltZSkge1xyXG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICd0aW1lJywgdmFsKSk7XHJcbiAgICB9XHJcbiAgICAoe3RpbWU6IHByZXZTb3VyY2UsIHBvczogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xyXG4gICAgKHt0aW1lOiBuZXh0U291cmNlLCBwb3M6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcclxuICB9XHJcbiAgY29uc3Qgc3BhbiA9IG5leHRTb3VyY2UgLSBwcmV2U291cmNlO1xyXG4gIHJldHVybiBzcGFuID8gcHJldlRhcmdldCArIChuZXh0VGFyZ2V0IC0gcHJldlRhcmdldCkgKiAodmFsIC0gcHJldlNvdXJjZSkgLyBzcGFuIDogcHJldlRhcmdldDtcclxufVxyXG5jbGFzcyBUaW1lU2VyaWVzU2NhbGUgZXh0ZW5kcyBUaW1lU2NhbGUge1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB0aGlzLl90YWJsZSA9IFtdO1xyXG4gICAgdGhpcy5fbWluUG9zID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgaW5pdE9mZnNldHMoKSB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCk7XHJcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuX3RhYmxlID0gdGhpcy5idWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpO1xyXG4gICAgdGhpcy5fbWluUG9zID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWluKTtcclxuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5tYXgpIC0gdGhpcy5fbWluUG9zO1xyXG4gICAgc3VwZXIuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XHJcbiAgfVxyXG4gIGJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcykge1xyXG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XHJcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xyXG4gICAgY29uc3QgdGFibGUgPSBbXTtcclxuICAgIGxldCBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xyXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xyXG4gICAgICBpZiAoY3VyciA+PSBtaW4gJiYgY3VyciA8PSBtYXgpIHtcclxuICAgICAgICBpdGVtcy5wdXNoKGN1cnIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMikge1xyXG4gICAgICByZXR1cm4gW1xyXG4gICAgICAgIHt0aW1lOiBtaW4sIHBvczogMH0sXHJcbiAgICAgICAge3RpbWU6IG1heCwgcG9zOiAxfVxyXG4gICAgICBdO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICBuZXh0ID0gaXRlbXNbaSArIDFdO1xyXG4gICAgICBwcmV2ID0gaXRlbXNbaSAtIDFdO1xyXG4gICAgICBjdXJyID0gaXRlbXNbaV07XHJcbiAgICAgIGlmIChNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xyXG4gICAgICAgIHRhYmxlLnB1c2goe3RpbWU6IGN1cnIsIHBvczogaSAvIChpbGVuIC0gMSl9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhYmxlO1xyXG4gIH1cclxuICBfZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCkge1xyXG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XHJcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xyXG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xyXG4gICAgaWYgKGRhdGEubGVuZ3RoICYmIGxhYmVsLmxlbmd0aCkge1xyXG4gICAgICB0aW1lc3RhbXBzID0gdGhpcy5ub3JtYWxpemUoZGF0YS5jb25jYXQobGFiZWwpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcclxuICAgIH1cclxuICAgIHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgPSB0aW1lc3RhbXBzO1xyXG4gICAgcmV0dXJuIHRpbWVzdGFtcHM7XHJcbiAgfVxyXG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIChpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgdmFsdWUpIC0gdGhpcy5fbWluUG9zKSAvIHRoaXMuX3RhYmxlUmFuZ2U7XHJcbiAgfVxyXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcclxuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xyXG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XHJcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIGRlY2ltYWwgKiB0aGlzLl90YWJsZVJhbmdlICsgdGhpcy5fbWluUG9zLCB0cnVlKTtcclxuICB9XHJcbn1cclxuVGltZVNlcmllc1NjYWxlLmlkID0gJ3RpbWVzZXJpZXMnO1xyXG5UaW1lU2VyaWVzU2NhbGUuZGVmYXVsdHMgPSBUaW1lU2NhbGUuZGVmYXVsdHM7XHJcblxyXG52YXIgc2NhbGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xyXG5fX3Byb3RvX186IG51bGwsXHJcbkNhdGVnb3J5U2NhbGU6IENhdGVnb3J5U2NhbGUsXHJcbkxpbmVhclNjYWxlOiBMaW5lYXJTY2FsZSxcclxuTG9nYXJpdGhtaWNTY2FsZTogTG9nYXJpdGhtaWNTY2FsZSxcclxuUmFkaWFsTGluZWFyU2NhbGU6IFJhZGlhbExpbmVhclNjYWxlLFxyXG5UaW1lU2NhbGU6IFRpbWVTY2FsZSxcclxuVGltZVNlcmllc1NjYWxlOiBUaW1lU2VyaWVzU2NhbGVcclxufSk7XHJcblxyXG5DaGFydC5yZWdpc3Rlcihjb250cm9sbGVycywgc2NhbGVzLCBlbGVtZW50cywgcGx1Z2lucyk7XHJcbkNoYXJ0LmhlbHBlcnMgPSB7Li4uaGVscGVyc307XHJcbkNoYXJ0Ll9hZGFwdGVycyA9IF9hZGFwdGVycztcclxuQ2hhcnQuQW5pbWF0aW9uID0gQW5pbWF0aW9uO1xyXG5DaGFydC5BbmltYXRpb25zID0gQW5pbWF0aW9ucztcclxuQ2hhcnQuYW5pbWF0b3IgPSBhbmltYXRvcjtcclxuQ2hhcnQuY29udHJvbGxlcnMgPSByZWdpc3RyeS5jb250cm9sbGVycy5pdGVtcztcclxuQ2hhcnQuRGF0YXNldENvbnRyb2xsZXIgPSBEYXRhc2V0Q29udHJvbGxlcjtcclxuQ2hhcnQuRWxlbWVudCA9IEVsZW1lbnQ7XHJcbkNoYXJ0LmVsZW1lbnRzID0gZWxlbWVudHM7XHJcbkNoYXJ0LkludGVyYWN0aW9uID0gSW50ZXJhY3Rpb247XHJcbkNoYXJ0LmxheW91dHMgPSBsYXlvdXRzO1xyXG5DaGFydC5wbGF0Zm9ybXMgPSBwbGF0Zm9ybXM7XHJcbkNoYXJ0LlNjYWxlID0gU2NhbGU7XHJcbkNoYXJ0LlRpY2tzID0gVGlja3M7XHJcbk9iamVjdC5hc3NpZ24oQ2hhcnQsIGNvbnRyb2xsZXJzLCBzY2FsZXMsIGVsZW1lbnRzLCBwbHVnaW5zLCBwbGF0Zm9ybXMpO1xyXG5DaGFydC5DaGFydCA9IENoYXJ0O1xyXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICB3aW5kb3cuQ2hhcnQgPSBDaGFydDtcclxufVxyXG5cclxucmV0dXJuIENoYXJ0O1xyXG5cclxufSkpO1xyXG4iLCAibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLicpLmhlbHBlcnM7XHJcbiIsICIvKiFcclxuICogY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscyB2Mi4wLjBcclxuICogaHR0cHM6Ly9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzLm5ldGxpZnkuYXBwXHJcbiAqIChjKSAyMDE3LTIwMjEgY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscyBjb250cmlidXRvcnNcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnY2hhcnQuanMvaGVscGVycycpLCByZXF1aXJlKCdjaGFydC5qcycpKSA6XHJcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2NoYXJ0LmpzL2hlbHBlcnMnLCAnY2hhcnQuanMnXSwgZmFjdG9yeSkgOlxyXG4oZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuQ2hhcnREYXRhTGFiZWxzID0gZmFjdG9yeShnbG9iYWwuQ2hhcnQuaGVscGVycywgZ2xvYmFsLkNoYXJ0KSk7XHJcbn0odGhpcywgKGZ1bmN0aW9uIChoZWxwZXJzLCBjaGFydF9qcykgeyAndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IChmdW5jdGlvbigpIHtcclxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykge1xyXG4gICAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZGV2aWNlUGl4ZWxSYXRpbyBpcyB1bmRlZmluZWQgb24gSUUxMFxyXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMjA0MTgwLzg4Mzc4ODdcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzg1XHJcbiAgICB2YXIgc2NyZWVuID0gd2luZG93LnNjcmVlbjtcclxuICAgIGlmIChzY3JlZW4pIHtcclxuICAgICAgcmV0dXJuIChzY3JlZW4uZGV2aWNlWERQSSB8fCAxKSAvIChzY3JlZW4ubG9naWNhbFhEUEkgfHwgMSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gMTtcclxufSgpKTtcclxuXHJcbnZhciB1dGlscyA9IHtcclxuICAvLyBAdG9kbyBtb3ZlIHRoaXMgaW4gQ2hhcnQuaGVscGVycy50b1RleHRMaW5lc1xyXG4gIHRvVGV4dExpbmVzOiBmdW5jdGlvbihpbnB1dHMpIHtcclxuICAgIHZhciBsaW5lcyA9IFtdO1xyXG4gICAgdmFyIGlucHV0O1xyXG5cclxuICAgIGlucHV0cyA9IFtdLmNvbmNhdChpbnB1dHMpO1xyXG4gICAgd2hpbGUgKGlucHV0cy5sZW5ndGgpIHtcclxuICAgICAgaW5wdXQgPSBpbnB1dHMucG9wKCk7XHJcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgbGluZXMudW5zaGlmdC5hcHBseShsaW5lcywgaW5wdXQuc3BsaXQoJ1xcbicpKTtcclxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgIGlucHV0cy5wdXNoLmFwcGx5KGlucHV0cywgaW5wdXQpO1xyXG4gICAgICB9IGVsc2UgaWYgKCFoZWxwZXJzLmlzTnVsbE9yVW5kZWYoaW5wdXRzKSkge1xyXG4gICAgICAgIGxpbmVzLnVuc2hpZnQoJycgKyBpbnB1dCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGluZXM7XHJcbiAgfSxcclxuXHJcbiAgLy8gQHRvZG8gbW92ZSB0aGlzIGluIENoYXJ0LmhlbHBlcnMuY2FudmFzLnRleHRTaXplXHJcbiAgLy8gQHRvZG8gY2FjaGUgY2FsbHMgb2YgbWVhc3VyZVRleHQgaWYgZm9udCBkb2Vzbid0IGNoYW5nZT8hXHJcbiAgdGV4dFNpemU6IGZ1bmN0aW9uKGN0eCwgbGluZXMsIGZvbnQpIHtcclxuICAgIHZhciBpdGVtcyA9IFtdLmNvbmNhdChsaW5lcyk7XHJcbiAgICB2YXIgaWxlbiA9IGl0ZW1zLmxlbmd0aDtcclxuICAgIHZhciBwcmV2ID0gY3R4LmZvbnQ7XHJcbiAgICB2YXIgd2lkdGggPSAwO1xyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIHdpZHRoID0gTWF0aC5tYXgoY3R4Lm1lYXN1cmVUZXh0KGl0ZW1zW2ldKS53aWR0aCwgd2lkdGgpO1xyXG4gICAgfVxyXG5cclxuICAgIGN0eC5mb250ID0gcHJldjtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBoZWlnaHQ6IGlsZW4gKiBmb250LmxpbmVIZWlnaHQsXHJcbiAgICAgIHdpZHRoOiB3aWR0aFxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHZhbHVlIGJvdW5kZWQgYnkgbWluIGFuZCBtYXguIFRoaXMgaXMgZXF1aXZhbGVudCB0byBtYXgobWluLCBtaW4odmFsdWUsIG1heCkpLlxyXG4gICAqIEB0b2RvIG1vdmUgdGhpcyBtZXRob2QgaW4gQ2hhcnQuaGVscGVycy5ib3VuZFxyXG4gICAqIGh0dHBzOi8vZG9jLnF0LmlvL3F0LTUvcXRnbG9iYWwuaHRtbCNxQm91bmRcclxuICAgKi9cclxuICBib3VuZDogZnVuY3Rpb24obWluLCB2YWx1ZSwgbWF4KSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBwYWlyIFt2YWx1ZSwgc3RhdGVdIHdoZXJlIHN0YXRlIGlzOlxyXG4gICAqICogLTE6IHZhbHVlIGlzIG9ubHkgaW4gYTAgKHJlbW92ZWQpXHJcbiAgICogKiAgMTogdmFsdWUgaXMgb25seSBpbiBhMSAoYWRkZWQpXHJcbiAgICovXHJcbiAgYXJyYXlEaWZmOiBmdW5jdGlvbihhMCwgYTEpIHtcclxuICAgIHZhciBwcmV2ID0gYTAuc2xpY2UoKTtcclxuICAgIHZhciB1cGRhdGVzID0gW107XHJcbiAgICB2YXIgaSwgaiwgaWxlbiwgdjtcclxuXHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYTEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIHYgPSBhMVtpXTtcclxuICAgICAgaiA9IHByZXYuaW5kZXhPZih2KTtcclxuXHJcbiAgICAgIGlmIChqID09PSAtMSkge1xyXG4gICAgICAgIHVwZGF0ZXMucHVzaChbdiwgMV0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHByZXYuc3BsaWNlKGosIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHByZXYubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIHVwZGF0ZXMucHVzaChbcHJldltpXSwgLTFdKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXBkYXRlcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy83MFxyXG4gICAqL1xyXG4gIHJhc3Rlcml6ZTogZnVuY3Rpb24odikge1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQodiAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbztcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBvcmllbnQocG9pbnQsIG9yaWdpbikge1xyXG4gIHZhciB4MCA9IG9yaWdpbi54O1xyXG4gIHZhciB5MCA9IG9yaWdpbi55O1xyXG5cclxuICBpZiAoeDAgPT09IG51bGwpIHtcclxuICAgIHJldHVybiB7eDogMCwgeTogLTF9O1xyXG4gIH1cclxuICBpZiAoeTAgPT09IG51bGwpIHtcclxuICAgIHJldHVybiB7eDogMSwgeTogMH07XHJcbiAgfVxyXG5cclxuICB2YXIgZHggPSBwb2ludC54IC0geDA7XHJcbiAgdmFyIGR5ID0gcG9pbnQueSAtIHkwO1xyXG4gIHZhciBsbiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB4OiBsbiA/IGR4IC8gbG4gOiAwLFxyXG4gICAgeTogbG4gPyBkeSAvIGxuIDogLTFcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbGlnbmVkKHgsIHksIHZ4LCB2eSwgYWxpZ24pIHtcclxuICBzd2l0Y2ggKGFsaWduKSB7XHJcbiAgY2FzZSAnY2VudGVyJzpcclxuICAgIHZ4ID0gdnkgPSAwO1xyXG4gICAgYnJlYWs7XHJcbiAgY2FzZSAnYm90dG9tJzpcclxuICAgIHZ4ID0gMDtcclxuICAgIHZ5ID0gMTtcclxuICAgIGJyZWFrO1xyXG4gIGNhc2UgJ3JpZ2h0JzpcclxuICAgIHZ4ID0gMTtcclxuICAgIHZ5ID0gMDtcclxuICAgIGJyZWFrO1xyXG4gIGNhc2UgJ2xlZnQnOlxyXG4gICAgdnggPSAtMTtcclxuICAgIHZ5ID0gMDtcclxuICAgIGJyZWFrO1xyXG4gIGNhc2UgJ3RvcCc6XHJcbiAgICB2eCA9IDA7XHJcbiAgICB2eSA9IC0xO1xyXG4gICAgYnJlYWs7XHJcbiAgY2FzZSAnc3RhcnQnOlxyXG4gICAgdnggPSAtdng7XHJcbiAgICB2eSA9IC12eTtcclxuICAgIGJyZWFrO1xyXG4gIGNhc2UgJ2VuZCc6XHJcbiAgICAvLyBrZWVwIG5hdHVyYWwgb3JpZW50YXRpb25cclxuICAgIGJyZWFrO1xyXG4gIGRlZmF1bHQ6XHJcbiAgICAvLyBjbG9ja3dpc2Ugcm90YXRpb24gKGluIGRlZ3JlZSlcclxuICAgIGFsaWduICo9IChNYXRoLlBJIC8gMTgwKTtcclxuICAgIHZ4ID0gTWF0aC5jb3MoYWxpZ24pO1xyXG4gICAgdnkgPSBNYXRoLnNpbihhbGlnbik7XHJcbiAgICBicmVhaztcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB4OiB4LFxyXG4gICAgeTogeSxcclxuICAgIHZ4OiB2eCxcclxuICAgIHZ5OiB2eVxyXG4gIH07XHJcbn1cclxuXHJcbi8vIExpbmUgY2xpcHBpbmcgKENvaGVuXHUyMDEzU3V0aGVybGFuZCBhbGdvcml0aG0pXHJcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVuXHUyMDEzU3V0aGVybGFuZF9hbGdvcml0aG1cclxuXHJcbnZhciBSX0lOU0lERSA9IDA7XHJcbnZhciBSX0xFRlQgPSAxO1xyXG52YXIgUl9SSUdIVCA9IDI7XHJcbnZhciBSX0JPVFRPTSA9IDQ7XHJcbnZhciBSX1RPUCA9IDg7XHJcblxyXG5mdW5jdGlvbiByZWdpb24oeCwgeSwgcmVjdCkge1xyXG4gIHZhciByZXMgPSBSX0lOU0lERTtcclxuXHJcbiAgaWYgKHggPCByZWN0LmxlZnQpIHtcclxuICAgIHJlcyB8PSBSX0xFRlQ7XHJcbiAgfSBlbHNlIGlmICh4ID4gcmVjdC5yaWdodCkge1xyXG4gICAgcmVzIHw9IFJfUklHSFQ7XHJcbiAgfVxyXG4gIGlmICh5IDwgcmVjdC50b3ApIHtcclxuICAgIHJlcyB8PSBSX1RPUDtcclxuICB9IGVsc2UgaWYgKHkgPiByZWN0LmJvdHRvbSkge1xyXG4gICAgcmVzIHw9IFJfQk9UVE9NO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuZnVuY3Rpb24gY2xpcHBlZChzZWdtZW50LCBhcmVhKSB7XHJcbiAgdmFyIHgwID0gc2VnbWVudC54MDtcclxuICB2YXIgeTAgPSBzZWdtZW50LnkwO1xyXG4gIHZhciB4MSA9IHNlZ21lbnQueDE7XHJcbiAgdmFyIHkxID0gc2VnbWVudC55MTtcclxuICB2YXIgcjAgPSByZWdpb24oeDAsIHkwLCBhcmVhKTtcclxuICB2YXIgcjEgPSByZWdpb24oeDEsIHkxLCBhcmVhKTtcclxuICB2YXIgciwgeCwgeTtcclxuXHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxyXG4gIHdoaWxlICh0cnVlKSB7XHJcbiAgICBpZiAoIShyMCB8IHIxKSB8fCAocjAgJiByMSkpIHtcclxuICAgICAgLy8gYm90aCBwb2ludHMgaW5zaWRlIG9yIG9uIHRoZSBzYW1lIHNpZGU6IG5vIGNsaXBwaW5nXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGF0IGxlYXN0IG9uZSBwb2ludCBpcyBvdXRzaWRlXHJcbiAgICByID0gcjAgfHwgcjE7XHJcblxyXG4gICAgaWYgKHIgJiBSX1RPUCkge1xyXG4gICAgICB4ID0geDAgKyAoeDEgLSB4MCkgKiAoYXJlYS50b3AgLSB5MCkgLyAoeTEgLSB5MCk7XHJcbiAgICAgIHkgPSBhcmVhLnRvcDtcclxuICAgIH0gZWxzZSBpZiAociAmIFJfQk9UVE9NKSB7XHJcbiAgICAgIHggPSB4MCArICh4MSAtIHgwKSAqIChhcmVhLmJvdHRvbSAtIHkwKSAvICh5MSAtIHkwKTtcclxuICAgICAgeSA9IGFyZWEuYm90dG9tO1xyXG4gICAgfSBlbHNlIGlmIChyICYgUl9SSUdIVCkge1xyXG4gICAgICB5ID0geTAgKyAoeTEgLSB5MCkgKiAoYXJlYS5yaWdodCAtIHgwKSAvICh4MSAtIHgwKTtcclxuICAgICAgeCA9IGFyZWEucmlnaHQ7XHJcbiAgICB9IGVsc2UgaWYgKHIgJiBSX0xFRlQpIHtcclxuICAgICAgeSA9IHkwICsgKHkxIC0geTApICogKGFyZWEubGVmdCAtIHgwKSAvICh4MSAtIHgwKTtcclxuICAgICAgeCA9IGFyZWEubGVmdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAociA9PT0gcjApIHtcclxuICAgICAgeDAgPSB4O1xyXG4gICAgICB5MCA9IHk7XHJcbiAgICAgIHIwID0gcmVnaW9uKHgwLCB5MCwgYXJlYSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4MSA9IHg7XHJcbiAgICAgIHkxID0geTtcclxuICAgICAgcjEgPSByZWdpb24oeDEsIHkxLCBhcmVhKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB4MDogeDAsXHJcbiAgICB4MTogeDEsXHJcbiAgICB5MDogeTAsXHJcbiAgICB5MTogeTFcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlJDEocmFuZ2UsIGNvbmZpZykge1xyXG4gIHZhciBhbmNob3IgPSBjb25maWcuYW5jaG9yO1xyXG4gIHZhciBzZWdtZW50ID0gcmFuZ2U7XHJcbiAgdmFyIHgsIHk7XHJcblxyXG4gIGlmIChjb25maWcuY2xhbXApIHtcclxuICAgIHNlZ21lbnQgPSBjbGlwcGVkKHNlZ21lbnQsIGNvbmZpZy5hcmVhKTtcclxuICB9XHJcblxyXG4gIGlmIChhbmNob3IgPT09ICdzdGFydCcpIHtcclxuICAgIHggPSBzZWdtZW50LngwO1xyXG4gICAgeSA9IHNlZ21lbnQueTA7XHJcbiAgfSBlbHNlIGlmIChhbmNob3IgPT09ICdlbmQnKSB7XHJcbiAgICB4ID0gc2VnbWVudC54MTtcclxuICAgIHkgPSBzZWdtZW50LnkxO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB4ID0gKHNlZ21lbnQueDAgKyBzZWdtZW50LngxKSAvIDI7XHJcbiAgICB5ID0gKHNlZ21lbnQueTAgKyBzZWdtZW50LnkxKSAvIDI7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYWxpZ25lZCh4LCB5LCByYW5nZS52eCwgcmFuZ2UudnksIGNvbmZpZy5hbGlnbik7XHJcbn1cclxuXHJcbnZhciBwb3NpdGlvbmVycyA9IHtcclxuICBhcmM6IGZ1bmN0aW9uKGVsLCBjb25maWcpIHtcclxuICAgIHZhciBhbmdsZSA9IChlbC5zdGFydEFuZ2xlICsgZWwuZW5kQW5nbGUpIC8gMjtcclxuICAgIHZhciB2eCA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIHZhciB2eSA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgIHZhciByMCA9IGVsLmlubmVyUmFkaXVzO1xyXG4gICAgdmFyIHIxID0gZWwub3V0ZXJSYWRpdXM7XHJcblxyXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XHJcbiAgICAgIHgwOiBlbC54ICsgdnggKiByMCxcclxuICAgICAgeTA6IGVsLnkgKyB2eSAqIHIwLFxyXG4gICAgICB4MTogZWwueCArIHZ4ICogcjEsXHJcbiAgICAgIHkxOiBlbC55ICsgdnkgKiByMSxcclxuICAgICAgdng6IHZ4LFxyXG4gICAgICB2eTogdnlcclxuICAgIH0sIGNvbmZpZyk7XHJcbiAgfSxcclxuXHJcbiAgcG9pbnQ6IGZ1bmN0aW9uKGVsLCBjb25maWcpIHtcclxuICAgIHZhciB2ID0gb3JpZW50KGVsLCBjb25maWcub3JpZ2luKTtcclxuICAgIHZhciByeCA9IHYueCAqIGVsLm9wdGlvbnMucmFkaXVzO1xyXG4gICAgdmFyIHJ5ID0gdi55ICogZWwub3B0aW9ucy5yYWRpdXM7XHJcblxyXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XHJcbiAgICAgIHgwOiBlbC54IC0gcngsXHJcbiAgICAgIHkwOiBlbC55IC0gcnksXHJcbiAgICAgIHgxOiBlbC54ICsgcngsXHJcbiAgICAgIHkxOiBlbC55ICsgcnksXHJcbiAgICAgIHZ4OiB2LngsXHJcbiAgICAgIHZ5OiB2LnlcclxuICAgIH0sIGNvbmZpZyk7XHJcbiAgfSxcclxuXHJcbiAgYmFyOiBmdW5jdGlvbihlbCwgY29uZmlnKSB7XHJcbiAgICB2YXIgdiA9IG9yaWVudChlbCwgY29uZmlnLm9yaWdpbik7XHJcbiAgICB2YXIgeCA9IGVsLng7XHJcbiAgICB2YXIgeSA9IGVsLnk7XHJcbiAgICB2YXIgc3ggPSAwO1xyXG4gICAgdmFyIHN5ID0gMDtcclxuXHJcbiAgICBpZiAoZWwuaG9yaXpvbnRhbCkge1xyXG4gICAgICB4ID0gTWF0aC5taW4oZWwueCwgZWwuYmFzZSk7XHJcbiAgICAgIHN4ID0gTWF0aC5hYnMoZWwuYmFzZSAtIGVsLngpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeSA9IE1hdGgubWluKGVsLnksIGVsLmJhc2UpO1xyXG4gICAgICBzeSA9IE1hdGguYWJzKGVsLmJhc2UgLSBlbC55KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29tcHV0ZSQxKHtcclxuICAgICAgeDA6IHgsXHJcbiAgICAgIHkwOiB5ICsgc3ksXHJcbiAgICAgIHgxOiB4ICsgc3gsXHJcbiAgICAgIHkxOiB5LFxyXG4gICAgICB2eDogdi54LFxyXG4gICAgICB2eTogdi55XHJcbiAgICB9LCBjb25maWcpO1xyXG4gIH0sXHJcblxyXG4gIGZhbGxiYWNrOiBmdW5jdGlvbihlbCwgY29uZmlnKSB7XHJcbiAgICB2YXIgdiA9IG9yaWVudChlbCwgY29uZmlnLm9yaWdpbik7XHJcblxyXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XHJcbiAgICAgIHgwOiBlbC54LFxyXG4gICAgICB5MDogZWwueSxcclxuICAgICAgeDE6IGVsLngsXHJcbiAgICAgIHkxOiBlbC55LFxyXG4gICAgICB2eDogdi54LFxyXG4gICAgICB2eTogdi55XHJcbiAgICB9LCBjb25maWcpO1xyXG4gIH1cclxufTtcclxuXHJcbnZhciByYXN0ZXJpemUgPSB1dGlscy5yYXN0ZXJpemU7XHJcblxyXG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKG1vZGVsKSB7XHJcbiAgdmFyIGJvcmRlcldpZHRoID0gbW9kZWwuYm9yZGVyV2lkdGggfHwgMDtcclxuICB2YXIgcGFkZGluZyA9IG1vZGVsLnBhZGRpbmc7XHJcbiAgdmFyIHRoID0gbW9kZWwuc2l6ZS5oZWlnaHQ7XHJcbiAgdmFyIHR3ID0gbW9kZWwuc2l6ZS53aWR0aDtcclxuICB2YXIgdHggPSAtdHcgLyAyO1xyXG4gIHZhciB0eSA9IC10aCAvIDI7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBmcmFtZToge1xyXG4gICAgICB4OiB0eCAtIHBhZGRpbmcubGVmdCAtIGJvcmRlcldpZHRoLFxyXG4gICAgICB5OiB0eSAtIHBhZGRpbmcudG9wIC0gYm9yZGVyV2lkdGgsXHJcbiAgICAgIHc6IHR3ICsgcGFkZGluZy53aWR0aCArIGJvcmRlcldpZHRoICogMixcclxuICAgICAgaDogdGggKyBwYWRkaW5nLmhlaWdodCArIGJvcmRlcldpZHRoICogMlxyXG4gICAgfSxcclxuICAgIHRleHQ6IHtcclxuICAgICAgeDogdHgsXHJcbiAgICAgIHk6IHR5LFxyXG4gICAgICB3OiB0dyxcclxuICAgICAgaDogdGhcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTY2FsZU9yaWdpbihlbCwgY29udGV4dCkge1xyXG4gIHZhciBzY2FsZSA9IGNvbnRleHQuY2hhcnQuZ2V0RGF0YXNldE1ldGEoY29udGV4dC5kYXRhc2V0SW5kZXgpLnZTY2FsZTtcclxuXHJcbiAgaWYgKCFzY2FsZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAoc2NhbGUueENlbnRlciAhPT0gdW5kZWZpbmVkICYmIHNjYWxlLnlDZW50ZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIHt4OiBzY2FsZS54Q2VudGVyLCB5OiBzY2FsZS55Q2VudGVyfTtcclxuICB9XHJcblxyXG4gIHZhciBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xyXG4gIHJldHVybiBlbC5ob3Jpem9udGFsID9cclxuICAgIHt4OiBwaXhlbCwgeTogbnVsbH0gOlxyXG4gICAge3g6IG51bGwsIHk6IHBpeGVsfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UG9zaXRpb25lcihlbCkge1xyXG4gIGlmIChlbCBpbnN0YW5jZW9mIGNoYXJ0X2pzLkFyY0VsZW1lbnQpIHtcclxuICAgIHJldHVybiBwb3NpdGlvbmVycy5hcmM7XHJcbiAgfVxyXG4gIGlmIChlbCBpbnN0YW5jZW9mIGNoYXJ0X2pzLlBvaW50RWxlbWVudCkge1xyXG4gICAgcmV0dXJuIHBvc2l0aW9uZXJzLnBvaW50O1xyXG4gIH1cclxuICBpZiAoZWwgaW5zdGFuY2VvZiBjaGFydF9qcy5CYXJFbGVtZW50KSB7XHJcbiAgICByZXR1cm4gcG9zaXRpb25lcnMuYmFyO1xyXG4gIH1cclxuICByZXR1cm4gcG9zaXRpb25lcnMuZmFsbGJhY2s7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdSb3VuZGVkUmVjdChjdHgsIHgsIHksIHcsIGgsIHJhZGl1cykge1xyXG4gIHZhciBIQUxGX1BJID0gTWF0aC5QSSAvIDI7XHJcblxyXG4gIGlmIChyYWRpdXMpIHtcclxuICAgIHZhciByID0gTWF0aC5taW4ocmFkaXVzLCBoIC8gMiwgdyAvIDIpO1xyXG4gICAgdmFyIGxlZnQgPSB4ICsgcjtcclxuICAgIHZhciB0b3AgPSB5ICsgcjtcclxuICAgIHZhciByaWdodCA9IHggKyB3IC0gcjtcclxuICAgIHZhciBib3R0b20gPSB5ICsgaCAtIHI7XHJcblxyXG4gICAgY3R4Lm1vdmVUbyh4LCB0b3ApO1xyXG4gICAgaWYgKGxlZnQgPCByaWdodCAmJiB0b3AgPCBib3R0b20pIHtcclxuICAgICAgY3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1NYXRoLlBJLCAtSEFMRl9QSSk7XHJcbiAgICAgIGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIDApO1xyXG4gICAgICBjdHguYXJjKHJpZ2h0LCBib3R0b20sIHIsIDAsIEhBTEZfUEkpO1xyXG4gICAgICBjdHguYXJjKGxlZnQsIGJvdHRvbSwgciwgSEFMRl9QSSwgTWF0aC5QSSk7XHJcbiAgICB9IGVsc2UgaWYgKGxlZnQgPCByaWdodCkge1xyXG4gICAgICBjdHgubW92ZVRvKGxlZnQsIHkpO1xyXG4gICAgICBjdHguYXJjKHJpZ2h0LCB0b3AsIHIsIC1IQUxGX1BJLCBIQUxGX1BJKTtcclxuICAgICAgY3R4LmFyYyhsZWZ0LCB0b3AsIHIsIEhBTEZfUEksIE1hdGguUEkgKyBIQUxGX1BJKTtcclxuICAgIH0gZWxzZSBpZiAodG9wIDwgYm90dG9tKSB7XHJcbiAgICAgIGN0eC5hcmMobGVmdCwgdG9wLCByLCAtTWF0aC5QSSwgMCk7XHJcbiAgICAgIGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCAwLCBNYXRoLlBJKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN0eC5hcmMobGVmdCwgdG9wLCByLCAtTWF0aC5QSSwgTWF0aC5QSSk7XHJcbiAgICB9XHJcbiAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjdHgucmVjdCh4LCB5LCB3LCBoKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdGcmFtZShjdHgsIHJlY3QsIG1vZGVsKSB7XHJcbiAgdmFyIGJnQ29sb3IgPSBtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgdmFyIGJvcmRlckNvbG9yID0gbW9kZWwuYm9yZGVyQ29sb3I7XHJcbiAgdmFyIGJvcmRlcldpZHRoID0gbW9kZWwuYm9yZGVyV2lkdGg7XHJcblxyXG4gIGlmICghYmdDb2xvciAmJiAoIWJvcmRlckNvbG9yIHx8ICFib3JkZXJXaWR0aCkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGN0eC5iZWdpblBhdGgoKTtcclxuXHJcbiAgZHJhd1JvdW5kZWRSZWN0KFxyXG4gICAgY3R4LFxyXG4gICAgcmFzdGVyaXplKHJlY3QueCkgKyBib3JkZXJXaWR0aCAvIDIsXHJcbiAgICByYXN0ZXJpemUocmVjdC55KSArIGJvcmRlcldpZHRoIC8gMixcclxuICAgIHJhc3Rlcml6ZShyZWN0LncpIC0gYm9yZGVyV2lkdGgsXHJcbiAgICByYXN0ZXJpemUocmVjdC5oKSAtIGJvcmRlcldpZHRoLFxyXG4gICAgbW9kZWwuYm9yZGVyUmFkaXVzKTtcclxuXHJcbiAgY3R4LmNsb3NlUGF0aCgpO1xyXG5cclxuICBpZiAoYmdDb2xvcikge1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IGJnQ29sb3I7XHJcbiAgICBjdHguZmlsbCgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGJvcmRlckNvbG9yICYmIGJvcmRlcldpZHRoKSB7XHJcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcclxuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcclxuICAgIGN0eC5saW5lSm9pbiA9ICdtaXRlcic7XHJcbiAgICBjdHguc3Ryb2tlKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB0ZXh0R2VvbWV0cnkocmVjdCwgYWxpZ24sIGZvbnQpIHtcclxuICB2YXIgaCA9IGZvbnQubGluZUhlaWdodDtcclxuICB2YXIgdyA9IHJlY3QudztcclxuICB2YXIgeCA9IHJlY3QueDtcclxuICB2YXIgeSA9IHJlY3QueSArIGggLyAyO1xyXG5cclxuICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XHJcbiAgICB4ICs9IHcgLyAyO1xyXG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnIHx8IGFsaWduID09PSAncmlnaHQnKSB7XHJcbiAgICB4ICs9IHc7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaDogaCxcclxuICAgIHc6IHcsXHJcbiAgICB4OiB4LFxyXG4gICAgeTogeVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdUZXh0TGluZShjdHgsIHRleHQsIGNmZykge1xyXG4gIHZhciBzaGFkb3cgPSBjdHguc2hhZG93Qmx1cjtcclxuICB2YXIgc3Ryb2tlZCA9IGNmZy5zdHJva2VkO1xyXG4gIHZhciB4ID0gcmFzdGVyaXplKGNmZy54KTtcclxuICB2YXIgeSA9IHJhc3Rlcml6ZShjZmcueSk7XHJcbiAgdmFyIHcgPSByYXN0ZXJpemUoY2ZnLncpO1xyXG5cclxuICBpZiAoc3Ryb2tlZCkge1xyXG4gICAgY3R4LnN0cm9rZVRleHQodGV4dCwgeCwgeSwgdyk7XHJcbiAgfVxyXG5cclxuICBpZiAoY2ZnLmZpbGxlZCkge1xyXG4gICAgaWYgKHNoYWRvdyAmJiBzdHJva2VkKSB7XHJcbiAgICAgIC8vIFByZXZlbnQgZHJhd2luZyBzaGFkb3cgb24gYm90aCB0aGUgdGV4dCBzdHJva2UgYW5kIGZpbGwsIHNvXHJcbiAgICAgIC8vIGlmIHRoZSB0ZXh0IGlzIHN0cm9rZWQsIHJlbW92ZSB0aGUgc2hhZG93IGZvciB0aGUgdGV4dCBmaWxsLlxyXG4gICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgY3R4LmZpbGxUZXh0KHRleHQsIHgsIHksIHcpO1xyXG5cclxuICAgIGlmIChzaGFkb3cgJiYgc3Ryb2tlZCkge1xyXG4gICAgICBjdHguc2hhZG93Qmx1ciA9IHNoYWRvdztcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdUZXh0KGN0eCwgbGluZXMsIHJlY3QsIG1vZGVsKSB7XHJcbiAgdmFyIGFsaWduID0gbW9kZWwudGV4dEFsaWduO1xyXG4gIHZhciBjb2xvciA9IG1vZGVsLmNvbG9yO1xyXG4gIHZhciBmaWxsZWQgPSAhIWNvbG9yO1xyXG4gIHZhciBmb250ID0gbW9kZWwuZm9udDtcclxuICB2YXIgaWxlbiA9IGxpbmVzLmxlbmd0aDtcclxuICB2YXIgc3Ryb2tlQ29sb3IgPSBtb2RlbC50ZXh0U3Ryb2tlQ29sb3I7XHJcbiAgdmFyIHN0cm9rZVdpZHRoID0gbW9kZWwudGV4dFN0cm9rZVdpZHRoO1xyXG4gIHZhciBzdHJva2VkID0gc3Ryb2tlQ29sb3IgJiYgc3Ryb2tlV2lkdGg7XHJcbiAgdmFyIGk7XHJcblxyXG4gIGlmICghaWxlbiB8fCAoIWZpbGxlZCAmJiAhc3Ryb2tlZCkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIEFkanVzdCBjb29yZGluYXRlcyBiYXNlZCBvbiB0ZXh0IGFsaWdubWVudCBhbmQgbGluZSBoZWlnaHRcclxuICByZWN0ID0gdGV4dEdlb21ldHJ5KHJlY3QsIGFsaWduLCBmb250KTtcclxuXHJcbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcclxuICBjdHgudGV4dEFsaWduID0gYWxpZ247XHJcbiAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xyXG4gIGN0eC5zaGFkb3dCbHVyID0gbW9kZWwudGV4dFNoYWRvd0JsdXI7XHJcbiAgY3R4LnNoYWRvd0NvbG9yID0gbW9kZWwudGV4dFNoYWRvd0NvbG9yO1xyXG5cclxuICBpZiAoZmlsbGVkKSB7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XHJcbiAgfVxyXG4gIGlmIChzdHJva2VkKSB7XHJcbiAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xyXG4gICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xyXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3I7XHJcbiAgfVxyXG5cclxuICBmb3IgKGkgPSAwLCBpbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICBkcmF3VGV4dExpbmUoY3R4LCBsaW5lc1tpXSwge1xyXG4gICAgICBzdHJva2VkOiBzdHJva2VkLFxyXG4gICAgICBmaWxsZWQ6IGZpbGxlZCxcclxuICAgICAgdzogcmVjdC53LFxyXG4gICAgICB4OiByZWN0LngsXHJcbiAgICAgIHk6IHJlY3QueSArIHJlY3QuaCAqIGlcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxudmFyIExhYmVsID0gZnVuY3Rpb24oY29uZmlnLCBjdHgsIGVsLCBpbmRleCkge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gIG1lLl9jb25maWcgPSBjb25maWc7XHJcbiAgbWUuX2luZGV4ID0gaW5kZXg7XHJcbiAgbWUuX21vZGVsID0gbnVsbDtcclxuICBtZS5fcmVjdHMgPSBudWxsO1xyXG4gIG1lLl9jdHggPSBjdHg7XHJcbiAgbWUuX2VsID0gZWw7XHJcbn07XHJcblxyXG5oZWxwZXJzLm1lcmdlKExhYmVsLnByb3RvdHlwZSwge1xyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX21vZGVsaXplOiBmdW5jdGlvbihkaXNwbGF5LCBsaW5lcywgY29uZmlnLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgbWUgPSB0aGlzO1xyXG4gICAgdmFyIGluZGV4ID0gbWUuX2luZGV4O1xyXG4gICAgdmFyIGZvbnQgPSBoZWxwZXJzLnRvRm9udChoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5mb250LCB7fV0sIGNvbnRleHQsIGluZGV4KSk7XHJcbiAgICB2YXIgY29sb3IgPSBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5jb2xvciwgY2hhcnRfanMuZGVmYXVsdHMuY29sb3JdLCBjb250ZXh0LCBpbmRleCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYWxpZ246IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmFsaWduLCAnY2VudGVyJ10sIGNvbnRleHQsIGluZGV4KSxcclxuICAgICAgYW5jaG9yOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5hbmNob3IsICdjZW50ZXInXSwgY29udGV4dCwgaW5kZXgpLFxyXG4gICAgICBhcmVhOiBjb250ZXh0LmNoYXJ0LmNoYXJ0QXJlYSxcclxuICAgICAgYmFja2dyb3VuZENvbG9yOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5iYWNrZ3JvdW5kQ29sb3IsIG51bGxdLCBjb250ZXh0LCBpbmRleCksXHJcbiAgICAgIGJvcmRlckNvbG9yOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5ib3JkZXJDb2xvciwgbnVsbF0sIGNvbnRleHQsIGluZGV4KSxcclxuICAgICAgYm9yZGVyUmFkaXVzOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5ib3JkZXJSYWRpdXMsIDBdLCBjb250ZXh0LCBpbmRleCksXHJcbiAgICAgIGJvcmRlcldpZHRoOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5ib3JkZXJXaWR0aCwgMF0sIGNvbnRleHQsIGluZGV4KSxcclxuICAgICAgY2xhbXA6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmNsYW1wLCBmYWxzZV0sIGNvbnRleHQsIGluZGV4KSxcclxuICAgICAgY2xpcDogaGVscGVycy5yZXNvbHZlKFtjb25maWcuY2xpcCwgZmFsc2VdLCBjb250ZXh0LCBpbmRleCksXHJcbiAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgZGlzcGxheTogZGlzcGxheSxcclxuICAgICAgZm9udDogZm9udCxcclxuICAgICAgbGluZXM6IGxpbmVzLFxyXG4gICAgICBvZmZzZXQ6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLm9mZnNldCwgMF0sIGNvbnRleHQsIGluZGV4KSxcclxuICAgICAgb3BhY2l0eTogaGVscGVycy5yZXNvbHZlKFtjb25maWcub3BhY2l0eSwgMV0sIGNvbnRleHQsIGluZGV4KSxcclxuICAgICAgb3JpZ2luOiBnZXRTY2FsZU9yaWdpbihtZS5fZWwsIGNvbnRleHQpLFxyXG4gICAgICBwYWRkaW5nOiBoZWxwZXJzLnRvUGFkZGluZyhoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy5wYWRkaW5nLCAwXSwgY29udGV4dCwgaW5kZXgpKSxcclxuICAgICAgcG9zaXRpb25lcjogZ2V0UG9zaXRpb25lcihtZS5fZWwpLFxyXG4gICAgICByb3RhdGlvbjogaGVscGVycy5yZXNvbHZlKFtjb25maWcucm90YXRpb24sIDBdLCBjb250ZXh0LCBpbmRleCkgKiAoTWF0aC5QSSAvIDE4MCksXHJcbiAgICAgIHNpemU6IHV0aWxzLnRleHRTaXplKG1lLl9jdHgsIGxpbmVzLCBmb250KSxcclxuICAgICAgdGV4dEFsaWduOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy50ZXh0QWxpZ24sICdzdGFydCddLCBjb250ZXh0LCBpbmRleCksXHJcbiAgICAgIHRleHRTaGFkb3dCbHVyOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy50ZXh0U2hhZG93Qmx1ciwgMF0sIGNvbnRleHQsIGluZGV4KSxcclxuICAgICAgdGV4dFNoYWRvd0NvbG9yOiBoZWxwZXJzLnJlc29sdmUoW2NvbmZpZy50ZXh0U2hhZG93Q29sb3IsIGNvbG9yXSwgY29udGV4dCwgaW5kZXgpLFxyXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLnRleHRTdHJva2VDb2xvciwgY29sb3JdLCBjb250ZXh0LCBpbmRleCksXHJcbiAgICAgIHRleHRTdHJva2VXaWR0aDogaGVscGVycy5yZXNvbHZlKFtjb25maWcudGV4dFN0cm9rZVdpZHRoLCAwXSwgY29udGV4dCwgaW5kZXgpXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZTogZnVuY3Rpb24oY29udGV4dCkge1xyXG4gICAgdmFyIG1lID0gdGhpcztcclxuICAgIHZhciBtb2RlbCA9IG51bGw7XHJcbiAgICB2YXIgcmVjdHMgPSBudWxsO1xyXG4gICAgdmFyIGluZGV4ID0gbWUuX2luZGV4O1xyXG4gICAgdmFyIGNvbmZpZyA9IG1lLl9jb25maWc7XHJcbiAgICB2YXIgdmFsdWUsIGxhYmVsLCBsaW5lcztcclxuXHJcbiAgICAvLyBXZSBmaXJzdCByZXNvbHZlIHRoZSBkaXNwbGF5IG9wdGlvbiAoc2VwYXJhdGVseSkgdG8gYXZvaWQgY29tcHV0aW5nXHJcbiAgICAvLyBvdGhlciBvcHRpb25zIGluIGNhc2UgdGhlIGxhYmVsIGlzIGhpZGRlbiAoaS5lLiBkaXNwbGF5OiBmYWxzZSkuXHJcbiAgICB2YXIgZGlzcGxheSA9IGhlbHBlcnMucmVzb2x2ZShbY29uZmlnLmRpc3BsYXksIHRydWVdLCBjb250ZXh0LCBpbmRleCk7XHJcblxyXG4gICAgaWYgKGRpc3BsYXkpIHtcclxuICAgICAgdmFsdWUgPSBjb250ZXh0LmRhdGFzZXQuZGF0YVtpbmRleF07XHJcbiAgICAgIGxhYmVsID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdChoZWxwZXJzLmNhbGxiYWNrKGNvbmZpZy5mb3JtYXR0ZXIsIFt2YWx1ZSwgY29udGV4dF0pLCB2YWx1ZSk7XHJcbiAgICAgIGxpbmVzID0gaGVscGVycy5pc051bGxPclVuZGVmKGxhYmVsKSA/IFtdIDogdXRpbHMudG9UZXh0TGluZXMobGFiZWwpO1xyXG5cclxuICAgICAgaWYgKGxpbmVzLmxlbmd0aCkge1xyXG4gICAgICAgIG1vZGVsID0gbWUuX21vZGVsaXplKGRpc3BsYXksIGxpbmVzLCBjb25maWcsIGNvbnRleHQpO1xyXG4gICAgICAgIHJlY3RzID0gYm91bmRpbmdSZWN0cyhtb2RlbCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBtZS5fbW9kZWwgPSBtb2RlbDtcclxuICAgIG1lLl9yZWN0cyA9IHJlY3RzO1xyXG4gIH0sXHJcblxyXG4gIGdlb21ldHJ5OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZWN0cyA/IHRoaXMuX3JlY3RzLmZyYW1lIDoge307XHJcbiAgfSxcclxuXHJcbiAgcm90YXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21vZGVsID8gdGhpcy5fbW9kZWwucm90YXRpb24gOiAwO1xyXG4gIH0sXHJcblxyXG4gIHZpc2libGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21vZGVsICYmIHRoaXMuX21vZGVsLm9wYWNpdHk7XHJcbiAgfSxcclxuXHJcbiAgbW9kZWw6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX21vZGVsO1xyXG4gIH0sXHJcblxyXG4gIGRyYXc6IGZ1bmN0aW9uKGNoYXJ0LCBjZW50ZXIpIHtcclxuICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICB2YXIgY3R4ID0gY2hhcnQuY3R4O1xyXG4gICAgdmFyIG1vZGVsID0gbWUuX21vZGVsO1xyXG4gICAgdmFyIHJlY3RzID0gbWUuX3JlY3RzO1xyXG4gICAgdmFyIGFyZWE7XHJcblxyXG4gICAgaWYgKCF0aGlzLnZpc2libGUoKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY3R4LnNhdmUoKTtcclxuXHJcbiAgICBpZiAobW9kZWwuY2xpcCkge1xyXG4gICAgICBhcmVhID0gbW9kZWwuYXJlYTtcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjdHgucmVjdChcclxuICAgICAgICBhcmVhLmxlZnQsXHJcbiAgICAgICAgYXJlYS50b3AsXHJcbiAgICAgICAgYXJlYS5yaWdodCAtIGFyZWEubGVmdCxcclxuICAgICAgICBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcclxuICAgICAgY3R4LmNsaXAoKTtcclxuICAgIH1cclxuXHJcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB1dGlscy5ib3VuZCgwLCBtb2RlbC5vcGFjaXR5LCAxKTtcclxuICAgIGN0eC50cmFuc2xhdGUocmFzdGVyaXplKGNlbnRlci54KSwgcmFzdGVyaXplKGNlbnRlci55KSk7XHJcbiAgICBjdHgucm90YXRlKG1vZGVsLnJvdGF0aW9uKTtcclxuXHJcbiAgICBkcmF3RnJhbWUoY3R4LCByZWN0cy5mcmFtZSwgbW9kZWwpO1xyXG4gICAgZHJhd1RleHQoY3R4LCBtb2RlbC5saW5lcywgcmVjdHMudGV4dCwgbW9kZWwpO1xyXG5cclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBNSU5fSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IC05MDA3MTk5MjU0NzQwOTkxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVzL25vLW51bWJlci1taW5zYWZlaW50ZWdlclxyXG52YXIgTUFYX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcy9uby1udW1iZXItbWF4c2FmZWludGVnZXJcclxuXHJcbmZ1bmN0aW9uIHJvdGF0ZWQocG9pbnQsIGNlbnRlciwgYW5nbGUpIHtcclxuICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgdmFyIGN4ID0gY2VudGVyLng7XHJcbiAgdmFyIGN5ID0gY2VudGVyLnk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB4OiBjeCArIGNvcyAqIChwb2ludC54IC0gY3gpIC0gc2luICogKHBvaW50LnkgLSBjeSksXHJcbiAgICB5OiBjeSArIHNpbiAqIChwb2ludC54IC0gY3gpICsgY29zICogKHBvaW50LnkgLSBjeSlcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9qZWN0ZWQocG9pbnRzLCBheGlzKSB7XHJcbiAgdmFyIG1pbiA9IE1BWF9JTlRFR0VSO1xyXG4gIHZhciBtYXggPSBNSU5fSU5URUdFUjtcclxuICB2YXIgb3JpZ2luID0gYXhpcy5vcmlnaW47XHJcbiAgdmFyIGksIHB0LCB2eCwgdnksIGRwO1xyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICBwdCA9IHBvaW50c1tpXTtcclxuICAgIHZ4ID0gcHQueCAtIG9yaWdpbi54O1xyXG4gICAgdnkgPSBwdC55IC0gb3JpZ2luLnk7XHJcbiAgICBkcCA9IGF4aXMudnggKiB2eCArIGF4aXMudnkgKiB2eTtcclxuICAgIG1pbiA9IE1hdGgubWluKG1pbiwgZHApO1xyXG4gICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkcCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbWluOiBtaW4sXHJcbiAgICBtYXg6IG1heFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvQXhpcyhwMCwgcDEpIHtcclxuICB2YXIgdnggPSBwMS54IC0gcDAueDtcclxuICB2YXIgdnkgPSBwMS55IC0gcDAueTtcclxuICB2YXIgbG4gPSBNYXRoLnNxcnQodnggKiB2eCArIHZ5ICogdnkpO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgdng6IChwMS54IC0gcDAueCkgLyBsbixcclxuICAgIHZ5OiAocDEueSAtIHAwLnkpIC8gbG4sXHJcbiAgICBvcmlnaW46IHAwLFxyXG4gICAgbG46IGxuXHJcbiAgfTtcclxufVxyXG5cclxudmFyIEhpdEJveCA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMuX3JvdGF0aW9uID0gMDtcclxuICB0aGlzLl9yZWN0ID0ge1xyXG4gICAgeDogMCxcclxuICAgIHk6IDAsXHJcbiAgICB3OiAwLFxyXG4gICAgaDogMFxyXG4gIH07XHJcbn07XHJcblxyXG5oZWxwZXJzLm1lcmdlKEhpdEJveC5wcm90b3R5cGUsIHtcclxuICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHIgPSB0aGlzLl9yZWN0O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogci54ICsgci53IC8gMixcclxuICAgICAgeTogci55ICsgci5oIC8gMlxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICB1cGRhdGU6IGZ1bmN0aW9uKGNlbnRlciwgcmVjdCwgcm90YXRpb24pIHtcclxuICAgIHRoaXMuX3JvdGF0aW9uID0gcm90YXRpb247XHJcbiAgICB0aGlzLl9yZWN0ID0ge1xyXG4gICAgICB4OiByZWN0LnggKyBjZW50ZXIueCxcclxuICAgICAgeTogcmVjdC55ICsgY2VudGVyLnksXHJcbiAgICAgIHc6IHJlY3QudyxcclxuICAgICAgaDogcmVjdC5oXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xyXG4gICAgdmFyIG1lID0gdGhpcztcclxuICAgIHZhciBtYXJnaW4gPSAxO1xyXG4gICAgdmFyIHJlY3QgPSBtZS5fcmVjdDtcclxuXHJcbiAgICBwb2ludCA9IHJvdGF0ZWQocG9pbnQsIG1lLmNlbnRlcigpLCAtbWUuX3JvdGF0aW9uKTtcclxuXHJcbiAgICByZXR1cm4gIShwb2ludC54IDwgcmVjdC54IC0gbWFyZ2luXHJcbiAgICAgIHx8IHBvaW50LnkgPCByZWN0LnkgLSBtYXJnaW5cclxuICAgICAgfHwgcG9pbnQueCA+IHJlY3QueCArIHJlY3QudyArIG1hcmdpbiAqIDJcclxuICAgICAgfHwgcG9pbnQueSA+IHJlY3QueSArIHJlY3QuaCArIG1hcmdpbiAqIDIpO1xyXG4gIH0sXHJcblxyXG4gIC8vIFNlcGFyYXRpbmcgQXhpcyBUaGVvcmVtXHJcbiAgLy8gaHR0cHM6Ly9nYW1lZGV2ZWxvcG1lbnQudHV0c3BsdXMuY29tL3R1dG9yaWFscy9jb2xsaXNpb24tZGV0ZWN0aW9uLXVzaW5nLXRoZS1zZXBhcmF0aW5nLWF4aXMtdGhlb3JlbS0tZ2FtZWRldi0xNjlcclxuICBpbnRlcnNlY3RzOiBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgdmFyIHIwID0gdGhpcy5fcG9pbnRzKCk7XHJcbiAgICB2YXIgcjEgPSBvdGhlci5fcG9pbnRzKCk7XHJcbiAgICB2YXIgYXhlcyA9IFtcclxuICAgICAgdG9BeGlzKHIwWzBdLCByMFsxXSksXHJcbiAgICAgIHRvQXhpcyhyMFswXSwgcjBbM10pXHJcbiAgICBdO1xyXG4gICAgdmFyIGksIHByMCwgcHIxO1xyXG5cclxuICAgIGlmICh0aGlzLl9yb3RhdGlvbiAhPT0gb3RoZXIuX3JvdGF0aW9uKSB7XHJcbiAgICAgIC8vIE9ubHkgc2VwYXJhdGUgd2l0aCByMSBheGlzIGlmIHRoZSByb3RhdGlvbiBpcyBkaWZmZXJlbnQsXHJcbiAgICAgIC8vIGVsc2UgaXQncyBlbm91Z2ggdG8gc2VwYXJhdGUgcjAgYW5kIHIxIHdpdGggcjAgYXhpcyBvbmx5IVxyXG4gICAgICBheGVzLnB1c2goXHJcbiAgICAgICAgdG9BeGlzKHIxWzBdLCByMVsxXSksXHJcbiAgICAgICAgdG9BeGlzKHIxWzBdLCByMVszXSlcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICBwcjAgPSBwcm9qZWN0ZWQocjAsIGF4ZXNbaV0pO1xyXG4gICAgICBwcjEgPSBwcm9qZWN0ZWQocjEsIGF4ZXNbaV0pO1xyXG5cclxuICAgICAgaWYgKHByMC5tYXggPCBwcjEubWluIHx8IHByMS5tYXggPCBwcjAubWluKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcG9pbnRzOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICB2YXIgcmVjdCA9IG1lLl9yZWN0O1xyXG4gICAgdmFyIGFuZ2xlID0gbWUuX3JvdGF0aW9uO1xyXG4gICAgdmFyIGNlbnRlciA9IG1lLmNlbnRlcigpO1xyXG5cclxuICAgIHJldHVybiBbXHJcbiAgICAgIHJvdGF0ZWQoe3g6IHJlY3QueCwgeTogcmVjdC55fSwgY2VudGVyLCBhbmdsZSksXHJcbiAgICAgIHJvdGF0ZWQoe3g6IHJlY3QueCArIHJlY3QudywgeTogcmVjdC55fSwgY2VudGVyLCBhbmdsZSksXHJcbiAgICAgIHJvdGF0ZWQoe3g6IHJlY3QueCArIHJlY3QudywgeTogcmVjdC55ICsgcmVjdC5ofSwgY2VudGVyLCBhbmdsZSksXHJcbiAgICAgIHJvdGF0ZWQoe3g6IHJlY3QueCwgeTogcmVjdC55ICsgcmVjdC5ofSwgY2VudGVyLCBhbmdsZSlcclxuICAgIF07XHJcbiAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGNvb3JkaW5hdGVzKGVsLCBtb2RlbCwgZ2VvbWV0cnkpIHtcclxuICB2YXIgcG9pbnQgPSBtb2RlbC5wb3NpdGlvbmVyKGVsLCBtb2RlbCk7XHJcbiAgdmFyIHZ4ID0gcG9pbnQudng7XHJcbiAgdmFyIHZ5ID0gcG9pbnQudnk7XHJcblxyXG4gIGlmICghdnggJiYgIXZ5KSB7XHJcbiAgICAvLyBpZiBhbGlnbmVkIGNlbnRlciwgd2UgZG9uJ3Qgd2FudCB0byBvZmZzZXQgdGhlIGNlbnRlciBwb2ludFxyXG4gICAgcmV0dXJuIHt4OiBwb2ludC54LCB5OiBwb2ludC55fTtcclxuICB9XHJcblxyXG4gIHZhciB3ID0gZ2VvbWV0cnkudztcclxuICB2YXIgaCA9IGdlb21ldHJ5Lmg7XHJcblxyXG4gIC8vIHRha2UgaW4gYWNjb3VudCB0aGUgbGFiZWwgcm90YXRpb25cclxuICB2YXIgcm90YXRpb24gPSBtb2RlbC5yb3RhdGlvbjtcclxuICB2YXIgZHggPSBNYXRoLmFicyh3IC8gMiAqIE1hdGguY29zKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhoIC8gMiAqIE1hdGguc2luKHJvdGF0aW9uKSk7XHJcbiAgdmFyIGR5ID0gTWF0aC5hYnModyAvIDIgKiBNYXRoLnNpbihyb3RhdGlvbikpICsgTWF0aC5hYnMoaCAvIDIgKiBNYXRoLmNvcyhyb3RhdGlvbikpO1xyXG5cclxuICAvLyBzY2FsZSB0aGUgdW5pdCB2ZWN0b3IgKHZ4LCB2eSkgdG8gZ2V0IGF0IGxlYXN0IGR4IG9yIGR5IGVxdWFsIHRvXHJcbiAgLy8gdyBvciBoIHJlc3BlY3RpdmVseSAoZWxzZSB3ZSB3b3VsZCBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIHRvIHRoZVxyXG4gIC8vIGVsbGlwc2UgaW5zY3JpYmVkIGluIHRoZSBib3VuZGluZyByZWN0KVxyXG4gIHZhciB2cyA9IDEgLyBNYXRoLm1heChNYXRoLmFicyh2eCksIE1hdGguYWJzKHZ5KSk7XHJcbiAgZHggKj0gdnggKiB2cztcclxuICBkeSAqPSB2eSAqIHZzO1xyXG5cclxuICAvLyBmaW5hbGx5LCBpbmNsdWRlIHRoZSBleHBsaWNpdCBvZmZzZXRcclxuICBkeCArPSBtb2RlbC5vZmZzZXQgKiB2eDtcclxuICBkeSArPSBtb2RlbC5vZmZzZXQgKiB2eTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHg6IHBvaW50LnggKyBkeCxcclxuICAgIHk6IHBvaW50LnkgKyBkeVxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbGxpZGUobGFiZWxzLCBjb2xsaWRlcikge1xyXG4gIHZhciBpLCBqLCBzMCwgczE7XHJcblxyXG4gIC8vIElNUE9SVEFOVCBJdGVyYXRlIGluIHRoZSByZXZlcnNlIG9yZGVyIHNpbmNlIGl0ZW1zIGF0IHRoZSBlbmQgb2YgdGhlXHJcbiAgLy8gbGlzdCBoYXZlIGFuIGhpZ2hlciB3ZWlnaHQvcHJpb3JpdHkgYW5kIHRodXMgc2hvdWxkIGJlIGxlc3MgaW1wYWN0ZWRcclxuICAvLyBieSB0aGUgb3ZlcmxhcHBpbmcgc3RyYXRlZ3kuXHJcblxyXG4gIGZvciAoaSA9IGxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgczAgPSBsYWJlbHNbaV0uJGxheW91dDtcclxuXHJcbiAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwICYmIHMwLl92aXNpYmxlOyAtLWopIHtcclxuICAgICAgczEgPSBsYWJlbHNbal0uJGxheW91dDtcclxuXHJcbiAgICAgIGlmIChzMS5fdmlzaWJsZSAmJiBzMC5fYm94LmludGVyc2VjdHMoczEuX2JveCkpIHtcclxuICAgICAgICBjb2xsaWRlcihzMCwgczEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGFiZWxzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlKGxhYmVscykge1xyXG4gIHZhciBpLCBpbGVuLCBsYWJlbCwgc3RhdGUsIGdlb21ldHJ5LCBjZW50ZXIsIHByb3h5O1xyXG5cclxuICAvLyBJbml0aWFsaXplIGxhYmVscyBmb3Igb3ZlcmxhcCBkZXRlY3Rpb25cclxuICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgbGFiZWwgPSBsYWJlbHNbaV07XHJcbiAgICBzdGF0ZSA9IGxhYmVsLiRsYXlvdXQ7XHJcblxyXG4gICAgaWYgKHN0YXRlLl92aXNpYmxlKSB7XHJcbiAgICAgIC8vIENoYXJ0LmpzIDMgcmVtb3ZlZCBlbC5fbW9kZWwgaW4gZmF2b3Igb2YgZ2V0UHJvcHMoKSwgbWFraW5nIGhhcmRlciB0b1xyXG4gICAgICAvLyBhYnN0cmFjdCByZWFkaW5nIHZhbHVlcyBpbiBwb3NpdGlvbmVycy4gQWxzbywgdXNpbmcgc3RyaW5nIGFycmF5cyB0b1xyXG4gICAgICAvLyByZWFkIHZhbHVlcyAoaS5lLiB2YXIge2EsYixjfSA9IGVsLmdldFByb3BzKFtcImFcIixcImJcIixcImNcIl0pKSB3b3VsZCBtYWtlXHJcbiAgICAgIC8vIHBvc2l0aW9uZXJzIGluZWZmaWNpZW50IGluIHRoZSBub3JtYWwgY2FzZSAoaS5lLiBub3QgdGhlIGZpbmFsIHZhbHVlcylcclxuICAgICAgLy8gYW5kIHRoZSBjb2RlIGEgYml0IHVnbHksIHNvIGxldCdzIHVzZSBhIFByb3h5IGluc3RlYWQuXHJcbiAgICAgIHByb3h5ID0gbmV3IFByb3h5KGxhYmVsLl9lbCwge2dldDogKGVsLCBwKSA9PiBlbC5nZXRQcm9wcyhbcF0sIHRydWUpW3BdfSk7XHJcblxyXG4gICAgICBnZW9tZXRyeSA9IGxhYmVsLmdlb21ldHJ5KCk7XHJcbiAgICAgIGNlbnRlciA9IGNvb3JkaW5hdGVzKHByb3h5LCBsYWJlbC5tb2RlbCgpLCBnZW9tZXRyeSk7XHJcbiAgICAgIHN0YXRlLl9ib3gudXBkYXRlKGNlbnRlciwgZ2VvbWV0cnksIGxhYmVsLnJvdGF0aW9uKCkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQXV0byBoaWRlIG92ZXJsYXBwaW5nIGxhYmVsc1xyXG4gIHJldHVybiBjb2xsaWRlKGxhYmVscywgZnVuY3Rpb24oczAsIHMxKSB7XHJcbiAgICB2YXIgaDAgPSBzMC5faGlkYWJsZTtcclxuICAgIHZhciBoMSA9IHMxLl9oaWRhYmxlO1xyXG5cclxuICAgIGlmICgoaDAgJiYgaDEpIHx8IGgxKSB7XHJcbiAgICAgIHMxLl92aXNpYmxlID0gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKGgwKSB7XHJcbiAgICAgIHMwLl92aXNpYmxlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbnZhciBsYXlvdXQgPSB7XHJcbiAgcHJlcGFyZTogZnVuY3Rpb24oZGF0YXNldHMpIHtcclxuICAgIHZhciBsYWJlbHMgPSBbXTtcclxuICAgIHZhciBpLCBqLCBpbGVuLCBqbGVuLCBsYWJlbDtcclxuXHJcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBkYXRhc2V0c1tpXS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcclxuICAgICAgICBsYWJlbCA9IGRhdGFzZXRzW2ldW2pdO1xyXG4gICAgICAgIGxhYmVscy5wdXNoKGxhYmVsKTtcclxuICAgICAgICBsYWJlbC4kbGF5b3V0ID0ge1xyXG4gICAgICAgICAgX2JveDogbmV3IEhpdEJveCgpLFxyXG4gICAgICAgICAgX2hpZGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgX3Zpc2libGU6IHRydWUsXHJcbiAgICAgICAgICBfc2V0OiBpLFxyXG4gICAgICAgICAgX2lkeDogalxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPIE5ldyBgemAgb3B0aW9uOiBsYWJlbHMgd2l0aCBhIGhpZ2hlciB6LWluZGV4IGFyZSBkcmF3blxyXG4gICAgLy8gb2YgdG9wIG9mIHRoZSBvbmVzIHdpdGggYSBsb3dlciBpbmRleC4gTG93ZXN0IHotaW5kZXggbGFiZWxzXHJcbiAgICAvLyBhcmUgYWxzbyBkaXNjYXJkZWQgZmlyc3Qgd2hlbiBoaWRpbmcgb3ZlcmxhcHBpbmcgbGFiZWxzLlxyXG4gICAgbGFiZWxzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICB2YXIgc2EgPSBhLiRsYXlvdXQ7XHJcbiAgICAgIHZhciBzYiA9IGIuJGxheW91dDtcclxuXHJcbiAgICAgIHJldHVybiBzYS5faWR4ID09PSBzYi5faWR4XHJcbiAgICAgICAgPyBzYi5fc2V0IC0gc2EuX3NldFxyXG4gICAgICAgIDogc2IuX2lkeCAtIHNhLl9pZHg7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZShsYWJlbHMpO1xyXG5cclxuICAgIHJldHVybiBsYWJlbHM7XHJcbiAgfSxcclxuXHJcbiAgdXBkYXRlOiBmdW5jdGlvbihsYWJlbHMpIHtcclxuICAgIHZhciBkaXJ0eSA9IGZhbHNlO1xyXG4gICAgdmFyIGksIGlsZW4sIGxhYmVsLCBtb2RlbCwgc3RhdGU7XHJcblxyXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuICAgICAgbGFiZWwgPSBsYWJlbHNbaV07XHJcbiAgICAgIG1vZGVsID0gbGFiZWwubW9kZWwoKTtcclxuICAgICAgc3RhdGUgPSBsYWJlbC4kbGF5b3V0O1xyXG4gICAgICBzdGF0ZS5faGlkYWJsZSA9IG1vZGVsICYmIG1vZGVsLmRpc3BsYXkgPT09ICdhdXRvJztcclxuICAgICAgc3RhdGUuX3Zpc2libGUgPSBsYWJlbC52aXNpYmxlKCk7XHJcbiAgICAgIGRpcnR5IHw9IHN0YXRlLl9oaWRhYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkaXJ0eSkge1xyXG4gICAgICBjb21wdXRlKGxhYmVscyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgbG9va3VwOiBmdW5jdGlvbihsYWJlbHMsIHBvaW50KSB7XHJcbiAgICB2YXIgaSwgc3RhdGU7XHJcblxyXG4gICAgLy8gSU1QT1JUQU5UIEl0ZXJhdGUgaW4gdGhlIHJldmVyc2Ugb3JkZXIgc2luY2UgaXRlbXMgYXQgdGhlIGVuZCBvZlxyXG4gICAgLy8gdGhlIGxpc3QgaGF2ZSBhbiBoaWdoZXIgei1pbmRleCwgdGh1cyBzaG91bGQgYmUgcGlja2VkIGZpcnN0LlxyXG5cclxuICAgIGZvciAoaSA9IGxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICBzdGF0ZSA9IGxhYmVsc1tpXS4kbGF5b3V0O1xyXG5cclxuICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLl92aXNpYmxlICYmIHN0YXRlLl9ib3guY29udGFpbnMocG9pbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGxhYmVsc1tpXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0sXHJcblxyXG4gIGRyYXc6IGZ1bmN0aW9uKGNoYXJ0LCBsYWJlbHMpIHtcclxuICAgIHZhciBpLCBpbGVuLCBsYWJlbCwgc3RhdGUsIGdlb21ldHJ5LCBjZW50ZXI7XHJcblxyXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcclxuICAgICAgbGFiZWwgPSBsYWJlbHNbaV07XHJcbiAgICAgIHN0YXRlID0gbGFiZWwuJGxheW91dDtcclxuXHJcbiAgICAgIGlmIChzdGF0ZS5fdmlzaWJsZSkge1xyXG4gICAgICAgIGdlb21ldHJ5ID0gbGFiZWwuZ2VvbWV0cnkoKTtcclxuICAgICAgICBjZW50ZXIgPSBjb29yZGluYXRlcyhsYWJlbC5fZWwsIGxhYmVsLm1vZGVsKCksIGdlb21ldHJ5KTtcclxuICAgICAgICBzdGF0ZS5fYm94LnVwZGF0ZShjZW50ZXIsIGdlb21ldHJ5LCBsYWJlbC5yb3RhdGlvbigpKTtcclxuICAgICAgICBsYWJlbC5kcmF3KGNoYXJ0LCBjZW50ZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIGZvcm1hdHRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgaWYgKGhlbHBlcnMuaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgdmFyIGxhYmVsID0gdmFsdWU7XHJcbiAgdmFyIGtleXMsIGtsZW4sIGs7XHJcbiAgaWYgKGhlbHBlcnMuaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICBpZiAoIWhlbHBlcnMuaXNOdWxsT3JVbmRlZih2YWx1ZS5sYWJlbCkpIHtcclxuICAgICAgbGFiZWwgPSB2YWx1ZS5sYWJlbDtcclxuICAgIH0gZWxzZSBpZiAoIWhlbHBlcnMuaXNOdWxsT3JVbmRlZih2YWx1ZS5yKSkge1xyXG4gICAgICBsYWJlbCA9IHZhbHVlLnI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsYWJlbCA9ICcnO1xyXG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xyXG4gICAgICBmb3IgKGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcclxuICAgICAgICBsYWJlbCArPSAoayAhPT0gMCA/ICcsICcgOiAnJykgKyBrZXlzW2tdICsgJzogJyArIHZhbHVlW2tleXNba11dO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gJycgKyBsYWJlbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJTVBPUlRBTlQ6IG1ha2Ugc3VyZSB0byBhbHNvIHVwZGF0ZSB0ZXN0cyBhbmQgVHlwZVNjcmlwdCBkZWZpbml0aW9uXHJcbiAqIGZpbGVzIChgL3Rlc3Qvc3BlY3MvZGVmYXVsdHMuc3BlYy5qc2AgYW5kIGAvdHlwZXMvb3B0aW9ucy5kLnRzYClcclxuICovXHJcblxyXG52YXIgZGVmYXVsdHMgPSB7XHJcbiAgYWxpZ246ICdjZW50ZXInLFxyXG4gIGFuY2hvcjogJ2NlbnRlcicsXHJcbiAgYmFja2dyb3VuZENvbG9yOiBudWxsLFxyXG4gIGJvcmRlckNvbG9yOiBudWxsLFxyXG4gIGJvcmRlclJhZGl1czogMCxcclxuICBib3JkZXJXaWR0aDogMCxcclxuICBjbGFtcDogZmFsc2UsXHJcbiAgY2xpcDogZmFsc2UsXHJcbiAgY29sb3I6IHVuZGVmaW5lZCxcclxuICBkaXNwbGF5OiB0cnVlLFxyXG4gIGZvbnQ6IHtcclxuICAgIGZhbWlseTogdW5kZWZpbmVkLFxyXG4gICAgbGluZUhlaWdodDogMS4yLFxyXG4gICAgc2l6ZTogdW5kZWZpbmVkLFxyXG4gICAgc3R5bGU6IHVuZGVmaW5lZCxcclxuICAgIHdlaWdodDogbnVsbFxyXG4gIH0sXHJcbiAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXHJcbiAgbGFiZWxzOiB1bmRlZmluZWQsXHJcbiAgbGlzdGVuZXJzOiB7fSxcclxuICBvZmZzZXQ6IDQsXHJcbiAgb3BhY2l0eTogMSxcclxuICBwYWRkaW5nOiB7XHJcbiAgICB0b3A6IDQsXHJcbiAgICByaWdodDogNCxcclxuICAgIGJvdHRvbTogNCxcclxuICAgIGxlZnQ6IDRcclxuICB9LFxyXG4gIHJvdGF0aW9uOiAwLFxyXG4gIHRleHRBbGlnbjogJ3N0YXJ0JyxcclxuICB0ZXh0U3Ryb2tlQ29sb3I6IHVuZGVmaW5lZCxcclxuICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXHJcbiAgdGV4dFNoYWRvd0JsdXI6IDAsXHJcbiAgdGV4dFNoYWRvd0NvbG9yOiB1bmRlZmluZWRcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTc2XHJcbiAqL1xyXG5cclxudmFyIEVYUEFORE9fS0VZID0gJyRkYXRhbGFiZWxzJztcclxudmFyIERFRkFVTFRfS0VZID0gJyRkZWZhdWx0JztcclxuXHJcbmZ1bmN0aW9uIGNvbmZpZ3VyZShkYXRhc2V0LCBvcHRpb25zKSB7XHJcbiAgdmFyIG92ZXJyaWRlID0gZGF0YXNldC5kYXRhbGFiZWxzO1xyXG4gIHZhciBsaXN0ZW5lcnMgPSB7fTtcclxuICB2YXIgY29uZmlncyA9IFtdO1xyXG4gIHZhciBsYWJlbHMsIGtleXM7XHJcblxyXG4gIGlmIChvdmVycmlkZSA9PT0gZmFsc2UpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHtcclxuICAgIG92ZXJyaWRlID0ge307XHJcbiAgfVxyXG5cclxuICBvcHRpb25zID0gaGVscGVycy5tZXJnZSh7fSwgW29wdGlvbnMsIG92ZXJyaWRlXSk7XHJcbiAgbGFiZWxzID0gb3B0aW9ucy5sYWJlbHMgfHwge307XHJcbiAga2V5cyA9IE9iamVjdC5rZXlzKGxhYmVscyk7XHJcbiAgZGVsZXRlIG9wdGlvbnMubGFiZWxzO1xyXG5cclxuICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuICAgICAgaWYgKGxhYmVsc1trZXldKSB7XHJcbiAgICAgICAgY29uZmlncy5wdXNoKGhlbHBlcnMubWVyZ2Uoe30sIFtcclxuICAgICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgICBsYWJlbHNba2V5XSxcclxuICAgICAgICAgIHtfa2V5OiBrZXl9XHJcbiAgICAgICAgXSkpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gRGVmYXVsdCBsYWJlbCBpZiBubyBcIm5hbWVkXCIgbGFiZWwgZGVmaW5lZC5cclxuICAgIGNvbmZpZ3MucHVzaChvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8vIGxpc3RlbmVyczogezxldmVudC10eXBlPjogezxsYWJlbC1rZXk+OiA8Zm4+fX1cclxuICBsaXN0ZW5lcnMgPSBjb25maWdzLnJlZHVjZShmdW5jdGlvbih0YXJnZXQsIGNvbmZpZykge1xyXG4gICAgaGVscGVycy5lYWNoKGNvbmZpZy5saXN0ZW5lcnMgfHwge30sIGZ1bmN0aW9uKGZuLCBldmVudCkge1xyXG4gICAgICB0YXJnZXRbZXZlbnRdID0gdGFyZ2V0W2V2ZW50XSB8fCB7fTtcclxuICAgICAgdGFyZ2V0W2V2ZW50XVtjb25maWcuX2tleSB8fCBERUZBVUxUX0tFWV0gPSBmbjtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlbGV0ZSBjb25maWcubGlzdGVuZXJzO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxuICB9LCB7fSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBsYWJlbHM6IGNvbmZpZ3MsXHJcbiAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoY2hhcnQsIGxpc3RlbmVycywgbGFiZWwpIHtcclxuICBpZiAoIWxpc3RlbmVycykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdmFyIGNvbnRleHQgPSBsYWJlbC4kY29udGV4dDtcclxuICB2YXIgZ3JvdXBzID0gbGFiZWwuJGdyb3VwcztcclxuICB2YXIgY2FsbGJhY2s7XHJcblxyXG4gIGlmICghbGlzdGVuZXJzW2dyb3Vwcy5fc2V0XSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY2FsbGJhY2sgPSBsaXN0ZW5lcnNbZ3JvdXBzLl9zZXRdW2dyb3Vwcy5fa2V5XTtcclxuICBpZiAoIWNhbGxiYWNrKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoaGVscGVycy5jYWxsYmFjayhjYWxsYmFjaywgW2NvbnRleHRdKSA9PT0gdHJ1ZSkge1xyXG4gICAgLy8gVXNlcnMgYXJlIGFsbG93ZWQgdG8gdHdlYWsgdGhlIGdpdmVuIGNvbnRleHQgYnkgaW5qZWN0aW5nIHZhbHVlcyB0aGF0IGNhbiBiZVxyXG4gICAgLy8gdXNlZCBpbiBzY3JpcHRhYmxlIG9wdGlvbnMgdG8gZGlzcGxheSBsYWJlbHMgZGlmZmVyZW50bHkgYmFzZWQgb24gdGhlIGN1cnJlbnRcclxuICAgIC8vIGV2ZW50IChlLmcuIGhpZ2hsaWdodCBhbiBob3ZlcmVkIGxhYmVsKS4gVGhhdCdzIHdoeSB3ZSB1cGRhdGUgdGhlIGxhYmVsIHdpdGhcclxuICAgIC8vIHRoZSBvdXRwdXQgY29udGV4dCBhbmQgc2NoZWR1bGUgYSBuZXcgY2hhcnQgcmVuZGVyIGJ5IHNldHRpbmcgaXQgZGlydHkuXHJcbiAgICBjaGFydFtFWFBBTkRPX0tFWV0uX2RpcnR5ID0gdHJ1ZTtcclxuICAgIGxhYmVsLnVwZGF0ZShjb250ZXh0KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc3BhdGNoTW92ZUV2ZW50cyhjaGFydCwgbGlzdGVuZXJzLCBwcmV2aW91cywgbGFiZWwpIHtcclxuICB2YXIgZW50ZXIsIGxlYXZlO1xyXG5cclxuICBpZiAoIXByZXZpb3VzICYmICFsYWJlbCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFwcmV2aW91cykge1xyXG4gICAgZW50ZXIgPSB0cnVlO1xyXG4gIH0gZWxzZSBpZiAoIWxhYmVsKSB7XHJcbiAgICBsZWF2ZSA9IHRydWU7XHJcbiAgfSBlbHNlIGlmIChwcmV2aW91cyAhPT0gbGFiZWwpIHtcclxuICAgIGxlYXZlID0gZW50ZXIgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKGxlYXZlKSB7XHJcbiAgICBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBsaXN0ZW5lcnMubGVhdmUsIHByZXZpb3VzKTtcclxuICB9XHJcbiAgaWYgKGVudGVyKSB7XHJcbiAgICBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBsaXN0ZW5lcnMuZW50ZXIsIGxhYmVsKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZU1vdmVFdmVudHMoY2hhcnQsIGV2ZW50KSB7XHJcbiAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XHJcbiAgdmFyIGxpc3RlbmVycyA9IGV4cGFuZG8uX2xpc3RlbmVycztcclxuICB2YXIgcHJldmlvdXMsIGxhYmVsO1xyXG5cclxuICBpZiAoIWxpc3RlbmVycy5lbnRlciAmJiAhbGlzdGVuZXJzLmxlYXZlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcclxuICAgIGxhYmVsID0gbGF5b3V0Lmxvb2t1cChleHBhbmRvLl9sYWJlbHMsIGV2ZW50KTtcclxuICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgIT09ICdtb3VzZW91dCcpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHByZXZpb3VzID0gZXhwYW5kby5faG92ZXJlZDtcclxuICBleHBhbmRvLl9ob3ZlcmVkID0gbGFiZWw7XHJcbiAgZGlzcGF0Y2hNb3ZlRXZlbnRzKGNoYXJ0LCBsaXN0ZW5lcnMsIHByZXZpb3VzLCBsYWJlbCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUNsaWNrRXZlbnRzKGNoYXJ0LCBldmVudCkge1xyXG4gIHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xyXG4gIHZhciBoYW5kbGVycyA9IGV4cGFuZG8uX2xpc3RlbmVycy5jbGljaztcclxuICB2YXIgbGFiZWwgPSBoYW5kbGVycyAmJiBsYXlvdXQubG9va3VwKGV4cGFuZG8uX2xhYmVscywgZXZlbnQpO1xyXG4gIGlmIChsYWJlbCkge1xyXG4gICAgZGlzcGF0Y2hFdmVudChjaGFydCwgaGFuZGxlcnMsIGxhYmVsKTtcclxuICB9XHJcbn1cclxuXHJcbnZhciBwbHVnaW4gPSB7XHJcbiAgaWQ6ICdkYXRhbGFiZWxzJyxcclxuXHJcbiAgZGVmYXVsdHM6IGRlZmF1bHRzLFxyXG5cclxuICBiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xyXG4gICAgY2hhcnRbRVhQQU5ET19LRVldID0ge1xyXG4gICAgICBfYWN0aXZlczogW11cclxuICAgIH07XHJcbiAgfSxcclxuXHJcbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xyXG4gICAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XHJcbiAgICBleHBhbmRvLl9saXN0ZW5lZCA9IGZhbHNlO1xyXG4gICAgZXhwYW5kby5fbGlzdGVuZXJzID0ge307ICAgICAvLyB7PGV2ZW50LXR5cGU+OiB7PGRhdGFzZXQtaW5kZXg+OiB7PGxhYmVsLWtleT46IDxmbj59fX1cclxuICAgIGV4cGFuZG8uX2RhdGFzZXRzID0gW107ICAgICAgLy8gcGVyIGRhdGFzZXQgbGFiZWxzOiBbTGFiZWxbXV1cclxuICAgIGV4cGFuZG8uX2xhYmVscyA9IFtdOyAgICAgICAgLy8gbGF5b3V0ZWQgbGFiZWxzOiBMYWJlbFtdXHJcbiAgfSxcclxuXHJcbiAgYWZ0ZXJEYXRhc2V0VXBkYXRlOiBmdW5jdGlvbihjaGFydCwgYXJncywgb3B0aW9ucykge1xyXG4gICAgdmFyIGRhdGFzZXRJbmRleCA9IGFyZ3MuaW5kZXg7XHJcbiAgICB2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcclxuICAgIHZhciBsYWJlbHMgPSBleHBhbmRvLl9kYXRhc2V0c1tkYXRhc2V0SW5kZXhdID0gW107XHJcbiAgICB2YXIgdmlzaWJsZSA9IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KTtcclxuICAgIHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xyXG4gICAgdmFyIGNvbmZpZyA9IGNvbmZpZ3VyZShkYXRhc2V0LCBvcHRpb25zKTtcclxuICAgIHZhciBlbGVtZW50cyA9IGFyZ3MubWV0YS5kYXRhIHx8IFtdO1xyXG4gICAgdmFyIGN0eCA9IGNoYXJ0LmN0eDtcclxuICAgIHZhciBpLCBqLCBpbGVuLCBqbGVuLCBjZmcsIGtleSwgZWwsIGxhYmVsO1xyXG5cclxuICAgIGN0eC5zYXZlKCk7XHJcblxyXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xyXG4gICAgICBlbCA9IGVsZW1lbnRzW2ldO1xyXG4gICAgICBlbFtFWFBBTkRPX0tFWV0gPSBbXTtcclxuXHJcbiAgICAgIGlmICh2aXNpYmxlICYmIGVsICYmIGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFlbC5za2lwKSB7XHJcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGNvbmZpZy5sYWJlbHMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XHJcbiAgICAgICAgICBjZmcgPSBjb25maWcubGFiZWxzW2pdO1xyXG4gICAgICAgICAga2V5ID0gY2ZnLl9rZXk7XHJcblxyXG4gICAgICAgICAgbGFiZWwgPSBuZXcgTGFiZWwoY2ZnLCBjdHgsIGVsLCBpKTtcclxuICAgICAgICAgIGxhYmVsLiRncm91cHMgPSB7XHJcbiAgICAgICAgICAgIF9zZXQ6IGRhdGFzZXRJbmRleCxcclxuICAgICAgICAgICAgX2tleToga2V5IHx8IERFRkFVTFRfS0VZXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgbGFiZWwuJGNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNoYXJ0OiBjaGFydCxcclxuICAgICAgICAgICAgZGF0YUluZGV4OiBpLFxyXG4gICAgICAgICAgICBkYXRhc2V0OiBkYXRhc2V0LFxyXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICBsYWJlbC51cGRhdGUobGFiZWwuJGNvbnRleHQpO1xyXG4gICAgICAgICAgZWxbRVhQQU5ET19LRVldLnB1c2gobGFiZWwpO1xyXG4gICAgICAgICAgbGFiZWxzLnB1c2gobGFiZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGN0eC5yZXN0b3JlKCk7XHJcblxyXG4gICAgLy8gU3RvcmUgbGlzdGVuZXJzIGF0IHRoZSBjaGFydCBsZXZlbCBhbmQgcGVyIGV2ZW50IHR5cGUgdG8gb3B0aW1pemVcclxuICAgIC8vIGNhc2VzIHdoZXJlIG5vIGxpc3RlbmVycyBhcmUgcmVnaXN0ZXJlZCBmb3IgYSBzcGVjaWZpYyBldmVudC5cclxuICAgIGhlbHBlcnMubWVyZ2UoZXhwYW5kby5fbGlzdGVuZXJzLCBjb25maWcubGlzdGVuZXJzLCB7XHJcbiAgICAgIG1lcmdlcjogZnVuY3Rpb24oZXZlbnQsIHRhcmdldCwgc291cmNlKSB7XHJcbiAgICAgICAgdGFyZ2V0W2V2ZW50XSA9IHRhcmdldFtldmVudF0gfHwge307XHJcbiAgICAgICAgdGFyZ2V0W2V2ZW50XVthcmdzLmluZGV4XSA9IHNvdXJjZVtldmVudF07XHJcbiAgICAgICAgZXhwYW5kby5fbGlzdGVuZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBhZnRlclVwZGF0ZTogZnVuY3Rpb24oY2hhcnQsIG9wdGlvbnMpIHtcclxuICAgIGNoYXJ0W0VYUEFORE9fS0VZXS5fbGFiZWxzID0gbGF5b3V0LnByZXBhcmUoXHJcbiAgICAgIGNoYXJ0W0VYUEFORE9fS0VZXS5fZGF0YXNldHMsXHJcbiAgICAgIG9wdGlvbnMpO1xyXG4gIH0sXHJcblxyXG4gIC8vIERyYXcgbGFiZWxzIG9uIHRvcCBvZiBhbGwgZGF0YXNldCBlbGVtZW50c1xyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzI5XHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvMzJcclxuICBhZnRlckRhdGFzZXRzRHJhdzogZnVuY3Rpb24oY2hhcnQpIHtcclxuICAgIGxheW91dC5kcmF3KGNoYXJ0LCBjaGFydFtFWFBBTkRPX0tFWV0uX2xhYmVscyk7XHJcbiAgfSxcclxuXHJcbiAgYmVmb3JlRXZlbnQ6IGZ1bmN0aW9uKGNoYXJ0LCBhcmdzKSB7XHJcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBsaXN0ZW5lciByZWdpc3RlcmVkIGZvciB0aGlzIGNoYXJ0LCBgbGlzdGVuZWRgIHdpbGwgYmUgZmFsc2UsXHJcbiAgICAvLyBtZWFuaW5nIHdlIGNhbiBpbW1lZGlhdGVseSBpZ25vcmUgdGhlIGluY29taW5nIGV2ZW50IGFuZCBhdm9pZCB1c2VsZXNzIGV4dHJhXHJcbiAgICAvLyBjb21wdXRhdGlvbiBmb3IgdXNlcnMgd2hvIGRvbid0IGltcGxlbWVudCBsYWJlbCBpbnRlcmFjdGlvbnMuXHJcbiAgICBpZiAoY2hhcnRbRVhQQU5ET19LRVldLl9saXN0ZW5lZCkge1xyXG4gICAgICB2YXIgZXZlbnQgPSBhcmdzLmV2ZW50O1xyXG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcclxuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcclxuICAgICAgY2FzZSAnbW91c2VvdXQnOlxyXG4gICAgICAgIGhhbmRsZU1vdmVFdmVudHMoY2hhcnQsIGV2ZW50KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnY2xpY2snOlxyXG4gICAgICAgIGhhbmRsZUNsaWNrRXZlbnRzKGNoYXJ0LCBldmVudCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuICBhZnRlckV2ZW50OiBmdW5jdGlvbihjaGFydCkge1xyXG4gICAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XHJcbiAgICB2YXIgcHJldmlvdXMgPSBleHBhbmRvLl9hY3RpdmVzO1xyXG4gICAgdmFyIGFjdGl2ZXMgPSBleHBhbmRvLl9hY3RpdmVzID0gY2hhcnQuZ2V0QWN0aXZlRWxlbWVudHMoKTtcclxuICAgIHZhciB1cGRhdGVzID0gdXRpbHMuYXJyYXlEaWZmKHByZXZpb3VzLCBhY3RpdmVzKTtcclxuICAgIHZhciBpLCBpbGVuLCBqLCBqbGVuLCB1cGRhdGUsIGxhYmVsLCBsYWJlbHM7XHJcblxyXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHVwZGF0ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XHJcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZXNbaV07XHJcbiAgICAgIGlmICh1cGRhdGVbMV0pIHtcclxuICAgICAgICBsYWJlbHMgPSB1cGRhdGVbMF0uZWxlbWVudFtFWFBBTkRPX0tFWV0gfHwgW107XHJcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVscy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcclxuICAgICAgICAgIGxhYmVsID0gbGFiZWxzW2pdO1xyXG4gICAgICAgICAgbGFiZWwuJGNvbnRleHQuYWN0aXZlID0gKHVwZGF0ZVsxXSA9PT0gMSk7XHJcbiAgICAgICAgICBsYWJlbC51cGRhdGUobGFiZWwuJGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChleHBhbmRvLl9kaXJ0eSB8fCB1cGRhdGVzLmxlbmd0aCkge1xyXG4gICAgICBsYXlvdXQudXBkYXRlKGV4cGFuZG8uX2xhYmVscyk7XHJcbiAgICAgIGNoYXJ0LnJlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlbGV0ZSBleHBhbmRvLl9kaXJ0eTtcclxuICB9XHJcbn07XHJcblxyXG5yZXR1cm4gcGx1Z2luO1xyXG5cclxufSkpKTtcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG4gIHZhciBQb2x5ZmlsbEV2ZW50ID0gZXZlbnRDb25zdHJ1Y3RvcigpO1xyXG5cclxuICBmdW5jdGlvbiBldmVudENvbnN0cnVjdG9yKCkge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHdpbmRvdy5DdXN0b21FdmVudDtcclxuICAgIC8vIElFPD05IFN1cHBvcnRcclxuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcclxuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHtidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkfTtcclxuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xyXG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xyXG4gICAgICByZXR1cm4gZXZ0O1xyXG4gICAgfVxyXG4gICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcclxuICAgIHJldHVybiBDdXN0b21FdmVudDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGJ1aWxkSGlkZGVuSW5wdXQobmFtZSwgdmFsdWUpIHtcclxuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcclxuICAgIGlucHV0LnR5cGUgPSBcImhpZGRlblwiO1xyXG4gICAgaW5wdXQubmFtZSA9IG5hbWU7XHJcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIGlucHV0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZWxlbWVudCwgdGFyZ2V0TW9kaWZpZXJLZXkpIHtcclxuICAgIHZhciB0byA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10b1wiKSxcclxuICAgICAgICBtZXRob2QgPSBidWlsZEhpZGRlbklucHV0KFwiX21ldGhvZFwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSxcclxuICAgICAgICBjc3JmID0gYnVpbGRIaWRkZW5JbnB1dChcIl9jc3JmX3Rva2VuXCIsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jc3JmXCIpKSxcclxuICAgICAgICBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXHJcbiAgICAgICAgdGFyZ2V0ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7XHJcblxyXG4gICAgZm9ybS5tZXRob2QgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSA9PT0gXCJnZXRcIikgPyBcImdldFwiIDogXCJwb3N0XCI7XHJcbiAgICBmb3JtLmFjdGlvbiA9IHRvO1xyXG4gICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJoaWRkZW5cIjtcclxuXHJcbiAgICBpZiAodGFyZ2V0KSBmb3JtLnRhcmdldCA9IHRhcmdldDtcclxuICAgIGVsc2UgaWYgKHRhcmdldE1vZGlmaWVyS2V5KSBmb3JtLnRhcmdldCA9IFwiX2JsYW5rXCI7XHJcblxyXG4gICAgZm9ybS5hcHBlbmRDaGlsZChjc3JmKTtcclxuICAgIGZvcm0uYXBwZW5kQ2hpbGQobWV0aG9kKTtcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XHJcbiAgICBmb3JtLnN1Ym1pdCgpO1xyXG4gIH1cclxuXHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgZWxlbWVudCA9IGUudGFyZ2V0O1xyXG4gICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xyXG5cclxuICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKSB7XHJcbiAgICAgIHZhciBwaG9lbml4TGlua0V2ZW50ID0gbmV3IFBvbHlmaWxsRXZlbnQoJ3Bob2VuaXgubGluay5jbGljaycsIHtcclxuICAgICAgICBcImJ1YmJsZXNcIjogdHJ1ZSwgXCJjYW5jZWxhYmxlXCI6IHRydWVcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIWVsZW1lbnQuZGlzcGF0Y2hFdmVudChwaG9lbml4TGlua0V2ZW50KSkge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikpIHtcclxuICAgICAgICBoYW5kbGVDbGljayhlbGVtZW50LCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSk7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgZmFsc2UpO1xyXG5cclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGhvZW5peC5saW5rLmNsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuICAgIHZhciBtZXNzYWdlID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb25maXJtXCIpO1xyXG4gICAgaWYobWVzc2FnZSAmJiAhd2luZG93LmNvbmZpcm0obWVzc2FnZSkpIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG4gIH0sIGZhbHNlKTtcclxufSkoKTtcclxuIiwgIi8vIHdyYXBzIHZhbHVlIGluIGNsb3N1cmUgb3IgcmV0dXJucyBjbG9zdXJlXG5leHBvcnQgbGV0IGNsb3N1cmUgPSAodmFsdWUpID0+IHtcbiAgaWYodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpe1xuICAgIHJldHVybiB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIGxldCBjbG9zdXJlID0gZnVuY3Rpb24gKCl7IHJldHVybiB2YWx1ZSB9XG4gICAgcmV0dXJuIGNsb3N1cmVcbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBnbG9iYWxTZWxmID0gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogbnVsbFxuZXhwb3J0IGNvbnN0IHBoeFdpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBudWxsXG5leHBvcnQgY29uc3QgZ2xvYmFsID0gZ2xvYmFsU2VsZiB8fCBwaHhXaW5kb3cgfHwgdGhpc1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVlNOID0gXCIyLjAuMFwiXG5leHBvcnQgY29uc3QgU09DS0VUX1NUQVRFUyA9IHtjb25uZWN0aW5nOiAwLCBvcGVuOiAxLCBjbG9zaW5nOiAyLCBjbG9zZWQ6IDN9XG5leHBvcnQgY29uc3QgREVGQVVMVF9USU1FT1VUID0gMTAwMDBcbmV4cG9ydCBjb25zdCBXU19DTE9TRV9OT1JNQUwgPSAxMDAwXG5leHBvcnQgY29uc3QgQ0hBTk5FTF9TVEFURVMgPSB7XG4gIGNsb3NlZDogXCJjbG9zZWRcIixcbiAgZXJyb3JlZDogXCJlcnJvcmVkXCIsXG4gIGpvaW5lZDogXCJqb2luZWRcIixcbiAgam9pbmluZzogXCJqb2luaW5nXCIsXG4gIGxlYXZpbmc6IFwibGVhdmluZ1wiLFxufVxuZXhwb3J0IGNvbnN0IENIQU5ORUxfRVZFTlRTID0ge1xuICBjbG9zZTogXCJwaHhfY2xvc2VcIixcbiAgZXJyb3I6IFwicGh4X2Vycm9yXCIsXG4gIGpvaW46IFwicGh4X2pvaW5cIixcbiAgcmVwbHk6IFwicGh4X3JlcGx5XCIsXG4gIGxlYXZlOiBcInBoeF9sZWF2ZVwiXG59XG5cbmV4cG9ydCBjb25zdCBUUkFOU1BPUlRTID0ge1xuICBsb25ncG9sbDogXCJsb25ncG9sbFwiLFxuICB3ZWJzb2NrZXQ6IFwid2Vic29ja2V0XCJcbn1cbmV4cG9ydCBjb25zdCBYSFJfU1RBVEVTID0ge1xuICBjb21wbGV0ZTogNFxufVxuIiwgIi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIFB1c2hcbiAqIEBwYXJhbSB7Q2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBDaGFubmVsXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQsIGZvciBleGFtcGxlIGBcInBoeF9qb2luXCJgXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkLCBmb3IgZXhhbXBsZSBge3VzZXJfaWQ6IDEyM31gXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCAtIFRoZSBwdXNoIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1c2gge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsLCBldmVudCwgcGF5bG9hZCwgdGltZW91dCl7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbFxuICAgIHRoaXMuZXZlbnQgPSBldmVudFxuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQgfHwgZnVuY3Rpb24gKCl7IHJldHVybiB7fSB9XG4gICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbFxuICAgIHRoaXMucmVjSG9va3MgPSBbXVxuICAgIHRoaXMuc2VudCA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAgICovXG4gIHJlc2VuZCh0aW1lb3V0KXtcbiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgdGhpcy5yZXNldCgpXG4gICAgdGhpcy5zZW5kKClcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgc2VuZCgpe1xuICAgIGlmKHRoaXMuaGFzUmVjZWl2ZWQoXCJ0aW1lb3V0XCIpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnN0YXJ0VGltZW91dCgpXG4gICAgdGhpcy5zZW50ID0gdHJ1ZVxuICAgIHRoaXMuY2hhbm5lbC5zb2NrZXQucHVzaCh7XG4gICAgICB0b3BpYzogdGhpcy5jaGFubmVsLnRvcGljLFxuICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICBwYXlsb2FkOiB0aGlzLnBheWxvYWQoKSxcbiAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHsqfSBzdGF0dXNcbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcmVjZWl2ZShzdGF0dXMsIGNhbGxiYWNrKXtcbiAgICBpZih0aGlzLmhhc1JlY2VpdmVkKHN0YXR1cykpe1xuICAgICAgY2FsbGJhY2sodGhpcy5yZWNlaXZlZFJlc3AucmVzcG9uc2UpXG4gICAgfVxuXG4gICAgdGhpcy5yZWNIb29rcy5wdXNoKHtzdGF0dXMsIGNhbGxiYWNrfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNldCgpe1xuICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKVxuICAgIHRoaXMucmVmID0gbnVsbFxuICAgIHRoaXMucmVmRXZlbnQgPSBudWxsXG4gICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsXG4gICAgdGhpcy5zZW50ID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbWF0Y2hSZWNlaXZlKHtzdGF0dXMsIHJlc3BvbnNlLCBfcmVmfSl7XG4gICAgdGhpcy5yZWNIb29rcy5maWx0ZXIoaCA9PiBoLnN0YXR1cyA9PT0gc3RhdHVzKVxuICAgICAgLmZvckVhY2goaCA9PiBoLmNhbGxiYWNrKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuY2VsUmVmRXZlbnQoKXtcbiAgICBpZighdGhpcy5yZWZFdmVudCl7IHJldHVybiB9XG4gICAgdGhpcy5jaGFubmVsLm9mZih0aGlzLnJlZkV2ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWxUaW1lb3V0KCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKVxuICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGFydFRpbWVvdXQoKXtcbiAgICBpZih0aGlzLnRpbWVvdXRUaW1lcil7IHRoaXMuY2FuY2VsVGltZW91dCgpIH1cbiAgICB0aGlzLnJlZiA9IHRoaXMuY2hhbm5lbC5zb2NrZXQubWFrZVJlZigpXG4gICAgdGhpcy5yZWZFdmVudCA9IHRoaXMuY2hhbm5lbC5yZXBseUV2ZW50TmFtZSh0aGlzLnJlZilcblxuICAgIHRoaXMuY2hhbm5lbC5vbih0aGlzLnJlZkV2ZW50LCBwYXlsb2FkID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKVxuICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KClcbiAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gcGF5bG9hZFxuICAgICAgdGhpcy5tYXRjaFJlY2VpdmUocGF5bG9hZClcbiAgICB9KVxuXG4gICAgdGhpcy50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihcInRpbWVvdXRcIiwge30pXG4gICAgfSwgdGhpcy50aW1lb3V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXNSZWNlaXZlZChzdGF0dXMpe1xuICAgIHJldHVybiB0aGlzLnJlY2VpdmVkUmVzcCAmJiB0aGlzLnJlY2VpdmVkUmVzcC5zdGF0dXMgPT09IHN0YXR1c1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0cmlnZ2VyKHN0YXR1cywgcmVzcG9uc2Upe1xuICAgIHRoaXMuY2hhbm5lbC50cmlnZ2VyKHRoaXMucmVmRXZlbnQsIHtzdGF0dXMsIHJlc3BvbnNlfSlcbiAgfVxufVxuIiwgIi8qKlxuICpcbiAqIENyZWF0ZXMgYSB0aW1lciB0aGF0IGFjY2VwdHMgYSBgdGltZXJDYWxjYCBmdW5jdGlvbiB0byBwZXJmb3JtXG4gKiBjYWxjdWxhdGVkIHRpbWVvdXQgcmV0cmllcywgc3VjaCBhcyBleHBvbmVudGlhbCBiYWNrb2ZmLlxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgcmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5jb25uZWN0KCksIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICogfSlcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDUwMDBcbiAqIHJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAqIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gdGltZXJDYWxjXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVyIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2ssIHRpbWVyQ2FsYyl7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy50aW1lckNhbGMgPSB0aW1lckNhbGNcbiAgICB0aGlzLnRpbWVyID0gbnVsbFxuICAgIHRoaXMudHJpZXMgPSAwXG4gIH1cblxuICByZXNldCgpe1xuICAgIHRoaXMudHJpZXMgPSAwXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpXG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VscyBhbnkgcHJldmlvdXMgc2NoZWR1bGVUaW1lb3V0IGFuZCBzY2hlZHVsZXMgY2FsbGJhY2tcbiAgICovXG4gIHNjaGVkdWxlVGltZW91dCgpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuXG4gICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxXG4gICAgICB0aGlzLmNhbGxiYWNrKClcbiAgICB9LCB0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzICsgMSkpXG4gIH1cbn1cbiIsICJpbXBvcnQge2Nsb3N1cmV9IGZyb20gXCIuL3V0aWxzXCJcbmltcG9ydCB7XG4gIENIQU5ORUxfRVZFTlRTLFxuICBDSEFOTkVMX1NUQVRFUyxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IFB1c2ggZnJvbSBcIi4vcHVzaFwiXG5pbXBvcnQgVGltZXIgZnJvbSBcIi4vdGltZXJcIlxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAqIEBwYXJhbSB7KE9iamVjdHxmdW5jdGlvbil9IHBhcmFtc1xuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFubmVsIHtcbiAgY29uc3RydWN0b3IodG9waWMsIHBhcmFtcywgc29ja2V0KXtcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkXG4gICAgdGhpcy50b3BpYyA9IHRvcGljXG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyB8fCB7fSlcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldFxuICAgIHRoaXMuYmluZGluZ3MgPSBbXVxuICAgIHRoaXMuYmluZGluZ1JlZiA9IDBcbiAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0XG4gICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2VcbiAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMuam9pbiwgdGhpcy5wYXJhbXMsIHRoaXMudGltZW91dClcbiAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzID0gW11cblxuICAgIHRoaXMucmVqb2luVGltZXIgPSBuZXcgVGltZXIoKCkgPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luKCkgfVxuICAgIH0sIHRoaXMuc29ja2V0LnJlam9pbkFmdGVyTXMpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZVJlZnMucHVzaCh0aGlzLnNvY2tldC5vbkVycm9yKCgpID0+IHRoaXMucmVqb2luVGltZXIucmVzZXQoKSkpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZVJlZnMucHVzaCh0aGlzLnNvY2tldC5vbk9wZW4oKCkgPT4ge1xuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICBpZih0aGlzLmlzRXJyb3JlZCgpKXsgdGhpcy5yZWpvaW4oKSB9XG4gICAgfSlcbiAgICApXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwib2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5lZFxuICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaChwdXNoRXZlbnQgPT4gcHVzaEV2ZW50LnNlbmQoKSlcbiAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdXG4gICAgfSlcbiAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5vbkNsb3NlKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGNsb3NlICR7dGhpcy50b3BpY30gJHt0aGlzLmpvaW5SZWYoKX1gKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlKHRoaXMpXG4gICAgfSlcbiAgICB0aGlzLm9uRXJyb3IocmVhc29uID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKVxuICAgICAgaWYodGhpcy5pc0pvaW5pbmcoKSl7IHRoaXMuam9pblB1c2gucmVzZXQoKSB9XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgdGltZW91dCAke3RoaXMudG9waWN9ICgke3RoaXMuam9pblJlZigpfSlgLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpXG4gICAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aGlzLnRpbWVvdXQpXG4gICAgICBsZWF2ZVB1c2guc2VuZCgpXG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZFxuICAgICAgdGhpcy5qb2luUHVzaC5yZXNldCgpXG4gICAgICBpZih0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKSB9XG4gICAgfSlcbiAgICB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLnJlcGx5LCAocGF5bG9hZCwgcmVmKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIodGhpcy5yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogSm9pbiB0aGUgY2hhbm5lbFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHRpbWVvdXRcbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIGlmKHRoaXMuam9pbmVkT25jZSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmllZCB0byBqb2luIG11bHRpcGxlIHRpbWVzLiAnam9pbicgY2FuIG9ubHkgYmUgY2FsbGVkIGEgc2luZ2xlIHRpbWUgcGVyIGNoYW5uZWwgaW5zdGFuY2VcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZVxuICAgICAgdGhpcy5yZWpvaW4oKVxuICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2hcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSG9vayBpbnRvIGNoYW5uZWwgY2xvc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2xvc2UoY2FsbGJhY2spe1xuICAgIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIEhvb2sgaW50byBjaGFubmVsIGVycm9yc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25FcnJvcihjYWxsYmFjayl7XG4gICAgcmV0dXJuIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIHJlYXNvbiA9PiBjYWxsYmFjayhyZWFzb24pKVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgb24gY2hhbm5lbCBldmVudHNcbiAgICpcbiAgICogU3Vic2NyaXB0aW9uIHJldHVybnMgYSByZWYgY291bnRlciwgd2hpY2ggY2FuIGJlIHVzZWQgbGF0ZXIgdG9cbiAgICogdW5zdWJzY3JpYmUgdGhlIGV4YWN0IGV2ZW50IGxpc3RlbmVyXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlZjEgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fc3R1ZmYpXG4gICAqIGNvbnN0IHJlZjIgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fb3RoZXJfc3R1ZmYpXG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIiwgcmVmMSlcbiAgICogLy8gU2luY2UgdW5zdWJzY3JpcHRpb24sIGRvX3N0dWZmIHdvbid0IGZpcmUsXG4gICAqIC8vIHdoaWxlIGRvX290aGVyX3N0dWZmIHdpbGwga2VlcCBmaXJpbmcgb24gdGhlIFwiZXZlbnRcIlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge2ludGVnZXJ9IHJlZlxuICAgKi9cbiAgb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5iaW5kaW5nUmVmKytcbiAgICB0aGlzLmJpbmRpbmdzLnB1c2goe2V2ZW50LCByZWYsIGNhbGxiYWNrfSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIG9mZiBvZiBjaGFubmVsIGV2ZW50c1xuICAgKlxuICAgKiBVc2UgdGhlIHJlZiByZXR1cm5lZCBmcm9tIGEgY2hhbm5lbC5vbigpIHRvIHVuc3Vic2NyaWJlIG9uZVxuICAgKiBoYW5kbGVyLCBvciBwYXNzIG5vdGhpbmcgZm9yIHRoZSByZWYgdG8gdW5zdWJzY3JpYmUgYWxsXG4gICAqIGhhbmRsZXJzIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFVuc3Vic2NyaWJlIHRoZSBkb19zdHVmZiBoYW5kbGVyXG4gICAqIGNvbnN0IHJlZjEgPSBjaGFubmVsLm9uKFwiZXZlbnRcIiwgZG9fc3R1ZmYpXG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIiwgcmVmMSlcbiAgICpcbiAgICogLy8gVW5zdWJzY3JpYmUgYWxsIGhhbmRsZXJzIGZyb20gZXZlbnRcbiAgICogY2hhbm5lbC5vZmYoXCJldmVudFwiKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSByZWZcbiAgICovXG4gIG9mZihldmVudCwgcmVmKXtcbiAgICB0aGlzLmJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgIHJldHVybiAhKGJpbmQuZXZlbnQgPT09IGV2ZW50ICYmICh0eXBlb2YgcmVmID09PSBcInVuZGVmaW5lZFwiIHx8IHJlZiA9PT0gYmluZC5yZWYpKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhblB1c2goKXsgcmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5pc0pvaW5lZCgpIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBtZXNzYWdlIGBldmVudGAgdG8gcGhvZW5peCB3aXRoIHRoZSBwYXlsb2FkIGBwYXlsb2FkYC5cbiAgICogUGhvZW5peCByZWNlaXZlcyB0aGlzIGluIHRoZSBgaGFuZGxlX2luKGV2ZW50LCBwYXlsb2FkLCBzb2NrZXQpYFxuICAgKiBmdW5jdGlvbi4gaWYgcGhvZW5peCByZXBsaWVzIG9yIGl0IHRpbWVzIG91dCAoZGVmYXVsdCAxMDAwMG1zKSxcbiAgICogdGhlbiBvcHRpb25hbGx5IHRoZSByZXBseSBjYW4gYmUgcmVjZWl2ZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNoYW5uZWwucHVzaChcImV2ZW50XCIpXG4gICAqICAgLnJlY2VpdmUoXCJva1wiLCBwYXlsb2FkID0+IGNvbnNvbGUubG9nKFwicGhvZW5peCByZXBsaWVkOlwiLCBwYXlsb2FkKSlcbiAgICogICAucmVjZWl2ZShcImVycm9yXCIsIGVyciA9PiBjb25zb2xlLmxvZyhcInBob2VuaXggZXJyb3JlZFwiLCBlcnIpKVxuICAgKiAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiBjb25zb2xlLmxvZyhcInRpbWVkIG91dCBwdXNoaW5nXCIpKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0XVxuICAgKiBAcmV0dXJucyB7UHVzaH1cbiAgICovXG4gIHB1c2goZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpe1xuICAgIHBheWxvYWQgPSBwYXlsb2FkIHx8IHt9XG4gICAgaWYoIXRoaXMuam9pbmVkT25jZSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyaWVkIHRvIHB1c2ggJyR7ZXZlbnR9JyB0byAnJHt0aGlzLnRvcGljfScgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLmpvaW4oKSBiZWZvcmUgcHVzaGluZyBldmVudHNgKVxuICAgIH1cbiAgICBsZXQgcHVzaEV2ZW50ID0gbmV3IFB1c2godGhpcywgZXZlbnQsIGZ1bmN0aW9uICgpeyByZXR1cm4gcGF5bG9hZCB9LCB0aW1lb3V0KVxuICAgIGlmKHRoaXMuY2FuUHVzaCgpKXtcbiAgICAgIHB1c2hFdmVudC5zZW5kKClcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEV2ZW50LnN0YXJ0VGltZW91dCgpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIucHVzaChwdXNoRXZlbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHB1c2hFdmVudFxuICB9XG5cbiAgLyoqIExlYXZlcyB0aGUgY2hhbm5lbFxuICAgKlxuICAgKiBVbnN1YnNjcmliZXMgZnJvbSBzZXJ2ZXIgZXZlbnRzLCBhbmRcbiAgICogaW5zdHJ1Y3RzIGNoYW5uZWwgdG8gdGVybWluYXRlIG9uIHNlcnZlclxuICAgKlxuICAgKiBUcmlnZ2VycyBvbkNsb3NlKCkgaG9va3NcbiAgICpcbiAgICogVG8gcmVjZWl2ZSBsZWF2ZSBhY2tub3dsZWRnZW1lbnRzLCB1c2UgdGhlIGByZWNlaXZlYFxuICAgKiBob29rIHRvIGJpbmQgdG8gdGhlIHNlcnZlciBhY2ssIGllOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFubmVsLmxlYXZlKCkucmVjZWl2ZShcIm9rXCIsICgpID0+IGFsZXJ0KFwibGVmdCFcIikgKVxuICAgKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHRpbWVvdXRcbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBsZWF2ZSh0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICB0aGlzLmpvaW5QdXNoLmNhbmNlbFRpbWVvdXQoKVxuXG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmxlYXZpbmdcbiAgICBsZXQgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBsZWF2ZSAke3RoaXMudG9waWN9YClcbiAgICAgIHRoaXMudHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5jbG9zZSwgXCJsZWF2ZVwiKVxuICAgIH1cbiAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aW1lb3V0KVxuICAgIGxlYXZlUHVzaC5yZWNlaXZlKFwib2tcIiwgKCkgPT4gb25DbG9zZSgpKVxuICAgICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IG9uQ2xvc2UoKSlcbiAgICBsZWF2ZVB1c2guc2VuZCgpXG4gICAgaWYoIXRoaXMuY2FuUHVzaCgpKXsgbGVhdmVQdXNoLnRyaWdnZXIoXCJva1wiLCB7fSkgfVxuXG4gICAgcmV0dXJuIGxlYXZlUHVzaFxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRhYmxlIG1lc3NhZ2UgaG9va1xuICAgKlxuICAgKiBSZWNlaXZlcyBhbGwgZXZlbnRzIGZvciBzcGVjaWFsaXplZCBtZXNzYWdlIGhhbmRsaW5nXG4gICAqIGJlZm9yZSBkaXNwYXRjaGluZyB0byB0aGUgY2hhbm5lbCBjYWxsYmFja3MuXG4gICAqXG4gICAqIE11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHJlZlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgb25NZXNzYWdlKF9ldmVudCwgcGF5bG9hZCwgX3JlZil7IHJldHVybiBwYXlsb2FkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTWVtYmVyKHRvcGljLCBldmVudCwgcGF5bG9hZCwgam9pblJlZil7XG4gICAgaWYodGhpcy50b3BpYyAhPT0gdG9waWMpeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYoam9pblJlZiAmJiBqb2luUmVmICE9PSB0aGlzLmpvaW5SZWYoKSl7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBcImRyb3BwaW5nIG91dGRhdGVkIG1lc3NhZ2VcIiwge3RvcGljLCBldmVudCwgcGF5bG9hZCwgam9pblJlZn0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGpvaW5SZWYoKXsgcmV0dXJuIHRoaXMuam9pblB1c2gucmVmIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBpZih0aGlzLmlzTGVhdmluZygpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnNvY2tldC5sZWF2ZU9wZW5Ub3BpYyh0aGlzLnRvcGljKVxuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nXG4gICAgdGhpcy5qb2luUHVzaC5yZXNlbmQodGltZW91dClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luUmVmKXtcbiAgICBsZXQgaGFuZGxlZFBheWxvYWQgPSB0aGlzLm9uTWVzc2FnZShldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luUmVmKVxuICAgIGlmKHBheWxvYWQgJiYgIWhhbmRsZWRQYXlsb2FkKXsgdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbCBvbk1lc3NhZ2UgY2FsbGJhY2tzIG11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkXCIpIH1cblxuICAgIGxldCBldmVudEJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoYmluZCA9PiBiaW5kLmV2ZW50ID09PSBldmVudClcblxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBldmVudEJpbmRpbmdzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGxldCBiaW5kID0gZXZlbnRCaW5kaW5nc1tpXVxuICAgICAgYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmLCBqb2luUmVmIHx8IHRoaXMuam9pblJlZigpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVwbHlFdmVudE5hbWUocmVmKXsgcmV0dXJuIGBjaGFuX3JlcGx5XyR7cmVmfWAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNDbG9zZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0Vycm9yZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmVycm9yZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNKb2luZWQoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0pvaW5pbmcoKXsgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5pbmcgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNMZWF2aW5nKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nIH1cbn1cbiIsICJpbXBvcnQge1xuICBnbG9iYWwsXG4gIFhIUl9TVEFURVNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWpheCB7XG5cbiAgc3RhdGljIHJlcXVlc3QobWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICBpZihnbG9iYWwuWERvbWFpblJlcXVlc3Qpe1xuICAgICAgbGV0IHJlcSA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKSAvLyBJRTgsIElFOVxuICAgICAgdGhpcy54ZG9tYWluUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KCkgLy8gSUU3KywgRmlyZWZveCwgQ2hyb21lLCBPcGVyYSwgU2FmYXJpXG4gICAgICB0aGlzLnhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHhkb21haW5SZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgcmVxLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgcmVxLm9wZW4obWV0aG9kLCBlbmRQb2ludClcbiAgICByZXEub25sb2FkID0gKCkgPT4ge1xuICAgICAgbGV0IHJlc3BvbnNlID0gdGhpcy5wYXJzZUpTT04ocmVxLnJlc3BvbnNlVGV4dClcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlKVxuICAgIH1cbiAgICBpZihvbnRpbWVvdXQpeyByZXEub250aW1lb3V0ID0gb250aW1lb3V0IH1cblxuICAgIC8vIFdvcmsgYXJvdW5kIGJ1ZyBpbiBJRTkgdGhhdCByZXF1aXJlcyBhbiBhdHRhY2hlZCBvbnByb2dyZXNzIGhhbmRsZXJcbiAgICByZXEub25wcm9ncmVzcyA9ICgpID0+IHsgfVxuXG4gICAgcmVxLnNlbmQoYm9keSlcbiAgfVxuXG4gIHN0YXRpYyB4aHJSZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKXtcbiAgICByZXEub3BlbihtZXRob2QsIGVuZFBvaW50LCB0cnVlKVxuICAgIHJlcS50aW1lb3V0ID0gdGltZW91dFxuICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIGFjY2VwdClcbiAgICByZXEub25lcnJvciA9ICgpID0+IHsgY2FsbGJhY2sgJiYgY2FsbGJhY2sobnVsbCkgfVxuICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZihyZXEucmVhZHlTdGF0ZSA9PT0gWEhSX1NUQVRFUy5jb21wbGV0ZSAmJiBjYWxsYmFjayl7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHRoaXMucGFyc2VKU09OKHJlcS5yZXNwb25zZVRleHQpXG4gICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihvbnRpbWVvdXQpeyByZXEub250aW1lb3V0ID0gb250aW1lb3V0IH1cblxuICAgIHJlcS5zZW5kKGJvZHkpXG4gIH1cblxuICBzdGF0aWMgcGFyc2VKU09OKHJlc3Ape1xuICAgIGlmKCFyZXNwIHx8IHJlc3AgPT09IFwiXCIpeyByZXR1cm4gbnVsbCB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcClcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgIGNvbnNvbGUgJiYgY29uc29sZS5sb2coXCJmYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZVwiLCByZXNwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgc2VyaWFsaXplKG9iaiwgcGFyZW50S2V5KXtcbiAgICBsZXQgcXVlcnlTdHIgPSBbXVxuICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICBpZighT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSl7IGNvbnRpbnVlIH1cbiAgICAgIGxldCBwYXJhbUtleSA9IHBhcmVudEtleSA/IGAke3BhcmVudEtleX1bJHtrZXl9XWAgOiBrZXlcbiAgICAgIGxldCBwYXJhbVZhbCA9IG9ialtrZXldXG4gICAgICBpZih0eXBlb2YgcGFyYW1WYWwgPT09IFwib2JqZWN0XCIpe1xuICAgICAgICBxdWVyeVN0ci5wdXNoKHRoaXMuc2VyaWFsaXplKHBhcmFtVmFsLCBwYXJhbUtleSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeVN0ci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwYXJhbUtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbCkpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeVN0ci5qb2luKFwiJlwiKVxuICB9XG5cbiAgc3RhdGljIGFwcGVuZFBhcmFtcyh1cmwsIHBhcmFtcyl7XG4gICAgaWYoT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApeyByZXR1cm4gdXJsIH1cblxuICAgIGxldCBwcmVmaXggPSB1cmwubWF0Y2goL1xcPy8pID8gXCImXCIgOiBcIj9cIlxuICAgIHJldHVybiBgJHt1cmx9JHtwcmVmaXh9JHt0aGlzLnNlcmlhbGl6ZShwYXJhbXMpfWBcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFNPQ0tFVF9TVEFURVMsXG4gIFRSQU5TUE9SVFNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IEFqYXggZnJvbSBcIi4vYWpheFwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvbmdQb2xsIHtcblxuICBjb25zdHJ1Y3RvcihlbmRQb2ludCl7XG4gICAgdGhpcy5lbmRQb2ludCA9IG51bGxcbiAgICB0aGlzLnRva2VuID0gbnVsbFxuICAgIHRoaXMuc2tpcEhlYXJ0YmVhdCA9IHRydWVcbiAgICB0aGlzLm9ub3BlbiA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbmNsb3NlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMucG9sbEVuZHBvaW50ID0gdGhpcy5ub3JtYWxpemVFbmRwb2ludChlbmRQb2ludClcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmdcblxuICAgIHRoaXMucG9sbCgpXG4gIH1cblxuICBub3JtYWxpemVFbmRwb2ludChlbmRQb2ludCl7XG4gICAgcmV0dXJuIChlbmRQb2ludFxuICAgICAgLnJlcGxhY2UoXCJ3czovL1wiLCBcImh0dHA6Ly9cIilcbiAgICAgIC5yZXBsYWNlKFwid3NzOi8vXCIsIFwiaHR0cHM6Ly9cIilcbiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoLiopXFwvXCIgKyBUUkFOU1BPUlRTLndlYnNvY2tldCksIFwiJDEvXCIgKyBUUkFOU1BPUlRTLmxvbmdwb2xsKSlcbiAgfVxuXG4gIGVuZHBvaW50VVJMKCl7XG4gICAgcmV0dXJuIEFqYXguYXBwZW5kUGFyYW1zKHRoaXMucG9sbEVuZHBvaW50LCB7dG9rZW46IHRoaXMudG9rZW59KVxuICB9XG5cbiAgY2xvc2VBbmRSZXRyeSgpe1xuICAgIHRoaXMuY2xvc2UoKVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZ1xuICB9XG5cbiAgb250aW1lb3V0KCl7XG4gICAgdGhpcy5vbmVycm9yKFwidGltZW91dFwiKVxuICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgpXG4gIH1cblxuICBwb2xsKCl7XG4gICAgaWYoISh0aGlzLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMub3BlbiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZykpeyByZXR1cm4gfVxuXG4gICAgQWpheC5yZXF1ZXN0KFwiR0VUXCIsIHRoaXMuZW5kcG9pbnRVUkwoKSwgXCJhcHBsaWNhdGlvbi9qc29uXCIsIG51bGwsIHRoaXMudGltZW91dCwgdGhpcy5vbnRpbWVvdXQuYmluZCh0aGlzKSwgKHJlc3ApID0+IHtcbiAgICAgIGlmKHJlc3Ape1xuICAgICAgICB2YXIge3N0YXR1cywgdG9rZW4sIG1lc3NhZ2VzfSA9IHJlc3BcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0dXMgPSAwXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaChzdGF0dXMpe1xuICAgICAgICBjYXNlIDIwMDpcbiAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKG1zZyA9PiB7XG4gICAgICAgICAgICAvLyBUYXNrcyBhcmUgd2hhdCB0aGluZ3MgbGlrZSBldmVudCBoYW5kbGVycywgc2V0VGltZW91dCBjYWxsYmFja3MsXG4gICAgICAgICAgICAvLyBwcm9taXNlIHJlc29sdmVzIGFuZCBtb3JlIGFyZSBydW4gd2l0aGluLlxuICAgICAgICAgICAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCB0aGVyZSBhcmUgdHdvIGRpZmZlcmVudCBraW5kcyBvZiB0YXNrcyxcbiAgICAgICAgICAgIC8vIG1pY3JvdGFza3MgYW5kIG1hY3JvdGFza3MuXG4gICAgICAgICAgICAvLyBNaWNyb3Rhc2tzIGFyZSBtYWlubHkgdXNlZCBmb3IgUHJvbWlzZXMsIHdoaWxlIG1hY3JvdGFza3MgYXJlXG4gICAgICAgICAgICAvLyB1c2VkIGZvciBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAgICAgICAvLyBNaWNyb3Rhc2tzIGFsd2F5cyBoYXZlIHByaW9yaXR5IG92ZXIgbWFjcm90YXNrcy4gSWYgdGhlIEpTIGVuZ2luZVxuICAgICAgICAgICAgLy8gaXMgbG9va2luZyBmb3IgYSB0YXNrIHRvIHJ1biwgaXQgd2lsbCBhbHdheXMgdHJ5IHRvIGVtcHR5IHRoZVxuICAgICAgICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHJ1biBhbnl0aGluZyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gbWFjcm90YXNrIHF1ZXVlLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEZvciB0aGUgV2ViU29ja2V0IHRyYW5zcG9ydCwgbWVzc2FnZXMgYWx3YXlzIGFycml2ZSBpbiB0aGVpciBvd25cbiAgICAgICAgICAgIC8vIGV2ZW50LiBUaGlzIG1lYW5zIHRoYXQgaWYgYW55IHByb21pc2VzIGFyZSByZXNvbHZlZCBmcm9tIHdpdGhpbixcbiAgICAgICAgICAgIC8vIHRoZWlyIGNhbGxiYWNrcyB3aWxsIGFsd2F5cyBmaW5pc2ggZXhlY3V0aW9uIGJ5IHRoZSB0aW1lIHRoZVxuICAgICAgICAgICAgLy8gbmV4dCBtZXNzYWdlIGV2ZW50IGhhbmRsZXIgaXMgcnVuLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGVtdWxhdGUgdGhpcyBiZWhhdmlvdXIsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGVhY2hcbiAgICAgICAgICAgIC8vIG9ubWVzc2FnZSBoYW5kbGVyIGlzIHJ1biB3aXRoaW4gaXQncyBvd24gbWFjcm90YXNrLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMub25tZXNzYWdlKHtkYXRhOiBtc2d9KVxuICAgICAgICAgICAgfSwgMClcbiAgICAgICAgICB9KVxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyMDQ6XG4gICAgICAgICAgdGhpcy5wb2xsKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQxMDpcbiAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLm9wZW5cbiAgICAgICAgICB0aGlzLm9ub3BlbigpXG4gICAgICAgICAgdGhpcy5wb2xsKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICB0aGlzLm9uZXJyb3IoKVxuICAgICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSA1MDA6XG4gICAgICAgICAgdGhpcy5vbmVycm9yKClcbiAgICAgICAgICB0aGlzLmNsb3NlQW5kUmV0cnkoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHBvbGwgc3RhdHVzICR7c3RhdHVzfWApXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHNlbmQoYm9keSl7XG4gICAgQWpheC5yZXF1ZXN0KFwiUE9TVFwiLCB0aGlzLmVuZHBvaW50VVJMKCksIFwiYXBwbGljYXRpb24vanNvblwiLCBib2R5LCB0aGlzLnRpbWVvdXQsIHRoaXMub25lcnJvci5iaW5kKHRoaXMsIFwidGltZW91dFwiKSwgKHJlc3ApID0+IHtcbiAgICAgIGlmKCFyZXNwIHx8IHJlc3Auc3RhdHVzICE9PSAyMDApe1xuICAgICAgICB0aGlzLm9uZXJyb3IocmVzcCAmJiByZXNwLnN0YXR1cylcbiAgICAgICAgdGhpcy5jbG9zZUFuZFJldHJ5KClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY2xvc2UoX2NvZGUsIF9yZWFzb24pe1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY2xvc2VkXG4gICAgdGhpcy5vbmNsb3NlKClcbiAgfVxufVxuIiwgIi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIFByZXNlbmNlXG4gKiBAcGFyYW0ge0NoYW5uZWx9IGNoYW5uZWwgLSBUaGUgQ2hhbm5lbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyxcbiAqICAgICAgICBmb3IgZXhhbXBsZSBge2V2ZW50czoge3N0YXRlOiBcInN0YXRlXCIsIGRpZmY6IFwiZGlmZlwifX1gXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZXNlbmNlIHtcblxuICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRzID0ge30pe1xuICAgIGxldCBldmVudHMgPSBvcHRzLmV2ZW50cyB8fCB7c3RhdGU6IFwicHJlc2VuY2Vfc3RhdGVcIiwgZGlmZjogXCJwcmVzZW5jZV9kaWZmXCJ9XG4gICAgdGhpcy5zdGF0ZSA9IHt9XG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWxcbiAgICB0aGlzLmpvaW5SZWYgPSBudWxsXG4gICAgdGhpcy5jYWxsZXIgPSB7XG4gICAgICBvbkpvaW46IGZ1bmN0aW9uICgpeyB9LFxuICAgICAgb25MZWF2ZTogZnVuY3Rpb24gKCl7IH0sXG4gICAgICBvblN5bmM6IGZ1bmN0aW9uICgpeyB9XG4gICAgfVxuXG4gICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5zdGF0ZSwgbmV3U3RhdGUgPT4ge1xuICAgICAgbGV0IHtvbkpvaW4sIG9uTGVhdmUsIG9uU3luY30gPSB0aGlzLmNhbGxlclxuXG4gICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuam9pblJlZigpXG4gICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpXG5cbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goZGlmZiA9PiB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpXG4gICAgICB9KVxuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgICAgb25TeW5jKClcbiAgICB9KVxuXG4gICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5kaWZmLCBkaWZmID0+IHtcbiAgICAgIGxldCB7b25Kb2luLCBvbkxlYXZlLCBvblN5bmN9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgaWYodGhpcy5pblBlbmRpbmdTeW5jU3RhdGUoKSl7XG4gICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goZGlmZilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpXG4gICAgICAgIG9uU3luYygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIG9uSm9pbihjYWxsYmFjayl7IHRoaXMuY2FsbGVyLm9uSm9pbiA9IGNhbGxiYWNrIH1cblxuICBvbkxlYXZlKGNhbGxiYWNrKXsgdGhpcy5jYWxsZXIub25MZWF2ZSA9IGNhbGxiYWNrIH1cblxuICBvblN5bmMoY2FsbGJhY2speyB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjayB9XG5cbiAgbGlzdChieSl7IHJldHVybiBQcmVzZW5jZS5saXN0KHRoaXMuc3RhdGUsIGJ5KSB9XG5cbiAgaW5QZW5kaW5nU3luY1N0YXRlKCl7XG4gICAgcmV0dXJuICF0aGlzLmpvaW5SZWYgfHwgKHRoaXMuam9pblJlZiAhPT0gdGhpcy5jaGFubmVsLmpvaW5SZWYoKSlcbiAgfVxuXG4gIC8vIGxvd2VyLWxldmVsIHB1YmxpYyBzdGF0aWMgQVBJXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gc3luYyB0aGUgbGlzdCBvZiBwcmVzZW5jZXMgb24gdGhlIHNlcnZlclxuICAgKiB3aXRoIHRoZSBjbGllbnQncyBzdGF0ZS4gQW4gb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFjayBjYW5cbiAgICogYmUgcHJvdmlkZWQgdG8gcmVhY3QgdG8gY2hhbmdlcyBpbiB0aGUgY2xpZW50J3MgbG9jYWwgcHJlc2VuY2VzIGFjcm9zc1xuICAgKiBkaXNjb25uZWN0cyBhbmQgcmVjb25uZWN0cyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcmVzZW5jZX1cbiAgICovXG4gIHN0YXRpYyBzeW5jU3RhdGUoY3VycmVudFN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKXtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmNsb25lKGN1cnJlbnRTdGF0ZSlcbiAgICBsZXQgam9pbnMgPSB7fVxuICAgIGxldCBsZWF2ZXMgPSB7fVxuXG4gICAgdGhpcy5tYXAoc3RhdGUsIChrZXksIHByZXNlbmNlKSA9PiB7XG4gICAgICBpZighbmV3U3RhdGVba2V5XSl7XG4gICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMubWFwKG5ld1N0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV1cbiAgICAgIGlmKGN1cnJlbnRQcmVzZW5jZSl7XG4gICAgICAgIGxldCBuZXdSZWZzID0gbmV3UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgY3VyUmVmcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5tYXAobSA9PiBtLnBoeF9yZWYpXG4gICAgICAgIGxldCBqb2luZWRNZXRhcyA9IG5ld1ByZXNlbmNlLm1ldGFzLmZpbHRlcihtID0+IGN1clJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMClcbiAgICAgICAgbGV0IGxlZnRNZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIobSA9PiBuZXdSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApXG4gICAgICAgIGlmKGpvaW5lZE1ldGFzLmxlbmd0aCA+IDApe1xuICAgICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZVxuICAgICAgICAgIGpvaW5zW2tleV0ubWV0YXMgPSBqb2luZWRNZXRhc1xuICAgICAgICB9XG4gICAgICAgIGlmKGxlZnRNZXRhcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICBsZWF2ZXNba2V5XSA9IHRoaXMuY2xvbmUoY3VycmVudFByZXNlbmNlKVxuICAgICAgICAgIGxlYXZlc1trZXldLm1ldGFzID0gbGVmdE1ldGFzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHtqb2luczogam9pbnMsIGxlYXZlczogbGVhdmVzfSwgb25Kb2luLCBvbkxlYXZlKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIFVzZWQgdG8gc3luYyBhIGRpZmYgb2YgcHJlc2VuY2Ugam9pbiBhbmQgbGVhdmVcbiAgICogZXZlbnRzIGZyb20gdGhlIHNlcnZlciwgYXMgdGhleSBoYXBwZW4uIExpa2UgYHN5bmNTdGF0ZWAsIGBzeW5jRGlmZmBcbiAgICogYWNjZXB0cyBvcHRpb25hbCBgb25Kb2luYCBhbmQgYG9uTGVhdmVgIGNhbGxiYWNrcyB0byByZWFjdCB0byBhIHVzZXJcbiAgICogam9pbmluZyBvciBsZWF2aW5nIGZyb20gYSBkZXZpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcmVzZW5jZX1cbiAgICovXG4gIHN0YXRpYyBzeW5jRGlmZihzdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKXtcbiAgICBsZXQge2pvaW5zLCBsZWF2ZXN9ID0gdGhpcy5jbG9uZShkaWZmKVxuICAgIGlmKCFvbkpvaW4peyBvbkpvaW4gPSBmdW5jdGlvbiAoKXsgfSB9XG4gICAgaWYoIW9uTGVhdmUpeyBvbkxlYXZlID0gZnVuY3Rpb24gKCl7IH0gfVxuXG4gICAgdGhpcy5tYXAoam9pbnMsIChrZXksIG5ld1ByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XVxuICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmUobmV3UHJlc2VuY2UpXG4gICAgICBpZihjdXJyZW50UHJlc2VuY2Upe1xuICAgICAgICBsZXQgam9pbmVkUmVmcyA9IHN0YXRlW2tleV0ubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgY3VyTWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKG0gPT4gam9pbmVkUmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKVxuICAgICAgICBzdGF0ZVtrZXldLm1ldGFzLnVuc2hpZnQoLi4uY3VyTWV0YXMpXG4gICAgICB9XG4gICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2UsIG5ld1ByZXNlbmNlKVxuICAgIH0pXG4gICAgdGhpcy5tYXAobGVhdmVzLCAoa2V5LCBsZWZ0UHJlc2VuY2UpID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldXG4gICAgICBpZighY3VycmVudFByZXNlbmNlKXsgcmV0dXJuIH1cbiAgICAgIGxldCByZWZzVG9SZW1vdmUgPSBsZWZ0UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgY3VycmVudFByZXNlbmNlLm1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcihwID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZnNUb1JlbW92ZS5pbmRleE9mKHAucGh4X3JlZikgPCAwXG4gICAgICB9KVxuICAgICAgb25MZWF2ZShrZXksIGN1cnJlbnRQcmVzZW5jZSwgbGVmdFByZXNlbmNlKVxuICAgICAgaWYoY3VycmVudFByZXNlbmNlLm1ldGFzLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZVtrZXldXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcmVzZW5jZXMsIHdpdGggc2VsZWN0ZWQgbWV0YWRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVzZW5jZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2hvb3NlclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgbGlzdChwcmVzZW5jZXMsIGNob29zZXIpe1xuICAgIGlmKCFjaG9vc2VyKXsgY2hvb3NlciA9IGZ1bmN0aW9uIChrZXksIHByZXMpeyByZXR1cm4gcHJlcyB9IH1cblxuICAgIHJldHVybiB0aGlzLm1hcChwcmVzZW5jZXMsIChrZXksIHByZXNlbmNlKSA9PiB7XG4gICAgICByZXR1cm4gY2hvb3NlcihrZXksIHByZXNlbmNlKVxuICAgIH0pXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgc3RhdGljIG1hcChvYmosIGZ1bmMpe1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLm1hcChrZXkgPT4gZnVuYyhrZXksIG9ialtrZXldKSlcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShvYmopeyByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKSB9XG59XG4iLCAiLyogVGhlIGRlZmF1bHQgc2VyaWFsaXplciBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIG1lc3NhZ2VzICovXG5pbXBvcnQge1xuICBDSEFOTkVMX0VWRU5UU1xufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEhFQURFUl9MRU5HVEg6IDEsXG4gIE1FVEFfTEVOR1RIOiA0LFxuICBLSU5EUzoge3B1c2g6IDAsIHJlcGx5OiAxLCBicm9hZGNhc3Q6IDJ9LFxuXG4gIGVuY29kZShtc2csIGNhbGxiYWNrKXtcbiAgICBpZihtc2cucGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RW5jb2RlKG1zZykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXlsb2FkID0gW21zZy5qb2luX3JlZiwgbXNnLnJlZiwgbXNnLnRvcGljLCBtc2cuZXZlbnQsIG1zZy5wYXlsb2FkXVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgIH1cbiAgfSxcblxuICBkZWNvZGUocmF3UGF5bG9hZCwgY2FsbGJhY2spe1xuICAgIGlmKHJhd1BheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLmJpbmFyeURlY29kZShyYXdQYXlsb2FkKSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IFtqb2luX3JlZiwgcmVmLCB0b3BpYywgZXZlbnQsIHBheWxvYWRdID0gSlNPTi5wYXJzZShyYXdQYXlsb2FkKVxuICAgICAgcmV0dXJuIGNhbGxiYWNrKHtqb2luX3JlZiwgcmVmLCB0b3BpYywgZXZlbnQsIHBheWxvYWR9KVxuICAgIH1cbiAgfSxcblxuICAvLyBwcml2YXRlXG5cbiAgYmluYXJ5RW5jb2RlKG1lc3NhZ2Upe1xuICAgIGxldCB7am9pbl9yZWYsIHJlZiwgZXZlbnQsIHRvcGljLCBwYXlsb2FkfSA9IG1lc3NhZ2VcbiAgICBsZXQgbWV0YUxlbmd0aCA9IHRoaXMuTUVUQV9MRU5HVEggKyBqb2luX3JlZi5sZW5ndGggKyByZWYubGVuZ3RoICsgdG9waWMubGVuZ3RoICsgZXZlbnQubGVuZ3RoXG4gICAgbGV0IGhlYWRlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLkhFQURFUl9MRU5HVEggKyBtZXRhTGVuZ3RoKVxuICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGhlYWRlcilcbiAgICBsZXQgb2Zmc2V0ID0gMFxuXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdGhpcy5LSU5EUy5wdXNoKSAvLyBraW5kXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgam9pbl9yZWYubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHJlZi5sZW5ndGgpXG4gICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgdG9waWMubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGV2ZW50Lmxlbmd0aClcbiAgICBBcnJheS5mcm9tKGpvaW5fcmVmLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbShyZWYsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcbiAgICBBcnJheS5mcm9tKHRvcGljLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbShldmVudCwgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuXG4gICAgdmFyIGNvbWJpbmVkID0gbmV3IFVpbnQ4QXJyYXkoaGVhZGVyLmJ5dGVMZW5ndGggKyBwYXlsb2FkLmJ5dGVMZW5ndGgpXG4gICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KGhlYWRlciksIDApXG4gICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBoZWFkZXIuYnl0ZUxlbmd0aClcblxuICAgIHJldHVybiBjb21iaW5lZC5idWZmZXJcbiAgfSxcblxuICBiaW5hcnlEZWNvZGUoYnVmZmVyKXtcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpXG4gICAgbGV0IGtpbmQgPSB2aWV3LmdldFVpbnQ4KDApXG4gICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5wdXNoOiByZXR1cm4gdGhpcy5kZWNvZGVQdXNoKGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5yZXBseTogcmV0dXJuIHRoaXMuZGVjb2RlUmVwbHkoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKVxuICAgICAgY2FzZSB0aGlzLktJTkRTLmJyb2FkY2FzdDogcmV0dXJuIHRoaXMuZGVjb2RlQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICB9XG4gIH0sXG5cbiAgZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgyKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDMpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEggLSAxIC8vIHB1c2hlcyBoYXZlIG5vIHJlZlxuICAgIGxldCBqb2luUmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgam9pblJlZlNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGpvaW5SZWZTaXplXG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgcmV0dXJuIHtqb2luX3JlZjogam9pblJlZiwgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiBldmVudCwgcGF5bG9hZDogZGF0YX1cbiAgfSxcblxuICBkZWNvZGVSZXBseShidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSlcbiAgICBsZXQgcmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgzKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDQpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEhcbiAgICBsZXQgam9pblJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGpvaW5SZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBqb2luUmVmU2l6ZVxuICAgIGxldCByZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyByZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyByZWZTaXplXG4gICAgbGV0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyB0b3BpY1NpemVcbiAgICBsZXQgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIGV2ZW50U2l6ZVxuICAgIGxldCBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgbGV0IHBheWxvYWQgPSB7c3RhdHVzOiBldmVudCwgcmVzcG9uc2U6IGRhdGF9XG4gICAgcmV0dXJuIHtqb2luX3JlZjogam9pblJlZiwgcmVmOiByZWYsIHRvcGljOiB0b3BpYywgZXZlbnQ6IENIQU5ORUxfRVZFTlRTLnJlcGx5LCBwYXlsb2FkOiBwYXlsb2FkfVxuICB9LFxuXG4gIGRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpe1xuICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMlxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuXG4gICAgcmV0dXJuIHtqb2luX3JlZjogbnVsbCwgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiBldmVudCwgcGF5bG9hZDogZGF0YX1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIGdsb2JhbCxcbiAgcGh4V2luZG93LFxuICBDSEFOTkVMX0VWRU5UUyxcbiAgREVGQVVMVF9USU1FT1VULFxuICBERUZBVUxUX1ZTTixcbiAgU09DS0VUX1NUQVRFUyxcbiAgVFJBTlNQT1JUUyxcbiAgV1NfQ0xPU0VfTk9STUFMXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNsb3N1cmVcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgQWpheCBmcm9tIFwiLi9hamF4XCJcbmltcG9ydCBDaGFubmVsIGZyb20gXCIuL2NoYW5uZWxcIlxuaW1wb3J0IExvbmdQb2xsIGZyb20gXCIuL2xvbmdwb2xsXCJcbmltcG9ydCBTZXJpYWxpemVyIGZyb20gXCIuL3NlcmlhbGl6ZXJcIlxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL3RpbWVyXCJcblxuLyoqIEluaXRpYWxpemVzIHRoZSBTb2NrZXQgKlxuICpcbiAqIEZvciBJRTggc3VwcG9ydCB1c2UgYW4gRVM1LXNoaW0gKGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5kUG9pbnQgLSBUaGUgc3RyaW5nIFdlYlNvY2tldCBlbmRwb2ludCwgaWUsIGBcIndzOi8vZXhhbXBsZS5jb20vc29ja2V0XCJgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIndzczovL2V4YW1wbGUuY29tXCJgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFwiL3NvY2tldFwiYCAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy50cmFuc3BvcnRdIC0gVGhlIFdlYnNvY2tldCBUcmFuc3BvcnQsIGZvciBleGFtcGxlIFdlYlNvY2tldCBvciBQaG9lbml4LkxvbmdQb2xsLlxuICpcbiAqIERlZmF1bHRzIHRvIFdlYlNvY2tldCB3aXRoIGF1dG9tYXRpYyBMb25nUG9sbCBmYWxsYmFjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmVuY29kZV0gLSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLlxuICpcbiAqIERlZmF1bHRzIHRvIEpTT04gZW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5kZWNvZGVdIC0gVGhlIGZ1bmN0aW9uIHRvIGRlY29kZSBpbmNvbWluZyBtZXNzYWdlcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBKU09OOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIChwYXlsb2FkLCBjYWxsYmFjaykgPT4gY2FsbGJhY2soSlNPTi5wYXJzZShwYXlsb2FkKSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lb3V0XSAtIFRoZSBkZWZhdWx0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgcHVzaCB0aW1lb3V0cy5cbiAqXG4gKiBEZWZhdWx0cyBgREVGQVVMVF9USU1FT1VUYFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlYXJ0YmVhdEludGVydmFsTXNdIC0gVGhlIG1pbGxpc2VjIGludGVydmFsIHRvIHNlbmQgYSBoZWFydGJlYXQgbWVzc2FnZVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnJlY29ubmVjdEFmdGVyTXNdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWlsbHNlY1xuICogc29ja2V0IHJlY29ubmVjdCBpbnRlcnZhbC5cbiAqXG4gKiBEZWZhdWx0cyB0byBzdGVwcGVkIGJhY2tvZmYgb2Y6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24odHJpZXMpe1xuICogICByZXR1cm4gWzEwLCA1MCwgMTAwLCAxNTAsIDIwMCwgMjUwLCA1MDAsIDEwMDAsIDIwMDBdW3RyaWVzIC0gMV0gfHwgNTAwMFxuICogfVxuICogYGBgYFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5yZWpvaW5BZnRlck1zXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG1pbGxzZWNcbiAqIHJlam9pbiBpbnRlcnZhbCBmb3IgaW5kaXZpZHVhbCBjaGFubmVscy5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBmdW5jdGlvbih0cmllcyl7XG4gKiAgIHJldHVybiBbMTAwMCwgMjAwMCwgNTAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICogfVxuICogYGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmxvZ2dlcl0gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gZm9yIHNwZWNpYWxpemVkIGxvZ2dpbmcsIGllOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKGtpbmQsIG1zZywgZGF0YSkge1xuICogICBjb25zb2xlLmxvZyhgJHtraW5kfTogJHttc2d9YCwgZGF0YSlcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5sb25ncG9sbGVyVGltZW91dF0gLSBUaGUgbWF4aW11bSB0aW1lb3V0IG9mIGEgbG9uZyBwb2xsIEFKQVggcmVxdWVzdC5cbiAqXG4gKiBEZWZhdWx0cyB0byAyMHMgKGRvdWJsZSB0aGUgc2VydmVyIGxvbmcgcG9sbCB0aW1lcikuXG4gKlxuICogQHBhcmFtIHsoT2JqZWN0fGZ1bmN0aW9uKX0gW29wdHMucGFyYW1zXSAtIFRoZSBvcHRpb25hbCBwYXJhbXMgdG8gcGFzcyB3aGVuIGNvbm5lY3RpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iaW5hcnlUeXBlXSAtIFRoZSBiaW5hcnkgdHlwZSB0byB1c2UgZm9yIGJpbmFyeSBXZWJTb2NrZXQgZnJhbWVzLlxuICpcbiAqIERlZmF1bHRzIHRvIFwiYXJyYXlidWZmZXJcIlxuICpcbiAqIEBwYXJhbSB7dnNufSBbb3B0cy52c25dIC0gVGhlIHNlcmlhbGl6ZXIncyBwcm90b2NvbCB2ZXJzaW9uIHRvIHNlbmQgb24gY29ubmVjdC5cbiAqXG4gKiBEZWZhdWx0cyB0byBERUZBVUxUX1ZTTi5cbiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb2NrZXQge1xuICBjb25zdHJ1Y3RvcihlbmRQb2ludCwgb3B0cyA9IHt9KXtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0ge29wZW46IFtdLCBjbG9zZTogW10sIGVycm9yOiBbXSwgbWVzc2FnZTogW119XG4gICAgdGhpcy5jaGFubmVscyA9IFtdXG4gICAgdGhpcy5zZW5kQnVmZmVyID0gW11cbiAgICB0aGlzLnJlZiA9IDBcbiAgICB0aGlzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgfHwgREVGQVVMVF9USU1FT1VUXG4gICAgdGhpcy50cmFuc3BvcnQgPSBvcHRzLnRyYW5zcG9ydCB8fCBnbG9iYWwuV2ViU29ja2V0IHx8IExvbmdQb2xsXG4gICAgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25zID0gMFxuICAgIHRoaXMuZGVmYXVsdEVuY29kZXIgPSBTZXJpYWxpemVyLmVuY29kZS5iaW5kKFNlcmlhbGl6ZXIpXG4gICAgdGhpcy5kZWZhdWx0RGVjb2RlciA9IFNlcmlhbGl6ZXIuZGVjb2RlLmJpbmQoU2VyaWFsaXplcilcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIHRoaXMuYmluYXJ5VHlwZSA9IG9wdHMuYmluYXJ5VHlwZSB8fCBcImFycmF5YnVmZmVyXCJcbiAgICB0aGlzLmNvbm5lY3RDbG9jayA9IDFcbiAgICBpZih0aGlzLnRyYW5zcG9ydCAhPT0gTG9uZ1BvbGwpe1xuICAgICAgdGhpcy5lbmNvZGUgPSBvcHRzLmVuY29kZSB8fCB0aGlzLmRlZmF1bHRFbmNvZGVyXG4gICAgICB0aGlzLmRlY29kZSA9IG9wdHMuZGVjb2RlIHx8IHRoaXMuZGVmYXVsdERlY29kZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmNvZGUgPSB0aGlzLmRlZmF1bHRFbmNvZGVyXG4gICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVmYXVsdERlY29kZXJcbiAgICB9XG4gICAgbGV0IGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSBudWxsXG4gICAgaWYocGh4V2luZG93ICYmIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKXtcbiAgICAgIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX2UgPT4ge1xuICAgICAgICBpZih0aGlzLmNvbm4pe1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgICAgICAgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IHRoaXMuY29ubmVjdENsb2NrXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsIF9lID0+IHtcbiAgICAgICAgaWYoYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9PT0gdGhpcy5jb25uZWN0Q2xvY2spe1xuICAgICAgICAgIGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSBudWxsXG4gICAgICAgICAgdGhpcy5jb25uZWN0KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID0gb3B0cy5oZWFydGJlYXRJbnRlcnZhbE1zIHx8IDMwMDAwXG4gICAgdGhpcy5yZWpvaW5BZnRlck1zID0gKHRyaWVzKSA9PiB7XG4gICAgICBpZihvcHRzLnJlam9pbkFmdGVyTXMpe1xuICAgICAgICByZXR1cm4gb3B0cy5yZWpvaW5BZnRlck1zKHRyaWVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyA9ICh0cmllcykgPT4ge1xuICAgICAgaWYob3B0cy5yZWNvbm5lY3RBZnRlck1zKXtcbiAgICAgICAgcmV0dXJuIG9wdHMucmVjb25uZWN0QWZ0ZXJNcyh0cmllcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMTAsIDUwLCAxMDAsIDE1MCwgMjAwLCAyNTAsIDUwMCwgMTAwMCwgMjAwMF1bdHJpZXMgLSAxXSB8fCA1MDAwXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyID0gb3B0cy5sb2dnZXIgfHwgbnVsbFxuICAgIHRoaXMubG9uZ3BvbGxlclRpbWVvdXQgPSBvcHRzLmxvbmdwb2xsZXJUaW1lb3V0IHx8IDIwMDAwXG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KVxuICAgIHRoaXMuZW5kUG9pbnQgPSBgJHtlbmRQb2ludH0vJHtUUkFOU1BPUlRTLndlYnNvY2tldH1gXG4gICAgdGhpcy52c24gPSBvcHRzLnZzbiB8fCBERUZBVUxUX1ZTTlxuICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBudWxsXG4gICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4ge1xuICAgICAgdGhpcy50ZWFyZG93bigoKSA9PiB0aGlzLmNvbm5lY3QoKSlcbiAgICB9LCB0aGlzLnJlY29ubmVjdEFmdGVyTXMpXG4gIH1cblxuICAvKipcbiAgICogRGlzY29ubmVjdHMgYW5kIHJlcGxhY2VzIHRoZSBhY3RpdmUgdHJhbnNwb3J0XG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5ld1RyYW5zcG9ydCAtIFRoZSBuZXcgdHJhbnNwb3J0IGNsYXNzIHRvIGluc3RhbnRpYXRlXG4gICAqXG4gICAqL1xuICByZXBsYWNlVHJhbnNwb3J0KG5ld1RyYW5zcG9ydCl7XG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG5ld1RyYW5zcG9ydFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNvY2tldCBwcm90b2NvbFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgcHJvdG9jb2woKXsgcmV0dXJuIGxvY2F0aW9uLnByb3RvY29sLm1hdGNoKC9eaHR0cHMvKSA/IFwid3NzXCIgOiBcIndzXCIgfVxuXG4gIC8qKlxuICAgKiBUaGUgZnVsbHkgcXVhbGlmZWQgc29ja2V0IHVybFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZW5kUG9pbnRVUkwoKXtcbiAgICBsZXQgdXJpID0gQWpheC5hcHBlbmRQYXJhbXMoXG4gICAgICBBamF4LmFwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCB0aGlzLnBhcmFtcygpKSwge3ZzbjogdGhpcy52c259KVxuICAgIGlmKHVyaS5jaGFyQXQoMCkgIT09IFwiL1wiKXsgcmV0dXJuIHVyaSB9XG4gICAgaWYodXJpLmNoYXJBdCgxKSA9PT0gXCIvXCIpeyByZXR1cm4gYCR7dGhpcy5wcm90b2NvbCgpfToke3VyaX1gIH1cblxuICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9Oi8vJHtsb2NhdGlvbi5ob3N0fSR7dXJpfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0XG4gICAqXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXMgZm9yIHZhbGlkIHN0YXR1cyBjb2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgc29ja2V0IGlzIGRpc2Nvbm5lY3RlZC5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBjb2RlIC0gQSBzdGF0dXMgY29kZSBmb3IgZGlzY29ubmVjdGlvbiAoT3B0aW9uYWwpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gQSB0ZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHRoZSByZWFzb24gdG8gZGlzY29ubmVjdC4gKE9wdGlvbmFsKVxuICAgKi9cbiAgZGlzY29ubmVjdChjYWxsYmFjaywgY29kZSwgcmVhc29uKXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMudGVhcmRvd24oY2FsbGJhY2ssIGNvZGUsIHJlYXNvbilcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtcyB0byBzZW5kIHdoZW4gY29ubmVjdGluZywgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiB1c2VyVG9rZW59YFxuICAgKlxuICAgKiBQYXNzaW5nIHBhcmFtcyB0byBjb25uZWN0IGlzIGRlcHJlY2F0ZWQ7IHBhc3MgdGhlbSBpbiB0aGUgU29ja2V0IGNvbnN0cnVjdG9yIGluc3RlYWQ6XG4gICAqIGBuZXcgU29ja2V0KFwiL3NvY2tldFwiLCB7cGFyYW1zOiB7dXNlcl9pZDogdXNlclRva2VufX0pYC5cbiAgICovXG4gIGNvbm5lY3QocGFyYW1zKXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgaWYocGFyYW1zKXtcbiAgICAgIGNvbnNvbGUgJiYgY29uc29sZS5sb2coXCJwYXNzaW5nIHBhcmFtcyB0byBjb25uZWN0IGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgcGFzcyA6cGFyYW1zIHRvIHRoZSBTb2NrZXQgY29uc3RydWN0b3JcIilcbiAgICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShwYXJhbXMpXG4gICAgfVxuICAgIGlmKHRoaXMuY29ubil7IHJldHVybiB9XG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICB0aGlzLmNvbm4gPSBuZXcgdGhpcy50cmFuc3BvcnQodGhpcy5lbmRQb2ludFVSTCgpKVxuICAgIHRoaXMuY29ubi5iaW5hcnlUeXBlID0gdGhpcy5iaW5hcnlUeXBlXG4gICAgdGhpcy5jb25uLnRpbWVvdXQgPSB0aGlzLmxvbmdwb2xsZXJUaW1lb3V0XG4gICAgdGhpcy5jb25uLm9ub3BlbiA9ICgpID0+IHRoaXMub25Db25uT3BlbigpXG4gICAgdGhpcy5jb25uLm9uZXJyb3IgPSBlcnJvciA9PiB0aGlzLm9uQ29ubkVycm9yKGVycm9yKVxuICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSBldmVudCA9PiB0aGlzLm9uQ29ubk1lc3NhZ2UoZXZlbnQpXG4gICAgdGhpcy5jb25uLm9uY2xvc2UgPSBldmVudCA9PiB0aGlzLm9uQ29ubkNsb3NlKGV2ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgdGhlIG1lc3NhZ2UuIE92ZXJyaWRlIGB0aGlzLmxvZ2dlcmAgZm9yIHNwZWNpYWxpemVkIGxvZ2dpbmcuIG5vb3BzIGJ5IGRlZmF1bHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgbG9nKGtpbmQsIG1zZywgZGF0YSl7IHRoaXMubG9nZ2VyKGtpbmQsIG1zZywgZGF0YSkgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBsb2dnZXIgaGFzIGJlZW4gc2V0IG9uIHRoaXMgc29ja2V0LlxuICAgKi9cbiAgaGFzTG9nZ2VyKCl7IHJldHVybiB0aGlzLmxvZ2dlciAhPT0gbnVsbCB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gb3BlbiBldmVudHNcbiAgICpcbiAgICogQGV4YW1wbGUgc29ja2V0Lm9uT3BlbihmdW5jdGlvbigpeyBjb25zb2xlLmluZm8oXCJ0aGUgc29ja2V0IHdhcyBvcGVuZWRcIikgfSlcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uT3BlbihjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLnB1c2goW3JlZiwgY2FsbGJhY2tdKVxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIGNsb3NlIGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25DbG9zZShjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBlcnJvciBldmVudHNcbiAgICpcbiAgICogQGV4YW1wbGUgc29ja2V0Lm9uRXJyb3IoZnVuY3Rpb24oZXJyb3IpeyBhbGVydChcIkFuIGVycm9yIG9jY3VycmVkXCIpIH0pXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkVycm9yKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLnB1c2goW3JlZiwgY2FsbGJhY2tdKVxuICAgIHJldHVybiByZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIG1lc3NhZ2UgZXZlbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbk1lc3NhZ2UoY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uQ29ubk9wZW4oKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgY29ubmVjdGVkIHRvICR7dGhpcy5lbmRQb2ludFVSTCgpfWApXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnMrK1xuICAgIHRoaXMuZmx1c2hTZW5kQnVmZmVyKClcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAgICB0aGlzLnJlc2V0SGVhcnRiZWF0KClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4uZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjaygpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIGhlYXJ0YmVhdFRpbWVvdXQoKXtcbiAgICBpZih0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpe1xuICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgICAgaWYodGhpcy5oYXNMb2dnZXIoKSl7IHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIFwiaGVhcnRiZWF0IHRpbWVvdXQuIEF0dGVtcHRpbmcgdG8gcmUtZXN0YWJsaXNoIGNvbm5lY3Rpb25cIikgfVxuICAgICAgdGhpcy5hYm5vcm1hbENsb3NlKFwiaGVhcnRiZWF0IHRpbWVvdXRcIilcbiAgICB9XG4gIH1cblxuICByZXNldEhlYXJ0YmVhdCgpe1xuICAgIGlmKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4uc2tpcEhlYXJ0YmVhdCl7IHJldHVybiB9XG4gICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbFxuICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVyKVxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgfVxuXG4gIHRlYXJkb3duKGNhbGxiYWNrLCBjb2RlLCByZWFzb24pe1xuICAgIGlmKCF0aGlzLmNvbm4pe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICB0aGlzLndhaXRGb3JCdWZmZXJEb25lKCgpID0+IHtcbiAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgIGlmKGNvZGUpeyB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uIHx8IFwiXCIpIH0gZWxzZSB7IHRoaXMuY29ubi5jbG9zZSgpIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy53YWl0Rm9yU29ja2V0Q2xvc2VkKCgpID0+IHtcbiAgICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICAgICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB3YWl0Rm9yQnVmZmVyRG9uZShjYWxsYmFjaywgdHJpZXMgPSAxKXtcbiAgICBpZih0cmllcyA9PT0gNSB8fCAhdGhpcy5jb25uIHx8ICF0aGlzLmNvbm4uYnVmZmVyZWRBbW91bnQpe1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLndhaXRGb3JCdWZmZXJEb25lKGNhbGxiYWNrLCB0cmllcyArIDEpXG4gICAgfSwgMTUwICogdHJpZXMpXG4gIH1cblxuICB3YWl0Rm9yU29ja2V0Q2xvc2VkKGNhbGxiYWNrLCB0cmllcyA9IDEpe1xuICAgIGlmKHRyaWVzID09PSA1IHx8ICF0aGlzLmNvbm4gfHwgdGhpcy5jb25uLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMuY2xvc2VkKXtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy53YWl0Rm9yU29ja2V0Q2xvc2VkKGNhbGxiYWNrLCB0cmllcyArIDEpXG4gICAgfSwgMTUwICogdHJpZXMpXG4gIH1cblxuICBvbkNvbm5DbG9zZShldmVudCl7XG4gICAgbGV0IGNsb3NlQ29kZSA9IGV2ZW50ICYmIGV2ZW50LmNvZGVcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImNsb3NlXCIsIGV2ZW50KVxuICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpXG4gICAgaWYoIXRoaXMuY2xvc2VXYXNDbGVhbiAmJiBjbG9zZUNvZGUgIT09IDEwMDApe1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKVxuICAgIH1cbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmNsb3NlLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4gY2FsbGJhY2soZXZlbnQpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbkNvbm5FcnJvcihlcnJvcil7XG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgZXJyb3IpXG4gICAgbGV0IHRyYW5zcG9ydEJlZm9yZSA9IHRoaXMudHJhbnNwb3J0XG4gICAgbGV0IGVzdGFibGlzaGVkQmVmb3JlID0gdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25zXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5mb3JFYWNoKChbLCBjYWxsYmFja10pID0+IHtcbiAgICAgIGNhbGxiYWNrKGVycm9yLCB0cmFuc3BvcnRCZWZvcmUsIGVzdGFibGlzaGVkQmVmb3JlKVxuICAgIH0pXG4gICAgaWYodHJhbnNwb3J0QmVmb3JlID09PSB0aGlzLnRyYW5zcG9ydCB8fCBlc3RhYmxpc2hlZEJlZm9yZSA+IDApe1xuICAgICAgdGhpcy50cmlnZ2VyQ2hhbkVycm9yKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRyaWdnZXJDaGFuRXJyb3IoKXtcbiAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goY2hhbm5lbCA9PiB7XG4gICAgICBpZighKGNoYW5uZWwuaXNFcnJvcmVkKCkgfHwgY2hhbm5lbC5pc0xlYXZpbmcoKSB8fCBjaGFubmVsLmlzQ2xvc2VkKCkpKXtcbiAgICAgICAgY2hhbm5lbC50cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGNvbm5lY3Rpb25TdGF0ZSgpe1xuICAgIHN3aXRjaCh0aGlzLmNvbm4gJiYgdGhpcy5jb25uLnJlYWR5U3RhdGUpe1xuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNvbm5lY3Rpbmc6IHJldHVybiBcImNvbm5lY3RpbmdcIlxuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLm9wZW46IHJldHVybiBcIm9wZW5cIlxuICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNsb3Npbmc6IHJldHVybiBcImNsb3NpbmdcIlxuICAgICAgZGVmYXVsdDogcmV0dXJuIFwiY2xvc2VkXCJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0Nvbm5lY3RlZCgpeyByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGUoKSA9PT0gXCJvcGVuXCIgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0NoYW5uZWx9XG4gICAqL1xuICByZW1vdmUoY2hhbm5lbCl7XG4gICAgdGhpcy5vZmYoY2hhbm5lbC5zdGF0ZUNoYW5nZVJlZnMpXG4gICAgdGhpcy5jaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZmlsdGVyKGMgPT4gYy5qb2luUmVmKCkgIT09IGNoYW5uZWwuam9pblJlZigpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYG9uT3BlbmAsIGBvbkNsb3NlYCwgYG9uRXJyb3IsYCBhbmQgYG9uTWVzc2FnZWAgcmVnaXN0cmF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtyZWZzfSAtIGxpc3Qgb2YgcmVmcyByZXR1cm5lZCBieSBjYWxscyB0b1xuICAgKiAgICAgICAgICAgICAgICAgYG9uT3BlbmAsIGBvbkNsb3NlYCwgYG9uRXJyb3IsYCBhbmQgYG9uTWVzc2FnZWBcbiAgICovXG4gIG9mZihyZWZzKXtcbiAgICBmb3IobGV0IGtleSBpbiB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzKXtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XS5maWx0ZXIoKFtyZWZdKSA9PiB7XG4gICAgICAgIHJldHVybiByZWZzLmluZGV4T2YocmVmKSA9PT0gLTFcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIG5ldyBjaGFubmVsIGZvciB0aGUgZ2l2ZW4gdG9waWNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuUGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgdGhlIGNoYW5uZWxcbiAgICogQHJldHVybnMge0NoYW5uZWx9XG4gICAqL1xuICBjaGFubmVsKHRvcGljLCBjaGFuUGFyYW1zID0ge30pe1xuICAgIGxldCBjaGFuID0gbmV3IENoYW5uZWwodG9waWMsIGNoYW5QYXJhbXMsIHRoaXMpXG4gICAgdGhpcy5jaGFubmVscy5wdXNoKGNoYW4pXG4gICAgcmV0dXJuIGNoYW5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgcHVzaChkYXRhKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKXtcbiAgICAgIGxldCB7dG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmfSA9IGRhdGFcbiAgICAgIHRoaXMubG9nKFwicHVzaFwiLCBgJHt0b3BpY30gJHtldmVudH0gKCR7am9pbl9yZWZ9LCAke3JlZn0pYCwgcGF5bG9hZClcbiAgICB9XG5cbiAgICBpZih0aGlzLmlzQ29ubmVjdGVkKCkpe1xuICAgICAgdGhpcy5lbmNvZGUoZGF0YSwgcmVzdWx0ID0+IHRoaXMuY29ubi5zZW5kKHJlc3VsdCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKCgpID0+IHRoaXMuZW5jb2RlKGRhdGEsIHJlc3VsdCA9PiB0aGlzLmNvbm4uc2VuZChyZXN1bHQpKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZXh0IG1lc3NhZ2UgcmVmLCBhY2NvdW50aW5nIGZvciBvdmVyZmxvd3NcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIG1ha2VSZWYoKXtcbiAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYgKyAxXG4gICAgaWYobmV3UmVmID09PSB0aGlzLnJlZil7IHRoaXMucmVmID0gMCB9IGVsc2UgeyB0aGlzLnJlZiA9IG5ld1JlZiB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWYudG9TdHJpbmcoKVxuICB9XG5cbiAgc2VuZEhlYXJ0YmVhdCgpe1xuICAgIGlmKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiAmJiAhdGhpcy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMucHVzaCh7dG9waWM6IFwicGhvZW5peFwiLCBldmVudDogXCJoZWFydGJlYXRcIiwgcGF5bG9hZDoge30sIHJlZjogdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmfSlcbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhlYXJ0YmVhdFRpbWVvdXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKVxuICB9XG5cbiAgYWJub3JtYWxDbG9zZShyZWFzb24pe1xuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgaWYodGhpcy5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5jb25uLmNsb3NlKFdTX0NMT1NFX05PUk1BTCwgcmVhc29uKSB9XG4gIH1cblxuICBmbHVzaFNlbmRCdWZmZXIoKXtcbiAgICBpZih0aGlzLmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApe1xuICAgICAgdGhpcy5zZW5kQnVmZmVyLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soKSlcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdXG4gICAgfVxuICB9XG5cbiAgb25Db25uTWVzc2FnZShyYXdNZXNzYWdlKXtcbiAgICB0aGlzLmRlY29kZShyYXdNZXNzYWdlLmRhdGEsIG1zZyA9PiB7XG4gICAgICBsZXQge3RvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZn0gPSBtc2dcbiAgICAgIGlmKHJlZiAmJiByZWYgPT09IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZil7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVyKVxuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJyZWNlaXZlXCIsIGAke3BheWxvYWQuc3RhdHVzIHx8IFwiXCJ9ICR7dG9waWN9ICR7ZXZlbnR9ICR7cmVmICYmIFwiKFwiICsgcmVmICsgXCIpXCIgfHwgXCJcIn1gLCBwYXlsb2FkKVxuXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldXG4gICAgICAgIGlmKCFjaGFubmVsLmlzTWVtYmVyKHRvcGljLCBldmVudCwgcGF5bG9hZCwgam9pbl9yZWYpKXsgY29udGludWUgfVxuICAgICAgICBjaGFubmVsLnRyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWYpXG4gICAgICB9XG5cbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UubGVuZ3RoOyBpKyspe1xuICAgICAgICBsZXQgWywgY2FsbGJhY2tdID0gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlW2ldXG4gICAgICAgIGNhbGxiYWNrKG1zZylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgbGVhdmVPcGVuVG9waWModG9waWMpe1xuICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKGMgPT4gYy50b3BpYyA9PT0gdG9waWMgJiYgKGMuaXNKb2luZWQoKSB8fCBjLmlzSm9pbmluZygpKSlcbiAgICBpZihkdXBDaGFubmVsKXtcbiAgICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKVxuICAgICAgZHVwQ2hhbm5lbC5sZWF2ZSgpXG4gICAgfVxuICB9XG59XG4iLCAiXG5leHBvcnQgY29uc3QgQ09OU0VDVVRJVkVfUkVMT0FEUyA9IFwiY29uc2VjdXRpdmUtcmVsb2Fkc1wiXG5leHBvcnQgY29uc3QgTUFYX1JFTE9BRFMgPSAxMFxuZXhwb3J0IGNvbnN0IFJFTE9BRF9KSVRURVJfTUlOID0gMTAwMFxuZXhwb3J0IGNvbnN0IFJFTE9BRF9KSVRURVJfTUFYID0gMzAwMFxuZXhwb3J0IGNvbnN0IEZBSUxTQUZFX0pJVFRFUiA9IDMwMDAwXG5leHBvcnQgY29uc3QgUEhYX0VWRU5UX0NMQVNTRVMgPSBbXG4gIFwicGh4LWNsaWNrLWxvYWRpbmdcIiwgXCJwaHgtY2hhbmdlLWxvYWRpbmdcIiwgXCJwaHgtc3VibWl0LWxvYWRpbmdcIixcbiAgXCJwaHgta2V5ZG93bi1sb2FkaW5nXCIsIFwicGh4LWtleXVwLWxvYWRpbmdcIiwgXCJwaHgtYmx1ci1sb2FkaW5nXCIsIFwicGh4LWZvY3VzLWxvYWRpbmdcIlxuXVxuZXhwb3J0IGNvbnN0IFBIWF9DT01QT05FTlQgPSBcImRhdGEtcGh4LWNvbXBvbmVudFwiXG5leHBvcnQgY29uc3QgUEhYX0xJVkVfTElOSyA9IFwiZGF0YS1waHgtbGlua1wiXG5leHBvcnQgY29uc3QgUEhYX1RSQUNLX1NUQVRJQyA9IFwidHJhY2stc3RhdGljXCJcbmV4cG9ydCBjb25zdCBQSFhfTElOS19TVEFURSA9IFwiZGF0YS1waHgtbGluay1zdGF0ZVwiXG5leHBvcnQgY29uc3QgUEhYX1JFRiA9IFwiZGF0YS1waHgtcmVmXCJcbmV4cG9ydCBjb25zdCBQSFhfUkVGX1NSQyA9IFwiZGF0YS1waHgtcmVmLXNyY1wiXG5leHBvcnQgY29uc3QgUEhYX1RSQUNLX1VQTE9BRFMgPSBcInRyYWNrLXVwbG9hZHNcIlxuZXhwb3J0IGNvbnN0IFBIWF9VUExPQURfUkVGID0gXCJkYXRhLXBoeC11cGxvYWQtcmVmXCJcbmV4cG9ydCBjb25zdCBQSFhfUFJFRkxJR0hURURfUkVGUyA9IFwiZGF0YS1waHgtcHJlZmxpZ2h0ZWQtcmVmc1wiXG5leHBvcnQgY29uc3QgUEhYX0RPTkVfUkVGUyA9IFwiZGF0YS1waHgtZG9uZS1yZWZzXCJcbmV4cG9ydCBjb25zdCBQSFhfRFJPUF9UQVJHRVQgPSBcImRyb3AtdGFyZ2V0XCJcbmV4cG9ydCBjb25zdCBQSFhfQUNUSVZFX0VOVFJZX1JFRlMgPSBcImRhdGEtcGh4LWFjdGl2ZS1yZWZzXCJcbmV4cG9ydCBjb25zdCBQSFhfTElWRV9GSUxFX1VQREFURUQgPSBcInBoeDpsaXZlLWZpbGU6dXBkYXRlZFwiXG5leHBvcnQgY29uc3QgUEhYX1NLSVAgPSBcImRhdGEtcGh4LXNraXBcIlxuZXhwb3J0IGNvbnN0IFBIWF9QUlVORSA9IFwiZGF0YS1waHgtcHJ1bmVcIlxuZXhwb3J0IGNvbnN0IFBIWF9QQUdFX0xPQURJTkcgPSBcInBhZ2UtbG9hZGluZ1wiXG5leHBvcnQgY29uc3QgUEhYX0NPTk5FQ1RFRF9DTEFTUyA9IFwicGh4LWNvbm5lY3RlZFwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUyA9IFwicGh4LWxvYWRpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9OT19GRUVEQkFDS19DTEFTUyA9IFwicGh4LW5vLWZlZWRiYWNrXCJcbmV4cG9ydCBjb25zdCBQSFhfRVJST1JfQ0xBU1MgPSBcInBoeC1lcnJvclwiXG5leHBvcnQgY29uc3QgUEhYX1BBUkVOVF9JRCA9IFwiZGF0YS1waHgtcGFyZW50LWlkXCJcbmV4cG9ydCBjb25zdCBQSFhfTUFJTiA9IFwiZGF0YS1waHgtbWFpblwiXG5leHBvcnQgY29uc3QgUEhYX1JPT1RfSUQgPSBcImRhdGEtcGh4LXJvb3QtaWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9UUklHR0VSX0FDVElPTiA9IFwidHJpZ2dlci1hY3Rpb25cIlxuZXhwb3J0IGNvbnN0IFBIWF9GRUVEQkFDS19GT1IgPSBcImZlZWRiYWNrLWZvclwiXG5leHBvcnQgY29uc3QgUEhYX0hBU19GT0NVU0VEID0gXCJwaHgtaGFzLWZvY3VzZWRcIlxuZXhwb3J0IGNvbnN0IEZPQ1VTQUJMRV9JTlBVVFMgPSBbXCJ0ZXh0XCIsIFwidGV4dGFyZWFcIiwgXCJudW1iZXJcIiwgXCJlbWFpbFwiLCBcInBhc3N3b3JkXCIsIFwic2VhcmNoXCIsIFwidGVsXCIsIFwidXJsXCIsIFwiZGF0ZVwiLCBcInRpbWVcIiwgXCJkYXRldGltZS1sb2NhbFwiLCBcImNvbG9yXCIsIFwicmFuZ2VcIl1cbmV4cG9ydCBjb25zdCBDSEVDS0FCTEVfSU5QVVRTID0gW1wiY2hlY2tib3hcIiwgXCJyYWRpb1wiXVxuZXhwb3J0IGNvbnN0IFBIWF9IQVNfU1VCTUlUVEVEID0gXCJwaHgtaGFzLXN1Ym1pdHRlZFwiXG5leHBvcnQgY29uc3QgUEhYX1NFU1NJT04gPSBcImRhdGEtcGh4LXNlc3Npb25cIlxuZXhwb3J0IGNvbnN0IFBIWF9WSUVXX1NFTEVDVE9SID0gYFske1BIWF9TRVNTSU9OfV1gXG5leHBvcnQgY29uc3QgUEhYX1NUSUNLWSA9IFwiZGF0YS1waHgtc3RpY2t5XCJcbmV4cG9ydCBjb25zdCBQSFhfU1RBVElDID0gXCJkYXRhLXBoeC1zdGF0aWNcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUFET05MWSA9IFwiZGF0YS1waHgtcmVhZG9ubHlcIlxuZXhwb3J0IGNvbnN0IFBIWF9ESVNBQkxFRCA9IFwiZGF0YS1waHgtZGlzYWJsZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9ESVNBQkxFX1dJVEggPSBcImRpc2FibGUtd2l0aFwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFID0gXCJkYXRhLXBoeC1kaXNhYmxlLXdpdGgtcmVzdG9yZVwiXG5leHBvcnQgY29uc3QgUEhYX0hPT0sgPSBcImhvb2tcIlxuZXhwb3J0IGNvbnN0IFBIWF9ERUJPVU5DRSA9IFwiZGVib3VuY2VcIlxuZXhwb3J0IGNvbnN0IFBIWF9USFJPVFRMRSA9IFwidGhyb3R0bGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9VUERBVEUgPSBcInVwZGF0ZVwiXG5leHBvcnQgY29uc3QgUEhYX0tFWSA9IFwia2V5XCJcbmV4cG9ydCBjb25zdCBQSFhfUFJJVkFURSA9IFwicGh4UHJpdmF0ZVwiXG5leHBvcnQgY29uc3QgUEhYX0FVVE9fUkVDT1ZFUiA9IFwiYXV0by1yZWNvdmVyXCJcbmV4cG9ydCBjb25zdCBQSFhfTFZfREVCVUcgPSBcInBoeDpsaXZlLXNvY2tldDpkZWJ1Z1wiXG5leHBvcnQgY29uc3QgUEhYX0xWX1BST0ZJTEUgPSBcInBoeDpsaXZlLXNvY2tldDpwcm9maWxpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9MVl9MQVRFTkNZX1NJTSA9IFwicGh4OmxpdmUtc29ja2V0OmxhdGVuY3ktc2ltXCJcbmV4cG9ydCBjb25zdCBQSFhfUFJPR1JFU1MgPSBcInByb2dyZXNzXCJcbmV4cG9ydCBjb25zdCBMT0FERVJfVElNRU9VVCA9IDFcbmV4cG9ydCBjb25zdCBCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUID0gMjAwXG5leHBvcnQgY29uc3QgQklORElOR19QUkVGSVggPSBcInBoeC1cIlxuZXhwb3J0IGNvbnN0IFBVU0hfVElNRU9VVCA9IDMwMDAwXG5leHBvcnQgY29uc3QgTElOS19IRUFERVIgPSBcIngtcmVxdWVzdGVkLXdpdGhcIlxuZXhwb3J0IGNvbnN0IFJFU1BPTlNFX1VSTF9IRUFERVIgPSBcIngtcmVzcG9uc2UtdXJsXCJcbmV4cG9ydCBjb25zdCBERUJPVU5DRV9UUklHR0VSID0gXCJkZWJvdW5jZS10cmlnZ2VyXCJcbmV4cG9ydCBjb25zdCBUSFJPVFRMRUQgPSBcInRocm90dGxlZFwiXG5leHBvcnQgY29uc3QgREVCT1VOQ0VfUFJFVl9LRVkgPSBcImRlYm91bmNlLXByZXYta2V5XCJcbmV4cG9ydCBjb25zdCBERUZBVUxUUyA9IHtcbiAgZGVib3VuY2U6IDMwMCxcbiAgdGhyb3R0bGU6IDMwMFxufVxuXG4vLyBSZW5kZXJlZFxuZXhwb3J0IGNvbnN0IERZTkFNSUNTID0gXCJkXCJcbmV4cG9ydCBjb25zdCBTVEFUSUMgPSBcInNcIlxuZXhwb3J0IGNvbnN0IENPTVBPTkVOVFMgPSBcImNcIlxuZXhwb3J0IGNvbnN0IEVWRU5UUyA9IFwiZVwiXG5leHBvcnQgY29uc3QgUkVQTFkgPSBcInJcIlxuZXhwb3J0IGNvbnN0IFRJVExFID0gXCJ0XCJcbmV4cG9ydCBjb25zdCBURU1QTEFURVMgPSBcInBcIlxuIiwgImltcG9ydCB7XG4gIGxvZ0Vycm9yXG59IGZyb20gXCIuL3V0aWxzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50cnlVcGxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGVudHJ5LCBjaHVua1NpemUsIGxpdmVTb2NrZXQpe1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcbiAgICB0aGlzLmVudHJ5ID0gZW50cnlcbiAgICB0aGlzLm9mZnNldCA9IDBcbiAgICB0aGlzLmNodW5rU2l6ZSA9IGNodW5rU2l6ZVxuICAgIHRoaXMuY2h1bmtUaW1lciA9IG51bGxcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwgPSBsaXZlU29ja2V0LmNoYW5uZWwoYGx2dToke2VudHJ5LnJlZn1gLCB7dG9rZW46IGVudHJ5Lm1ldGFkYXRhKCl9KVxuICB9XG5cbiAgZXJyb3IocmVhc29uKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jaHVua1RpbWVyKVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5sZWF2ZSgpXG4gICAgdGhpcy5lbnRyeS5lcnJvcihyZWFzb24pXG4gIH1cblxuICB1cGxvYWQoKXtcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwub25FcnJvcihyZWFzb24gPT4gdGhpcy5lcnJvcihyZWFzb24pKVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5qb2luKClcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgX2RhdGEgPT4gdGhpcy5yZWFkTmV4dENodW5rKCkpXG4gICAgICAucmVjZWl2ZShcImVycm9yXCIsIHJlYXNvbiA9PiB0aGlzLmVycm9yKHJlYXNvbikpXG4gIH1cblxuICBpc0RvbmUoKXsgcmV0dXJuIHRoaXMub2Zmc2V0ID49IHRoaXMuZW50cnkuZmlsZS5zaXplIH1cblxuICByZWFkTmV4dENodW5rKCl7XG4gICAgbGV0IHJlYWRlciA9IG5ldyB3aW5kb3cuRmlsZVJlYWRlcigpXG4gICAgbGV0IGJsb2IgPSB0aGlzLmVudHJ5LmZpbGUuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMuY2h1bmtTaXplICsgdGhpcy5vZmZzZXQpXG4gICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICBpZihlLnRhcmdldC5lcnJvciA9PT0gbnVsbCl7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IGUudGFyZ2V0LnJlc3VsdC5ieXRlTGVuZ3RoXG4gICAgICAgIHRoaXMucHVzaENodW5rKGUudGFyZ2V0LnJlc3VsdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2dFcnJvcihcIlJlYWQgZXJyb3I6IFwiICsgZS50YXJnZXQuZXJyb3IpXG4gICAgICB9XG4gICAgfVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICB9XG5cbiAgcHVzaENodW5rKGNodW5rKXtcbiAgICBpZighdGhpcy51cGxvYWRDaGFubmVsLmlzSm9pbmVkKCkpeyByZXR1cm4gfVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5wdXNoKFwiY2h1bmtcIiwgY2h1bmspXG4gICAgICAucmVjZWl2ZShcIm9rXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5lbnRyeS5wcm9ncmVzcygodGhpcy5vZmZzZXQgLyB0aGlzLmVudHJ5LmZpbGUuc2l6ZSkgKiAxMDApXG4gICAgICAgIGlmKCF0aGlzLmlzRG9uZSgpKXtcbiAgICAgICAgICB0aGlzLmNodW5rVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVhZE5leHRDaHVuaygpLCB0aGlzLmxpdmVTb2NrZXQuZ2V0TGF0ZW5jeVNpbSgpIHx8IDApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBQSFhfVklFV19TRUxFQ1RPUlxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQgRW50cnlVcGxvYWRlciBmcm9tIFwiLi9lbnRyeV91cGxvYWRlclwiXG5cbmV4cG9ydCBsZXQgbG9nRXJyb3IgPSAobXNnLCBvYmopID0+IGNvbnNvbGUuZXJyb3IgJiYgY29uc29sZS5lcnJvcihtc2csIG9iailcblxuZXhwb3J0IGxldCBpc0NpZCA9IChjaWQpID0+IHtcbiAgbGV0IHR5cGUgPSB0eXBlb2YoY2lkKVxuICByZXR1cm4gdHlwZSA9PT0gXCJudW1iZXJcIiB8fCAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAvXigwfFsxLTldXFxkKikkLy50ZXN0KGNpZCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3REdXBsaWNhdGVJZHMoKXtcbiAgbGV0IGlkcyA9IG5ldyBTZXQoKVxuICBsZXQgZWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKltpZF1cIilcbiAgZm9yKGxldCBpID0gMCwgbGVuID0gZWxlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgIGlmKGlkcy5oYXMoZWxlbXNbaV0uaWQpKXtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYE11bHRpcGxlIElEcyBkZXRlY3RlZDogJHtlbGVtc1tpXS5pZH0uIEVuc3VyZSB1bmlxdWUgZWxlbWVudCBpZHMuYClcbiAgICB9IGVsc2Uge1xuICAgICAgaWRzLmFkZChlbGVtc1tpXS5pZClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGxldCBkZWJ1ZyA9ICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4ge1xuICBpZih2aWV3LmxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSl7XG4gICAgY29uc29sZS5sb2coYCR7dmlldy5pZH0gJHtraW5kfTogJHttc2d9IC0gYCwgb2JqKVxuICB9XG59XG5cbi8vIHdyYXBzIHZhbHVlIGluIGNsb3N1cmUgb3IgcmV0dXJucyBjbG9zdXJlXG5leHBvcnQgbGV0IGNsb3N1cmUgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIgPyB2YWwgOiBmdW5jdGlvbiAoKXsgcmV0dXJuIHZhbCB9XG5cbmV4cG9ydCBsZXQgY2xvbmUgPSAob2JqKSA9PiB7IHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpIH1cblxuZXhwb3J0IGxldCBjbG9zZXN0UGh4QmluZGluZyA9IChlbCwgYmluZGluZywgYm9yZGVyRWwpID0+IHtcbiAgZG8ge1xuICAgIGlmKGVsLm1hdGNoZXMoYFske2JpbmRpbmd9XWApKXsgcmV0dXJuIGVsIH1cbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZVxuICB9IHdoaWxlKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxICYmICEoKGJvcmRlckVsICYmIGJvcmRlckVsLmlzU2FtZU5vZGUoZWwpKSB8fCBlbC5tYXRjaGVzKFBIWF9WSUVXX1NFTEVDVE9SKSkpXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBsZXQgaXNPYmplY3QgPSAob2JqKSA9PiB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhKG9iaiBpbnN0YW5jZW9mIEFycmF5KVxufVxuXG5leHBvcnQgbGV0IGlzRXF1YWxPYmogPSAob2JqMSwgb2JqMikgPT4gSlNPTi5zdHJpbmdpZnkob2JqMSkgPT09IEpTT04uc3RyaW5naWZ5KG9iajIpXG5cbmV4cG9ydCBsZXQgaXNFbXB0eSA9IChvYmopID0+IHtcbiAgZm9yKGxldCB4IGluIG9iail7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBsZXQgbWF5YmUgPSAoZWwsIGNhbGxiYWNrKSA9PiBlbCAmJiBjYWxsYmFjayhlbClcblxuZXhwb3J0IGxldCBjaGFubmVsVXBsb2FkZXIgPSBmdW5jdGlvbiAoZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldCl7XG4gIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgbGV0IGVudHJ5VXBsb2FkZXIgPSBuZXcgRW50cnlVcGxvYWRlcihlbnRyeSwgcmVzcC5jb25maWcuY2h1bmtfc2l6ZSwgbGl2ZVNvY2tldClcbiAgICBlbnRyeVVwbG9hZGVyLnVwbG9hZCgpXG4gIH0pXG59XG4iLCAibGV0IEJyb3dzZXIgPSB7XG4gIGNhblB1c2hTdGF0ZSgpeyByZXR1cm4gKHR5cGVvZiAoaGlzdG9yeS5wdXNoU3RhdGUpICE9PSBcInVuZGVmaW5lZFwiKSB9LFxuXG4gIGRyb3BMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KXtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5sb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSkpXG4gIH0sXG5cbiAgdXBkYXRlTG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSwgaW5pdGlhbCwgZnVuYyl7XG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLmdldExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpXG4gICAgbGV0IGtleSA9IHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpXG4gICAgbGV0IG5ld1ZhbCA9IGN1cnJlbnQgPT09IG51bGwgPyBpbml0aWFsIDogZnVuYyhjdXJyZW50KVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkobmV3VmFsKSlcbiAgICByZXR1cm4gbmV3VmFsXG4gIH0sXG5cbiAgZ2V0TG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSl7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5sb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSkpKVxuICB9LFxuXG4gIHVwZGF0ZUN1cnJlbnRTdGF0ZShjYWxsYmFjayl7XG4gICAgaWYoIXRoaXMuY2FuUHVzaFN0YXRlKCkpeyByZXR1cm4gfVxuICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKGNhbGxiYWNrKGhpc3Rvcnkuc3RhdGUgfHwge30pLCBcIlwiLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgfSxcblxuICBwdXNoU3RhdGUoa2luZCwgbWV0YSwgdG8pe1xuICAgIGlmKHRoaXMuY2FuUHVzaFN0YXRlKCkpe1xuICAgICAgaWYodG8gIT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmKXtcbiAgICAgICAgaWYobWV0YS50eXBlID09IFwicmVkaXJlY3RcIiAmJiBtZXRhLnNjcm9sbCl7XG4gICAgICAgICAgLy8gSWYgd2UncmUgcmVkaXJlY3Rpbmcgc3RvcmUgdGhlIGN1cnJlbnQgc2Nyb2xsWSBmb3IgdGhlIGN1cnJlbnQgaGlzdG9yeSBzdGF0ZS5cbiAgICAgICAgICBsZXQgY3VycmVudFN0YXRlID0gaGlzdG9yeS5zdGF0ZSB8fCB7fVxuICAgICAgICAgIGN1cnJlbnRTdGF0ZS5zY3JvbGwgPSBtZXRhLnNjcm9sbFxuICAgICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKGN1cnJlbnRTdGF0ZSwgXCJcIiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgbWV0YS5zY3JvbGwgLy8gT25seSBzdG9yZSB0aGUgc2Nyb2xsIGluIHRoZSByZWRpcmVjdCBjYXNlLlxuICAgICAgICBoaXN0b3J5W2tpbmQgKyBcIlN0YXRlXCJdKG1ldGEsIFwiXCIsIHRvIHx8IG51bGwpIC8vIElFIHdpbGwgY29lcmNlIHVuZGVmaW5lZCB0byBzdHJpbmdcbiAgICAgICAgbGV0IGhhc2hFbCA9IHRoaXMuZ2V0SGFzaFRhcmdldEVsKHdpbmRvdy5sb2NhdGlvbi5oYXNoKVxuXG4gICAgICAgIGlmKGhhc2hFbCl7XG4gICAgICAgICAgaGFzaEVsLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAgfSBlbHNlIGlmKG1ldGEudHlwZSA9PT0gXCJyZWRpcmVjdFwiKXtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsKDAsIDApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWRpcmVjdCh0bylcbiAgICB9XG4gIH0sXG5cbiAgc2V0Q29va2llKG5hbWUsIHZhbHVlKXtcbiAgICBkb2N1bWVudC5jb29raWUgPSBgJHtuYW1lfT0ke3ZhbHVlfWBcbiAgfSxcblxuICBnZXRDb29raWUobmFtZSl7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNvb2tpZS5yZXBsYWNlKG5ldyBSZWdFeHAoYCg/Oig/Ol58Lio7XFxzKikke25hbWV9XFxzKlxcPVxccyooW147XSopLiokKXxeLiokYCksIFwiJDFcIilcbiAgfSxcblxuICByZWRpcmVjdCh0b1VSTCwgZmxhc2gpe1xuICAgIGlmKGZsYXNoKXsgQnJvd3Nlci5zZXRDb29raWUoXCJfX3Bob2VuaXhfZmxhc2hfX1wiLCBmbGFzaCArIFwiOyBtYXgtYWdlPTYwMDAwOyBwYXRoPS9cIikgfVxuICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRvVVJMXG4gIH0sXG5cbiAgbG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpeyByZXR1cm4gYCR7bmFtZXNwYWNlfS0ke3N1YmtleX1gIH0sXG5cbiAgZ2V0SGFzaFRhcmdldEVsKG1heWJlSGFzaCl7XG4gICAgbGV0IGhhc2ggPSBtYXliZUhhc2gudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSlcbiAgICBpZihoYXNoID09PSBcIlwiKXsgcmV0dXJuIH1cbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCkgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgYVtuYW1lPVwiJHtoYXNofVwiXWApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnJvd3NlclxuIiwgImltcG9ydCB7XG4gIENIRUNLQUJMRV9JTlBVVFMsXG4gIERFQk9VTkNFX1BSRVZfS0VZLFxuICBERUJPVU5DRV9UUklHR0VSLFxuICBGT0NVU0FCTEVfSU5QVVRTLFxuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfRVZFTlRfQ0xBU1NFUyxcbiAgUEhYX0hBU19GT0NVU0VELFxuICBQSFhfSEFTX1NVQk1JVFRFRCxcbiAgUEhYX01BSU4sXG4gIFBIWF9OT19GRUVEQkFDS19DTEFTUyxcbiAgUEhYX1BBUkVOVF9JRCxcbiAgUEhYX1BSSVZBVEUsXG4gIFBIWF9SRUYsXG4gIFBIWF9SRUZfU1JDLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9VUExPQURfUkVGLFxuICBQSFhfVklFV19TRUxFQ1RPUixcbiAgUEhYX1NUSUNLWSxcbiAgVEhST1RUTEVEXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGxvZ0Vycm9yXG59IGZyb20gXCIuL3V0aWxzXCJcblxubGV0IERPTSA9IHtcbiAgYnlJZChpZCl7IHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgfHwgbG9nRXJyb3IoYG5vIGlkIGZvdW5kIGZvciAke2lkfWApIH0sXG5cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSl7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpXG4gICAgaWYoZWwuY2xhc3NMaXN0Lmxlbmd0aCA9PT0gMCl7IGVsLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpIH1cbiAgfSxcblxuICBhbGwobm9kZSwgcXVlcnksIGNhbGxiYWNrKXtcbiAgICBpZighbm9kZSl7IHJldHVybiBbXSB9XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuZnJvbShub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKVxuICAgIHJldHVybiBjYWxsYmFjayA/IGFycmF5LmZvckVhY2goY2FsbGJhY2spIDogYXJyYXlcbiAgfSxcblxuICBjaGlsZE5vZGVMZW5ndGgoaHRtbCl7XG4gICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmNoaWxkRWxlbWVudENvdW50XG4gIH0sXG5cbiAgaXNVcGxvYWRJbnB1dChlbCl7IHJldHVybiBlbC50eXBlID09PSBcImZpbGVcIiAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpICE9PSBudWxsIH0sXG5cbiAgZmluZFVwbG9hZElucHV0cyhub2RlKXsgcmV0dXJuIHRoaXMuYWxsKG5vZGUsIGBpbnB1dFt0eXBlPVwiZmlsZVwiXVske1BIWF9VUExPQURfUkVGfV1gKSB9LFxuXG4gIGZpbmRDb21wb25lbnROb2RlTGlzdChub2RlLCBjaWQpe1xuICAgIHJldHVybiB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl1gKSwgbm9kZSlcbiAgfSxcblxuICBpc1BoeERlc3Ryb3llZChub2RlKXtcbiAgICByZXR1cm4gbm9kZS5pZCAmJiBET00ucHJpdmF0ZShub2RlLCBcImRlc3Ryb3llZFwiKSA/IHRydWUgOiBmYWxzZVxuICB9LFxuXG4gIG1hcmtQaHhDaGlsZERlc3Ryb3llZChlbCl7XG4gICAgaWYodGhpcy5pc1BoeENoaWxkKGVsKSl7IGVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgXCJcIikgfVxuICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgXCJkZXN0cm95ZWRcIiwgdHJ1ZSlcbiAgfSxcblxuICBmaW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50KGh0bWwsIHBhcmVudElkKXtcbiAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sXG4gICAgcmV0dXJuIHRoaXMuZmluZFBoeENoaWxkcmVuKHRlbXBsYXRlLmNvbnRlbnQsIHBhcmVudElkKVxuICB9LFxuXG4gIGlzSWdub3JlZChlbCwgcGh4VXBkYXRlKXtcbiAgICByZXR1cm4gKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpIHx8IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXVwZGF0ZVwiKSkgPT09IFwiaWdub3JlXCJcbiAgfSxcblxuICBpc1BoeFVwZGF0ZShlbCwgcGh4VXBkYXRlLCB1cGRhdGVUeXBlcyl7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiB1cGRhdGVUeXBlcy5pbmRleE9mKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpKSA+PSAwXG4gIH0sXG5cbiAgZmluZFBoeFN0aWNreShlbCl7IHJldHVybiB0aGlzLmFsbChlbCwgYFske1BIWF9TVElDS1l9XWApIH0sXG5cbiAgZmluZFBoeENoaWxkcmVuKGVsLCBwYXJlbnRJZCl7XG4gICAgcmV0dXJuIHRoaXMuYWxsKGVsLCBgJHtQSFhfVklFV19TRUxFQ1RPUn1bJHtQSFhfUEFSRU5UX0lEfT1cIiR7cGFyZW50SWR9XCJdYClcbiAgfSxcblxuICBmaW5kUGFyZW50Q0lEcyhub2RlLCBjaWRzKXtcbiAgICBsZXQgaW5pdGlhbCA9IG5ldyBTZXQoY2lkcylcbiAgICByZXR1cm4gY2lkcy5yZWR1Y2UoKGFjYywgY2lkKSA9PiB7XG4gICAgICBsZXQgc2VsZWN0b3IgPSBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl0gWyR7UEhYX0NPTVBPTkVOVH1dYFxuXG4gICAgICB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBzZWxlY3RvciksIG5vZGUpXG4gICAgICAgIC5tYXAoZWwgPT4gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpKSlcbiAgICAgICAgLmZvckVhY2goY2hpbGRDSUQgPT4gYWNjLmRlbGV0ZShjaGlsZENJRCkpXG5cbiAgICAgIHJldHVybiBhY2NcbiAgICB9LCBpbml0aWFsKVxuICB9LFxuXG4gIGZpbHRlcldpdGhpblNhbWVMaXZlVmlldyhub2RlcywgcGFyZW50KXtcbiAgICBpZihwYXJlbnQucXVlcnlTZWxlY3RvcihQSFhfVklFV19TRUxFQ1RPUikpe1xuICAgICAgcmV0dXJuIG5vZGVzLmZpbHRlcihlbCA9PiB0aGlzLndpdGhpblNhbWVMaXZlVmlldyhlbCwgcGFyZW50KSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGVzXG4gICAgfVxuICB9LFxuXG4gIHdpdGhpblNhbWVMaXZlVmlldyhub2RlLCBwYXJlbnQpe1xuICAgIHdoaWxlKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpe1xuICAgICAgaWYobm9kZS5pc1NhbWVOb2RlKHBhcmVudCkpeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBpZihub2RlLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTikgIT09IG51bGwpeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgfSxcblxuICBwcml2YXRlKGVsLCBrZXkpeyByZXR1cm4gZWxbUEhYX1BSSVZBVEVdICYmIGVsW1BIWF9QUklWQVRFXVtrZXldIH0sXG5cbiAgZGVsZXRlUHJpdmF0ZShlbCwga2V5KXsgZWxbUEhYX1BSSVZBVEVdICYmIGRlbGV0ZSAoZWxbUEhYX1BSSVZBVEVdW2tleV0pIH0sXG5cbiAgcHV0UHJpdmF0ZShlbCwga2V5LCB2YWx1ZSl7XG4gICAgaWYoIWVsW1BIWF9QUklWQVRFXSl7IGVsW1BIWF9QUklWQVRFXSA9IHt9IH1cbiAgICBlbFtQSFhfUFJJVkFURV1ba2V5XSA9IHZhbHVlXG4gIH0sXG5cbiAgdXBkYXRlUHJpdmF0ZShlbCwga2V5LCBkZWZhdWx0VmFsLCB1cGRhdGVGdW5jKXtcbiAgICBsZXQgZXhpc3RpbmcgPSB0aGlzLnByaXZhdGUoZWwsIGtleSlcbiAgICBpZihleGlzdGluZyA9PT0gdW5kZWZpbmVkKXtcbiAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwga2V5LCB1cGRhdGVGdW5jKGRlZmF1bHRWYWwpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdXBkYXRlRnVuYyhleGlzdGluZykpXG4gICAgfVxuICB9LFxuXG4gIGNvcHlQcml2YXRlcyh0YXJnZXQsIHNvdXJjZSl7XG4gICAgaWYoc291cmNlW1BIWF9QUklWQVRFXSl7XG4gICAgICB0YXJnZXRbUEhYX1BSSVZBVEVdID0gc291cmNlW1BIWF9QUklWQVRFXVxuICAgIH1cbiAgfSxcblxuICBwdXRUaXRsZShzdHIpe1xuICAgIGxldCB0aXRsZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRpdGxlXCIpXG4gICAgbGV0IHtwcmVmaXgsIHN1ZmZpeH0gPSB0aXRsZUVsLmRhdGFzZXRcbiAgICBkb2N1bWVudC50aXRsZSA9IGAke3ByZWZpeCB8fCBcIlwifSR7c3RyfSR7c3VmZml4IHx8IFwiXCJ9YFxuICB9LFxuXG4gIGRlYm91bmNlKGVsLCBldmVudCwgcGh4RGVib3VuY2UsIGRlZmF1bHREZWJvdW5jZSwgcGh4VGhyb3R0bGUsIGRlZmF1bHRUaHJvdHRsZSwgY2FsbGJhY2spe1xuICAgIGxldCBkZWJvdW5jZSA9IGVsLmdldEF0dHJpYnV0ZShwaHhEZWJvdW5jZSlcbiAgICBsZXQgdGhyb3R0bGUgPSBlbC5nZXRBdHRyaWJ1dGUocGh4VGhyb3R0bGUpXG4gICAgaWYoZGVib3VuY2UgPT09IFwiXCIpeyBkZWJvdW5jZSA9IGRlZmF1bHREZWJvdW5jZSB9XG4gICAgaWYodGhyb3R0bGUgPT09IFwiXCIpeyB0aHJvdHRsZSA9IGRlZmF1bHRUaHJvdHRsZSB9XG4gICAgbGV0IHZhbHVlID0gZGVib3VuY2UgfHwgdGhyb3R0bGVcbiAgICBzd2l0Y2godmFsdWUpe1xuICAgICAgY2FzZSBudWxsOiByZXR1cm4gY2FsbGJhY2soKVxuXG4gICAgICBjYXNlIFwiYmx1clwiOlxuICAgICAgICBpZih0aGlzLm9uY2UoZWwsIFwiZGVib3VuY2UtYmx1clwiKSl7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgKCkgPT4gY2FsbGJhY2soKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGV0IHRpbWVvdXQgPSBwYXJzZUludCh2YWx1ZSlcbiAgICAgICAgbGV0IHRyaWdnZXIgPSAoKSA9PiB0aHJvdHRsZSA/IHRoaXMuZGVsZXRlUHJpdmF0ZShlbCwgVEhST1RUTEVEKSA6IGNhbGxiYWNrKClcbiAgICAgICAgbGV0IGN1cnJlbnRDeWNsZSA9IHRoaXMuaW5jQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIsIHRyaWdnZXIpXG4gICAgICAgIGlmKGlzTmFOKHRpbWVvdXQpKXsgcmV0dXJuIGxvZ0Vycm9yKGBpbnZhbGlkIHRocm90dGxlL2RlYm91bmNlIHZhbHVlOiAke3ZhbHVlfWApIH1cbiAgICAgICAgaWYodGhyb3R0bGUpe1xuICAgICAgICAgIGxldCBuZXdLZXlEb3duID0gZmFsc2VcbiAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImtleWRvd25cIil7XG4gICAgICAgICAgICBsZXQgcHJldktleSA9IHRoaXMucHJpdmF0ZShlbCwgREVCT1VOQ0VfUFJFVl9LRVkpXG4gICAgICAgICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIERFQk9VTkNFX1BSRVZfS0VZLCBldmVudC5rZXkpXG4gICAgICAgICAgICBuZXdLZXlEb3duID0gcHJldktleSAhPT0gZXZlbnQua2V5XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIW5ld0tleURvd24gJiYgdGhpcy5wcml2YXRlKGVsLCBUSFJPVFRMRUQpKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIFRIUk9UVExFRCwgdHJ1ZSlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy50cmlnZ2VyQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIpLCB0aW1lb3V0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCBjdXJyZW50Q3ljbGUpLCB0aW1lb3V0KVxuICAgICAgICB9XG5cblxuICAgICAgICBsZXQgZm9ybSA9IGVsLmZvcm1cbiAgICAgICAgaWYoZm9ybSAmJiB0aGlzLm9uY2UoZm9ybSwgXCJiaW5kLWRlYm91bmNlXCIpKXtcbiAgICAgICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgQXJyYXkuZnJvbSgobmV3IEZvcm1EYXRhKGZvcm0pKS5lbnRyaWVzKCksIChbbmFtZV0pID0+IHtcbiAgICAgICAgICAgICAgbGV0IGlucHV0ID0gZm9ybS5xdWVyeVNlbGVjdG9yKGBbbmFtZT1cIiR7bmFtZX1cIl1gKVxuICAgICAgICAgICAgICB0aGlzLmluY0N5Y2xlKGlucHV0LCBERUJPVU5DRV9UUklHR0VSKVxuICAgICAgICAgICAgICB0aGlzLmRlbGV0ZVByaXZhdGUoaW5wdXQsIFRIUk9UVExFRClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLm9uY2UoZWwsIFwiYmluZC1kZWJvdW5jZVwiKSl7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgKCkgPT4gdGhpcy50cmlnZ2VyQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIpKVxuICAgICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRyaWdnZXJDeWNsZShlbCwga2V5LCBjdXJyZW50Q3ljbGUpe1xuICAgIGxldCBbY3ljbGUsIHRyaWdnZXJdID0gdGhpcy5wcml2YXRlKGVsLCBrZXkpXG4gICAgaWYoIWN1cnJlbnRDeWNsZSl7IGN1cnJlbnRDeWNsZSA9IGN5Y2xlIH1cbiAgICBpZihjdXJyZW50Q3ljbGUgPT09IGN5Y2xlKXtcbiAgICAgIHRoaXMuaW5jQ3ljbGUoZWwsIGtleSlcbiAgICAgIHRyaWdnZXIoKVxuICAgIH1cbiAgfSxcblxuICBvbmNlKGVsLCBrZXkpe1xuICAgIGlmKHRoaXMucHJpdmF0ZShlbCwga2V5KSA9PT0gdHJ1ZSl7IHJldHVybiBmYWxzZSB9XG4gICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIHRydWUpXG4gICAgcmV0dXJuIHRydWVcbiAgfSxcblxuICBpbmNDeWNsZShlbCwga2V5LCB0cmlnZ2VyID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIGxldCBbY3VycmVudEN5Y2xlXSA9IHRoaXMucHJpdmF0ZShlbCwga2V5KSB8fCBbMCwgdHJpZ2dlcl1cbiAgICBjdXJyZW50Q3ljbGUrK1xuICAgIHRoaXMucHV0UHJpdmF0ZShlbCwga2V5LCBbY3VycmVudEN5Y2xlLCB0cmlnZ2VyXSlcbiAgICByZXR1cm4gY3VycmVudEN5Y2xlXG4gIH0sXG5cbiAgZGlzY2FyZEVycm9yKGNvbnRhaW5lciwgZWwsIHBoeEZlZWRiYWNrRm9yKXtcbiAgICBsZXQgZmllbGQgPSBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKHBoeEZlZWRiYWNrRm9yKVxuICAgIC8vIFRPRE86IFJlbW92ZSBpZCBsb29rdXAgYWZ0ZXIgd2UgdXBkYXRlIFBob2VuaXggdG8gdXNlIGlucHV0X25hbWUgaW5zdGVhZCBvZiBpbnB1dF9pZFxuICAgIGxldCBpbnB1dCA9IGZpZWxkICYmIGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGBbaWQ9XCIke2ZpZWxkfVwiXSwgW25hbWU9XCIke2ZpZWxkfVwiXWApXG4gICAgaWYoIWlucHV0KXsgcmV0dXJuIH1cblxuICAgIGlmKCEodGhpcy5wcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQpIHx8IHRoaXMucHJpdmF0ZShpbnB1dC5mb3JtLCBQSFhfSEFTX1NVQk1JVFRFRCkpKXtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoUEhYX05PX0ZFRURCQUNLX0NMQVNTKVxuICAgIH1cbiAgfSxcblxuICBzaG93RXJyb3IoaW5wdXRFbCwgcGh4RmVlZGJhY2tGb3Ipe1xuICAgIGlmKGlucHV0RWwuaWQgfHwgaW5wdXRFbC5uYW1lKXtcbiAgICAgIHRoaXMuYWxsKGlucHV0RWwuZm9ybSwgYFske3BoeEZlZWRiYWNrRm9yfT1cIiR7aW5wdXRFbC5pZH1cIl0sIFske3BoeEZlZWRiYWNrRm9yfT1cIiR7aW5wdXRFbC5uYW1lfVwiXWAsIChlbCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKGVsLCBQSFhfTk9fRkVFREJBQ0tfQ0xBU1MpXG4gICAgICB9KVxuICAgIH1cbiAgfSxcblxuICBpc1BoeENoaWxkKG5vZGUpe1xuICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKVxuICB9LFxuXG4gIGlzUGh4U3RpY2t5KG5vZGUpe1xuICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShQSFhfU1RJQ0tZKSAhPT0gbnVsbFxuICB9LFxuXG4gIGZpcnN0UGh4Q2hpbGQoZWwpe1xuICAgIHJldHVybiB0aGlzLmlzUGh4Q2hpbGQoZWwpID8gZWwgOiB0aGlzLmFsbChlbCwgYFske1BIWF9QQVJFTlRfSUR9XWApWzBdXG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudCh0YXJnZXQsIGV2ZW50U3RyaW5nLCBkZXRhaWwgPSB7fSl7XG4gICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50U3RyaW5nLCB7YnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSwgZGV0YWlsOiBkZXRhaWx9KVxuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICB9LFxuXG4gIGNsb25lTm9kZShub2RlLCBodG1sKXtcbiAgICBpZih0eXBlb2YgKGh0bWwpID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgIHJldHVybiBub2RlLmNsb25lTm9kZSh0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY2xvbmVkID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpXG4gICAgICBjbG9uZWQuaW5uZXJIVE1MID0gaHRtbFxuICAgICAgcmV0dXJuIGNsb25lZFxuICAgIH1cbiAgfSxcblxuICBtZXJnZUF0dHJzKHRhcmdldCwgc291cmNlLCBvcHRzID0ge30pe1xuICAgIGxldCBleGNsdWRlID0gb3B0cy5leGNsdWRlIHx8IFtdXG4gICAgbGV0IGlzSWdub3JlZCA9IG9wdHMuaXNJZ25vcmVkXG4gICAgbGV0IHNvdXJjZUF0dHJzID0gc291cmNlLmF0dHJpYnV0ZXNcbiAgICBmb3IobGV0IGkgPSBzb3VyY2VBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICBsZXQgbmFtZSA9IHNvdXJjZUF0dHJzW2ldLm5hbWVcbiAgICAgIGlmKGV4Y2x1ZGUuaW5kZXhPZihuYW1lKSA8IDApeyB0YXJnZXQuc2V0QXR0cmlidXRlKG5hbWUsIHNvdXJjZS5nZXRBdHRyaWJ1dGUobmFtZSkpIH1cbiAgICB9XG5cbiAgICBsZXQgdGFyZ2V0QXR0cnMgPSB0YXJnZXQuYXR0cmlidXRlc1xuICAgIGZvcihsZXQgaSA9IHRhcmdldEF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcbiAgICAgIGxldCBuYW1lID0gdGFyZ2V0QXR0cnNbaV0ubmFtZVxuICAgICAgaWYoaXNJZ25vcmVkKXtcbiAgICAgICAgaWYobmFtZS5zdGFydHNXaXRoKFwiZGF0YS1cIikgJiYgIXNvdXJjZS5oYXNBdHRyaWJ1dGUobmFtZSkpeyB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKCFzb3VyY2UuaGFzQXR0cmlidXRlKG5hbWUpKXsgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShuYW1lKSB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG1lcmdlRm9jdXNlZElucHV0KHRhcmdldCwgc291cmNlKXtcbiAgICAvLyBza2lwIHNlbGVjdHMgYmVjYXVzZSBGRiB3aWxsIHJlc2V0IGhpZ2hsaWdodGVkIGluZGV4IGZvciBhbnkgc2V0QXR0cmlidXRlXG4gICAgaWYoISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCkpeyBET00ubWVyZ2VBdHRycyh0YXJnZXQsIHNvdXJjZSwge2V4Y2VwdDogW1widmFsdWVcIl19KSB9XG4gICAgaWYoc291cmNlLnJlYWRPbmx5KXtcbiAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwicmVhZG9ubHlcIilcbiAgICB9XG4gIH0sXG5cbiAgaGFzU2VsZWN0aW9uUmFuZ2UoZWwpe1xuICAgIHJldHVybiBlbC5zZXRTZWxlY3Rpb25SYW5nZSAmJiAoZWwudHlwZSA9PT0gXCJ0ZXh0XCIgfHwgZWwudHlwZSA9PT0gXCJ0ZXh0YXJlYVwiKVxuICB9LFxuXG4gIHJlc3RvcmVGb2N1cyhmb2N1c2VkLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKXtcbiAgICBpZighRE9NLmlzVGV4dHVhbElucHV0KGZvY3VzZWQpKXsgcmV0dXJuIH1cbiAgICBsZXQgd2FzRm9jdXNlZCA9IGZvY3VzZWQubWF0Y2hlcyhcIjpmb2N1c1wiKVxuICAgIGlmKGZvY3VzZWQucmVhZE9ubHkpeyBmb2N1c2VkLmJsdXIoKSB9XG4gICAgaWYoIXdhc0ZvY3VzZWQpeyBmb2N1c2VkLmZvY3VzKCkgfVxuICAgIGlmKHRoaXMuaGFzU2VsZWN0aW9uUmFuZ2UoZm9jdXNlZCkpe1xuICAgICAgZm9jdXNlZC5zZXRTZWxlY3Rpb25SYW5nZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKVxuICAgIH1cbiAgfSxcblxuICBpc0Zvcm1JbnB1dChlbCl7IHJldHVybiAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYSkkL2kudGVzdChlbC50YWdOYW1lKSAmJiBlbC50eXBlICE9PSBcImJ1dHRvblwiIH0sXG5cbiAgc3luY0F0dHJzVG9Qcm9wcyhlbCl7XG4gICAgaWYoZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmIENIRUNLQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkpID49IDApe1xuICAgICAgZWwuY2hlY2tlZCA9IGVsLmdldEF0dHJpYnV0ZShcImNoZWNrZWRcIikgIT09IG51bGxcbiAgICB9XG4gIH0sXG5cbiAgaXNUZXh0dWFsSW5wdXQoZWwpeyByZXR1cm4gRk9DVVNBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUpID49IDAgfSxcblxuICBpc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCl7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUocGh4VHJpZ2dlckV4dGVybmFsKSAhPT0gbnVsbFxuICB9LFxuXG4gIHN5bmNQZW5kaW5nUmVmKGZyb21FbCwgdG9FbCwgZGlzYWJsZVdpdGgpe1xuICAgIGxldCByZWYgPSBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9SRUYpXG4gICAgaWYocmVmID09PSBudWxsKXsgcmV0dXJuIHRydWUgfVxuICAgIGxldCByZWZTcmMgPSBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9SRUZfU1JDKVxuXG4gICAgaWYoRE9NLmlzRm9ybUlucHV0KGZyb21FbCkgfHwgZnJvbUVsLmdldEF0dHJpYnV0ZShkaXNhYmxlV2l0aCkgIT09IG51bGwpe1xuICAgICAgaWYoRE9NLmlzVXBsb2FkSW5wdXQoZnJvbUVsKSl7IERPTS5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwge2lzSWdub3JlZDogdHJ1ZX0pIH1cbiAgICAgIERPTS5wdXRQcml2YXRlKGZyb21FbCwgUEhYX1JFRiwgdG9FbClcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICBQSFhfRVZFTlRfQ0xBU1NFUy5mb3JFYWNoKGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIGZyb21FbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSAmJiB0b0VsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKVxuICAgICAgfSlcbiAgICAgIHRvRWwuc2V0QXR0cmlidXRlKFBIWF9SRUYsIHJlZilcbiAgICAgIHRvRWwuc2V0QXR0cmlidXRlKFBIWF9SRUZfU1JDLCByZWZTcmMpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfSxcblxuICBjbGVhbkNoaWxkTm9kZXMoY29udGFpbmVyLCBwaHhVcGRhdGUpe1xuICAgIGlmKERPTS5pc1BoeFVwZGF0ZShjb250YWluZXIsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkpe1xuICAgICAgbGV0IHRvUmVtb3ZlID0gW11cbiAgICAgIGNvbnRhaW5lci5jaGlsZE5vZGVzLmZvckVhY2goY2hpbGROb2RlID0+IHtcbiAgICAgICAgaWYoIWNoaWxkTm9kZS5pZCl7XG4gICAgICAgICAgLy8gU2tpcCB3YXJuaW5nIGlmIGl0J3MgYW4gZW1wdHkgdGV4dCBub2RlIChlLmcuIGEgbmV3LWxpbmUpXG4gICAgICAgICAgbGV0IGlzRW1wdHlUZXh0Tm9kZSA9IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgY2hpbGROb2RlLm5vZGVWYWx1ZS50cmltKCkgPT09IFwiXCJcbiAgICAgICAgICBpZighaXNFbXB0eVRleHROb2RlKXtcbiAgICAgICAgICAgIGxvZ0Vycm9yKFwib25seSBIVE1MIGVsZW1lbnQgdGFncyB3aXRoIGFuIGlkIGFyZSBhbGxvd2VkIGluc2lkZSBjb250YWluZXJzIHdpdGggcGh4LXVwZGF0ZS5cXG5cXG5cIiArXG4gICAgICAgICAgICAgIGByZW1vdmluZyBpbGxlZ2FsIG5vZGU6IFwiJHsoY2hpbGROb2RlLm91dGVySFRNTCB8fCBjaGlsZE5vZGUubm9kZVZhbHVlKS50cmltKCl9XCJcXG5cXG5gKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0b1JlbW92ZS5wdXNoKGNoaWxkTm9kZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRvUmVtb3ZlLmZvckVhY2goY2hpbGROb2RlID0+IGNoaWxkTm9kZS5yZW1vdmUoKSlcbiAgICB9XG4gIH0sXG5cbiAgcmVwbGFjZVJvb3RDb250YWluZXIoY29udGFpbmVyLCB0YWdOYW1lLCBhdHRycyl7XG4gICAgbGV0IHJldGFpbmVkQXR0cnMgPSBuZXcgU2V0KFtcImlkXCIsIFBIWF9TRVNTSU9OLCBQSFhfU1RBVElDLCBQSFhfTUFJTiwgUEhYX1JPT1RfSURdKVxuICAgIGlmKGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHRhZ05hbWUudG9Mb3dlckNhc2UoKSl7XG4gICAgICBBcnJheS5mcm9tKGNvbnRhaW5lci5hdHRyaWJ1dGVzKVxuICAgICAgICAuZmlsdGVyKGF0dHIgPT4gIXJldGFpbmVkQXR0cnMuaGFzKGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgLmZvckVhY2goYXR0ciA9PiBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKGF0dHIubmFtZSkpXG5cbiAgICAgIE9iamVjdC5rZXlzKGF0dHJzKVxuICAgICAgICAuZmlsdGVyKG5hbWUgPT4gIXJldGFpbmVkQXR0cnMuaGFzKG5hbWUudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIC5mb3JFYWNoKGF0dHIgPT4gY29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSkpXG5cbiAgICAgIHJldHVybiBjb250YWluZXJcblxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKVxuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goYXR0ciA9PiBuZXdDb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSlcbiAgICAgIHJldGFpbmVkQXR0cnMuZm9yRWFjaChhdHRyID0+IG5ld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoYXR0ciwgY29udGFpbmVyLmdldEF0dHJpYnV0ZShhdHRyKSkpXG4gICAgICBuZXdDb250YWluZXIuaW5uZXJIVE1MID0gY29udGFpbmVyLmlubmVySFRNTFxuICAgICAgY29udGFpbmVyLnJlcGxhY2VXaXRoKG5ld0NvbnRhaW5lcilcbiAgICAgIHJldHVybiBuZXdDb250YWluZXJcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U3RpY2t5KGVsLCBuYW1lLCBkZWZhdWx0VmFsKXtcbiAgICBsZXQgb3AgPSAoRE9NLnByaXZhdGUoZWwsIFwic3RpY2t5XCIpIHx8IFtdKS5maW5kKChbZXhpc3RpbmdOYW1lLCBdKSA9PiBuYW1lID09PSBleGlzdGluZ05hbWUpXG4gICAgaWYob3Ape1xuICAgICAgbGV0IFtfbmFtZSwgX29wLCBzdGFzaGVkUmVzdWx0XSA9IG9wXG4gICAgICByZXR1cm4gc3Rhc2hlZFJlc3VsdFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHlwZW9mKGRlZmF1bHRWYWwpID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0VmFsKCkgOiBkZWZhdWx0VmFsXG4gICAgfVxuICB9LFxuXG4gIGRlbGV0ZVN0aWNreShlbCwgbmFtZSl7XG4gICAgdGhpcy51cGRhdGVQcml2YXRlKGVsLCBcInN0aWNreVwiLCBbXSwgb3BzID0+IHtcbiAgICAgIHJldHVybiBvcHMuZmlsdGVyKChbZXhpc3RpbmdOYW1lLCBfXSkgPT4gZXhpc3RpbmdOYW1lICE9PSBuYW1lKVxuICAgIH0pXG4gIH0sXG5cbiAgcHV0U3RpY2t5KGVsLCBuYW1lLCBvcCl7XG4gICAgbGV0IHN0YXNoZWRSZXN1bHQgPSBvcChlbClcbiAgICB0aGlzLnVwZGF0ZVByaXZhdGUoZWwsIFwic3RpY2t5XCIsIFtdLCBvcHMgPT4ge1xuICAgICAgbGV0IGV4aXN0aW5nSW5kZXggPSBvcHMuZmluZEluZGV4KChbZXhpc3RpbmdOYW1lLCBdKSA9PiBuYW1lID09PSBleGlzdGluZ05hbWUpXG4gICAgICBpZihleGlzdGluZ0luZGV4ID49IDApe1xuICAgICAgICBvcHNbZXhpc3RpbmdJbmRleF0gPSBbbmFtZSwgb3AsIHN0YXNoZWRSZXN1bHRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHMucHVzaChbbmFtZSwgb3AsIHN0YXNoZWRSZXN1bHRdKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wc1xuICAgIH0pXG4gIH0sXG5cbiAgYXBwbHlTdGlja3lPcGVyYXRpb25zKGVsKXtcbiAgICBsZXQgb3BzID0gRE9NLnByaXZhdGUoZWwsIFwic3RpY2t5XCIpXG4gICAgaWYoIW9wcyl7IHJldHVybiB9XG5cbiAgICBvcHMuZm9yRWFjaCgoW25hbWUsIG9wLCBfc3Rhc2hlZF0pID0+IHRoaXMucHV0U3RpY2t5KGVsLCBuYW1lLCBvcCkpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRE9NXG4iLCAiaW1wb3J0IHtcbiAgUEhYX0FDVElWRV9FTlRSWV9SRUZTLFxuICBQSFhfTElWRV9GSUxFX1VQREFURUQsXG4gIFBIWF9QUkVGTElHSFRFRF9SRUZTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNoYW5uZWxVcGxvYWRlcixcbiAgbG9nRXJyb3Jcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVcGxvYWRFbnRyeSB7XG4gIHN0YXRpYyBpc0FjdGl2ZShmaWxlRWwsIGZpbGUpe1xuICAgIGxldCBpc05ldyA9IGZpbGUuX3BoeFJlZiA9PT0gdW5kZWZpbmVkXG4gICAgbGV0IGFjdGl2ZVJlZnMgPSBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgbGV0IGlzQWN0aXZlID0gYWN0aXZlUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwXG4gICAgcmV0dXJuIGZpbGUuc2l6ZSA+IDAgJiYgKGlzTmV3IHx8IGlzQWN0aXZlKVxuICB9XG5cbiAgc3RhdGljIGlzUHJlZmxpZ2h0ZWQoZmlsZUVsLCBmaWxlKXtcbiAgICBsZXQgcHJlZmxpZ2h0ZWRSZWZzID0gZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgbGV0IGlzUHJlZmxpZ2h0ZWQgPSBwcmVmbGlnaHRlZFJlZnMuaW5kZXhPZihMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKSkgPj0gMFxuICAgIHJldHVybiBpc1ByZWZsaWdodGVkICYmIHRoaXMuaXNBY3RpdmUoZmlsZUVsLCBmaWxlKVxuICB9XG5cbiAgY29uc3RydWN0b3IoZmlsZUVsLCBmaWxlLCB2aWV3KXtcbiAgICB0aGlzLnJlZiA9IExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpXG4gICAgdGhpcy5maWxlRWwgPSBmaWxlRWxcbiAgICB0aGlzLmZpbGUgPSBmaWxlXG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMubWV0YSA9IG51bGxcbiAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IGZhbHNlXG4gICAgdGhpcy5faXNEb25lID0gZmFsc2VcbiAgICB0aGlzLl9wcm9ncmVzcyA9IDBcbiAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gLTFcbiAgICB0aGlzLl9vbkRvbmUgPSBmdW5jdGlvbiAoKXsgfVxuICAgIHRoaXMuX29uRWxVcGRhdGVkID0gdGhpcy5vbkVsVXBkYXRlZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5maWxlRWwuYWRkRXZlbnRMaXN0ZW5lcihQSFhfTElWRV9GSUxFX1VQREFURUQsIHRoaXMuX29uRWxVcGRhdGVkKVxuICB9XG5cbiAgbWV0YWRhdGEoKXsgcmV0dXJuIHRoaXMubWV0YSB9XG5cbiAgcHJvZ3Jlc3MocHJvZ3Jlc3Mpe1xuICAgIHRoaXMuX3Byb2dyZXNzID0gTWF0aC5mbG9vcihwcm9ncmVzcylcbiAgICBpZih0aGlzLl9wcm9ncmVzcyA+IHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQpe1xuICAgICAgaWYodGhpcy5fcHJvZ3Jlc3MgPj0gMTAwKXtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSAxMDBcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IDEwMFxuICAgICAgICB0aGlzLl9pc0RvbmUgPSB0cnVlXG4gICAgICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgMTAwLCAoKSA9PiB7XG4gICAgICAgICAgTGl2ZVVwbG9hZGVyLnVudHJhY2tGaWxlKHRoaXMuZmlsZUVsLCB0aGlzLmZpbGUpXG4gICAgICAgICAgdGhpcy5fb25Eb25lKClcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSB0aGlzLl9wcm9ncmVzc1xuICAgICAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIHRoaXMuX3Byb2dyZXNzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNhbmNlbCgpe1xuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gdHJ1ZVxuICAgIHRoaXMuX2lzRG9uZSA9IHRydWVcbiAgICB0aGlzLl9vbkRvbmUoKVxuICB9XG5cbiAgaXNEb25lKCl7IHJldHVybiB0aGlzLl9pc0RvbmUgfVxuXG4gIGVycm9yKHJlYXNvbiA9IFwiZmFpbGVkXCIpe1xuICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwge2Vycm9yOiByZWFzb259KVxuICAgIExpdmVVcGxvYWRlci5jbGVhckZpbGVzKHRoaXMuZmlsZUVsKVxuICB9XG5cbiAgLy9wcml2YXRlXG5cbiAgb25Eb25lKGNhbGxiYWNrKXtcbiAgICB0aGlzLl9vbkRvbmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmZpbGVFbC5yZW1vdmVFdmVudExpc3RlbmVyKFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCwgdGhpcy5fb25FbFVwZGF0ZWQpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgb25FbFVwZGF0ZWQoKXtcbiAgICBsZXQgYWN0aXZlUmVmcyA9IHRoaXMuZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpLnNwbGl0KFwiLFwiKVxuICAgIGlmKGFjdGl2ZVJlZnMuaW5kZXhPZih0aGlzLnJlZikgPT09IC0xKXsgdGhpcy5jYW5jZWwoKSB9XG4gIH1cblxuICB0b1ByZWZsaWdodFBheWxvYWQoKXtcbiAgICByZXR1cm4ge1xuICAgICAgbGFzdF9tb2RpZmllZDogdGhpcy5maWxlLmxhc3RNb2RpZmllZCxcbiAgICAgIG5hbWU6IHRoaXMuZmlsZS5uYW1lLFxuICAgICAgc2l6ZTogdGhpcy5maWxlLnNpemUsXG4gICAgICB0eXBlOiB0aGlzLmZpbGUudHlwZSxcbiAgICAgIHJlZjogdGhpcy5yZWZcbiAgICB9XG4gIH1cblxuICB1cGxvYWRlcih1cGxvYWRlcnMpe1xuICAgIGlmKHRoaXMubWV0YS51cGxvYWRlcil7XG4gICAgICBsZXQgY2FsbGJhY2sgPSB1cGxvYWRlcnNbdGhpcy5tZXRhLnVwbG9hZGVyXSB8fCBsb2dFcnJvcihgbm8gdXBsb2FkZXIgY29uZmlndXJlZCBmb3IgJHt0aGlzLm1ldGEudXBsb2FkZXJ9YClcbiAgICAgIHJldHVybiB7bmFtZTogdGhpcy5tZXRhLnVwbG9hZGVyLCBjYWxsYmFjazogY2FsbGJhY2t9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7bmFtZTogXCJjaGFubmVsXCIsIGNhbGxiYWNrOiBjaGFubmVsVXBsb2FkZXJ9XG4gICAgfVxuICB9XG5cbiAgemlwUG9zdEZsaWdodChyZXNwKXtcbiAgICB0aGlzLm1ldGEgPSByZXNwLmVudHJpZXNbdGhpcy5yZWZdXG4gICAgaWYoIXRoaXMubWV0YSl7IGxvZ0Vycm9yKGBubyBwcmVmbGlnaHQgdXBsb2FkIHJlc3BvbnNlIHJldHVybmVkIHdpdGggcmVmICR7dGhpcy5yZWZ9YCwge2lucHV0OiB0aGlzLmZpbGVFbCwgcmVzcG9uc2U6IHJlc3B9KSB9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBQSFhfRE9ORV9SRUZTLFxuICBQSFhfUFJFRkxJR0hURURfUkVGUyxcbiAgUEhYX1VQTE9BRF9SRUZcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgVXBsb2FkRW50cnkgZnJvbSBcIi4vdXBsb2FkX2VudHJ5XCJcblxubGV0IGxpdmVVcGxvYWRlckZpbGVSZWYgPSAwXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpdmVVcGxvYWRlciB7XG4gIHN0YXRpYyBnZW5GaWxlUmVmKGZpbGUpe1xuICAgIGxldCByZWYgPSBmaWxlLl9waHhSZWZcbiAgICBpZihyZWYgIT09IHVuZGVmaW5lZCl7XG4gICAgICByZXR1cm4gcmVmXG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGUuX3BoeFJlZiA9IChsaXZlVXBsb2FkZXJGaWxlUmVmKyspLnRvU3RyaW5nKClcbiAgICAgIHJldHVybiBmaWxlLl9waHhSZWZcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0RW50cnlEYXRhVVJMKGlucHV0RWwsIHJlZiwgY2FsbGJhY2spe1xuICAgIGxldCBmaWxlID0gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5maW5kKGZpbGUgPT4gdGhpcy5nZW5GaWxlUmVmKGZpbGUpID09PSByZWYpXG4gICAgY2FsbGJhY2soVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKSlcbiAgfVxuXG4gIHN0YXRpYyBoYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpe1xuICAgIGxldCBhY3RpdmUgPSAwXG4gICAgRE9NLmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKS5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgIGlmKGlucHV0LmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykgIT09IGlucHV0LmdldEF0dHJpYnV0ZShQSFhfRE9ORV9SRUZTKSl7XG4gICAgICAgIGFjdGl2ZSsrXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gYWN0aXZlID4gMFxuICB9XG5cbiAgc3RhdGljIHNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbCl7XG4gICAgbGV0IGZpbGVzID0gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKVxuICAgIGxldCBmaWxlRGF0YSA9IHt9XG4gICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IHtwYXRoOiBpbnB1dEVsLm5hbWV9XG4gICAgICBsZXQgdXBsb2FkUmVmID0gaW5wdXRFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpXG4gICAgICBmaWxlRGF0YVt1cGxvYWRSZWZdID0gZmlsZURhdGFbdXBsb2FkUmVmXSB8fCBbXVxuICAgICAgZW50cnkucmVmID0gdGhpcy5nZW5GaWxlUmVmKGZpbGUpXG4gICAgICBlbnRyeS5uYW1lID0gZmlsZS5uYW1lIHx8IGVudHJ5LnJlZlxuICAgICAgZW50cnkudHlwZSA9IGZpbGUudHlwZVxuICAgICAgZW50cnkuc2l6ZSA9IGZpbGUuc2l6ZVxuICAgICAgZmlsZURhdGFbdXBsb2FkUmVmXS5wdXNoKGVudHJ5KVxuICAgIH0pXG4gICAgcmV0dXJuIGZpbGVEYXRhXG4gIH1cblxuICBzdGF0aWMgY2xlYXJGaWxlcyhpbnB1dEVsKXtcbiAgICBpbnB1dEVsLnZhbHVlID0gbnVsbFxuICAgIGlucHV0RWwucmVtb3ZlQXR0cmlidXRlKFBIWF9VUExPQURfUkVGKVxuICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgW10pXG4gIH1cblxuICBzdGF0aWMgdW50cmFja0ZpbGUoaW5wdXRFbCwgZmlsZSl7XG4gICAgRE9NLnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBET00ucHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIpLmZpbHRlcihmID0+ICFPYmplY3QuaXMoZiwgZmlsZSkpKVxuICB9XG5cbiAgc3RhdGljIHRyYWNrRmlsZXMoaW5wdXRFbCwgZmlsZXMpe1xuICAgIGlmKGlucHV0RWwuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgIT09IG51bGwpe1xuICAgICAgbGV0IG5ld0ZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT4gIXRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuZmluZChmID0+IE9iamVjdC5pcyhmLCBmaWxlKSkpXG4gICAgICBET00ucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuY29uY2F0KG5ld0ZpbGVzKSlcbiAgICAgIGlucHV0RWwudmFsdWUgPSBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgZmlsZXMpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFjdGl2ZUZpbGVJbnB1dHMoZm9ybUVsKXtcbiAgICBsZXQgZmlsZUlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlSW5wdXRzKS5maWx0ZXIoZWwgPT4gZWwuZmlsZXMgJiYgdGhpcy5hY3RpdmVGaWxlcyhlbCkubGVuZ3RoID4gMClcbiAgfVxuXG4gIHN0YXRpYyBhY3RpdmVGaWxlcyhpbnB1dCl7XG4gICAgcmV0dXJuIChET00ucHJpdmF0ZShpbnB1dCwgXCJmaWxlc1wiKSB8fCBbXSkuZmlsdGVyKGYgPT4gVXBsb2FkRW50cnkuaXNBY3RpdmUoaW5wdXQsIGYpKVxuICB9XG5cbiAgc3RhdGljIGlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCl7XG4gICAgbGV0IGZpbGVJbnB1dHMgPSBET00uZmluZFVwbG9hZElucHV0cyhmb3JtRWwpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZmlsZUlucHV0cykuZmlsdGVyKGlucHV0ID0+IHRoaXMuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dCkubGVuZ3RoID4gMClcbiAgfVxuXG4gIHN0YXRpYyBmaWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0KXtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dCkuZmlsdGVyKGYgPT4gIVVwbG9hZEVudHJ5LmlzUHJlZmxpZ2h0ZWQoaW5wdXQsIGYpKVxuICB9XG5cbiAgY29uc3RydWN0b3IoaW5wdXRFbCwgdmlldywgb25Db21wbGV0ZSl7XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG9uQ29tcGxldGVcbiAgICB0aGlzLl9lbnRyaWVzID1cbiAgICAgIEFycmF5LmZyb20oTGl2ZVVwbG9hZGVyLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXRFbCkgfHwgW10pXG4gICAgICAgIC5tYXAoZmlsZSA9PiBuZXcgVXBsb2FkRW50cnkoaW5wdXRFbCwgZmlsZSwgdmlldykpXG5cbiAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzID0gdGhpcy5fZW50cmllcy5sZW5ndGhcbiAgfVxuXG4gIGVudHJpZXMoKXsgcmV0dXJuIHRoaXMuX2VudHJpZXMgfVxuXG4gIGluaXRBZGFwdGVyVXBsb2FkKHJlc3AsIG9uRXJyb3IsIGxpdmVTb2NrZXQpe1xuICAgIHRoaXMuX2VudHJpZXMgPVxuICAgICAgdGhpcy5fZW50cmllcy5tYXAoZW50cnkgPT4ge1xuICAgICAgICBlbnRyeS56aXBQb3N0RmxpZ2h0KHJlc3ApXG4gICAgICAgIGVudHJ5Lm9uRG9uZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcy0tXG4gICAgICAgICAgaWYodGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcyA9PT0gMCl7IHRoaXMub25Db21wbGV0ZSgpIH1cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGVudHJ5XG4gICAgICB9KVxuXG4gICAgbGV0IGdyb3VwZWRFbnRyaWVzID0gdGhpcy5fZW50cmllcy5yZWR1Y2UoKGFjYywgZW50cnkpID0+IHtcbiAgICAgIGxldCB7bmFtZSwgY2FsbGJhY2t9ID0gZW50cnkudXBsb2FkZXIobGl2ZVNvY2tldC51cGxvYWRlcnMpXG4gICAgICBhY2NbbmFtZV0gPSBhY2NbbmFtZV0gfHwge2NhbGxiYWNrOiBjYWxsYmFjaywgZW50cmllczogW119XG4gICAgICBhY2NbbmFtZV0uZW50cmllcy5wdXNoKGVudHJ5KVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIHt9KVxuXG4gICAgZm9yKGxldCBuYW1lIGluIGdyb3VwZWRFbnRyaWVzKXtcbiAgICAgIGxldCB7Y2FsbGJhY2ssIGVudHJpZXN9ID0gZ3JvdXBlZEVudHJpZXNbbmFtZV1cbiAgICAgIGNhbGxiYWNrKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgUEhYX0FDVElWRV9FTlRSWV9SRUZTLFxuICBQSFhfTElWRV9GSUxFX1VQREFURUQsXG4gIFBIWF9QUkVGTElHSFRFRF9SRUZTLFxuICBQSFhfVVBMT0FEX1JFRlxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuXG5sZXQgSG9va3MgPSB7XG4gIExpdmVGaWxlVXBsb2FkOiB7XG4gICAgYWN0aXZlUmVmcygpeyByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX0FDVElWRV9FTlRSWV9SRUZTKSB9LFxuXG4gICAgcHJlZmxpZ2h0ZWRSZWZzKCl7IHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykgfSxcblxuICAgIG1vdW50ZWQoKXsgdGhpcy5wcmVmbGlnaHRlZFdhcyA9IHRoaXMucHJlZmxpZ2h0ZWRSZWZzKCkgfSxcblxuICAgIHVwZGF0ZWQoKXtcbiAgICAgIGxldCBuZXdQcmVmbGlnaHRzID0gdGhpcy5wcmVmbGlnaHRlZFJlZnMoKVxuICAgICAgaWYodGhpcy5wcmVmbGlnaHRlZFdhcyAhPT0gbmV3UHJlZmxpZ2h0cyl7XG4gICAgICAgIHRoaXMucHJlZmxpZ2h0ZWRXYXMgPSBuZXdQcmVmbGlnaHRzXG4gICAgICAgIGlmKG5ld1ByZWZsaWdodHMgPT09IFwiXCIpe1xuICAgICAgICAgIHRoaXMuX192aWV3LmNhbmNlbFN1Ym1pdCh0aGlzLmVsLmZvcm0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5hY3RpdmVSZWZzKCkgPT09IFwiXCIpeyB0aGlzLmVsLnZhbHVlID0gbnVsbCB9XG4gICAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCkpXG4gICAgfVxuICB9LFxuXG4gIExpdmVJbWdQcmV2aWV3OiB7XG4gICAgbW91bnRlZCgpe1xuICAgICAgdGhpcy5yZWYgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWVudHJ5LXJlZlwiKVxuICAgICAgdGhpcy5pbnB1dEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpKVxuICAgICAgTGl2ZVVwbG9hZGVyLmdldEVudHJ5RGF0YVVSTCh0aGlzLmlucHV0RWwsIHRoaXMucmVmLCB1cmwgPT4ge1xuICAgICAgICB0aGlzLnVybCA9IHVybFxuICAgICAgICB0aGlzLmVsLnNyYyA9IHVybFxuICAgICAgfSlcbiAgICB9LFxuICAgIGRlc3Ryb3llZCgpe1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLnVybClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSG9va3NcbiIsICJpbXBvcnQge1xuICBtYXliZVxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRE9NUG9zdE1vcnBoUmVzdG9yZXIge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXJCZWZvcmUsIGNvbnRhaW5lckFmdGVyLCB1cGRhdGVUeXBlKXtcbiAgICBsZXQgaWRzQmVmb3JlID0gbmV3IFNldCgpXG4gICAgbGV0IGlkc0FmdGVyID0gbmV3IFNldChbLi4uY29udGFpbmVyQWZ0ZXIuY2hpbGRyZW5dLm1hcChjaGlsZCA9PiBjaGlsZC5pZCkpXG5cbiAgICBsZXQgZWxlbWVudHNUb01vZGlmeSA9IFtdXG5cbiAgICBBcnJheS5mcm9tKGNvbnRhaW5lckJlZm9yZS5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBpZihjaGlsZC5pZCl7IC8vIGFsbCBvZiBvdXIgY2hpbGRyZW4gc2hvdWxkIGJlIGVsZW1lbnRzIHdpdGggaWRzXG4gICAgICAgIGlkc0JlZm9yZS5hZGQoY2hpbGQuaWQpXG4gICAgICAgIGlmKGlkc0FmdGVyLmhhcyhjaGlsZC5pZCkpe1xuICAgICAgICAgIGxldCBwcmV2aW91c0VsZW1lbnRJZCA9IGNoaWxkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZy5pZFxuICAgICAgICAgIGVsZW1lbnRzVG9Nb2RpZnkucHVzaCh7ZWxlbWVudElkOiBjaGlsZC5pZCwgcHJldmlvdXNFbGVtZW50SWQ6IHByZXZpb3VzRWxlbWVudElkfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmNvbnRhaW5lcklkID0gY29udGFpbmVyQWZ0ZXIuaWRcbiAgICB0aGlzLnVwZGF0ZVR5cGUgPSB1cGRhdGVUeXBlXG4gICAgdGhpcy5lbGVtZW50c1RvTW9kaWZ5ID0gZWxlbWVudHNUb01vZGlmeVxuICAgIHRoaXMuZWxlbWVudElkc1RvQWRkID0gWy4uLmlkc0FmdGVyXS5maWx0ZXIoaWQgPT4gIWlkc0JlZm9yZS5oYXMoaWQpKVxuICB9XG5cbiAgLy8gV2UgZG8gdGhlIGZvbGxvd2luZyB0byBvcHRpbWl6ZSBhcHBlbmQvcHJlcGVuZCBvcGVyYXRpb25zOlxuICAvLyAgIDEpIFRyYWNrIGlkcyBvZiBtb2RpZmllZCBlbGVtZW50cyAmIG9mIG5ldyBlbGVtZW50c1xuICAvLyAgIDIpIEFsbCB0aGUgbW9kaWZpZWQgZWxlbWVudHMgYXJlIHB1dCBiYWNrIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBET00gdHJlZVxuICAvLyAgICAgIGJ5IHN0b3JpbmcgdGhlIGlkIG9mIHRoZWlyIHByZXZpb3VzIHNpYmxpbmdcbiAgLy8gICAzKSBOZXcgZWxlbWVudHMgYXJlIGdvaW5nIHRvIGJlIHB1dCBpbiB0aGUgcmlnaHQgcGxhY2UgYnkgbW9ycGhkb20gZHVyaW5nIGFwcGVuZC5cbiAgLy8gICAgICBGb3IgcHJlcGVuZCwgd2UgbW92ZSB0aGVtIHRvIHRoZSBmaXJzdCBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyXG4gIHBlcmZvcm0oKXtcbiAgICBsZXQgY29udGFpbmVyID0gRE9NLmJ5SWQodGhpcy5jb250YWluZXJJZClcbiAgICB0aGlzLmVsZW1lbnRzVG9Nb2RpZnkuZm9yRWFjaChlbGVtZW50VG9Nb2RpZnkgPT4ge1xuICAgICAgaWYoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKXtcbiAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKSwgcHJldmlvdXNFbGVtID0+IHtcbiAgICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgZWxlbSA9PiB7XG4gICAgICAgICAgICBsZXQgaXNJblJpZ2h0UGxhY2UgPSBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlkID09IHByZXZpb3VzRWxlbS5pZFxuICAgICAgICAgICAgaWYoIWlzSW5SaWdodFBsYWNlKXtcbiAgICAgICAgICAgICAgcHJldmlvdXNFbGVtLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIGVsZW0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGNvbnRhaW5lclxuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgZWxlbSA9PiB7XG4gICAgICAgICAgbGV0IGlzSW5SaWdodFBsYWNlID0gZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nID09IG51bGxcbiAgICAgICAgICBpZighaXNJblJpZ2h0UGxhY2Upe1xuICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgZWxlbSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmKHRoaXMudXBkYXRlVHlwZSA9PSBcInByZXBlbmRcIil7XG4gICAgICB0aGlzLmVsZW1lbnRJZHNUb0FkZC5yZXZlcnNlKCkuZm9yRWFjaChlbGVtSWQgPT4ge1xuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtSWQpLCBlbGVtID0+IGNvbnRhaW5lci5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGVsZW0pKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cbiIsICJ2YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG5mdW5jdGlvbiBtb3JwaEF0dHJzKGZyb21Ob2RlLCB0b05vZGUpIHtcbiAgICB2YXIgdG9Ob2RlQXR0cnMgPSB0b05vZGUuYXR0cmlidXRlcztcbiAgICB2YXIgYXR0cjtcbiAgICB2YXIgYXR0ck5hbWU7XG4gICAgdmFyIGF0dHJOYW1lc3BhY2VVUkk7XG4gICAgdmFyIGF0dHJWYWx1ZTtcbiAgICB2YXIgZnJvbVZhbHVlO1xuXG4gICAgLy8gZG9jdW1lbnQtZnJhZ21lbnRzIGRvbnQgaGF2ZSBhdHRyaWJ1dGVzIHNvIGxldHMgbm90IGRvIGFueXRoaW5nXG4gICAgaWYgKHRvTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBmcm9tTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBhdHRyaWJ1dGVzIG9uIG9yaWdpbmFsIERPTSBlbGVtZW50XG4gICAgZm9yICh2YXIgaSA9IHRvTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGF0dHIgPSB0b05vZGVBdHRyc1tpXTtcbiAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSTtcbiAgICAgICAgYXR0clZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgICAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZTtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIucHJlZml4ID09PSAneG1sbnMnKXtcbiAgICAgICAgICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7IC8vIEl0J3Mgbm90IGFsbG93ZWQgdG8gc2V0IGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBYTUxOUyBuYW1lc3BhY2Ugd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBgeG1sbnNgIHByZWZpeFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tVmFsdWUgIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXh0cmEgYXR0cmlidXRlcyBmb3VuZCBvbiB0aGUgb3JpZ2luYWwgRE9NIGVsZW1lbnQgdGhhdFxuICAgIC8vIHdlcmVuJ3QgZm91bmQgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgIHZhciBmcm9tTm9kZUF0dHJzID0gZnJvbU5vZGUuYXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIGQgPSBmcm9tTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGF0dHIgPSBmcm9tTm9kZUF0dHJzW2RdO1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuXG4gICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuXG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGUoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHJhbmdlOyAvLyBDcmVhdGUgYSByYW5nZSBvYmplY3QgZm9yIGVmZmljZW50bHkgcmVuZGVyaW5nIHN0cmluZ3MgdG8gZWxlbWVudHMuXG52YXIgTlNfWEhUTUwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5cbnZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZG9jdW1lbnQ7XG52YXIgSEFTX1RFTVBMQVRFX1NVUFBPUlQgPSAhIWRvYyAmJiAnY29udGVudCcgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG52YXIgSEFTX1JBTkdFX1NVUFBPUlQgPSAhIWRvYyAmJiBkb2MuY3JlYXRlUmFuZ2UgJiYgJ2NyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCcgaW4gZG9jLmNyZWF0ZVJhbmdlKCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IGRvYy5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHN0cjtcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21SYW5nZShzdHIpIHtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoZG9jLmJvZHkpO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudCA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHIpO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21XcmFwKHN0cikge1xuICAgIHZhciBmcmFnbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KCdib2R5Jyk7XG4gICAgZnJhZ21lbnQuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYWJvdXQgdGhlIHNhbWVcbiAqIHZhciBodG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdHIsICd0ZXh0L2h0bWwnKTtcbiAqIHJldHVybiBodG1sLmJvZHkuZmlyc3RDaGlsZDtcbiAqXG4gKiBAbWV0aG9kIHRvRWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiB0b0VsZW1lbnQoc3RyKSB7XG4gICAgc3RyID0gc3RyLnRyaW0oKTtcbiAgICBpZiAoSEFTX1RFTVBMQVRFX1NVUFBPUlQpIHtcbiAgICAgIC8vIGF2b2lkIHJlc3RyaWN0aW9ucyBvbiBjb250ZW50IGZvciB0aGluZ3MgbGlrZSBgPHRyPjx0aD5IaTwvdGg+PC90cj5gIHdoaWNoXG4gICAgICAvLyBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgZG9lc24ndCBzdXBwb3J0XG4gICAgICAvLyA8dGVtcGxhdGU+IHN1cHBvcnQgbm90IGF2YWlsYWJsZSBpbiBJRVxuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cik7XG4gICAgfSBlbHNlIGlmIChIQVNfUkFOR0VfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdHdvIG5vZGUncyBuYW1lcyBhcmUgdGhlIHNhbWUuXG4gKlxuICogTk9URTogV2UgZG9uJ3QgYm90aGVyIGNoZWNraW5nIGBuYW1lc3BhY2VVUklgIGJlY2F1c2UgeW91IHdpbGwgbmV2ZXIgZmluZCB0d28gSFRNTCBlbGVtZW50cyB3aXRoIHRoZSBzYW1lXG4gKiAgICAgICBub2RlTmFtZSBhbmQgZGlmZmVyZW50IG5hbWVzcGFjZSBVUklzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiIFRoZSB0YXJnZXQgZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU5vZGVOYW1lcyhmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgZnJvbU5vZGVOYW1lID0gZnJvbUVsLm5vZGVOYW1lO1xuICAgIHZhciB0b05vZGVOYW1lID0gdG9FbC5ub2RlTmFtZTtcbiAgICB2YXIgZnJvbUNvZGVTdGFydCwgdG9Db2RlU3RhcnQ7XG5cbiAgICBpZiAoZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZyb21Db2RlU3RhcnQgPSBmcm9tTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcbiAgICB0b0NvZGVTdGFydCA9IHRvTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcblxuICAgIC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIHZpcnR1YWwgRE9NIG5vZGUgb3IgU1ZHIG5vZGUgdGhlbiB3ZSBtYXlcbiAgICAvLyBuZWVkIHRvIG5vcm1hbGl6ZSB0aGUgdGFnIG5hbWUgYmVmb3JlIGNvbXBhcmluZy4gTm9ybWFsIEhUTUwgZWxlbWVudHMgdGhhdCBhcmVcbiAgICAvLyBpbiB0aGUgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJcbiAgICAvLyBhcmUgY29udmVydGVkIHRvIHVwcGVyIGNhc2VcbiAgICBpZiAoZnJvbUNvZGVTdGFydCA8PSA5MCAmJiB0b0NvZGVTdGFydCA+PSA5NykgeyAvLyBmcm9tIGlzIHVwcGVyIGFuZCB0byBpcyBsb3dlclxuICAgICAgICByZXR1cm4gZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmICh0b0NvZGVTdGFydCA8PSA5MCAmJiBmcm9tQ29kZVN0YXJ0ID49IDk3KSB7IC8vIHRvIGlzIHVwcGVyIGFuZCBmcm9tIGlzIGxvd2VyXG4gICAgICAgIHJldHVybiB0b05vZGVOYW1lID09PSBmcm9tTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlbGVtZW50LCBvcHRpb25hbGx5IHdpdGggYSBrbm93biBuYW1lc3BhY2UgVVJJLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBlbGVtZW50IG5hbWUsIGUuZy4gJ2Rpdicgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZXNwYWNlVVJJXSB0aGUgZWxlbWVudCdzIG5hbWVzcGFjZSBVUkksIGkuZS4gdGhlIHZhbHVlIG9mXG4gKiBpdHMgYHhtbG5zYCBhdHRyaWJ1dGUgb3IgaXRzIGluZmVycmVkIG5hbWVzcGFjZS5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZSwgbmFtZXNwYWNlVVJJKSB7XG4gICAgcmV0dXJuICFuYW1lc3BhY2VVUkkgfHwgbmFtZXNwYWNlVVJJID09PSBOU19YSFRNTCA/XG4gICAgICAgIGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpIDpcbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIG5hbWUpO1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgY2hpbGRyZW4gb2Ygb25lIERPTSBlbGVtZW50IHRvIGFub3RoZXIgRE9NIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gbW92ZUNoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIHRvRWwuYXBwZW5kQ2hpbGQoY3VyQ2hpbGQpO1xuICAgICAgICBjdXJDaGlsZCA9IG5leHRDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHRvRWw7XG59XG5cbmZ1bmN0aW9uIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBuYW1lKSB7XG4gICAgaWYgKGZyb21FbFtuYW1lXSAhPT0gdG9FbFtuYW1lXSkge1xuICAgICAgICBmcm9tRWxbbmFtZV0gPSB0b0VsW25hbWVdO1xuICAgICAgICBpZiAoZnJvbUVsW25hbWVdKSB7XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBzcGVjaWFsRWxIYW5kbGVycyA9IHtcbiAgICBPUFRJT046IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGZyb21FbC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09ICdTRUxFQ1QnICYmICFwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tRWwuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpICYmICF0b0VsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIE1TIEVkZ2UgYnVnIHdoZXJlIHRoZSAnc2VsZWN0ZWQnIGF0dHJpYnV0ZSBjYW4gb25seSBiZVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmVkIGlmIHNldCB0byBhIG5vbi1lbXB0eSB2YWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTIwODc2NzkvXG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcmVzZXQgc2VsZWN0IGVsZW1lbnQncyBzZWxlY3RlZEluZGV4IHRvIC0xLCBvdGhlcndpc2Ugc2V0dGluZ1xuICAgICAgICAgICAgICAgIC8vIGZyb21FbC5zZWxlY3RlZCB1c2luZyB0aGUgc3luY0Jvb2xlYW5BdHRyUHJvcCBiZWxvdyBoYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBjb3JyZWN0IHNlbGVjdGVkSW5kZXggd2lsbCBiZSBzZXQgaW4gdGhlIFNFTEVDVCBzcGVjaWFsIGhhbmRsZXIgYmVsb3cuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdzZWxlY3RlZCcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgaXMgc3BlY2lhbCBmb3IgdGhlIDxpbnB1dD4gZWxlbWVudCBzaW5jZSBpdCBzZXRzXG4gICAgICogdGhlIGluaXRpYWwgdmFsdWUuIENoYW5naW5nIHRoZSBcInZhbHVlXCIgYXR0cmlidXRlIHdpdGhvdXQgY2hhbmdpbmcgdGhlXG4gICAgICogXCJ2YWx1ZVwiIHByb3BlcnR5IHdpbGwgaGF2ZSBubyBlZmZlY3Qgc2luY2UgaXQgaXMgb25seSB1c2VkIHRvIHRoZSBzZXQgdGhlXG4gICAgICogaW5pdGlhbCB2YWx1ZS4gIFNpbWlsYXIgZm9yIHRoZSBcImNoZWNrZWRcIiBhdHRyaWJ1dGUsIGFuZCBcImRpc2FibGVkXCIuXG4gICAgICovXG4gICAgSU5QVVQ6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2NoZWNrZWQnKTtcbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdkaXNhYmxlZCcpO1xuXG4gICAgICAgIGlmIChmcm9tRWwudmFsdWUgIT09IHRvRWwudmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRvRWwuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFRFWFRBUkVBOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIE5lZWRlZCBmb3IgSUUuIEFwcGFyZW50bHkgSUUgc2V0cyB0aGUgcGxhY2Vob2xkZXIgYXMgdGhlXG4gICAgICAgICAgICAvLyBub2RlIHZhbHVlIGFuZCB2aXNlIHZlcnNhLiBUaGlzIGlnbm9yZXMgYW4gZW1wdHkgdXBkYXRlLlxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PSBuZXdWYWx1ZSB8fCAoIW5ld1ZhbHVlICYmIG9sZFZhbHVlID09IGZyb21FbC5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFNFTEVDVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJykpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGxvb3AgdGhyb3VnaCBjaGlsZHJlbiBvZiBmcm9tRWwsIG5vdCB0b0VsIHNpbmNlIG5vZGVzIGNhbiBiZSBtb3ZlZFxuICAgICAgICAgICAgLy8gZnJvbSB0b0VsIHRvIGZyb21FbCBkaXJlY3RseSB3aGVuIG1vcnBoaW5nLlxuICAgICAgICAgICAgLy8gQXQgdGhlIHRpbWUgdGhpcyBzcGVjaWFsIGhhbmRsZXIgaXMgaW52b2tlZCwgYWxsIGNoaWxkcmVuIGhhdmUgYWxyZWFkeSBiZWVuIG1vcnBoZWRcbiAgICAgICAgICAgIC8vIGFuZCBhcHBlbmRlZCB0byAvIHJlbW92ZWQgZnJvbSBmcm9tRWwsIHNvIHVzaW5nIGZyb21FbCBoZXJlIGlzIHNhZmUgYW5kIGNvcnJlY3QuXG4gICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBvcHRncm91cDtcbiAgICAgICAgICAgIHZhciBub2RlTmFtZTtcbiAgICAgICAgICAgIHdoaWxlKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBjdXJDaGlsZC5ub2RlTmFtZSAmJiBjdXJDaGlsZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IGN1ckNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IG9wdGdyb3VwLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnT1BUSU9OJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VyQ2hpbGQgJiYgb3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyb21FbC5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSA9IDExO1xudmFyIFRFWFRfTk9ERSA9IDM7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXROb2RlS2V5KG5vZGUpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykpIHx8IG5vZGUuaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbiBtb3JwaGRvbShmcm9tTm9kZSwgdG9Ob2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0b05vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoZnJvbU5vZGUubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQnIHx8IGZyb21Ob2RlLm5vZGVOYW1lID09PSAnSFRNTCcgfHwgZnJvbU5vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAgICAgICAgIHZhciB0b05vZGVIdG1sID0gdG9Ob2RlO1xuICAgICAgICAgICAgICAgIHRvTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdodG1sJyk7XG4gICAgICAgICAgICAgICAgdG9Ob2RlLmlubmVySFRNTCA9IHRvTm9kZUh0bWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvTm9kZSA9IHRvRWxlbWVudCh0b05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdldE5vZGVLZXkgPSBvcHRpb25zLmdldE5vZGVLZXkgfHwgZGVmYXVsdEdldE5vZGVLZXk7XG4gICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlQWRkZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uTm9kZUFkZGVkID0gb3B0aW9ucy5vbk5vZGVBZGRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVFbFVwZGF0ZWQgPSBvcHRpb25zLm9uQmVmb3JlRWxVcGRhdGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkVsVXBkYXRlZCA9IG9wdGlvbnMub25FbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uQmVmb3JlTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbk5vZGVEaXNjYXJkZWQgPSBvcHRpb25zLm9uTm9kZURpc2NhcmRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCB8fCBub29wO1xuICAgICAgICB2YXIgY2hpbGRyZW5Pbmx5ID0gb3B0aW9ucy5jaGlsZHJlbk9ubHkgPT09IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBvYmplY3QgaXMgdXNlZCBhcyBhIGxvb2t1cCB0byBxdWlja2x5IGZpbmQgYWxsIGtleWVkIGVsZW1lbnRzIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS5cbiAgICAgICAgdmFyIGZyb21Ob2Rlc0xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBrZXllZFJlbW92YWxMaXN0ID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkS2V5ZWRSZW1vdmFsKGtleSkge1xuICAgICAgICAgICAga2V5ZWRSZW1vdmFsTGlzdC5wdXNoKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwS2V5ZWROb2RlcyAmJiAoa2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgc2tpcHBpbmcga2V5ZWQgbm9kZXMgdGhlbiB3ZSBhZGQgdGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYSBsaXN0IHNvIHRoYXQgaXQgY2FuIGJlIGhhbmRsZWQgYXQgdGhlIHZlcnkgZW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJlcG9ydCB0aGUgbm9kZSBhcyBkaXNjYXJkZWQgaWYgaXQgaXMgbm90IGtleWVkLiBXZSBkbyB0aGlzIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0IHRoZSBlbmQgd2UgbG9vcCB0aHJvdWdoIGFsbCBrZXllZCBlbGVtZW50cyB0aGF0IHdlcmUgdW5tYXRjaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiBkaXNjYXJkIHRoZW0gaW4gb25lIGZpbmFsIHBhc3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2RlcyhjdXJDaGlsZCwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIERPTSBub2RlIG91dCBvZiB0aGUgb3JpZ2luYWwgRE9NXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gICAgICAgICAqIEBwYXJhbSAge05vZGV9IHBhcmVudE5vZGUgVGhlIG5vZGVzIHBhcmVudFxuICAgICAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwS2V5ZWROb2RlcyBJZiB0cnVlIHRoZW4gZWxlbWVudHMgd2l0aCBrZXlzIHdpbGwgYmUgc2tpcHBlZCBhbmQgbm90IGRpc2NhcmRlZC5cbiAgICAgICAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlLCBwYXJlbnROb2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZURpc2NhcmRlZChub2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKG5vZGUpO1xuICAgICAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLy8gVHJlZVdhbGtlciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKHJvb3QpIHtcbiAgICAgICAgLy8gICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcbiAgICAgICAgLy8gICAgICAgICByb290LFxuICAgICAgICAvLyAgICAgICAgIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIHZhciBlbDtcbiAgICAgICAgLy8gICAgIHdoaWxlKChlbCA9IHRyZWVXYWxrZXIubmV4dE5vZGUoKSkpIHtcbiAgICAgICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgICAgIC8vICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAvLyAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGVsO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIC8vIE5vZGVJdGVyYXRvciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKG5vZGUpIHtcbiAgICAgICAgLy8gICAgIHZhciBub2RlSXRlcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVOb2RlSXRlcmF0b3Iobm9kZSwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQpO1xuICAgICAgICAvLyAgICAgdmFyIGVsO1xuICAgICAgICAvLyAgICAgd2hpbGUoKGVsID0gbm9kZUl0ZXJhdG9yLm5leHROb2RlKCkpKSB7XG4gICAgICAgIC8vICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoZWwpO1xuICAgICAgICAvLyAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBlbDtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBjdXJDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdhbGsgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhUcmVlKGN1ckNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4VHJlZShmcm9tTm9kZSk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTm9kZUFkZGVkKGVsKSB7XG4gICAgICAgICAgICBvbk5vZGVBZGRlZChlbCk7XG5cbiAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjdXJDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bm1hdGNoZWRGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZmluZCBhIGR1cGxpY2F0ZSAjaWQgbm9kZSBpbiBjYWNoZSwgcmVwbGFjZSBgZWxgIHdpdGggY2FjaGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG1vcnBoIGl0IHRvIHRoZSBjaGlsZCBub2RlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodW5tYXRjaGVkRnJvbUVsICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyQ2hpbGQsIHVubWF0Y2hlZEZyb21FbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhFbCh1bm1hdGNoZWRGcm9tRWwsIGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGwgZm9yIGN1ckNoaWxkIGFuZCBpdCdzIGNoaWxkcmVuIHRvIHNlZSBpZiB3ZSBmaW5kIHNvbWV0aGluZyBpblxuICAgICAgICAgICAgICAgICAgLy8gZnJvbU5vZGVzTG9va3VwXG4gICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBvZiB0aGUgXCJ0byBub2Rlc1wiLiBJZiBjdXJGcm9tTm9kZUNoaWxkIGlzXG4gICAgICAgICAgICAvLyBub24tbnVsbCB0aGVuIHdlIHN0aWxsIGhhdmUgc29tZSBmcm9tIG5vZGVzIGxlZnQgb3ZlciB0aGF0IG5lZWRcbiAgICAgICAgICAgIC8vIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgaWYgKChjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbW9ycGhFbChmcm9tRWwsIHRvRWwsIGNoaWxkcmVuT25seSkge1xuICAgICAgICAgICAgdmFyIHRvRWxLZXkgPSBnZXROb2RlS2V5KHRvRWwpO1xuXG4gICAgICAgICAgICBpZiAodG9FbEtleSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGFuIGVsZW1lbnQgd2l0aCBhbiBJRCBpcyBiZWluZyBtb3JwaGVkIHRoZW4gaXQgd2lsbCBiZSBpbiB0aGUgZmluYWxcbiAgICAgICAgICAgICAgICAvLyBET00gc28gY2xlYXIgaXQgb3V0IG9mIHRoZSBzYXZlZCBlbGVtZW50cyBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgZGVsZXRlIGZyb21Ob2Rlc0xvb2t1cFt0b0VsS2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICAgICAgICAgIGlmIChvbkJlZm9yZUVsVXBkYXRlZChmcm9tRWwsIHRvRWwpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXMgb24gb3JpZ2luYWwgRE9NIGVsZW1lbnQgZmlyc3RcbiAgICAgICAgICAgICAgICBtb3JwaEF0dHJzKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgICAgICBvbkVsVXBkYXRlZChmcm9tRWwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQoZnJvbUVsLCB0b0VsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZyb21FbC5ub2RlTmFtZSAhPT0gJ1RFWFRBUkVBJykge1xuICAgICAgICAgICAgICBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzcGVjaWFsRWxIYW5kbGVycy5URVhUQVJFQShmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbW9ycGhDaGlsZHJlbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgICAgIHZhciBjdXJUb05vZGVDaGlsZCA9IHRvRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB2YXIgY3VyVG9Ob2RlS2V5O1xuICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlS2V5O1xuXG4gICAgICAgICAgICB2YXIgZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgdmFyIHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdGcm9tRWw7XG5cbiAgICAgICAgICAgIC8vIHdhbGsgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICBvdXRlcjogd2hpbGUgKGN1clRvTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdG9OZXh0U2libGluZyA9IGN1clRvTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGN1clRvTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyVG9Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgLy8gd2FsayB0aGUgZnJvbU5vZGUgY2hpbGRyZW4gYWxsIHRoZSB3YXkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUgJiYgY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZShjdXJGcm9tTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZVR5cGUgPSBjdXJGcm9tTm9kZUNoaWxkLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgaWYgdGhlIGN1ckZyb21Ob2RlQ2hpbGQgZG9lc250IGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJUb05vZGVDaGlsZFxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNDb21wYXRpYmxlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IGN1clRvTm9kZUNoaWxkLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCb3RoIG5vZGVzIGJlaW5nIGNvbXBhcmVkIGFyZSBFbGVtZW50IG5vZGVzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgbm9kZSBoYXMgYSBrZXkgc28gd2Ugd2FudCB0byBtYXRjaCBpdCB1cCB3aXRoIHRoZSBjb3JyZWN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgIT09IGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCBET00gdHJlZSBkb2VzIG5vdCBoYXZlIGEgbWF0Y2hpbmcga2V5IHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBjaGVjayBvdXIgbG9va3VwIHRvIHNlZSBpZiB0aGVyZSBpcyBhIG1hdGNoaW5nIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBET00gdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tTmV4dFNpYmxpbmcgPT09IG1hdGNoaW5nRnJvbUVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igc2luZ2xlIGVsZW1lbnQgcmVtb3ZhbHMuIFRvIGF2b2lkIHJlbW92aW5nIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBET00gbm9kZSBvdXQgb2YgdGhlIHRyZWUgKHNpbmNlIHRoYXQgY2FuIGJyZWFrIENTUyB0cmFuc2l0aW9ucywgZXRjLiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdpbGwgaW5zdGVhZCBkaXNjYXJkIHRoZSBjdXJyZW50IG5vZGUgYW5kIHdhaXQgdW50aWwgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW9uIHRvIHByb3Blcmx5IG1hdGNoIHVwIHRoZSBrZXllZCB0YXJnZXQgZWxlbWVudCB3aXRoIGl0cyBtYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbWF0Y2hpbmcga2V5ZWQgZWxlbWVudCBzb21ld2hlcmUgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXQncyBtb3ZlIHRoZSBvcmlnaW5hbCBET00gbm9kZSBpbnRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBtb3JwaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdC5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSB1c2UgaW5zZXJ0QmVmb3JlIGluc3RlYWQgb2YgcmVwbGFjZUNoaWxkIGJlY2F1c2Ugd2Ugd2FudCB0byBnbyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgcmVtb3ZlTm9kZSgpYCBmdW5jdGlvbiBmb3IgdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBkaXNjYXJkZWQgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgbGlmZWN5Y2xlIGhvb2tzIGFyZSBjb3JyZWN0bHkgaW52b2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tRWwuaW5zZXJ0QmVmb3JlKG1hdGNoaW5nRnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gbWF0Y2hpbmdGcm9tRWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm9kZXMgYXJlIG5vdCBjb21wYXRpYmxlIHNpbmNlIHRoZSBcInRvXCIgbm9kZSBoYXMgYSBrZXkgYW5kIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm8gbWF0Y2hpbmcga2V5ZWQgbm9kZSBpbiB0aGUgc291cmNlIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIGhhcyBhIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBpc0NvbXBhdGlibGUgIT09IGZhbHNlICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyRnJvbU5vZGVDaGlsZCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgY29tcGF0aWJsZSBET00gZWxlbWVudHMgc28gdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IFwiZnJvbVwiIG5vZGUgdG8gbWF0Y2ggdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFyZ2V0IERPTSBub2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNT1JQSFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBURVhUX05PREUgfHwgY3VyRnJvbU5vZGVUeXBlID09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIFRleHQgb3IgQ29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2ltcGx5IHVwZGF0ZSBub2RlVmFsdWUgb24gdGhlIG9yaWdpbmFsIG5vZGUgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIHRleHQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVDaGlsZC5ub2RlVmFsdWUgIT09IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSA9IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgYm90aCB0aGUgXCJ0b1wiIGNoaWxkIGFuZCB0aGUgXCJmcm9tXCIgY2hpbGQgc2luY2Ugd2UgZm91bmQgYSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBlbHNlIHRvIGRvIGFzIHdlIGFscmVhZHkgcmVjdXJzaXZlbHkgY2FsbGVkIG1vcnBoQ2hpbGRyZW4gYWJvdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNvbXBhdGlibGUgbWF0Y2ggc28gcmVtb3ZlIHRoZSBvbGQgbm9kZSBmcm9tIHRoZSBET00gYW5kIGNvbnRpbnVlIHRyeWluZyB0byBmaW5kIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggaW4gdGhlIG9yaWdpbmFsIERPTS4gSG93ZXZlciwgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSBmcm9tIG5vZGUgaXMgbm90IGtleWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0IGlzIHBvc3NpYmxlIHRoYXQgYSBrZXllZCBub2RlIG1pZ2h0IG1hdGNoIHVwIHdpdGggYSBub2RlIHNvbWV3aGVyZSBlbHNlIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQgdHJlZSBhbmQgd2UgZG9uJ3Qgd2FudCB0byBkaXNjYXJkIGl0IGp1c3QgeWV0IHNpbmNlIGl0IHN0aWxsIG1pZ2h0IGZpbmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBob21lIGluIHRoZSBmaW5hbCBET00gdHJlZS4gQWZ0ZXIgZXZlcnl0aGluZyBpcyBkb25lIHdlIHdpbGwgcmVtb3ZlIGFueSBrZXllZCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGRpZG4ndCBmaW5kIGEgaG9tZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9IC8vIEVORDogd2hpbGUoY3VyRnJvbU5vZGVDaGlsZCkge31cblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGlzIGZhciB0aGVuIHdlIGRpZCBub3QgZmluZCBhIGNhbmRpZGF0ZSBtYXRjaCBmb3JcbiAgICAgICAgICAgICAgICAvLyBvdXIgXCJ0byBub2RlXCIgYW5kIHdlIGV4aGF1c3RlZCBhbGwgb2YgdGhlIGNoaWxkcmVuIFwiZnJvbVwiXG4gICAgICAgICAgICAgICAgLy8gbm9kZXMuIFRoZXJlZm9yZSwgd2Ugd2lsbCBqdXN0IGFwcGVuZCB0aGUgY3VycmVudCBcInRvXCIgbm9kZVxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBlbmRcbiAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICYmIChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSAmJiBjb21wYXJlTm9kZU5hbWVzKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLmFwcGVuZENoaWxkKG1hdGNoaW5nRnJvbUVsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTU9SUEhcbiAgICAgICAgICAgICAgICAgICAgbW9ycGhFbChtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCA9IG9uQmVmb3JlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmFjdHVhbGl6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKGZyb21FbC5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tRWwuYXBwZW5kQ2hpbGQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpO1xuXG4gICAgICAgICAgICB2YXIgc3BlY2lhbEVsSGFuZGxlciA9IHNwZWNpYWxFbEhhbmRsZXJzW2Zyb21FbC5ub2RlTmFtZV07XG4gICAgICAgICAgICBpZiAoc3BlY2lhbEVsSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxFbEhhbmRsZXIoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBFTkQ6IG1vcnBoQ2hpbGRyZW4oLi4uKVxuXG4gICAgICAgIHZhciBtb3JwaGVkTm9kZSA9IGZyb21Ob2RlO1xuICAgICAgICB2YXIgbW9ycGhlZE5vZGVUeXBlID0gbW9ycGhlZE5vZGUubm9kZVR5cGU7XG4gICAgICAgIHZhciB0b05vZGVUeXBlID0gdG9Ob2RlLm5vZGVUeXBlO1xuXG4gICAgICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgYXJlIGdpdmVuIHR3byBET00gbm9kZXMgdGhhdCBhcmUgbm90XG4gICAgICAgICAgICAvLyBjb21wYXRpYmxlIChlLmcuIDxkaXY+IC0tPiA8c3Bhbj4gb3IgPGRpdj4gLS0+IFRFWFQpXG4gICAgICAgICAgICBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZU5vZGVOYW1lcyhmcm9tTm9kZSwgdG9Ob2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW92ZUNoaWxkcmVuKGZyb21Ob2RlLCBjcmVhdGVFbGVtZW50TlModG9Ob2RlLm5vZGVOYW1lLCB0b05vZGUubmFtZXNwYWNlVVJJKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBHb2luZyBmcm9tIGFuIGVsZW1lbnQgbm9kZSB0byBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vcnBoZWROb2RlVHlwZSA9PT0gVEVYVF9OT0RFIHx8IG1vcnBoZWROb2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7IC8vIFRleHQgb3IgY29tbWVudCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IG1vcnBoZWROb2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9ycGhlZE5vZGUubm9kZVZhbHVlICE9PSB0b05vZGUubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZS5ub2RlVmFsdWUgPSB0b05vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHQgbm9kZSB0byBzb21ldGhpbmcgZWxzZVxuICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9ycGhlZE5vZGUgPT09IHRvTm9kZSkge1xuICAgICAgICAgICAgLy8gVGhlIFwidG8gbm9kZVwiIHdhcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBcImZyb20gbm9kZVwiIHNvIHdlIGhhZCB0b1xuICAgICAgICAgICAgLy8gdG9zcyBvdXQgdGhlIFwiZnJvbSBub2RlXCIgYW5kIHVzZSB0aGUgXCJ0byBub2RlXCJcbiAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChmcm9tTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodG9Ob2RlLmlzU2FtZU5vZGUgJiYgdG9Ob2RlLmlzU2FtZU5vZGUobW9ycGhlZE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3JwaEVsKG1vcnBoZWROb2RlLCB0b05vZGUsIGNoaWxkcmVuT25seSk7XG5cbiAgICAgICAgICAgIC8vIFdlIG5vdyBuZWVkIHRvIGxvb3Agb3ZlciBhbnkga2V5ZWQgbm9kZXMgdGhhdCBtaWdodCBuZWVkIHRvIGJlXG4gICAgICAgICAgICAvLyByZW1vdmVkLiBXZSBvbmx5IGRvIHRoZSByZW1vdmFsIGlmIHdlIGtub3cgdGhhdCB0aGUga2V5ZWQgbm9kZVxuICAgICAgICAgICAgLy8gbmV2ZXIgZm91bmQgYSBtYXRjaC4gV2hlbiBhIGtleWVkIG5vZGUgaXMgbWF0Y2hlZCB1cCB3ZSByZW1vdmVcbiAgICAgICAgICAgIC8vIGl0IG91dCBvZiBmcm9tTm9kZXNMb29rdXAgYW5kIHdlIHVzZSBmcm9tTm9kZXNMb29rdXAgdG8gZGV0ZXJtaW5lXG4gICAgICAgICAgICAvLyBpZiBhIGtleWVkIG5vZGUgaGFzIGJlZW4gbWF0Y2hlZCB1cCBvciBub3RcbiAgICAgICAgICAgIGlmIChrZXllZFJlbW92YWxMaXN0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsZW49a2V5ZWRSZW1vdmFsTGlzdC5sZW5ndGg7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsVG9SZW1vdmUgPSBmcm9tTm9kZXNMb29rdXBba2V5ZWRSZW1vdmFsTGlzdFtpXV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbFRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGVsVG9SZW1vdmUsIGVsVG9SZW1vdmUucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkgJiYgbW9ycGhlZE5vZGUgIT09IGZyb21Ob2RlICYmIGZyb21Ob2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChtb3JwaGVkTm9kZS5hY3R1YWxpemUpIHtcbiAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IG1vcnBoZWROb2RlLmFjdHVhbGl6ZShmcm9tTm9kZS5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYWQgdG8gc3dhcCBvdXQgdGhlIGZyb20gbm9kZSB3aXRoIGEgbmV3IG5vZGUgYmVjYXVzZSB0aGUgb2xkXG4gICAgICAgICAgICAvLyBub2RlIHdhcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSB0YXJnZXQgbm9kZSB0aGVuIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIG9sZCBET00gbm9kZSBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuIFRoaXMgaXMgb25seVxuICAgICAgICAgICAgLy8gcG9zc2libGUgaWYgdGhlIG9yaWdpbmFsIERPTSBub2RlIHdhcyBwYXJ0IG9mIGEgRE9NIHRyZWUgd2hpY2hcbiAgICAgICAgICAgIC8vIHdlIGtub3cgaXMgdGhlIGNhc2UgaWYgaXQgaGFzIGEgcGFyZW50IG5vZGUuXG4gICAgICAgICAgICBmcm9tTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChtb3JwaGVkTm9kZSwgZnJvbU5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgIH07XG59XG5cbnZhciBtb3JwaGRvbSA9IG1vcnBoZG9tRmFjdG9yeShtb3JwaEF0dHJzKTtcblxuZXhwb3J0IGRlZmF1bHQgbW9ycGhkb207XG4iLCAiaW1wb3J0IHtcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX0RJU0FCTEVfV0lUSCxcbiAgUEhYX0ZFRURCQUNLX0ZPUixcbiAgUEhYX1BSVU5FLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TS0lQLFxuICBQSFhfU1RBVElDLFxuICBQSFhfVFJJR0dFUl9BQ1RJT04sXG4gIFBIWF9VUERBVEVcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgZGV0ZWN0RHVwbGljYXRlSWRzLFxuICBpc0NpZFxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBET01Qb3N0TW9ycGhSZXN0b3JlciBmcm9tIFwiLi9kb21fcG9zdF9tb3JwaF9yZXN0b3JlclwiXG5pbXBvcnQgbW9ycGhkb20gZnJvbSBcIm1vcnBoZG9tXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRE9NUGF0Y2gge1xuICBzdGF0aWMgcGF0Y2hFbChmcm9tRWwsIHRvRWwsIGFjdGl2ZUVsZW1lbnQpe1xuICAgIG1vcnBoZG9tKGZyb21FbCwgdG9FbCwge1xuICAgICAgY2hpbGRyZW5Pbmx5OiBmYWxzZSxcbiAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiAoZnJvbUVsLCB0b0VsKSA9PiB7XG4gICAgICAgIGlmKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC5pc1NhbWVOb2RlKGZyb21FbCkgJiYgRE9NLmlzRm9ybUlucHV0KGZyb21FbCkpe1xuICAgICAgICAgIERPTS5tZXJnZUZvY3VzZWRJbnB1dChmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY29uc3RydWN0b3IodmlldywgY29udGFpbmVyLCBpZCwgaHRtbCwgdGFyZ2V0Q0lEKXtcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5saXZlU29ja2V0ID0gdmlldy5saXZlU29ja2V0XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXJcbiAgICB0aGlzLmlkID0gaWRcbiAgICB0aGlzLnJvb3RJRCA9IHZpZXcucm9vdC5pZFxuICAgIHRoaXMuaHRtbCA9IGh0bWxcbiAgICB0aGlzLnRhcmdldENJRCA9IHRhcmdldENJRFxuICAgIHRoaXMuY2lkUGF0Y2ggPSBpc0NpZCh0aGlzLnRhcmdldENJRClcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHtcbiAgICAgIGJlZm9yZWFkZGVkOiBbXSwgYmVmb3JldXBkYXRlZDogW10sIGJlZm9yZXBoeENoaWxkQWRkZWQ6IFtdLFxuICAgICAgYWZ0ZXJhZGRlZDogW10sIGFmdGVydXBkYXRlZDogW10sIGFmdGVyZGlzY2FyZGVkOiBbXSwgYWZ0ZXJwaHhDaGlsZEFkZGVkOiBbXSxcbiAgICAgIGFmdGVydHJhbnNpdGlvbnNEaXNjYXJkZWQ6IFtdXG4gICAgfVxuICB9XG5cbiAgYmVmb3JlKGtpbmQsIGNhbGxiYWNrKXsgdGhpcy5jYWxsYmFja3NbYGJlZm9yZSR7a2luZH1gXS5wdXNoKGNhbGxiYWNrKSB9XG4gIGFmdGVyKGtpbmQsIGNhbGxiYWNrKXsgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLnB1c2goY2FsbGJhY2spIH1cblxuICB0cmFja0JlZm9yZShraW5kLCAuLi5hcmdzKXtcbiAgICB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soLi4uYXJncykpXG4gIH1cblxuICB0cmFja0FmdGVyKGtpbmQsIC4uLmFyZ3Mpe1xuICAgIHRoaXMuY2FsbGJhY2tzW2BhZnRlciR7a2luZH1gXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKC4uLmFyZ3MpKVxuICB9XG5cbiAgbWFya1BydW5hYmxlQ29udGVudEZvclJlbW92YWwoKXtcbiAgICBET00uYWxsKHRoaXMuY29udGFpbmVyLCBcIltwaHgtdXBkYXRlPWFwcGVuZF0gPiAqLCBbcGh4LXVwZGF0ZT1wcmVwZW5kXSA+ICpcIiwgZWwgPT4ge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9QUlVORSwgXCJcIilcbiAgICB9KVxuICB9XG5cbiAgcGVyZm9ybSgpe1xuICAgIGxldCB7dmlldywgbGl2ZVNvY2tldCwgY29udGFpbmVyLCBodG1sfSA9IHRoaXNcbiAgICBsZXQgdGFyZ2V0Q29udGFpbmVyID0gdGhpcy5pc0NJRFBhdGNoKCkgPyB0aGlzLnRhcmdldENJRENvbnRhaW5lcihodG1sKSA6IGNvbnRhaW5lclxuICAgIGlmKHRoaXMuaXNDSURQYXRjaCgpICYmICF0YXJnZXRDb250YWluZXIpeyByZXR1cm4gfVxuXG4gICAgbGV0IGZvY3VzZWQgPSBsaXZlU29ja2V0LmdldEFjdGl2ZUVsZW1lbnQoKVxuICAgIGxldCB7c2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZH0gPSBmb2N1c2VkICYmIERPTS5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSA/IGZvY3VzZWQgOiB7fVxuICAgIGxldCBwaHhVcGRhdGUgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1VQREFURSlcbiAgICBsZXQgcGh4RmVlZGJhY2tGb3IgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUilcbiAgICBsZXQgZGlzYWJsZVdpdGggPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSClcbiAgICBsZXQgcGh4VHJpZ2dlckV4dGVybmFsID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9UUklHR0VSX0FDVElPTilcbiAgICBsZXQgcGh4UmVtb3ZlID0gbGl2ZVNvY2tldC5iaW5kaW5nKFwicmVtb3ZlXCIpXG4gICAgbGV0IGFkZGVkID0gW11cbiAgICBsZXQgdXBkYXRlcyA9IFtdXG4gICAgbGV0IGFwcGVuZFByZXBlbmRVcGRhdGVzID0gW11cbiAgICBsZXQgcGVuZGluZ1JlbW92ZXMgPSBbXVxuICAgIGxldCBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBudWxsXG5cbiAgICBsZXQgZGlmZkhUTUwgPSBsaXZlU29ja2V0LnRpbWUoXCJwcmVtb3JwaCBjb250YWluZXIgcHJlcFwiLCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5idWlsZERpZmZIVE1MKGNvbnRhaW5lciwgaHRtbCwgcGh4VXBkYXRlLCB0YXJnZXRDb250YWluZXIpXG4gICAgfSlcblxuICAgIHRoaXMudHJhY2tCZWZvcmUoXCJhZGRlZFwiLCBjb250YWluZXIpXG4gICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgY29udGFpbmVyLCBjb250YWluZXIpXG5cbiAgICBsaXZlU29ja2V0LnRpbWUoXCJtb3JwaGRvbVwiLCAoKSA9PiB7XG4gICAgICBtb3JwaGRvbSh0YXJnZXRDb250YWluZXIsIGRpZmZIVE1MLCB7XG4gICAgICAgIGNoaWxkcmVuT25seTogdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gbnVsbCxcbiAgICAgICAgZ2V0Tm9kZUtleTogKG5vZGUpID0+IHtcbiAgICAgICAgICByZXR1cm4gRE9NLmlzUGh4RGVzdHJveWVkKG5vZGUpID8gbnVsbCA6IG5vZGUuaWRcbiAgICAgICAgfSxcbiAgICAgICAgb25CZWZvcmVOb2RlQWRkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJhZGRlZFwiLCBlbClcbiAgICAgICAgICByZXR1cm4gZWxcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob2RlQWRkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIC8vIGhhY2sgdG8gZml4IFNhZmFyaSBoYW5kbGluZyBvZiBpbWcgc3Jjc2V0IGFuZCB2aWRlbyB0YWdzXG4gICAgICAgICAgaWYoZWwgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICYmIGVsLnNyY3NldCl7XG4gICAgICAgICAgICBlbC5zcmNzZXQgPSBlbC5zcmNzZXRcbiAgICAgICAgICB9IGVsc2UgaWYoZWwgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ICYmIGVsLmF1dG9wbGF5KXtcbiAgICAgICAgICAgIGVsLnBsYXkoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihET00uaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpKXtcbiAgICAgICAgICAgIGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IGVsXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vaW5wdXQgaGFuZGxpbmdcbiAgICAgICAgICBET00uZGlzY2FyZEVycm9yKHRhcmdldENvbnRhaW5lciwgZWwsIHBoeEZlZWRiYWNrRm9yKVxuICAgICAgICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgICAgICAgaWYoKERPTS5pc1BoeENoaWxkKGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsKSkgfHwgRE9NLmlzUGh4U3RpY2t5KGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsLnBhcmVudE5vZGUpKXtcbiAgICAgICAgICAgIHRoaXMudHJhY2tBZnRlcihcInBoeENoaWxkQWRkZWRcIiwgZWwpXG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZGVkLnB1c2goZWwpXG4gICAgICAgIH0sXG4gICAgICAgIG9uTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgLy8gbmVzdGVkIHZpZXcgaGFuZGxpbmdcbiAgICAgICAgICBpZihET00uaXNQaHhDaGlsZChlbCkgfHwgRE9NLmlzUGh4U3RpY2t5KGVsKSl7IGxpdmVTb2NrZXQuZGVzdHJveVZpZXdCeUVsKGVsKSB9XG4gICAgICAgICAgdGhpcy50cmFja0FmdGVyKFwiZGlzY2FyZGVkXCIsIGVsKVxuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZU5vZGVEaXNjYXJkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1BSVU5FKSAhPT0gbnVsbCl7IHJldHVybiB0cnVlIH1cbiAgICAgICAgICBpZihlbC5wYXJlbnROb2RlICE9PSBudWxsICYmIERPTS5pc1BoeFVwZGF0ZShlbC5wYXJlbnROb2RlLCBwaHhVcGRhdGUsIFtcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pICYmIGVsLmlkKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICBpZihlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKHBoeFJlbW92ZSkpe1xuICAgICAgICAgICAgcGVuZGluZ1JlbW92ZXMucHVzaChlbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0aGlzLnNraXBDSURTaWJsaW5nKGVsKSl7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgb25FbFVwZGF0ZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIGlmKERPTS5pc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCkpe1xuICAgICAgICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkID0gZWxcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlcy5wdXNoKGVsKVxuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZUVsVXBkYXRlZDogKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgICAgIERPTS5jbGVhbkNoaWxkTm9kZXModG9FbCwgcGh4VXBkYXRlKVxuICAgICAgICAgIGlmKHRoaXMuc2tpcENJRFNpYmxpbmcodG9FbCkpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmKERPTS5pc1BoeFN0aWNreShmcm9tRWwpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgICBpZihET00uaXNJZ25vcmVkKGZyb21FbCwgcGh4VXBkYXRlKSl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtpc0lnbm9yZWQ6IHRydWV9KVxuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGZyb21FbC50eXBlID09PSBcIm51bWJlclwiICYmIChmcm9tRWwudmFsaWRpdHkgJiYgZnJvbUVsLnZhbGlkaXR5LmJhZElucHV0KSl7IHJldHVybiBmYWxzZSB9XG4gICAgICAgICAgaWYoIURPTS5zeW5jUGVuZGluZ1JlZihmcm9tRWwsIHRvRWwsIGRpc2FibGVXaXRoKSl7XG4gICAgICAgICAgICBpZihET00uaXNVcGxvYWRJbnB1dChmcm9tRWwpKXtcbiAgICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goZnJvbUVsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBuZXN0ZWQgdmlldyBoYW5kbGluZ1xuICAgICAgICAgIGlmKERPTS5pc1BoeENoaWxkKHRvRWwpKXtcbiAgICAgICAgICAgIGxldCBwcmV2U2Vzc2lvbiA9IGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pXG4gICAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtleGNsdWRlOiBbUEhYX1NUQVRJQ119KVxuICAgICAgICAgICAgaWYocHJldlNlc3Npb24gIT09IFwiXCIpeyBmcm9tRWwuc2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OLCBwcmV2U2Vzc2lvbikgfVxuICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCwgdGhpcy5yb290SUQpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlucHV0IGhhbmRsaW5nXG4gICAgICAgICAgRE9NLmNvcHlQcml2YXRlcyh0b0VsLCBmcm9tRWwpXG4gICAgICAgICAgRE9NLmRpc2NhcmRFcnJvcih0YXJnZXRDb250YWluZXIsIHRvRWwsIHBoeEZlZWRiYWNrRm9yKVxuXG4gICAgICAgICAgbGV0IGlzRm9jdXNlZEZvcm1FbCA9IGZvY3VzZWQgJiYgZnJvbUVsLmlzU2FtZU5vZGUoZm9jdXNlZCkgJiYgRE9NLmlzRm9ybUlucHV0KGZyb21FbClcbiAgICAgICAgICBpZihpc0ZvY3VzZWRGb3JtRWwpe1xuICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgRE9NLm1lcmdlRm9jdXNlZElucHV0KGZyb21FbCwgdG9FbClcbiAgICAgICAgICAgIERPTS5zeW5jQXR0cnNUb1Byb3BzKGZyb21FbClcbiAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZihET00uaXNQaHhVcGRhdGUodG9FbCwgcGh4VXBkYXRlLCBbXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSl7XG4gICAgICAgICAgICAgIGFwcGVuZFByZXBlbmRVcGRhdGVzLnB1c2gobmV3IERPTVBvc3RNb3JwaFJlc3RvcmVyKGZyb21FbCwgdG9FbCwgdG9FbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBET00uc3luY0F0dHJzVG9Qcm9wcyh0b0VsKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyh0b0VsKVxuICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmKGxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSl7IGRldGVjdER1cGxpY2F0ZUlkcygpIH1cblxuICAgIGlmKGFwcGVuZFByZXBlbmRVcGRhdGVzLmxlbmd0aCA+IDApe1xuICAgICAgbGl2ZVNvY2tldC50aW1lKFwicG9zdC1tb3JwaCBhcHBlbmQvcHJlcGVuZCByZXN0b3JhdGlvblwiLCAoKSA9PiB7XG4gICAgICAgIGFwcGVuZFByZXBlbmRVcGRhdGVzLmZvckVhY2godXBkYXRlID0+IHVwZGF0ZS5wZXJmb3JtKCkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGxpdmVTb2NrZXQuc2lsZW5jZUV2ZW50cygoKSA9PiBET00ucmVzdG9yZUZvY3VzKGZvY3VzZWQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpKVxuICAgIERPTS5kaXNwYXRjaEV2ZW50KGRvY3VtZW50LCBcInBoeDp1cGRhdGVcIilcbiAgICBhZGRlZC5mb3JFYWNoKGVsID0+IHRoaXMudHJhY2tBZnRlcihcImFkZGVkXCIsIGVsKSlcbiAgICB1cGRhdGVzLmZvckVhY2goZWwgPT4gdGhpcy50cmFja0FmdGVyKFwidXBkYXRlZFwiLCBlbCkpXG5cbiAgICBpZihwZW5kaW5nUmVtb3Zlcy5sZW5ndGggPiAwKXtcbiAgICAgIGxpdmVTb2NrZXQudHJhbnNpdGlvblJlbW92ZXMocGVuZGluZ1JlbW92ZXMpXG4gICAgICBsaXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBwZW5kaW5nUmVtb3Zlcy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBsZXQgY2hpbGQgPSBET00uZmlyc3RQaHhDaGlsZChlbClcbiAgICAgICAgICBpZihjaGlsZCl7IGxpdmVTb2NrZXQuZGVzdHJveVZpZXdCeUVsKGNoaWxkKSB9XG4gICAgICAgICAgZWwucmVtb3ZlKClcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy50cmFja0FmdGVyKFwidHJhbnNpdGlvbnNEaXNjYXJkZWRcIiwgcGVuZGluZ1JlbW92ZXMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmKGV4dGVybmFsRm9ybVRyaWdnZXJlZCl7XG4gICAgICBsaXZlU29ja2V0LmRpc2Nvbm5lY3QoKVxuICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkLnN1Ym1pdCgpXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpc0NJRFBhdGNoKCl7IHJldHVybiB0aGlzLmNpZFBhdGNoIH1cblxuICBza2lwQ0lEU2libGluZyhlbCl7XG4gICAgcmV0dXJuIGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1NLSVApICE9PSBudWxsXG4gIH1cblxuICB0YXJnZXRDSURDb250YWluZXIoaHRtbCl7XG4gICAgaWYoIXRoaXMuaXNDSURQYXRjaCgpKXsgcmV0dXJuIH1cbiAgICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5jb250YWluZXIsIHRoaXMudGFyZ2V0Q0lEKVxuICAgIGlmKHJlc3QubGVuZ3RoID09PSAwICYmIERPTS5jaGlsZE5vZGVMZW5ndGgoaHRtbCkgPT09IDEpe1xuICAgICAgcmV0dXJuIGZpcnN0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5wYXJlbnROb2RlXG4gICAgfVxuICB9XG5cbiAgLy8gYnVpbGRzIEhUTUwgZm9yIG1vcnBoZG9tIHBhdGNoXG4gIC8vIC0gZm9yIGZ1bGwgcGF0Y2hlcyBvZiBMaXZlVmlldyBvciBhIGNvbXBvbmVudCB3aXRoIGEgc2luZ2xlXG4gIC8vICAgcm9vdCBub2RlLCBzaW1wbHkgcmV0dXJucyB0aGUgSFRNTFxuICAvLyAtIGZvciBwYXRjaGVzIG9mIGEgY29tcG9uZW50IHdpdGggbXVsdGlwbGUgcm9vdCBub2RlcywgdGhlXG4gIC8vICAgcGFyZW50IG5vZGUgYmVjb21lcyB0aGUgdGFyZ2V0IGNvbnRhaW5lciBhbmQgbm9uLWNvbXBvbmVudFxuICAvLyAgIHNpYmxpbmdzIGFyZSBtYXJrZWQgYXMgc2tpcC5cbiAgYnVpbGREaWZmSFRNTChjb250YWluZXIsIGh0bWwsIHBoeFVwZGF0ZSwgdGFyZ2V0Q29udGFpbmVyKXtcbiAgICBsZXQgaXNDSURQYXRjaCA9IHRoaXMuaXNDSURQYXRjaCgpXG4gICAgbGV0IGlzQ0lEV2l0aFNpbmdsZVJvb3QgPSBpc0NJRFBhdGNoICYmIHRhcmdldENvbnRhaW5lci5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkgPT09IHRoaXMudGFyZ2V0Q0lELnRvU3RyaW5nKClcbiAgICBpZighaXNDSURQYXRjaCB8fCBpc0NJRFdpdGhTaW5nbGVSb290KXtcbiAgICAgIHJldHVybiBodG1sXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBvbmVudCBwYXRjaCB3aXRoIG11bHRpcGxlIENJRCByb290c1xuICAgICAgbGV0IGRpZmZDb250YWluZXIgPSBudWxsXG4gICAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICAgIGRpZmZDb250YWluZXIgPSBET00uY2xvbmVOb2RlKHRhcmdldENvbnRhaW5lcilcbiAgICAgIGxldCBbZmlyc3RDb21wb25lbnQsIC4uLnJlc3RdID0gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdChkaWZmQ29udGFpbmVyLCB0aGlzLnRhcmdldENJRClcbiAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcbiAgICAgIHJlc3QuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSlcbiAgICAgIEFycmF5LmZyb20oZGlmZkNvbnRhaW5lci5jaGlsZE5vZGVzKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgLy8gd2UgY2FuIG9ubHkgc2tpcCB0cmFja2FibGUgbm9kZXMgd2l0aCBhbiBJRFxuICAgICAgICBpZihjaGlsZC5pZCAmJiBjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgY2hpbGQuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpICE9PSB0aGlzLnRhcmdldENJRC50b1N0cmluZygpKXtcbiAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX1NLSVAsIFwiXCIpXG4gICAgICAgICAgY2hpbGQuaW5uZXJIVE1MID0gXCJcIlxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgQXJyYXkuZnJvbSh0ZW1wbGF0ZS5jb250ZW50LmNoaWxkTm9kZXMpLmZvckVhY2goZWwgPT4gZGlmZkNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZWwsIGZpcnN0Q29tcG9uZW50KSlcbiAgICAgIGZpcnN0Q29tcG9uZW50LnJlbW92ZSgpXG4gICAgICByZXR1cm4gZGlmZkNvbnRhaW5lci5vdXRlckhUTUxcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBDT01QT05FTlRTLFxuICBEWU5BTUlDUyxcbiAgVEVNUExBVEVTLFxuICBFVkVOVFMsXG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9TS0lQLFxuICBSRVBMWSxcbiAgU1RBVElDLFxuICBUSVRMRVxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBpc09iamVjdCxcbiAgbG9nRXJyb3IsXG4gIGlzQ2lkLFxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVkIHtcbiAgc3RhdGljIGV4dHJhY3QoZGlmZil7XG4gICAgbGV0IHtbUkVQTFldOiByZXBseSwgW0VWRU5UU106IGV2ZW50cywgW1RJVExFXTogdGl0bGV9ID0gZGlmZlxuICAgIGRlbGV0ZSBkaWZmW1JFUExZXVxuICAgIGRlbGV0ZSBkaWZmW0VWRU5UU11cbiAgICBkZWxldGUgZGlmZltUSVRMRV1cbiAgICByZXR1cm4ge2RpZmYsIHRpdGxlLCByZXBseTogcmVwbHkgfHwgbnVsbCwgZXZlbnRzOiBldmVudHMgfHwgW119XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih2aWV3SWQsIHJlbmRlcmVkKXtcbiAgICB0aGlzLnZpZXdJZCA9IHZpZXdJZFxuICAgIHRoaXMucmVuZGVyZWQgPSB7fVxuICAgIHRoaXMubWVyZ2VEaWZmKHJlbmRlcmVkKVxuICB9XG5cbiAgcGFyZW50Vmlld0lkKCl7IHJldHVybiB0aGlzLnZpZXdJZCB9XG5cbiAgdG9TdHJpbmcob25seUNpZHMpe1xuICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKHRoaXMucmVuZGVyZWQsIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIG9ubHlDaWRzKVxuICB9XG5cbiAgcmVjdXJzaXZlVG9TdHJpbmcocmVuZGVyZWQsIGNvbXBvbmVudHMgPSByZW5kZXJlZFtDT01QT05FTlRTXSwgb25seUNpZHMpe1xuICAgIG9ubHlDaWRzID0gb25seUNpZHMgPyBuZXcgU2V0KG9ubHlDaWRzKSA6IG51bGxcbiAgICBsZXQgb3V0cHV0ID0ge2J1ZmZlcjogXCJcIiwgY29tcG9uZW50czogY29tcG9uZW50cywgb25seUNpZHM6IG9ubHlDaWRzfVxuICAgIHRoaXMudG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIG51bGwsIG91dHB1dClcbiAgICByZXR1cm4gb3V0cHV0LmJ1ZmZlclxuICB9XG5cbiAgY29tcG9uZW50Q0lEcyhkaWZmKXsgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmZbQ09NUE9ORU5UU10gfHwge30pLm1hcChpID0+IHBhcnNlSW50KGkpKSB9XG5cbiAgaXNDb21wb25lbnRPbmx5RGlmZihkaWZmKXtcbiAgICBpZighZGlmZltDT01QT05FTlRTXSl7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmYpLmxlbmd0aCA9PT0gMVxuICB9XG5cbiAgZ2V0Q29tcG9uZW50KGRpZmYsIGNpZCl7IHJldHVybiBkaWZmW0NPTVBPTkVOVFNdW2NpZF0gfVxuXG4gIG1lcmdlRGlmZihkaWZmKXtcbiAgICBsZXQgbmV3YyA9IGRpZmZbQ09NUE9ORU5UU11cbiAgICBsZXQgY2FjaGUgPSB7fVxuICAgIGRlbGV0ZSBkaWZmW0NPTVBPTkVOVFNdXG4gICAgdGhpcy5yZW5kZXJlZCA9IHRoaXMubXV0YWJsZU1lcmdlKHRoaXMucmVuZGVyZWQsIGRpZmYpXG4gICAgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSA9IHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10gfHwge31cblxuICAgIGlmKG5ld2Mpe1xuICAgICAgbGV0IG9sZGMgPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdXG5cbiAgICAgIGZvcihsZXQgY2lkIGluIG5ld2Mpe1xuICAgICAgICBuZXdjW2NpZF0gPSB0aGlzLmNhY2hlZEZpbmRDb21wb25lbnQoY2lkLCBuZXdjW2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKVxuICAgICAgfVxuXG4gICAgICBmb3IobGV0IGNpZCBpbiBuZXdjKXsgb2xkY1tjaWRdID0gbmV3Y1tjaWRdIH1cbiAgICAgIGRpZmZbQ09NUE9ORU5UU10gPSBuZXdjXG4gICAgfVxuICB9XG5cbiAgY2FjaGVkRmluZENvbXBvbmVudChjaWQsIGNkaWZmLCBvbGRjLCBuZXdjLCBjYWNoZSl7XG4gICAgaWYoY2FjaGVbY2lkXSl7XG4gICAgICByZXR1cm4gY2FjaGVbY2lkXVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmRpZmYsIHN0YXQsIHNjaWQgPSBjZGlmZltTVEFUSUNdXG5cbiAgICAgIGlmKGlzQ2lkKHNjaWQpKXtcbiAgICAgICAgbGV0IHRkaWZmXG5cbiAgICAgICAgaWYoc2NpZCA+IDApe1xuICAgICAgICAgIHRkaWZmID0gdGhpcy5jYWNoZWRGaW5kQ29tcG9uZW50KHNjaWQsIG5ld2Nbc2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRkaWZmID0gb2xkY1stc2NpZF1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXQgPSB0ZGlmZltTVEFUSUNdXG4gICAgICAgIG5kaWZmID0gdGhpcy5jbG9uZU1lcmdlKHRkaWZmLCBjZGlmZilcbiAgICAgICAgbmRpZmZbU1RBVElDXSA9IHN0YXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5kaWZmID0gY2RpZmZbU1RBVElDXSAhPT0gdW5kZWZpbmVkID8gY2RpZmYgOiB0aGlzLmNsb25lTWVyZ2Uob2xkY1tjaWRdIHx8IHt9LCBjZGlmZilcbiAgICAgIH1cblxuICAgICAgY2FjaGVbY2lkXSA9IG5kaWZmXG4gICAgICByZXR1cm4gbmRpZmZcbiAgICB9XG4gIH1cblxuICBtdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2Upe1xuICAgIGlmKHNvdXJjZVtTVEFUSUNdICE9PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIHNvdXJjZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKVxuICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cbiAgfVxuXG4gIGRvTXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKXtcbiAgICBmb3IobGV0IGtleSBpbiBzb3VyY2Upe1xuICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldXG4gICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV1cbiAgICAgIGlmKGlzT2JqZWN0KHZhbCkgJiYgdmFsW1NUQVRJQ10gPT09IHVuZGVmaW5lZCAmJiBpc09iamVjdCh0YXJnZXRWYWwpKXtcbiAgICAgICAgdGhpcy5kb011dGFibGVNZXJnZSh0YXJnZXRWYWwsIHZhbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xvbmVNZXJnZSh0YXJnZXQsIHNvdXJjZSl7XG4gICAgbGV0IG1lcmdlZCA9IHsuLi50YXJnZXQsIC4uLnNvdXJjZX1cbiAgICBmb3IobGV0IGtleSBpbiBtZXJnZWQpe1xuICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldXG4gICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV1cbiAgICAgIGlmKGlzT2JqZWN0KHZhbCkgJiYgdmFsW1NUQVRJQ10gPT09IHVuZGVmaW5lZCAmJiBpc09iamVjdCh0YXJnZXRWYWwpKXtcbiAgICAgICAgbWVyZ2VkW2tleV0gPSB0aGlzLmNsb25lTWVyZ2UodGFyZ2V0VmFsLCB2YWwpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRcbiAgfVxuXG4gIGNvbXBvbmVudFRvU3RyaW5nKGNpZCl7IHJldHVybiB0aGlzLnJlY3Vyc2l2ZUNJRFRvU3RyaW5nKHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIGNpZCkgfVxuXG4gIHBydW5lQ0lEcyhjaWRzKXtcbiAgICBjaWRzLmZvckVhY2goY2lkID0+IGRlbGV0ZSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdW2NpZF0pXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgZ2V0KCl7IHJldHVybiB0aGlzLnJlbmRlcmVkIH1cblxuICBpc05ld0ZpbmdlcnByaW50KGRpZmYgPSB7fSl7IHJldHVybiAhIWRpZmZbU1RBVElDXSB9XG5cbiAgdGVtcGxhdGVTdGF0aWMocGFydCwgdGVtcGxhdGVzKXtcbiAgICBpZih0eXBlb2YgKHBhcnQpID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdGVtcGxhdGVzW3BhcnRdXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJ0XG4gICAgfVxuICB9XG5cbiAgdG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KXtcbiAgICBpZihyZW5kZXJlZFtEWU5BTUlDU10peyByZXR1cm4gdGhpcy5jb21wcmVoZW5zaW9uVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KSB9XG4gICAgbGV0IHtbU1RBVElDXTogc3RhdGljc30gPSByZW5kZXJlZFxuICAgIHN0YXRpY3MgPSB0aGlzLnRlbXBsYXRlU3RhdGljKHN0YXRpY3MsIHRlbXBsYXRlcylcblxuICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1swXVxuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKXtcbiAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKHJlbmRlcmVkW2kgLSAxXSwgdGVtcGxhdGVzLCBvdXRwdXQpXG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbaV1cbiAgICB9XG4gIH1cblxuICBjb21wcmVoZW5zaW9uVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KXtcbiAgICBsZXQge1tEWU5BTUlDU106IGR5bmFtaWNzLCBbU1RBVElDXTogc3RhdGljc30gPSByZW5kZXJlZFxuICAgIHN0YXRpY3MgPSB0aGlzLnRlbXBsYXRlU3RhdGljKHN0YXRpY3MsIHRlbXBsYXRlcylcbiAgICBsZXQgY29tcFRlbXBsYXRlcyA9IHRlbXBsYXRlcyB8fCByZW5kZXJlZFtURU1QTEFURVNdXG5cbiAgICBmb3IobGV0IGQgPSAwOyBkIDwgZHluYW1pY3MubGVuZ3RoOyBkKyspe1xuICAgICAgbGV0IGR5bmFtaWMgPSBkeW5hbWljc1tkXVxuICAgICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzWzBdXG4gICAgICBmb3IobGV0IGkgPSAxOyBpIDwgc3RhdGljcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKGR5bmFtaWNbaSAtIDFdLCBjb21wVGVtcGxhdGVzLCBvdXRwdXQpXG4gICAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGR5bmFtaWNUb0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpe1xuICAgIGlmKHR5cGVvZiAocmVuZGVyZWQpID09PSBcIm51bWJlclwiKXtcbiAgICAgIG91dHB1dC5idWZmZXIgKz0gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyhvdXRwdXQuY29tcG9uZW50cywgcmVuZGVyZWQsIG91dHB1dC5vbmx5Q2lkcylcbiAgICB9IGVsc2UgaWYoaXNPYmplY3QocmVuZGVyZWQpKXtcbiAgICAgIHRoaXMudG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHJlbmRlcmVkXG4gICAgfVxuICB9XG5cbiAgcmVjdXJzaXZlQ0lEVG9TdHJpbmcoY29tcG9uZW50cywgY2lkLCBvbmx5Q2lkcyl7XG4gICAgbGV0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY2lkXSB8fCBsb2dFcnJvcihgbm8gY29tcG9uZW50IGZvciBDSUQgJHtjaWR9YCwgY29tcG9uZW50cylcbiAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIilcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKGNvbXBvbmVudCwgY29tcG9uZW50cywgb25seUNpZHMpXG4gICAgbGV0IGNvbnRhaW5lciA9IHRlbXBsYXRlLmNvbnRlbnRcbiAgICBsZXQgc2tpcCA9IG9ubHlDaWRzICYmICFvbmx5Q2lkcy5oYXMoY2lkKVxuXG4gICAgbGV0IFtoYXNDaGlsZE5vZGVzLCBoYXNDaGlsZENvbXBvbmVudHNdID1cbiAgICAgIEFycmF5LmZyb20oY29udGFpbmVyLmNoaWxkTm9kZXMpLnJlZHVjZSgoW2hhc05vZGVzLCBoYXNDb21wb25lbnRzXSwgY2hpbGQsIGkpID0+IHtcbiAgICAgICAgaWYoY2hpbGQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKXtcbiAgICAgICAgICBpZihjaGlsZC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkpe1xuICAgICAgICAgICAgcmV0dXJuIFtoYXNOb2RlcywgdHJ1ZV1cbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQsIGNpZClcbiAgICAgICAgICBpZighY2hpbGQuaWQpeyBjaGlsZC5pZCA9IGAke3RoaXMucGFyZW50Vmlld0lkKCl9LSR7Y2lkfS0ke2l9YCB9XG4gICAgICAgICAgaWYoc2tpcCl7XG4gICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX1NLSVAsIFwiXCIpXG4gICAgICAgICAgICBjaGlsZC5pbm5lckhUTUwgPSBcIlwiXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbdHJ1ZSwgaGFzQ29tcG9uZW50c11cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZihjaGlsZC5ub2RlVmFsdWUudHJpbSgpICE9PSBcIlwiKXtcbiAgICAgICAgICAgIGxvZ0Vycm9yKFwib25seSBIVE1MIGVsZW1lbnQgdGFncyBhcmUgYWxsb3dlZCBhdCB0aGUgcm9vdCBvZiBjb21wb25lbnRzLlxcblxcblwiICtcbiAgICAgICAgICAgICAgYGdvdDogXCIke2NoaWxkLm5vZGVWYWx1ZS50cmltKCl9XCJcXG5cXG5gICtcbiAgICAgICAgICAgICAgXCJ3aXRoaW46XFxuXCIsIHRlbXBsYXRlLmlubmVySFRNTC50cmltKCkpXG4gICAgICAgICAgICBjaGlsZC5yZXBsYWNlV2l0aCh0aGlzLmNyZWF0ZVNwYW4oY2hpbGQubm9kZVZhbHVlLCBjaWQpKVxuICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCBoYXNDb21wb25lbnRzXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZC5yZW1vdmUoKVxuICAgICAgICAgICAgcmV0dXJuIFtoYXNOb2RlcywgaGFzQ29tcG9uZW50c11cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIFtmYWxzZSwgZmFsc2VdKVxuXG4gICAgaWYoIWhhc0NoaWxkTm9kZXMgJiYgIWhhc0NoaWxkQ29tcG9uZW50cyl7XG4gICAgICBsb2dFcnJvcihcImV4cGVjdGVkIGF0IGxlYXN0IG9uZSBIVE1MIGVsZW1lbnQgdGFnIGluc2lkZSBhIGNvbXBvbmVudCwgYnV0IHRoZSBjb21wb25lbnQgaXMgZW1wdHk6XFxuXCIsXG4gICAgICAgIHRlbXBsYXRlLmlubmVySFRNTC50cmltKCkpXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVTcGFuKFwiXCIsIGNpZCkub3V0ZXJIVE1MXG4gICAgfSBlbHNlIGlmKCFoYXNDaGlsZE5vZGVzICYmIGhhc0NoaWxkQ29tcG9uZW50cyl7XG4gICAgICBsb2dFcnJvcihcImV4cGVjdGVkIGF0IGxlYXN0IG9uZSBIVE1MIGVsZW1lbnQgdGFnIGRpcmVjdGx5IGluc2lkZSBhIGNvbXBvbmVudCwgYnV0IG9ubHkgc3ViY29tcG9uZW50cyB3ZXJlIGZvdW5kLiBBIGNvbXBvbmVudCBtdXN0IHJlbmRlciBhdCBsZWFzdCBvbmUgSFRNTCB0YWcgZGlyZWN0bHkgaW5zaWRlIGl0c2VsZi5cIixcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSlcbiAgICAgIHJldHVybiB0ZW1wbGF0ZS5pbm5lckhUTUxcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlLmlubmVySFRNTFxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVNwYW4odGV4dCwgY2lkKXtcbiAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgc3Bhbi5pbm5lclRleHQgPSB0ZXh0XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCwgY2lkKVxuICAgIHJldHVybiBzcGFuXG4gIH1cbn1cbiIsICJsZXQgdmlld0hvb2tJRCA9IDFcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdIb29rIHtcbiAgc3RhdGljIG1ha2VJRCgpeyByZXR1cm4gdmlld0hvb2tJRCsrIH1cbiAgc3RhdGljIGVsZW1lbnRJRChlbCl7IHJldHVybiBlbC5waHhIb29rSWQgfVxuXG4gIGNvbnN0cnVjdG9yKHZpZXcsIGVsLCBjYWxsYmFja3Mpe1xuICAgIHRoaXMuX192aWV3ID0gdmlld1xuICAgIHRoaXMuX19saXZlU29ja2V0ID0gdmlldy5saXZlU29ja2V0XG4gICAgdGhpcy5fX2NhbGxiYWNrcyA9IGNhbGxiYWNrc1xuICAgIHRoaXMuX19saXN0ZW5lcnMgPSBuZXcgU2V0KClcbiAgICB0aGlzLl9faXNEaXNjb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMuZWwgPSBlbFxuICAgIHRoaXMuZWwucGh4SG9va0lkID0gdGhpcy5jb25zdHJ1Y3Rvci5tYWtlSUQoKVxuICAgIGZvcihsZXQga2V5IGluIHRoaXMuX19jYWxsYmFja3MpeyB0aGlzW2tleV0gPSB0aGlzLl9fY2FsbGJhY2tzW2tleV0gfVxuICB9XG5cbiAgX19tb3VudGVkKCl7IHRoaXMubW91bnRlZCAmJiB0aGlzLm1vdW50ZWQoKSB9XG4gIF9fdXBkYXRlZCgpeyB0aGlzLnVwZGF0ZWQgJiYgdGhpcy51cGRhdGVkKCkgfVxuICBfX2JlZm9yZVVwZGF0ZSgpeyB0aGlzLmJlZm9yZVVwZGF0ZSAmJiB0aGlzLmJlZm9yZVVwZGF0ZSgpIH1cbiAgX19kZXN0cm95ZWQoKXsgdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5kZXN0cm95ZWQoKSB9XG4gIF9fcmVjb25uZWN0ZWQoKXtcbiAgICBpZih0aGlzLl9faXNEaXNjb25uZWN0ZWQpe1xuICAgICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICAgIHRoaXMucmVjb25uZWN0ZWQgJiYgdGhpcy5yZWNvbm5lY3RlZCgpXG4gICAgfVxuICB9XG4gIF9fZGlzY29ubmVjdGVkKCl7XG4gICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gdHJ1ZVxuICAgIHRoaXMuZGlzY29ubmVjdGVkICYmIHRoaXMuZGlzY29ubmVjdGVkKClcbiAgfVxuXG4gIHB1c2hFdmVudChldmVudCwgcGF5bG9hZCA9IHt9LCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHJldHVybiB0aGlzLl9fdmlldy5wdXNoSG9va0V2ZW50KG51bGwsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KVxuICB9XG5cbiAgcHVzaEV2ZW50VG8ocGh4VGFyZ2V0LCBldmVudCwgcGF5bG9hZCA9IHt9LCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIHJldHVybiB0aGlzLl9fdmlldy53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgcmV0dXJuIHZpZXcucHVzaEhvb2tFdmVudCh0YXJnZXRDdHgsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVFdmVudChldmVudCwgY2FsbGJhY2spe1xuICAgIGxldCBjYWxsYmFja1JlZiA9IChjdXN0b21FdmVudCwgYnlwYXNzKSA9PiBieXBhc3MgPyBldmVudCA6IGNhbGxiYWNrKGN1c3RvbUV2ZW50LmRldGFpbClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihgcGh4OiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpXG4gICAgdGhpcy5fX2xpc3RlbmVycy5hZGQoY2FsbGJhY2tSZWYpXG4gICAgcmV0dXJuIGNhbGxiYWNrUmVmXG4gIH1cblxuICByZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZil7XG4gICAgbGV0IGV2ZW50ID0gY2FsbGJhY2tSZWYobnVsbCwgdHJ1ZSlcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihgcGh4OiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpXG4gICAgdGhpcy5fX2xpc3RlbmVycy5kZWxldGUoY2FsbGJhY2tSZWYpXG4gIH1cblxuICB1cGxvYWQobmFtZSwgZmlsZXMpe1xuICAgIHJldHVybiB0aGlzLl9fdmlldy5kaXNwYXRjaFVwbG9hZHMobmFtZSwgZmlsZXMpXG4gIH1cblxuICB1cGxvYWRUbyhwaHhUYXJnZXQsIG5hbWUsIGZpbGVzKXtcbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsIHZpZXcgPT4gdmlldy5kaXNwYXRjaFVwbG9hZHMobmFtZSwgZmlsZXMpKVxuICB9XG5cbiAgX19jbGVhbnVwX18oKXtcbiAgICB0aGlzLl9fbGlzdGVuZXJzLmZvckVhY2goY2FsbGJhY2tSZWYgPT4gdGhpcy5yZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZikpXG4gIH1cbn1cbiIsICJpbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5cbmxldCBKUyA9IHtcbiAgZXhlYyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZGVmYXVsdHMpe1xuICAgIGxldCBbZGVmYXVsdEtpbmQsIGRlZmF1bHRBcmdzXSA9IGRlZmF1bHRzIHx8IFtudWxsLCB7fV1cbiAgICBsZXQgY29tbWFuZHMgPSBwaHhFdmVudC5jaGFyQXQoMCkgPT09IFwiW1wiID9cbiAgICAgIEpTT04ucGFyc2UocGh4RXZlbnQpIDogW1tkZWZhdWx0S2luZCwgZGVmYXVsdEFyZ3NdXVxuXG4gICAgY29tbWFuZHMuZm9yRWFjaCgoW2tpbmQsIGFyZ3NdKSA9PiB7XG4gICAgICBpZihraW5kID09PSBkZWZhdWx0S2luZCAmJiBkZWZhdWx0QXJncy5kYXRhKXtcbiAgICAgICAgYXJncy5kYXRhID0gT2JqZWN0LmFzc2lnbihhcmdzLmRhdGEgfHwge30sIGRlZmF1bHRBcmdzLmRhdGEpXG4gICAgICB9XG4gICAgICB0aGlzLmZpbHRlclRvRWxzKHNvdXJjZUVsLCBhcmdzKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgdGhpc1tgZXhlY18ke2tpbmR9YF0oZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCBhcmdzKVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuXG4gIGlzVmlzaWJsZShlbCl7XG4gICAgcmV0dXJuICEhKGVsLm9mZnNldFdpZHRoIHx8IGVsLm9mZnNldEhlaWdodCB8fCBlbC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA+IDApXG4gIH0sXG5cbiAgLy8gcHJpdmF0ZVxuXG4gIC8vIGNvbW1hbmRzXG5cbiAgZXhlY19kaXNwYXRjaChldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHt0bywgZXZlbnQsIGRldGFpbH0pe1xuICAgIERPTS5kaXNwYXRjaEV2ZW50KGVsLCBldmVudCwgZGV0YWlsKVxuICB9LFxuXG4gIGV4ZWNfcHVzaChldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIGFyZ3Mpe1xuICAgIGxldCB7ZXZlbnQsIGRhdGEsIHRhcmdldCwgcGFnZV9sb2FkaW5nLCBsb2FkaW5nLCB2YWx1ZX0gPSBhcmdzXG4gICAgbGV0IHB1c2hPcHRzID0ge2xvYWRpbmcsIHZhbHVlLCB0YXJnZXQsIHBhZ2VfbG9hZGluZzogISFwYWdlX2xvYWRpbmd9XG4gICAgbGV0IHRhcmdldFNyYyA9IGV2ZW50VHlwZSA9PT0gXCJjaGFuZ2VcIiA/IHNvdXJjZUVsLmZvcm0gOiBzb3VyY2VFbFxuICAgIGxldCBwaHhUYXJnZXQgPSB0YXJnZXQgfHwgdGFyZ2V0U3JjLmdldEF0dHJpYnV0ZSh2aWV3LmJpbmRpbmcoXCJ0YXJnZXRcIikpIHx8IHRhcmdldFNyY1xuICAgIHZpZXcud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsICh0YXJnZXRWaWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIGlmKGV2ZW50VHlwZSA9PT0gXCJjaGFuZ2VcIil7XG4gICAgICAgIGxldCB7bmV3Q2lkLCBfdGFyZ2V0LCBjYWxsYmFja30gPSBhcmdzXG4gICAgICAgIGlmKF90YXJnZXQpeyBwdXNoT3B0cy5fdGFyZ2V0ID0gX3RhcmdldCB9XG4gICAgICAgIHRhcmdldFZpZXcucHVzaElucHV0KHNvdXJjZUVsLCB0YXJnZXRDdHgsIG5ld0NpZCwgZXZlbnQgfHwgcGh4RXZlbnQsIHB1c2hPcHRzLCBjYWxsYmFjaylcbiAgICAgIH0gZWxzZSBpZihldmVudFR5cGUgPT09IFwic3VibWl0XCIpe1xuICAgICAgICB0YXJnZXRWaWV3LnN1Ym1pdEZvcm0oc291cmNlRWwsIHRhcmdldEN0eCwgZXZlbnQgfHwgcGh4RXZlbnQsIHB1c2hPcHRzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Vmlldy5wdXNoRXZlbnQoZXZlbnRUeXBlLCBzb3VyY2VFbCwgdGFyZ2V0Q3R4LCBldmVudCB8fCBwaHhFdmVudCwgZGF0YSwgcHVzaE9wdHMpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcblxuICBleGVjX2FkZF9jbGFzcyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtuYW1lcywgdHJhbnNpdGlvbiwgdGltZX0pe1xuICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBuYW1lcywgW10sIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcpXG4gIH0sXG5cbiAgZXhlY19yZW1vdmVfY2xhc3MoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7bmFtZXMsIHRyYW5zaXRpb24sIHRpbWV9KXtcbiAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIG5hbWVzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KVxuICB9LFxuXG4gIGV4ZWNfdHJhbnNpdGlvbihldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHt0aW1lLCB0cmFuc2l0aW9ufSl7XG4gICAgbGV0IFt0cmFuc2l0aW9uX3N0YXJ0LCBydW5uaW5nLCB0cmFuc2l0aW9uX2VuZF0gPSB0cmFuc2l0aW9uXG4gICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvbl9zdGFydC5jb25jYXQocnVubmluZyksIFtdKVxuICAgIGxldCBvbkRvbmUgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvbl9lbmQsIHRyYW5zaXRpb25fc3RhcnQuY29uY2F0KHJ1bm5pbmcpKVxuICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gIH0sXG5cbiAgZXhlY190b2dnbGUoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7ZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lfSl7XG4gICAgdGhpcy50b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lKVxuICB9LFxuXG4gIGV4ZWNfc2hvdyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lfSl7XG4gICAgdGhpcy5zaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUpXG4gIH0sXG5cbiAgZXhlY19oaWRlKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2Rpc3BsYXksIHRyYW5zaXRpb24sIHRpbWV9KXtcbiAgICB0aGlzLmhpZGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSlcbiAgfSxcblxuICBleGVjX3NldF9hdHRyKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2F0dHI6IFthdHRyLCB2YWxdfSl7XG4gICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbF1dLCBbXSlcbiAgfSxcblxuICBleGVjX3JlbW92ZV9hdHRyKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2F0dHJ9KXtcbiAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtdLCBbYXR0cl0pXG4gIH0sXG5cbiAgLy8gdXRpbHMgZm9yIGNvbW1hbmRzXG5cbiAgc2hvdyhldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKXtcbiAgICBpZighdGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIG51bGwsIHRpbWUpXG4gICAgfVxuICB9LFxuXG4gIGhpZGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSl7XG4gICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIG51bGwsIHRyYW5zaXRpb24sIHRpbWUpXG4gICAgfVxuICB9LFxuXG4gIHRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWUpe1xuICAgIGxldCBbaW5DbGFzc2VzLCBpblN0YXJ0Q2xhc3NlcywgaW5FbmRDbGFzc2VzXSA9IGlucyB8fCBbW10sIFtdLCBbXV1cbiAgICBsZXQgW291dENsYXNzZXMsIG91dFN0YXJ0Q2xhc3Nlcywgb3V0RW5kQ2xhc3Nlc10gPSBvdXRzIHx8IFtbXSwgW10sIFtdXVxuICAgIGlmKGluQ2xhc3Nlcy5sZW5ndGggPiAwIHx8IG91dENsYXNzZXMubGVuZ3RoID4gMCl7XG4gICAgICBpZih0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgICBsZXQgb25TdGFydCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgb3V0U3RhcnRDbGFzc2VzLCBpbkNsYXNzZXMuY29uY2F0KGluU3RhcnRDbGFzc2VzKS5jb25jYXQoaW5FbmRDbGFzc2VzKSlcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRDbGFzc2VzLCBbXSlcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dEVuZENsYXNzZXMsIG91dFN0YXJ0Q2xhc3NlcykpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLXN0YXJ0XCIpKVxuICAgICAgICB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgb3V0Q2xhc3Nlcy5jb25jYXQob3V0RW5kQ2xhc3NlcykpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1lbmRcIikpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZihldmVudFR5cGUgPT09IFwicmVtb3ZlXCIpeyByZXR1cm4gfVxuICAgICAgICBsZXQgb25TdGFydCA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgaW5TdGFydENsYXNzZXMsIG91dENsYXNzZXMuY29uY2F0KG91dFN0YXJ0Q2xhc3NlcykuY29uY2F0KG91dEVuZENsYXNzZXMpKVxuICAgICAgICAgIERPTS5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIGN1cnJlbnRFbCA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IChkaXNwbGF5IHx8IFwiYmxvY2tcIikpXG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgaW5DbGFzc2VzLCBbXSlcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluRW5kQ2xhc3NlcywgaW5TdGFydENsYXNzZXMpKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1zdGFydFwiKSlcbiAgICAgICAgdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIGluQ2xhc3Nlcy5jb25jYXQoaW5FbmRDbGFzc2VzKSlcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpzaG93LWVuZFwiKSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1zdGFydFwiKSlcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIilcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLWVuZFwiKSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctc3RhcnRcIikpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheSB8fCBcImJsb2NrXCIpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1lbmRcIikpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgYWRkcywgcmVtb3ZlcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldyl7XG4gICAgbGV0IFt0cmFuc2l0aW9uX3J1biwgdHJhbnNpdGlvbl9zdGFydCwgdHJhbnNpdGlvbl9lbmRdID0gdHJhbnNpdGlvbiB8fCBbW10sIFtdLCBbXV1cbiAgICBpZih0cmFuc2l0aW9uX3J1bi5sZW5ndGggPiAwKXtcbiAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIHRyYW5zaXRpb25fc3RhcnQuY29uY2F0KHRyYW5zaXRpb25fcnVuKSwgW10pXG4gICAgICBsZXQgb25Eb25lID0gKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGFkZHMuY29uY2F0KHRyYW5zaXRpb25fZW5kKSwgcmVtb3Zlcy5jb25jYXQodHJhbnNpdGlvbl9ydW4pLmNvbmNhdCh0cmFuc2l0aW9uX3N0YXJ0KSlcbiAgICAgIHJldHVybiB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKVxuICAgIH1cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGxldCBbcHJldkFkZHMsIHByZXZSZW1vdmVzXSA9IERPTS5nZXRTdGlja3koZWwsIFwiY2xhc3Nlc1wiLCBbW10sIFtdXSlcbiAgICAgIGxldCBrZWVwQWRkcyA9IGFkZHMuZmlsdGVyKG5hbWUgPT4gcHJldkFkZHMuaW5kZXhPZihuYW1lKSA8IDAgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSlcbiAgICAgIGxldCBrZWVwUmVtb3ZlcyA9IHJlbW92ZXMuZmlsdGVyKG5hbWUgPT4gcHJldlJlbW92ZXMuaW5kZXhPZihuYW1lKSA8IDAgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKVxuICAgICAgbGV0IG5ld0FkZHMgPSBwcmV2QWRkcy5maWx0ZXIobmFtZSA9PiByZW1vdmVzLmluZGV4T2YobmFtZSkgPCAwKS5jb25jYXQoa2VlcEFkZHMpXG4gICAgICBsZXQgbmV3UmVtb3ZlcyA9IHByZXZSZW1vdmVzLmZpbHRlcihuYW1lID0+IGFkZHMuaW5kZXhPZihuYW1lKSA8IDApLmNvbmNhdChrZWVwUmVtb3ZlcylcblxuICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJjbGFzc2VzXCIsIGN1cnJlbnRFbCA9PiB7XG4gICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QucmVtb3ZlKC4uLm5ld1JlbW92ZXMpXG4gICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QuYWRkKC4uLm5ld0FkZHMpXG4gICAgICAgIHJldHVybiBbbmV3QWRkcywgbmV3UmVtb3Zlc11cbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcblxuICBzZXRPclJlbW92ZUF0dHJzKGVsLCBzZXRzLCByZW1vdmVzKXtcbiAgICBsZXQgW3ByZXZTZXRzLCBwcmV2UmVtb3Zlc10gPSBET00uZ2V0U3RpY2t5KGVsLCBcImF0dHJzXCIsIFtbXSwgW11dKVxuICAgIGxldCBrZWVwU2V0cyA9IHNldHMuZmlsdGVyKChbYXR0ciwgX3ZhbF0pID0+ICF0aGlzLmhhc1NldChwcmV2U2V0cywgYXR0cikgJiYgIWVsLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKGF0dHIpKVxuICAgIGxldCBrZWVwUmVtb3ZlcyA9IHJlbW92ZXMuZmlsdGVyKGF0dHIgPT4gcHJldlJlbW92ZXMuaW5kZXhPZihhdHRyKSA8IDAgJiYgZWwuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oYXR0cikpXG4gICAgbGV0IG5ld1NldHMgPSBwcmV2U2V0cy5maWx0ZXIoKFthdHRyLCBfdmFsXSkgPT4gcmVtb3Zlcy5pbmRleE9mKGF0dHIpIDwgMCkuY29uY2F0KGtlZXBTZXRzKVxuICAgIGxldCBuZXdSZW1vdmVzID0gcHJldlJlbW92ZXMuZmlsdGVyKGF0dHIgPT4gIXRoaXMuaGFzU2V0KHNldHMsIGF0dHIpKS5jb25jYXQoa2VlcFJlbW92ZXMpXG5cbiAgICBET00ucHV0U3RpY2t5KGVsLCBcImF0dHJzXCIsIGN1cnJlbnRFbCA9PiB7XG4gICAgICBuZXdSZW1vdmVzLmZvckVhY2goYXR0ciA9PiBjdXJyZW50RWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpKVxuICAgICAgbmV3U2V0cy5mb3JFYWNoKChbYXR0ciwgdmFsXSkgPT4gY3VycmVudEVsLnNldEF0dHJpYnV0ZShhdHRyLCB2YWwpKVxuICAgICAgcmV0dXJuIFtuZXdTZXRzLCBuZXdSZW1vdmVzXVxuICAgIH0pXG4gIH0sXG5cbiAgaGFzU2V0KHNldHMsIG5hbWVTZWFyY2gpeyByZXR1cm4gc2V0cy5maW5kKChbbmFtZSwgdmFsXSkgPT4gbmFtZSA9PT0gbmFtZVNlYXJjaCkgfSxcblxuICBoYXNBbGxDbGFzc2VzKGVsLCBjbGFzc2VzKXsgcmV0dXJuIGNsYXNzZXMuZXZlcnkobmFtZSA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpIH0sXG5cbiAgaXNUb2dnbGVkT3V0KGVsLCBvdXRDbGFzc2VzKXtcbiAgICByZXR1cm4gIXRoaXMuaXNWaXNpYmxlKGVsKSB8fCB0aGlzLmhhc0FsbENsYXNzZXMoZWwsIG91dENsYXNzZXMpXG4gIH0sXG5cbiAgZmlsdGVyVG9FbHMoc291cmNlRWwsIHt0b30pe1xuICAgIHJldHVybiB0byA/IERPTS5hbGwoZG9jdW1lbnQsIHRvKSA6IFtzb3VyY2VFbF1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBKU1xuIiwgImltcG9ydCB7XG4gIEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQsXG4gIENIRUNLQUJMRV9JTlBVVFMsXG4gIENPTlNFQ1VUSVZFX1JFTE9BRFMsXG4gIFBIWF9BVVRPX1JFQ09WRVIsXG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9DT05ORUNURURfQ0xBU1MsXG4gIFBIWF9ESVNBQkxFX1dJVEgsXG4gIFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSxcbiAgUEhYX0RJU0FCTEVELFxuICBQSFhfRElTQ09OTkVDVEVEX0NMQVNTLFxuICBQSFhfRVZFTlRfQ0xBU1NFUyxcbiAgUEhYX0VSUk9SX0NMQVNTLFxuICBQSFhfRkVFREJBQ0tfRk9SLFxuICBQSFhfSEFTX1NVQk1JVFRFRCxcbiAgUEhYX0hPT0ssXG4gIFBIWF9QQUdFX0xPQURJTkcsXG4gIFBIWF9QQVJFTlRfSUQsXG4gIFBIWF9QUk9HUkVTUyxcbiAgUEhYX1JFQURPTkxZLFxuICBQSFhfUkVGLFxuICBQSFhfUkVGX1NSQyxcbiAgUEhYX1JPT1RfSUQsXG4gIFBIWF9TRVNTSU9OLFxuICBQSFhfU1RBVElDLFxuICBQSFhfVFJBQ0tfU1RBVElDLFxuICBQSFhfVFJBQ0tfVVBMT0FEUyxcbiAgUEhYX1VQREFURSxcbiAgUEhYX1VQTE9BRF9SRUYsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQVVNIX1RJTUVPVVQsXG4gIFBIWF9NQUlOLFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9uZSxcbiAgY2xvc2VzdFBoeEJpbmRpbmcsXG4gIGlzRW1wdHksXG4gIGlzRXF1YWxPYmosXG4gIGxvZ0Vycm9yLFxuICBtYXliZSxcbiAgaXNDaWQsXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEJyb3dzZXIgZnJvbSBcIi4vYnJvd3NlclwiXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgRE9NUGF0Y2ggZnJvbSBcIi4vZG9tX3BhdGNoXCJcbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5pbXBvcnQgUmVuZGVyZWQgZnJvbSBcIi4vcmVuZGVyZWRcIlxuaW1wb3J0IFZpZXdIb29rIGZyb20gXCIuL3ZpZXdfaG9va1wiXG5pbXBvcnQgSlMgZnJvbSBcIi4vanNcIlxuXG5sZXQgc2VyaWFsaXplRm9ybSA9IChmb3JtLCBtZXRhID0ge30pID0+IHtcbiAgbGV0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pXG4gIGxldCB0b1JlbW92ZSA9IFtdXG5cbiAgZm9ybURhdGEuZm9yRWFjaCgodmFsLCBrZXksIF9pbmRleCkgPT4ge1xuICAgIGlmKHZhbCBpbnN0YW5jZW9mIEZpbGUpeyB0b1JlbW92ZS5wdXNoKGtleSkgfVxuICB9KVxuXG4gIC8vIENsZWFudXAgYWZ0ZXIgYnVpbGRpbmcgZmlsZURhdGFcbiAgdG9SZW1vdmUuZm9yRWFjaChrZXkgPT4gZm9ybURhdGEuZGVsZXRlKGtleSkpXG5cbiAgbGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuICBmb3IobGV0IFtrZXksIHZhbF0gb2YgZm9ybURhdGEuZW50cmllcygpKXsgcGFyYW1zLmFwcGVuZChrZXksIHZhbCkgfVxuICBmb3IobGV0IG1ldGFLZXkgaW4gbWV0YSl7IHBhcmFtcy5hcHBlbmQobWV0YUtleSwgbWV0YVttZXRhS2V5XSkgfVxuXG4gIHJldHVybiBwYXJhbXMudG9TdHJpbmcoKVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3IHtcbiAgY29uc3RydWN0b3IoZWwsIGxpdmVTb2NrZXQsIHBhcmVudFZpZXcsIGZsYXNoKXtcbiAgICB0aGlzLmxpdmVTb2NrZXQgPSBsaXZlU29ja2V0XG4gICAgdGhpcy5mbGFzaCA9IGZsYXNoXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRWaWV3XG4gICAgdGhpcy5yb290ID0gcGFyZW50VmlldyA/IHBhcmVudFZpZXcucm9vdCA6IHRoaXNcbiAgICB0aGlzLmVsID0gZWxcbiAgICB0aGlzLmlkID0gdGhpcy5lbC5pZFxuICAgIHRoaXMucmVmID0gMFxuICAgIHRoaXMuY2hpbGRKb2lucyA9IDBcbiAgICB0aGlzLmxvYWRlclRpbWVyID0gbnVsbFxuICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgICB0aGlzLnBydW5pbmdDSURzID0gW11cbiAgICB0aGlzLnJlZGlyZWN0ID0gZmFsc2VcbiAgICB0aGlzLmhyZWYgPSBudWxsXG4gICAgdGhpcy5qb2luQ291bnQgPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmpvaW5Db3VudCAtIDEgOiAwXG4gICAgdGhpcy5qb2luUGVuZGluZyA9IHRydWVcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG4gICAgdGhpcy5qb2luQ2FsbGJhY2sgPSBmdW5jdGlvbihvbkRvbmUpeyBvbkRvbmUgJiYgb25Eb25lKCkgfVxuICAgIHRoaXMuc3RvcENhbGxiYWNrID0gZnVuY3Rpb24oKXsgfVxuICAgIHRoaXMucGVuZGluZ0pvaW5PcHMgPSB0aGlzLnBhcmVudCA/IG51bGwgOiBbXVxuICAgIHRoaXMudmlld0hvb2tzID0ge31cbiAgICB0aGlzLnVwbG9hZGVycyA9IHt9XG4gICAgdGhpcy5mb3JtU3VibWl0cyA9IFtdXG4gICAgdGhpcy5jaGlsZHJlbiA9IHRoaXMucGFyZW50ID8gbnVsbCA6IHt9XG4gICAgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdID0ge31cbiAgICB0aGlzLmNoYW5uZWwgPSB0aGlzLmxpdmVTb2NrZXQuY2hhbm5lbChgbHY6JHt0aGlzLmlkfWAsICgpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZGlyZWN0OiB0aGlzLnJlZGlyZWN0ID8gdGhpcy5ocmVmIDogdW5kZWZpbmVkLFxuICAgICAgICB1cmw6IHRoaXMucmVkaXJlY3QgPyB1bmRlZmluZWQgOiB0aGlzLmhyZWYgfHwgdW5kZWZpbmVkLFxuICAgICAgICBwYXJhbXM6IHRoaXMuY29ubmVjdFBhcmFtcygpLFxuICAgICAgICBzZXNzaW9uOiB0aGlzLmdldFNlc3Npb24oKSxcbiAgICAgICAgc3RhdGljOiB0aGlzLmdldFN0YXRpYygpLFxuICAgICAgICBmbGFzaDogdGhpcy5mbGFzaFxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5zaG93TG9hZGVyKHRoaXMubGl2ZVNvY2tldC5sb2FkZXJUaW1lb3V0KVxuICAgIHRoaXMuYmluZENoYW5uZWwoKVxuICB9XG5cbiAgc2V0SHJlZihocmVmKXsgdGhpcy5ocmVmID0gaHJlZiB9XG5cbiAgc2V0UmVkaXJlY3QoaHJlZil7XG4gICAgdGhpcy5yZWRpcmVjdCA9IHRydWVcbiAgICB0aGlzLmhyZWYgPSBocmVmXG4gIH1cblxuICBpc01haW4oKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9NQUlOKSAhPT0gbnVsbCB9XG5cbiAgY29ubmVjdFBhcmFtcygpe1xuICAgIGxldCBwYXJhbXMgPSB0aGlzLmxpdmVTb2NrZXQucGFyYW1zKHRoaXMuZWwpXG4gICAgbGV0IG1hbmlmZXN0ID1cbiAgICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHt0aGlzLmJpbmRpbmcoUEhYX1RSQUNLX1NUQVRJQyl9XWApXG4gICAgICAgIC5tYXAobm9kZSA9PiBub2RlLnNyYyB8fCBub2RlLmhyZWYpLmZpbHRlcih1cmwgPT4gdHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKVxuXG4gICAgaWYobWFuaWZlc3QubGVuZ3RoID4gMCl7IHBhcmFtc1tcIl90cmFja19zdGF0aWNcIl0gPSBtYW5pZmVzdCB9XG4gICAgcGFyYW1zW1wiX21vdW50c1wiXSA9IHRoaXMuam9pbkNvdW50XG5cbiAgICByZXR1cm4gcGFyYW1zXG4gIH1cblxuICBpc0Nvbm5lY3RlZCgpeyByZXR1cm4gdGhpcy5jaGFubmVsLmNhblB1c2goKSB9XG5cbiAgZ2V0U2Vzc2lvbigpeyByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pIH1cblxuICBnZXRTdGF0aWMoKXtcbiAgICBsZXQgdmFsID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQylcbiAgICByZXR1cm4gdmFsID09PSBcIlwiID8gbnVsbCA6IHZhbFxuICB9XG5cbiAgZGVzdHJveShjYWxsYmFjayA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICB0aGlzLmRlc3Ryb3lBbGxDaGlsZHJlbigpXG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gICAgZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXVxuICAgIGlmKHRoaXMucGFyZW50KXsgZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLnBhcmVudC5pZF1bdGhpcy5pZF0gfVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKVxuICAgIGxldCBvbkZpbmlzaGVkID0gKCkgPT4ge1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgZm9yKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcyl7XG4gICAgICAgIHRoaXMuZGVzdHJveUhvb2sodGhpcy52aWV3SG9va3NbaWRdKVxuICAgICAgfVxuICAgIH1cblxuICAgIERPTS5tYXJrUGh4Q2hpbGREZXN0cm95ZWQodGhpcy5lbClcblxuICAgIHRoaXMubG9nKFwiZGVzdHJveWVkXCIsICgpID0+IFtcInRoZSBjaGlsZCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhcmVudFwiXSlcbiAgICB0aGlzLmNoYW5uZWwubGVhdmUoKVxuICAgICAgLnJlY2VpdmUoXCJva1wiLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlY2VpdmUoXCJlcnJvclwiLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlY2VpdmUoXCJ0aW1lb3V0XCIsIG9uRmluaXNoZWQpXG4gIH1cblxuICBzZXRDb250YWluZXJDbGFzc2VzKC4uLmNsYXNzZXMpe1xuICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgIFBIWF9DT05ORUNURURfQ0xBU1MsXG4gICAgICBQSFhfRElTQ09OTkVDVEVEX0NMQVNTLFxuICAgICAgUEhYX0VSUk9SX0NMQVNTXG4gICAgKVxuICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzKVxuICB9XG5cbiAgc2hvd0xvYWRlcih0aW1lb3V0KXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICBpZih0aW1lb3V0KXtcbiAgICAgIHRoaXMubG9hZGVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2hvd0xvYWRlcigpLCB0aW1lb3V0KVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IobGV0IGlkIGluIHRoaXMudmlld0hvb2tzKXsgdGhpcy52aWV3SG9va3NbaWRdLl9fZGlzY29ubmVjdGVkKCkgfVxuICAgICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9ESVNDT05ORUNURURfQ0xBU1MpXG4gICAgfVxuICB9XG5cbiAgaGlkZUxvYWRlcigpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKVxuICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhQSFhfQ09OTkVDVEVEX0NMQVNTKVxuICB9XG5cbiAgdHJpZ2dlclJlY29ubmVjdGVkKCl7XG4gICAgZm9yKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcyl7IHRoaXMudmlld0hvb2tzW2lkXS5fX3JlY29ubmVjdGVkKCkgfVxuICB9XG5cbiAgbG9nKGtpbmQsIG1zZ0NhbGxiYWNrKXtcbiAgICB0aGlzLmxpdmVTb2NrZXQubG9nKHRoaXMsIGtpbmQsIG1zZ0NhbGxiYWNrKVxuICB9XG5cbiAgdHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUgPSBmdW5jdGlvbigpe30pe1xuICAgIHRoaXMubGl2ZVNvY2tldC50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgfVxuXG4gIHdpdGhpblRhcmdldHMocGh4VGFyZ2V0LCBjYWxsYmFjayl7XG4gICAgaWYocGh4VGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgcGh4VGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCl7XG4gICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0Lm93bmVyKHBoeFRhcmdldCwgdmlldyA9PiBjYWxsYmFjayh2aWV3LCBwaHhUYXJnZXQpKVxuICAgIH1cblxuICAgIGlmKGlzQ2lkKHBoeFRhcmdldCkpe1xuICAgICAgbGV0IHRhcmdldHMgPSBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuZWwsIHBoeFRhcmdldClcbiAgICAgIGlmKHRhcmdldHMubGVuZ3RoID09PSAwKXtcbiAgICAgICAgbG9nRXJyb3IoYG5vIGNvbXBvbmVudCBmb3VuZCBtYXRjaGluZyBwaHgtdGFyZ2V0IG9mICR7cGh4VGFyZ2V0fWApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayh0aGlzLCBwYXJzZUludChwaHhUYXJnZXQpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdGFyZ2V0cyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChwaHhUYXJnZXQpKVxuICAgICAgaWYodGFyZ2V0cy5sZW5ndGggPT09IDApeyBsb2dFcnJvcihgbm90aGluZyBmb3VuZCBtYXRjaGluZyB0aGUgcGh4LXRhcmdldCBzZWxlY3RvciBcIiR7cGh4VGFyZ2V0fVwiYCkgfVxuICAgICAgdGFyZ2V0cy5mb3JFYWNoKHRhcmdldCA9PiB0aGlzLmxpdmVTb2NrZXQub3duZXIodGFyZ2V0LCB2aWV3ID0+IGNhbGxiYWNrKHZpZXcsIHRhcmdldCkpKVxuICAgIH1cbiAgfVxuXG4gIGFwcGx5RGlmZih0eXBlLCByYXdEaWZmLCBjYWxsYmFjayl7XG4gICAgdGhpcy5sb2codHlwZSwgKCkgPT4gW1wiXCIsIGNsb25lKHJhd0RpZmYpXSlcbiAgICBsZXQge2RpZmYsIHJlcGx5LCBldmVudHMsIHRpdGxlfSA9IFJlbmRlcmVkLmV4dHJhY3QocmF3RGlmZilcbiAgICBpZih0aXRsZSl7IERPTS5wdXRUaXRsZSh0aXRsZSkgfVxuXG4gICAgY2FsbGJhY2soe2RpZmYsIHJlcGx5LCBldmVudHN9KVxuICAgIHJldHVybiByZXBseVxuICB9XG5cbiAgb25Kb2luKHJlc3Ape1xuICAgIGxldCB7cmVuZGVyZWQsIGNvbnRhaW5lcn0gPSByZXNwXG4gICAgaWYoY29udGFpbmVyKXtcbiAgICAgIGxldCBbdGFnLCBhdHRyc10gPSBjb250YWluZXJcbiAgICAgIHRoaXMuZWwgPSBET00ucmVwbGFjZVJvb3RDb250YWluZXIodGhpcy5lbCwgdGFnLCBhdHRycylcbiAgICB9XG4gICAgdGhpcy5jaGlsZEpvaW5zID0gMFxuICAgIHRoaXMuam9pblBlbmRpbmcgPSB0cnVlXG4gICAgdGhpcy5mbGFzaCA9IG51bGxcblxuICAgIEJyb3dzZXIuZHJvcExvY2FsKHRoaXMubGl2ZVNvY2tldC5sb2NhbFN0b3JhZ2UsIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSwgQ09OU0VDVVRJVkVfUkVMT0FEUylcbiAgICB0aGlzLmFwcGx5RGlmZihcIm1vdW50XCIsIHJlbmRlcmVkLCAoe2RpZmYsIGV2ZW50c30pID0+IHtcbiAgICAgIHRoaXMucmVuZGVyZWQgPSBuZXcgUmVuZGVyZWQodGhpcy5pZCwgZGlmZilcbiAgICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJDb250YWluZXIobnVsbCwgXCJqb2luXCIpXG4gICAgICB0aGlzLmRyb3BQZW5kaW5nUmVmcygpXG4gICAgICBsZXQgZm9ybXMgPSB0aGlzLmZvcm1zRm9yUmVjb3ZlcnkoaHRtbClcbiAgICAgIHRoaXMuam9pbkNvdW50KytcblxuICAgICAgaWYoZm9ybXMubGVuZ3RoID4gMCl7XG4gICAgICAgIGZvcm1zLmZvckVhY2goKFtmb3JtLCBuZXdGb3JtLCBuZXdDaWRdLCBpKSA9PiB7XG4gICAgICAgICAgdGhpcy5wdXNoRm9ybVJlY292ZXJ5KGZvcm0sIG5ld0NpZCwgcmVzcCA9PiB7XG4gICAgICAgICAgICBpZihpID09PSBmb3Jtcy5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgICAgdGhpcy5vbkpvaW5Db21wbGV0ZShyZXNwLCBodG1sLCBldmVudHMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25Kb2luQ29tcGxldGUocmVzcCwgaHRtbCwgZXZlbnRzKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBkcm9wUGVuZGluZ1JlZnMoKXtcbiAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7UEhYX1JFRl9TUkN9PVwiJHt0aGlzLmlkfVwiXVske1BIWF9SRUZ9XWAsIGVsID0+IHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGKVxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUZfU1JDKVxuICAgIH0pXG4gIH1cblxuICBvbkpvaW5Db21wbGV0ZSh7bGl2ZV9wYXRjaH0sIGh0bWwsIGV2ZW50cyl7XG4gICAgLy8gSW4gb3JkZXIgdG8gcHJvdmlkZSBhIGJldHRlciBleHBlcmllbmNlLCB3ZSB3YW50IHRvIGpvaW5cbiAgICAvLyBhbGwgTGl2ZVZpZXdzIGZpcnN0IGFuZCBvbmx5IHRoZW4gYXBwbHkgdGhlaXIgcGF0Y2hlcy5cbiAgICBpZih0aGlzLmpvaW5Db3VudCA+IDEgfHwgKHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5pc0pvaW5QZW5kaW5nKCkpKXtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cylcbiAgICB9XG5cbiAgICAvLyBPbmUgZG93bnNpZGUgb2YgdGhpcyBhcHByb2FjaCBpcyB0aGF0IHdlIG5lZWQgdG8gZmluZCBwaHhDaGlsZHJlblxuICAgIC8vIGluIHRoZSBodG1sIGZyYWdtZW50LCBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBET00uIFRoZSBmcmFnbWVudFxuICAgIC8vIGFsc28gZG9lcyBub3QgaW5jbHVkZSBQSFhfU1RBVElDLCBzbyB3ZSBuZWVkIHRvIGNvcHkgaXQgb3ZlciBmcm9tXG4gICAgLy8gdGhlIERPTS5cbiAgICBsZXQgbmV3Q2hpbGRyZW4gPSBET00uZmluZFBoeENoaWxkcmVuSW5GcmFnbWVudChodG1sLCB0aGlzLmlkKS5maWx0ZXIodG9FbCA9PiB7XG4gICAgICBsZXQgZnJvbUVsID0gdG9FbC5pZCAmJiB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoYFtpZD1cIiR7dG9FbC5pZH1cIl1gKVxuICAgICAgbGV0IHBoeFN0YXRpYyA9IGZyb21FbCAmJiBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9TVEFUSUMpXG4gICAgICBpZihwaHhTdGF0aWMpeyB0b0VsLnNldEF0dHJpYnV0ZShQSFhfU1RBVElDLCBwaHhTdGF0aWMpIH1cbiAgICAgIHJldHVybiB0aGlzLmpvaW5DaGlsZCh0b0VsKVxuICAgIH0pXG5cbiAgICBpZihuZXdDaGlsZHJlbi5sZW5ndGggPT09IDApe1xuICAgICAgaWYodGhpcy5wYXJlbnQpe1xuICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXSlcbiAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpXG4gICAgICAgIHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXSlcbiAgICB9XG4gIH1cblxuICBhdHRhY2hUcnVlRG9jRWwoKXtcbiAgICB0aGlzLmVsID0gRE9NLmJ5SWQodGhpcy5pZClcbiAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCwgdGhpcy5yb290LmlkKVxuICB9XG5cbiAgYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKXtcbiAgICB0aGlzLmF0dGFjaFRydWVEb2NFbCgpXG4gICAgbGV0IHBhdGNoID0gbmV3IERPTVBhdGNoKHRoaXMsIHRoaXMuZWwsIHRoaXMuaWQsIGh0bWwsIG51bGwpXG4gICAgcGF0Y2gubWFya1BydW5hYmxlQ29udGVudEZvclJlbW92YWwoKVxuICAgIHRoaXMucGVyZm9ybVBhdGNoKHBhdGNoLCBmYWxzZSlcbiAgICB0aGlzLmpvaW5OZXdDaGlsZHJlbigpXG4gICAgRE9NLmFsbCh0aGlzLmVsLCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9IT09LKX1dLCBbZGF0YS1waHgtJHtQSFhfSE9PS31dYCwgaG9va0VsID0+IHtcbiAgICAgIGxldCBob29rID0gdGhpcy5hZGRIb29rKGhvb2tFbClcbiAgICAgIGlmKGhvb2speyBob29rLl9fbW91bnRlZCgpIH1cbiAgICB9KVxuXG4gICAgdGhpcy5qb2luUGVuZGluZyA9IGZhbHNlXG4gICAgdGhpcy5saXZlU29ja2V0LmRpc3BhdGNoRXZlbnRzKGV2ZW50cylcbiAgICB0aGlzLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKVxuXG4gICAgaWYobGl2ZV9wYXRjaCl7XG4gICAgICBsZXQge2tpbmQsIHRvfSA9IGxpdmVfcGF0Y2hcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UGF0Y2godG8sIGtpbmQpXG4gICAgfVxuICAgIHRoaXMuaGlkZUxvYWRlcigpXG4gICAgaWYodGhpcy5qb2luQ291bnQgPiAxKXsgdGhpcy50cmlnZ2VyUmVjb25uZWN0ZWQoKSB9XG4gICAgdGhpcy5zdG9wQ2FsbGJhY2soKVxuICB9XG5cbiAgdHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZnJvbUVsLCB0b0VsKXtcbiAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uQmVmb3JlRWxVcGRhdGVkXCIsIFtmcm9tRWwsIHRvRWxdKVxuICAgIGxldCBob29rID0gdGhpcy5nZXRIb29rKGZyb21FbClcbiAgICBsZXQgaXNJZ25vcmVkID0gaG9vayAmJiBET00uaXNJZ25vcmVkKGZyb21FbCwgdGhpcy5iaW5kaW5nKFBIWF9VUERBVEUpKVxuICAgIGlmKGhvb2sgJiYgIWZyb21FbC5pc0VxdWFsTm9kZSh0b0VsKSAmJiAhKGlzSWdub3JlZCAmJiBpc0VxdWFsT2JqKGZyb21FbC5kYXRhc2V0LCB0b0VsLmRhdGFzZXQpKSl7XG4gICAgICBob29rLl9fYmVmb3JlVXBkYXRlKClcbiAgICAgIHJldHVybiBob29rXG4gICAgfVxuICB9XG5cbiAgcGVyZm9ybVBhdGNoKHBhdGNoLCBwcnVuZUNpZHMpe1xuICAgIGxldCByZW1vdmVkRWxzID0gW11cbiAgICBsZXQgcGh4Q2hpbGRyZW5BZGRlZCA9IGZhbHNlXG4gICAgbGV0IHVwZGF0ZWRIb29rSWRzID0gbmV3IFNldCgpXG5cbiAgICBwYXRjaC5hZnRlcihcImFkZGVkXCIsIGVsID0+IHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50cmlnZ2VyRE9NKFwib25Ob2RlQWRkZWRcIiwgW2VsXSlcblxuICAgICAgbGV0IG5ld0hvb2sgPSB0aGlzLmFkZEhvb2soZWwpXG4gICAgICBpZihuZXdIb29rKXsgbmV3SG9vay5fX21vdW50ZWQoKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwicGh4Q2hpbGRBZGRlZFwiLCBlbCA9PiB7XG4gICAgICBpZihET00uaXNQaHhTdGlja3koZWwpKXtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LmpvaW5Sb290Vmlld3MoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcGF0Y2guYmVmb3JlKFwidXBkYXRlZFwiLCAoZnJvbUVsLCB0b0VsKSA9PiB7XG4gICAgICBsZXQgaG9vayA9IHRoaXMudHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZnJvbUVsLCB0b0VsKVxuICAgICAgaWYoaG9vayl7IHVwZGF0ZWRIb29rSWRzLmFkZChmcm9tRWwuaWQpIH1cbiAgICB9KVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJ1cGRhdGVkXCIsIGVsID0+IHtcbiAgICAgIGlmKHVwZGF0ZWRIb29rSWRzLmhhcyhlbC5pZCkpeyB0aGlzLmdldEhvb2soZWwpLl9fdXBkYXRlZCgpIH1cbiAgICB9KVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJkaXNjYXJkZWRcIiwgKGVsKSA9PiB7XG4gICAgICBpZihlbC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpeyByZW1vdmVkRWxzLnB1c2goZWwpIH1cbiAgICB9KVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJ0cmFuc2l0aW9uc0Rpc2NhcmRlZFwiLCBlbHMgPT4gdGhpcy5hZnRlckVsZW1lbnRzUmVtb3ZlZChlbHMsIHBydW5lQ2lkcykpXG4gICAgcGF0Y2gucGVyZm9ybSgpXG4gICAgdGhpcy5hZnRlckVsZW1lbnRzUmVtb3ZlZChyZW1vdmVkRWxzLCBwcnVuZUNpZHMpXG5cbiAgICByZXR1cm4gcGh4Q2hpbGRyZW5BZGRlZFxuICB9XG5cbiAgYWZ0ZXJFbGVtZW50c1JlbW92ZWQoZWxlbWVudHMsIHBydW5lQ2lkcyl7XG4gICAgbGV0IGRlc3Ryb3llZENJRHMgPSBbXVxuICAgIGVsZW1lbnRzLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgIGxldCBjb21wb25lbnRzID0gRE9NLmFsbChwYXJlbnQsIGBbJHtQSFhfQ09NUE9ORU5UfV1gKVxuICAgICAgICBjb21wb25lbnRzLmNvbmNhdChwYXJlbnQpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBsZXQgY2lkID0gdGhpcy5jb21wb25lbnRJRChlbClcbiAgICAgICAgaWYoaXNDaWQoY2lkKSAmJiBkZXN0cm95ZWRDSURzLmluZGV4T2YoY2lkKSA9PT0gLTEpeyBkZXN0cm95ZWRDSURzLnB1c2goY2lkKSB9XG4gICAgICAgIGxldCBob29rID0gdGhpcy5nZXRIb29rKGVsKVxuICAgICAgICBob29rICYmIHRoaXMuZGVzdHJveUhvb2soaG9vaylcbiAgICAgIH0pXG4gICAgfSlcbiAgICAvLyBXZSBzaG91bGQgbm90IHBydW5lQ2lkcyBvbiBqb2lucy4gT3RoZXJ3aXNlLCBpbiBjYXNlIG9mXG4gICAgLy8gcmVqb2lucywgd2UgbWF5IG5vdGlmeSBjaWRzIHRoYXQgbm8gbG9uZ2VyIGJlbG9uZyB0byB0aGVcbiAgICAvLyBjdXJyZW50IExpdmVWaWV3IHRvIGJlIHJlbW92ZWQuXG4gICAgaWYocHJ1bmVDaWRzKXtcbiAgICAgIHRoaXMubWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChkZXN0cm95ZWRDSURzKVxuICAgIH1cbiAgfVxuXG4gIGpvaW5OZXdDaGlsZHJlbigpe1xuICAgIERPTS5maW5kUGh4Q2hpbGRyZW4odGhpcy5lbCwgdGhpcy5pZCkuZm9yRWFjaChlbCA9PiB0aGlzLmpvaW5DaGlsZChlbCkpXG4gIH1cblxuICBnZXRDaGlsZEJ5SWQoaWQpeyByZXR1cm4gdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdW2lkXSB9XG5cbiAgZ2V0RGVzY2VuZGVudEJ5RWwoZWwpe1xuICAgIGlmKGVsLmlkID09PSB0aGlzLmlkKXtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2VsLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKV1bZWwuaWRdXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveURlc2NlbmRlbnQoaWQpe1xuICAgIGZvcihsZXQgcGFyZW50SWQgaW4gdGhpcy5yb290LmNoaWxkcmVuKXtcbiAgICAgIGZvcihsZXQgY2hpbGRJZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW5bcGFyZW50SWRdKXtcbiAgICAgICAgaWYoY2hpbGRJZCA9PT0gaWQpeyByZXR1cm4gdGhpcy5yb290LmNoaWxkcmVuW3BhcmVudElkXVtjaGlsZElkXS5kZXN0cm95KCkgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGpvaW5DaGlsZChlbCl7XG4gICAgbGV0IGNoaWxkID0gdGhpcy5nZXRDaGlsZEJ5SWQoZWwuaWQpXG4gICAgaWYoIWNoaWxkKXtcbiAgICAgIGxldCB2aWV3ID0gbmV3IFZpZXcoZWwsIHRoaXMubGl2ZVNvY2tldCwgdGhpcylcbiAgICAgIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXVt2aWV3LmlkXSA9IHZpZXdcbiAgICAgIHZpZXcuam9pbigpXG4gICAgICB0aGlzLmNoaWxkSm9pbnMrK1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBpc0pvaW5QZW5kaW5nKCl7IHJldHVybiB0aGlzLmpvaW5QZW5kaW5nIH1cblxuICBhY2tKb2luKF9jaGlsZCl7XG4gICAgdGhpcy5jaGlsZEpvaW5zLS1cblxuICAgIGlmKHRoaXMuY2hpbGRKb2lucyA9PT0gMCl7XG4gICAgICBpZih0aGlzLnBhcmVudCl7XG4gICAgICAgIHRoaXMucGFyZW50LmFja0pvaW4odGhpcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKCl7XG4gICAgdGhpcy5qb2luQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcy5mb3JFYWNoKChbdmlldywgb3BdKSA9PiB7XG4gICAgICAgIGlmKCF2aWV3LmlzRGVzdHJveWVkKCkpeyBvcCgpIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLnBlbmRpbmdKb2luT3BzID0gW11cbiAgICB9KVxuICB9XG5cbiAgdXBkYXRlKGRpZmYsIGV2ZW50cyl7XG4gICAgaWYodGhpcy5pc0pvaW5QZW5kaW5nKCkgfHwgdGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkpe1xuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goe2RpZmYsIGV2ZW50c30pXG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlZC5tZXJnZURpZmYoZGlmZilcbiAgICBsZXQgcGh4Q2hpbGRyZW5BZGRlZCA9IGZhbHNlXG5cbiAgICAvLyBXaGVuIHRoZSBkaWZmIG9ubHkgY29udGFpbnMgY29tcG9uZW50IGRpZmZzLCB0aGVuIHdhbGsgY29tcG9uZW50c1xuICAgIC8vIGFuZCBwYXRjaCBvbmx5IHRoZSBwYXJlbnQgY29tcG9uZW50IGNvbnRhaW5lcnMgZm91bmQgaW4gdGhlIGRpZmYuXG4gICAgLy8gT3RoZXJ3aXNlLCBwYXRjaCBlbnRpcmUgTFYgY29udGFpbmVyLlxuICAgIGlmKHRoaXMucmVuZGVyZWQuaXNDb21wb25lbnRPbmx5RGlmZihkaWZmKSl7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudGltZShcImNvbXBvbmVudCBwYXRjaCBjb21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgIGxldCBwYXJlbnRDaWRzID0gRE9NLmZpbmRQYXJlbnRDSURzKHRoaXMuZWwsIHRoaXMucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhkaWZmKSlcbiAgICAgICAgcGFyZW50Q2lkcy5mb3JFYWNoKHBhcmVudENJRCA9PiB7XG4gICAgICAgICAgaWYodGhpcy5jb21wb25lbnRQYXRjaCh0aGlzLnJlbmRlcmVkLmdldENvbXBvbmVudChkaWZmLCBwYXJlbnRDSUQpLCBwYXJlbnRDSUQpKXsgcGh4Q2hpbGRyZW5BZGRlZCA9IHRydWUgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYoIWlzRW1wdHkoZGlmZikpe1xuICAgICAgdGhpcy5saXZlU29ja2V0LnRpbWUoXCJmdWxsIHBhdGNoIGNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgbGV0IGh0bWwgPSB0aGlzLnJlbmRlckNvbnRhaW5lcihkaWZmLCBcInVwZGF0ZVwiKVxuICAgICAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgbnVsbClcbiAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRoaXMucGVyZm9ybVBhdGNoKHBhdGNoLCB0cnVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmxpdmVTb2NrZXQuZGlzcGF0Y2hFdmVudHMoZXZlbnRzKVxuICAgIGlmKHBoeENoaWxkcmVuQWRkZWQpeyB0aGlzLmpvaW5OZXdDaGlsZHJlbigpIH1cbiAgfVxuXG4gIHJlbmRlckNvbnRhaW5lcihkaWZmLCBraW5kKXtcbiAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnRpbWUoYHRvU3RyaW5nIGRpZmYgKCR7a2luZH0pYCwgKCkgPT4ge1xuICAgICAgbGV0IHRhZyA9IHRoaXMuZWwudGFnTmFtZVxuICAgICAgLy8gRG9uJ3Qgc2tpcCBhbnkgY29tcG9uZW50IGluIHRoZSBkaWZmIG5vciBhbnkgbWFya2VkIGFzIHBydW5lZFxuICAgICAgLy8gKGFzIHRoZXkgbWF5IGhhdmUgYmVlbiBhZGRlZCBiYWNrKVxuICAgICAgbGV0IGNpZHMgPSBkaWZmID8gdGhpcy5yZW5kZXJlZC5jb21wb25lbnRDSURzKGRpZmYpLmNvbmNhdCh0aGlzLnBydW5pbmdDSURzKSA6IG51bGxcbiAgICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJlZC50b1N0cmluZyhjaWRzKVxuICAgICAgcmV0dXJuIGA8JHt0YWd9PiR7aHRtbH08LyR7dGFnfT5gXG4gICAgfSlcbiAgfVxuXG4gIGNvbXBvbmVudFBhdGNoKGRpZmYsIGNpZCl7XG4gICAgaWYoaXNFbXB0eShkaWZmKSkgcmV0dXJuIGZhbHNlXG4gICAgbGV0IGh0bWwgPSB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudFRvU3RyaW5nKGNpZClcbiAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgY2lkKVxuICAgIGxldCBjaGlsZHJlbkFkZGVkID0gdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIHRydWUpXG4gICAgcmV0dXJuIGNoaWxkcmVuQWRkZWRcbiAgfVxuXG4gIGdldEhvb2soZWwpeyByZXR1cm4gdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGVsKV0gfVxuXG4gIGFkZEhvb2soZWwpe1xuICAgIGlmKFZpZXdIb29rLmVsZW1lbnRJRChlbCkgfHwgIWVsLmdldEF0dHJpYnV0ZSl7IHJldHVybiB9XG4gICAgbGV0IGhvb2tOYW1lID0gZWwuZ2V0QXR0cmlidXRlKGBkYXRhLXBoeC0ke1BIWF9IT09LfWApIHx8IGVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0hPT0spKVxuICAgIGlmKGhvb2tOYW1lICYmICF0aGlzLm93bnNFbGVtZW50KGVsKSl7IHJldHVybiB9XG4gICAgbGV0IGNhbGxiYWNrcyA9IHRoaXMubGl2ZVNvY2tldC5nZXRIb29rQ2FsbGJhY2tzKGhvb2tOYW1lKVxuXG4gICAgaWYoY2FsbGJhY2tzKXtcbiAgICAgIGlmKCFlbC5pZCl7IGxvZ0Vycm9yKGBubyBET00gSUQgZm9yIGhvb2sgXCIke2hvb2tOYW1lfVwiLiBIb29rcyByZXF1aXJlIGEgdW5pcXVlIElEIG9uIGVhY2ggZWxlbWVudC5gLCBlbCkgfVxuICAgICAgbGV0IGhvb2sgPSBuZXcgVmlld0hvb2sodGhpcywgZWwsIGNhbGxiYWNrcylcbiAgICAgIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChob29rLmVsKV0gPSBob29rXG4gICAgICByZXR1cm4gaG9va1xuICAgIH0gZWxzZSBpZihob29rTmFtZSAhPT0gbnVsbCl7XG4gICAgICBsb2dFcnJvcihgdW5rbm93biBob29rIGZvdW5kIGZvciBcIiR7aG9va05hbWV9XCJgLCBlbClcbiAgICB9XG4gIH1cblxuICBkZXN0cm95SG9vayhob29rKXtcbiAgICBob29rLl9fZGVzdHJveWVkKClcbiAgICBob29rLl9fY2xlYW51cF9fKClcbiAgICBkZWxldGUgdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGhvb2suZWwpXVxuICB9XG5cbiAgYXBwbHlQZW5kaW5nVXBkYXRlcygpe1xuICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goKHtkaWZmLCBldmVudHN9KSA9PiB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpKVxuICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgfVxuXG4gIG9uQ2hhbm5lbChldmVudCwgY2Ipe1xuICAgIHRoaXMubGl2ZVNvY2tldC5vbkNoYW5uZWwodGhpcy5jaGFubmVsLCBldmVudCwgcmVzcCA9PiB7XG4gICAgICBpZih0aGlzLmlzSm9pblBlbmRpbmcoKSl7XG4gICAgICAgIHRoaXMucm9vdC5wZW5kaW5nSm9pbk9wcy5wdXNoKFt0aGlzLCAoKSA9PiBjYihyZXNwKV0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiBjYihyZXNwKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgYmluZENoYW5uZWwoKXtcbiAgICAvLyBUaGUgZGlmZiBldmVudCBzaG91bGQgYmUgaGFuZGxlZCBieSB0aGUgcmVndWxhciB1cGRhdGUgb3BlcmF0aW9ucy5cbiAgICAvLyBBbGwgb3RoZXIgb3BlcmF0aW9ucyBhcmUgcXVldWVkIHRvIGJlIGFwcGxpZWQgb25seSBhZnRlciBqb2luLlxuICAgIHRoaXMubGl2ZVNvY2tldC5vbkNoYW5uZWwodGhpcy5jaGFubmVsLCBcImRpZmZcIiwgKHJhd0RpZmYpID0+IHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5hcHBseURpZmYoXCJ1cGRhdGVcIiwgcmF3RGlmZiwgKHtkaWZmLCBldmVudHN9KSA9PiB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpKVxuICAgICAgfSlcbiAgICB9KVxuICAgIHRoaXMub25DaGFubmVsKFwicmVkaXJlY3RcIiwgKHt0bywgZmxhc2h9KSA9PiB0aGlzLm9uUmVkaXJlY3Qoe3RvLCBmbGFzaH0pKVxuICAgIHRoaXMub25DaGFubmVsKFwibGl2ZV9wYXRjaFwiLCAocmVkaXIpID0+IHRoaXMub25MaXZlUGF0Y2gocmVkaXIpKVxuICAgIHRoaXMub25DaGFubmVsKFwibGl2ZV9yZWRpcmVjdFwiLCAocmVkaXIpID0+IHRoaXMub25MaXZlUmVkaXJlY3QocmVkaXIpKVxuICAgIHRoaXMuY2hhbm5lbC5vbkVycm9yKHJlYXNvbiA9PiB0aGlzLm9uRXJyb3IocmVhc29uKSlcbiAgICB0aGlzLmNoYW5uZWwub25DbG9zZShyZWFzb24gPT4gdGhpcy5vbkNsb3NlKHJlYXNvbikpXG4gIH1cblxuICBkZXN0cm95QWxsQ2hpbGRyZW4oKXtcbiAgICBmb3IobGV0IGlkIGluIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSl7XG4gICAgICB0aGlzLmdldENoaWxkQnlJZChpZCkuZGVzdHJveSgpXG4gICAgfVxuICB9XG5cbiAgb25MaXZlUmVkaXJlY3QocmVkaXIpe1xuICAgIGxldCB7dG8sIGtpbmQsIGZsYXNofSA9IHJlZGlyXG4gICAgbGV0IHVybCA9IHRoaXMuZXhwYW5kVVJMKHRvKVxuICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UmVkaXJlY3QodXJsLCBraW5kLCBmbGFzaClcbiAgfVxuXG4gIG9uTGl2ZVBhdGNoKHJlZGlyKXtcbiAgICBsZXQge3RvLCBraW5kfSA9IHJlZGlyXG4gICAgdGhpcy5ocmVmID0gdGhpcy5leHBhbmRVUkwodG8pXG4gICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlQYXRjaCh0bywga2luZClcbiAgfVxuXG4gIGV4cGFuZFVSTCh0byl7XG4gICAgcmV0dXJuIHRvLnN0YXJ0c1dpdGgoXCIvXCIpID8gYCR7d2luZG93LmxvY2F0aW9uLnByb3RvY29sfS8vJHt3aW5kb3cubG9jYXRpb24uaG9zdH0ke3RvfWAgOiB0b1xuICB9XG5cbiAgb25SZWRpcmVjdCh7dG8sIGZsYXNofSl7IHRoaXMubGl2ZVNvY2tldC5yZWRpcmVjdCh0bywgZmxhc2gpIH1cblxuICBpc0Rlc3Ryb3llZCgpeyByZXR1cm4gdGhpcy5kZXN0cm95ZWQgfVxuXG4gIGpvaW4oY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuaXNNYWluKCkpe1xuICAgICAgdGhpcy5zdG9wQ2FsbGJhY2sgPSB0aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHt0bzogdGhpcy5ocmVmLCBraW5kOiBcImluaXRpYWxcIn0pXG4gICAgfVxuICAgIHRoaXMuam9pbkNhbGxiYWNrID0gKG9uRG9uZSkgPT4ge1xuICAgICAgb25Eb25lID0gb25Eb25lIHx8IGZ1bmN0aW9uKCl7fVxuICAgICAgY2FsbGJhY2sgPyBjYWxsYmFjayh0aGlzLmpvaW5Db3VudCwgb25Eb25lKSA6IG9uRG9uZSgpXG4gICAgfVxuICAgIHRoaXMubGl2ZVNvY2tldC53cmFwUHVzaCh0aGlzLCB7dGltZW91dDogZmFsc2V9LCAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsLmpvaW4oKVxuICAgICAgICAucmVjZWl2ZShcIm9rXCIsIGRhdGEgPT4ge1xuICAgICAgICAgIGlmKCF0aGlzLmlzRGVzdHJveWVkKCkpe1xuICAgICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4gdGhpcy5vbkpvaW4oZGF0YSkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAucmVjZWl2ZShcImVycm9yXCIsIHJlc3AgPT4gIXRoaXMuaXNEZXN0cm95ZWQoKSAmJiB0aGlzLm9uSm9pbkVycm9yKHJlc3ApKVxuICAgICAgICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gIXRoaXMuaXNEZXN0cm95ZWQoKSAmJiB0aGlzLm9uSm9pbkVycm9yKHtyZWFzb246IFwidGltZW91dFwifSkpXG4gICAgfSlcbiAgfVxuXG4gIG9uSm9pbkVycm9yKHJlc3Ape1xuICAgIGlmKHJlc3AucmVhc29uID09PSBcInVuYXV0aG9yaXplZFwiIHx8IHJlc3AucmVhc29uID09PSBcInN0YWxlXCIpe1xuICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ1bmF1dGhvcml6ZWQgbGl2ZV9yZWRpcmVjdC4gRmFsbGluZyBiYWNrIHRvIHBhZ2UgcmVxdWVzdFwiLCByZXNwXSlcbiAgICAgIHJldHVybiB0aGlzLm9uUmVkaXJlY3Qoe3RvOiB0aGlzLmhyZWZ9KVxuICAgIH1cbiAgICBpZihyZXNwLnJlZGlyZWN0IHx8IHJlc3AubGl2ZV9yZWRpcmVjdCl7XG4gICAgICB0aGlzLmpvaW5QZW5kaW5nID0gZmFsc2VcbiAgICAgIHRoaXMuY2hhbm5lbC5sZWF2ZSgpXG4gICAgfVxuICAgIGlmKHJlc3AucmVkaXJlY3QpeyByZXR1cm4gdGhpcy5vblJlZGlyZWN0KHJlc3AucmVkaXJlY3QpIH1cbiAgICBpZihyZXNwLmxpdmVfcmVkaXJlY3QpeyByZXR1cm4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZXNwLmxpdmVfcmVkaXJlY3QpIH1cbiAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtcInVuYWJsZSB0byBqb2luXCIsIHJlc3BdKVxuICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQucmVsb2FkV2l0aEppdHRlcih0aGlzKVxuICB9XG5cbiAgb25DbG9zZShyZWFzb24pe1xuICAgIGlmKHRoaXMuaXNEZXN0cm95ZWQoKSl7IHJldHVybiB9XG4gICAgaWYoKHRoaXMuaXNKb2luUGVuZGluZygpICYmIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSAhPT0gXCJoaWRkZW5cIikgfHxcbiAgICAgICh0aGlzLmxpdmVTb2NrZXQuaGFzUGVuZGluZ0xpbmsoKSAmJiByZWFzb24gIT09IFwibGVhdmVcIikpe1xuXG4gICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcylcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKVxuICAgIHRoaXMubGl2ZVNvY2tldC5kcm9wQWN0aXZlRWxlbWVudCh0aGlzKVxuICAgIC8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIGJlIG51bGwgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTFcbiAgICBpZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KXsgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCkgfVxuICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpe1xuICAgICAgdGhpcy5zaG93TG9hZGVyKEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQpXG4gICAgfVxuICB9XG5cbiAgb25FcnJvcihyZWFzb24pe1xuICAgIHRoaXMub25DbG9zZShyZWFzb24pXG4gICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ2aWV3IGNyYXNoZWRcIiwgcmVhc29uXSlcbiAgICBpZighdGhpcy5saXZlU29ja2V0LmlzVW5sb2FkZWQoKSl7IHRoaXMuZGlzcGxheUVycm9yKCkgfVxuICB9XG5cbiAgZGlzcGxheUVycm9yKCl7XG4gICAgaWYodGhpcy5pc01haW4oKSl7IERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIHt0bzogdGhpcy5ocmVmLCBraW5kOiBcImVycm9yXCJ9KSB9XG4gICAgdGhpcy5zaG93TG9hZGVyKClcbiAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUywgUEhYX0VSUk9SX0NMQVNTKVxuICB9XG5cbiAgcHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5ID0gZnVuY3Rpb24gKCl7IH0pe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuXG4gICAgbGV0IFtyZWYsIFtlbF0sIG9wdHNdID0gcmVmR2VuZXJhdG9yID8gcmVmR2VuZXJhdG9yKCkgOiBbbnVsbCwgW10sIHt9XVxuICAgIGxldCBvbkxvYWRpbmdEb25lID0gZnVuY3Rpb24oKXsgfVxuICAgIGlmKG9wdHMucGFnZV9sb2FkaW5nIHx8IChlbCAmJiAoZWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfUEFHRV9MT0FESU5HKSkgIT09IG51bGwpKSl7XG4gICAgICBvbkxvYWRpbmdEb25lID0gdGhpcy5saXZlU29ja2V0LndpdGhQYWdlTG9hZGluZyh7a2luZDogXCJlbGVtZW50XCIsIHRhcmdldDogZWx9KVxuICAgIH1cblxuICAgIGlmKHR5cGVvZiAocGF5bG9hZC5jaWQpICE9PSBcIm51bWJlclwiKXsgZGVsZXRlIHBheWxvYWQuY2lkIH1cbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5saXZlU29ja2V0LndyYXBQdXNoKHRoaXMsIHt0aW1lb3V0OiB0cnVlfSwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsLnB1c2goZXZlbnQsIHBheWxvYWQsIFBVU0hfVElNRU9VVCkucmVjZWl2ZShcIm9rXCIsIHJlc3AgPT4ge1xuICAgICAgICAgIGlmKHJlZiAhPT0gbnVsbCl7IHRoaXMudW5kb1JlZnMocmVmKSB9XG4gICAgICAgICAgbGV0IGZpbmlzaCA9IChob29rUmVwbHkpID0+IHtcbiAgICAgICAgICAgIGlmKHJlc3AucmVkaXJlY3QpeyB0aGlzLm9uUmVkaXJlY3QocmVzcC5yZWRpcmVjdCkgfVxuICAgICAgICAgICAgaWYocmVzcC5saXZlX3BhdGNoKXsgdGhpcy5vbkxpdmVQYXRjaChyZXNwLmxpdmVfcGF0Y2gpIH1cbiAgICAgICAgICAgIGlmKHJlc3AubGl2ZV9yZWRpcmVjdCl7IHRoaXMub25MaXZlUmVkaXJlY3QocmVzcC5saXZlX3JlZGlyZWN0KSB9XG4gICAgICAgICAgICBvbkxvYWRpbmdEb25lKClcbiAgICAgICAgICAgIG9uUmVwbHkocmVzcCwgaG9va1JlcGx5KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXNwLmRpZmYpe1xuICAgICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICBsZXQgaG9va1JlcGx5ID0gdGhpcy5hcHBseURpZmYoXCJ1cGRhdGVcIiwgcmVzcC5kaWZmLCAoe2RpZmYsIGV2ZW50c30pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIGZpbmlzaChob29rUmVwbHkpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaW5pc2gobnVsbClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIHVuZG9SZWZzKHJlZil7XG4gICAgRE9NLmFsbChkb2N1bWVudCwgYFske1BIWF9SRUZfU1JDfT1cIiR7dGhpcy5pZH1cIl1bJHtQSFhfUkVGfT1cIiR7cmVmfVwiXWAsIGVsID0+IHtcbiAgICAgIGxldCBkaXNhYmxlZFZhbCA9IGVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRUQpXG4gICAgICAvLyByZW1vdmUgcmVmc1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUYpXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG4gICAgICAvLyByZXN0b3JlIGlucHV0c1xuICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlKFBIWF9SRUFET05MWSkgIT09IG51bGwpe1xuICAgICAgICBlbC5yZWFkT25seSA9IGZhbHNlXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVBRE9OTFkpXG4gICAgICB9XG4gICAgICBpZihkaXNhYmxlZFZhbCAhPT0gbnVsbCl7XG4gICAgICAgIGVsLmRpc2FibGVkID0gZGlzYWJsZWRWYWwgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfRElTQUJMRUQpXG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgY2xhc3Nlc1xuICAgICAgUEhYX0VWRU5UX0NMQVNTRVMuZm9yRWFjaChjbGFzc05hbWUgPT4gRE9NLnJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpKVxuICAgICAgLy8gcmVzdG9yZSBkaXNhYmxlc1xuICAgICAgbGV0IGRpc2FibGVSZXN0b3JlID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSlcbiAgICAgIGlmKGRpc2FibGVSZXN0b3JlICE9PSBudWxsKXtcbiAgICAgICAgZWwuaW5uZXJUZXh0ID0gZGlzYWJsZVJlc3RvcmVcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSlcbiAgICAgIH1cbiAgICAgIGxldCB0b0VsID0gRE9NLnByaXZhdGUoZWwsIFBIWF9SRUYpXG4gICAgICBpZih0b0VsKXtcbiAgICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGVsLCB0b0VsKVxuICAgICAgICBET01QYXRjaC5wYXRjaEVsKGVsLCB0b0VsLCB0aGlzLmxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpKVxuICAgICAgICBpZihob29rKXsgaG9vay5fX3VwZGF0ZWQoKSB9XG4gICAgICAgIERPTS5kZWxldGVQcml2YXRlKGVsLCBQSFhfUkVGKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBwdXRSZWYoZWxlbWVudHMsIGV2ZW50LCBvcHRzID0ge30pe1xuICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZisrXG4gICAgbGV0IGRpc2FibGVXaXRoID0gdGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpXG4gICAgaWYob3B0cy5sb2FkaW5nKXsgZWxlbWVudHMgPSBlbGVtZW50cy5jb25jYXQoRE9NLmFsbChkb2N1bWVudCwgb3B0cy5sb2FkaW5nKSl9XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYHBoeC0ke2V2ZW50fS1sb2FkaW5nYClcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUkVGLCBuZXdSZWYpXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRl9TUkMsIHRoaXMuZWwuaWQpXG4gICAgICBsZXQgZGlzYWJsZVRleHQgPSBlbC5nZXRBdHRyaWJ1dGUoZGlzYWJsZVdpdGgpXG4gICAgICBpZihkaXNhYmxlVGV4dCAhPT0gbnVsbCl7XG4gICAgICAgIGlmKCFlbC5nZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFKSl7XG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSwgZWwuaW5uZXJUZXh0KVxuICAgICAgICB9XG4gICAgICAgIGlmKGRpc2FibGVUZXh0ICE9PSBcIlwiKXsgZWwuaW5uZXJUZXh0ID0gZGlzYWJsZVRleHQgfVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIFtuZXdSZWYsIGVsZW1lbnRzLCBvcHRzXVxuICB9XG5cbiAgY29tcG9uZW50SUQoZWwpe1xuICAgIGxldCBjaWQgPSBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpXG4gICAgcmV0dXJuIGNpZCA/IHBhcnNlSW50KGNpZCkgOiBudWxsXG4gIH1cblxuICB0YXJnZXRDb21wb25lbnRJRCh0YXJnZXQsIHRhcmdldEN0eCwgb3B0cyA9IHt9KXtcbiAgICBpZihpc0NpZCh0YXJnZXRDdHgpKXsgcmV0dXJuIHRhcmdldEN0eCB9XG5cbiAgICBsZXQgY2lkT3JTZWxlY3RvciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwidGFyZ2V0XCIpKVxuICAgIGlmKGlzQ2lkKGNpZE9yU2VsZWN0b3IpKXtcbiAgICAgIHJldHVybiBwYXJzZUludChjaWRPclNlbGVjdG9yKVxuICAgIH0gZWxzZSBpZih0YXJnZXRDdHggJiYgKGNpZE9yU2VsZWN0b3IgIT09IG51bGwgfHwgb3B0cy50YXJnZXQpKXtcbiAgICAgIHJldHVybiB0aGlzLmNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eCl7XG4gICAgaWYoaXNDaWQodGFyZ2V0Q3R4KSl7XG4gICAgICByZXR1cm4gdGFyZ2V0Q3R4XG4gICAgfSBlbHNlIGlmKHRhcmdldEN0eCl7XG4gICAgICByZXR1cm4gbWF5YmUodGFyZ2V0Q3R4LmNsb3Nlc3QoYFske1BIWF9DT01QT05FTlR9XWApLCBlbCA9PiB0aGlzLm93bnNFbGVtZW50KGVsKSAmJiB0aGlzLmNvbXBvbmVudElEKGVsKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBwdXNoSG9va0V2ZW50KHRhcmdldEN0eCwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkpe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpe1xuICAgICAgdGhpcy5sb2coXCJob29rXCIsICgpID0+IFtcInVuYWJsZSB0byBwdXNoIGhvb2sgZXZlbnQuIExpdmVWaWV3IG5vdCBjb25uZWN0ZWRcIiwgZXZlbnQsIHBheWxvYWRdKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGxldCBbcmVmLCBlbHMsIG9wdHNdID0gdGhpcy5wdXRSZWYoW10sIFwiaG9va1wiKVxuICAgIHRoaXMucHVzaFdpdGhSZXBseSgoKSA9PiBbcmVmLCBlbHMsIG9wdHNdLCBcImV2ZW50XCIsIHtcbiAgICAgIHR5cGU6IFwiaG9va1wiLFxuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgdmFsdWU6IHBheWxvYWQsXG4gICAgICBjaWQ6IHRoaXMuY2xvc2VzdENvbXBvbmVudElEKHRhcmdldEN0eClcbiAgICB9LCAocmVzcCwgcmVwbHkpID0+IG9uUmVwbHkocmVwbHksIHJlZikpXG5cbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICBleHRyYWN0TWV0YShlbCwgbWV0YSwgdmFsdWUpe1xuICAgIGxldCBwcmVmaXggPSB0aGlzLmJpbmRpbmcoXCJ2YWx1ZS1cIilcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZWwuYXR0cmlidXRlcy5sZW5ndGg7IGkrKyl7XG4gICAgICBpZighbWV0YSl7IG1ldGEgPSB7fSB9XG4gICAgICBsZXQgbmFtZSA9IGVsLmF0dHJpYnV0ZXNbaV0ubmFtZVxuICAgICAgaWYobmFtZS5zdGFydHNXaXRoKHByZWZpeCkpeyBtZXRhW25hbWUucmVwbGFjZShwcmVmaXgsIFwiXCIpXSA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKSB9XG4gICAgfVxuICAgIGlmKGVsLnZhbHVlICE9PSB1bmRlZmluZWQpe1xuICAgICAgaWYoIW1ldGEpeyBtZXRhID0ge30gfVxuICAgICAgbWV0YS52YWx1ZSA9IGVsLnZhbHVlXG5cbiAgICAgIGlmKGVsLnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiBDSEVDS0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZSkgPj0gMCAmJiAhZWwuY2hlY2tlZCl7XG4gICAgICAgIGRlbGV0ZSBtZXRhLnZhbHVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHZhbHVlKXtcbiAgICAgIGlmKCFtZXRhKXsgbWV0YSA9IHt9IH1cbiAgICAgIGZvcihsZXQga2V5IGluIHZhbHVlKXsgbWV0YVtrZXldID0gdmFsdWVba2V5XSB9XG4gICAgfVxuICAgIHJldHVybiBtZXRhXG4gIH1cblxuICBwdXNoRXZlbnQodHlwZSwgZWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG1ldGEsIG9wdHMgPSB7fSl7XG4gICAgdGhpcy5wdXNoV2l0aFJlcGx5KCgpID0+IHRoaXMucHV0UmVmKFtlbF0sIHR5cGUsIG9wdHMpLCBcImV2ZW50XCIsIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICB2YWx1ZTogdGhpcy5leHRyYWN0TWV0YShlbCwgbWV0YSwgb3B0cy52YWx1ZSksXG4gICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZWwsIHRhcmdldEN0eCwgb3B0cylcbiAgICB9KVxuICB9XG5cbiAgcHVzaEZpbGVQcm9ncmVzcyhmaWxlRWwsIGVudHJ5UmVmLCBwcm9ncmVzcywgb25SZXBseSA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICB0aGlzLmxpdmVTb2NrZXQud2l0aGluT3duZXJzKGZpbGVFbC5mb3JtLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICB2aWV3LnB1c2hXaXRoUmVwbHkobnVsbCwgXCJwcm9ncmVzc1wiLCB7XG4gICAgICAgIGV2ZW50OiBmaWxlRWwuZ2V0QXR0cmlidXRlKHZpZXcuYmluZGluZyhQSFhfUFJPR1JFU1MpKSxcbiAgICAgICAgcmVmOiBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSxcbiAgICAgICAgZW50cnlfcmVmOiBlbnRyeVJlZixcbiAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzLFxuICAgICAgICBjaWQ6IHZpZXcudGFyZ2V0Q29tcG9uZW50SUQoZmlsZUVsLmZvcm0sIHRhcmdldEN0eClcbiAgICAgIH0sIG9uUmVwbHkpXG4gICAgfSlcbiAgfVxuXG4gIHB1c2hJbnB1dChpbnB1dEVsLCB0YXJnZXRDdHgsIGZvcmNlQ2lkLCBwaHhFdmVudCwgb3B0cywgY2FsbGJhY2spe1xuICAgIGxldCB1cGxvYWRzXG4gICAgbGV0IGNpZCA9IGlzQ2lkKGZvcmNlQ2lkKSA/IGZvcmNlQ2lkIDogdGhpcy50YXJnZXRDb21wb25lbnRJRChpbnB1dEVsLmZvcm0sIHRhcmdldEN0eClcbiAgICBsZXQgcmVmR2VuZXJhdG9yID0gKCkgPT4gdGhpcy5wdXRSZWYoW2lucHV0RWwsIGlucHV0RWwuZm9ybV0sIFwiY2hhbmdlXCIsIG9wdHMpXG4gICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShpbnB1dEVsLmZvcm0sIHtfdGFyZ2V0OiBvcHRzLl90YXJnZXR9KVxuICAgIGlmKERPTS5pc1VwbG9hZElucHV0KGlucHV0RWwpICYmIGlucHV0RWwuZmlsZXMgJiYgaW5wdXRFbC5maWxlcy5sZW5ndGggPiAwKXtcbiAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKGlucHV0RWwsIEFycmF5LmZyb20oaW5wdXRFbC5maWxlcykpXG4gICAgfVxuICAgIHVwbG9hZHMgPSBMaXZlVXBsb2FkZXIuc2VyaWFsaXplVXBsb2FkcyhpbnB1dEVsKVxuICAgIGxldCBldmVudCA9IHtcbiAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgdXBsb2FkczogdXBsb2FkcyxcbiAgICAgIGNpZDogY2lkXG4gICAgfVxuICAgIHRoaXMucHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIFwiZXZlbnRcIiwgZXZlbnQsIHJlc3AgPT4ge1xuICAgICAgRE9NLnNob3dFcnJvcihpbnB1dEVsLCB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKSlcbiAgICAgIGlmKERPTS5pc1VwbG9hZElucHV0KGlucHV0RWwpICYmIGlucHV0RWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtYXV0by11cGxvYWRcIikgIT09IG51bGwpe1xuICAgICAgICBpZihMaXZlVXBsb2FkZXIuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dEVsKS5sZW5ndGggPiAwKXtcbiAgICAgICAgICBsZXQgW3JlZiwgX2Vsc10gPSByZWZHZW5lcmF0b3IoKVxuICAgICAgICAgIHRoaXMudXBsb2FkRmlsZXMoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgsIHJlZiwgY2lkLCAoX3VwbG9hZHMpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3ApXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJBd2FpdGluZ1N1Ym1pdChpbnB1dEVsLmZvcm0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdHJpZ2dlckF3YWl0aW5nU3VibWl0KGZvcm1FbCl7XG4gICAgbGV0IGF3YWl0aW5nU3VibWl0ID0gdGhpcy5nZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKVxuICAgIGlmKGF3YWl0aW5nU3VibWl0KXtcbiAgICAgIGxldCBbX2VsLCBfcmVmLCBfb3B0cywgY2FsbGJhY2tdID0gYXdhaXRpbmdTdWJtaXRcbiAgICAgIHRoaXMuY2FuY2VsU3VibWl0KGZvcm1FbClcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICBnZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKXtcbiAgICByZXR1cm4gdGhpcy5mb3JtU3VibWl0cy5maW5kKChbZWwsIF9yZWYsIF9vcHRzLCBfY2FsbGJhY2tdKSA9PiBlbC5pc1NhbWVOb2RlKGZvcm1FbCkpXG4gIH1cblxuICBzY2hlZHVsZVN1Ym1pdChmb3JtRWwsIHJlZiwgb3B0cywgY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCkpeyByZXR1cm4gdHJ1ZSB9XG4gICAgdGhpcy5mb3JtU3VibWl0cy5wdXNoKFtmb3JtRWwsIHJlZiwgb3B0cywgY2FsbGJhY2tdKVxuICB9XG5cbiAgY2FuY2VsU3VibWl0KGZvcm1FbCl7XG4gICAgdGhpcy5mb3JtU3VibWl0cyA9IHRoaXMuZm9ybVN1Ym1pdHMuZmlsdGVyKChbZWwsIHJlZiwgX2NhbGxiYWNrXSkgPT4ge1xuICAgICAgaWYoZWwuaXNTYW1lTm9kZShmb3JtRWwpKXtcbiAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCBvblJlcGx5KXtcbiAgICBsZXQgZmlsdGVySWdub3JlZCA9IGVsID0+IHtcbiAgICAgIGxldCB1c2VySWdub3JlZCA9IGNsb3Nlc3RQaHhCaW5kaW5nKGVsLCBgJHt0aGlzLmJpbmRpbmcoUEhYX1VQREFURSl9PWlnbm9yZWAsIGVsLmZvcm0pXG4gICAgICByZXR1cm4gISh1c2VySWdub3JlZCB8fCBjbG9zZXN0UGh4QmluZGluZyhlbCwgXCJkYXRhLXBoeC11cGRhdGU9aWdub3JlXCIsIGVsLmZvcm0pKVxuICAgIH1cbiAgICBsZXQgZmlsdGVyRGlzYWJsZXMgPSBlbCA9PiB7XG4gICAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKSlcbiAgICB9XG4gICAgbGV0IGZpbHRlckJ1dHRvbiA9IGVsID0+IGVsLnRhZ05hbWUgPT0gXCJCVVRUT05cIlxuXG4gICAgbGV0IGZpbHRlcklucHV0ID0gZWwgPT4gW1wiSU5QVVRcIiwgXCJURVhUQVJFQVwiLCBcIlNFTEVDVFwiXS5pbmNsdWRlcyhlbC50YWdOYW1lKVxuXG4gICAgbGV0IHJlZkdlbmVyYXRvciA9ICgpID0+IHtcbiAgICAgIGxldCBmb3JtRWxlbWVudHMgPSBBcnJheS5mcm9tKGZvcm1FbC5lbGVtZW50cylcbiAgICAgIGxldCBkaXNhYmxlcyA9IGZvcm1FbGVtZW50cy5maWx0ZXIoZmlsdGVyRGlzYWJsZXMpXG4gICAgICBsZXQgYnV0dG9ucyA9IGZvcm1FbGVtZW50cy5maWx0ZXIoZmlsdGVyQnV0dG9uKS5maWx0ZXIoZmlsdGVySWdub3JlZClcbiAgICAgIGxldCBpbnB1dHMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlcklucHV0KS5maWx0ZXIoZmlsdGVySWdub3JlZClcblxuICAgICAgYnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBidXR0b24uZGlzYWJsZWQpXG4gICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IHRydWVcbiAgICAgIH0pXG4gICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShQSFhfUkVBRE9OTFksIGlucHV0LnJlYWRPbmx5KVxuICAgICAgICBpbnB1dC5yZWFkT25seSA9IHRydWVcbiAgICAgICAgaWYoaW5wdXQuZmlsZXMpe1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShQSFhfRElTQUJMRUQsIGlucHV0LmRpc2FibGVkKVxuICAgICAgICAgIGlucHV0LmRpc2FibGVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgZm9ybUVsLnNldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX1BBR0VfTE9BRElORyksIFwiXCIpXG4gICAgICByZXR1cm4gdGhpcy5wdXRSZWYoW2Zvcm1FbF0uY29uY2F0KGRpc2FibGVzKS5jb25jYXQoYnV0dG9ucykuY29uY2F0KGlucHV0cyksIFwic3VibWl0XCIsIG9wdHMpXG4gICAgfVxuXG4gICAgbGV0IGNpZCA9IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZm9ybUVsLCB0YXJnZXRDdHgpXG4gICAgaWYoTGl2ZVVwbG9hZGVyLmhhc1VwbG9hZHNJblByb2dyZXNzKGZvcm1FbCkpe1xuICAgICAgbGV0IFtyZWYsIF9lbHNdID0gcmVmR2VuZXJhdG9yKClcbiAgICAgIGxldCBwdXNoID0gKCkgPT4gdGhpcy5wdXNoRm9ybVN1Ym1pdChmb3JtRWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG9wdHMsIG9uUmVwbHkpXG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVN1Ym1pdChmb3JtRWwsIHJlZiwgb3B0cywgcHVzaClcbiAgICB9IGVsc2UgaWYoTGl2ZVVwbG9hZGVyLmlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCkubGVuZ3RoID4gMCl7XG4gICAgICBsZXQgW3JlZiwgZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHJveHlSZWZHZW4gPSAoKSA9PiBbcmVmLCBlbHMsIG9wdHNdXG4gICAgICB0aGlzLnVwbG9hZEZpbGVzKGZvcm1FbCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgKF91cGxvYWRzKSA9PiB7XG4gICAgICAgIGxldCBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oZm9ybUVsLCB7fSlcbiAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHByb3h5UmVmR2VuLCBcImV2ZW50XCIsIHtcbiAgICAgICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgICAgIGNpZDogY2lkXG4gICAgICAgIH0sIG9uUmVwbHkpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGZvcm1FbClcbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIFwiZXZlbnRcIiwge1xuICAgICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICB2YWx1ZTogZm9ybURhdGEsXG4gICAgICAgIGNpZDogY2lkXG4gICAgICB9LCBvblJlcGx5KVxuICAgIH1cbiAgfVxuXG4gIHVwbG9hZEZpbGVzKGZvcm1FbCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgb25Db21wbGV0ZSl7XG4gICAgbGV0IGpvaW5Db3VudEF0VXBsb2FkID0gdGhpcy5qb2luQ291bnRcbiAgICBsZXQgaW5wdXRFbHMgPSBMaXZlVXBsb2FkZXIuYWN0aXZlRmlsZUlucHV0cyhmb3JtRWwpXG4gICAgbGV0IG51bUZpbGVJbnB1dHNJblByb2dyZXNzID0gaW5wdXRFbHMubGVuZ3RoXG5cbiAgICAvLyBnZXQgZWFjaCBmaWxlIGlucHV0XG4gICAgaW5wdXRFbHMuZm9yRWFjaChpbnB1dEVsID0+IHtcbiAgICAgIGxldCB1cGxvYWRlciA9IG5ldyBMaXZlVXBsb2FkZXIoaW5wdXRFbCwgdGhpcywgKCkgPT4ge1xuICAgICAgICBudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcy0tXG4gICAgICAgIGlmKG51bUZpbGVJbnB1dHNJblByb2dyZXNzID09PSAwKXsgb25Db21wbGV0ZSgpIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnVwbG9hZGVyc1tpbnB1dEVsXSA9IHVwbG9hZGVyXG4gICAgICBsZXQgZW50cmllcyA9IHVwbG9hZGVyLmVudHJpZXMoKS5tYXAoZW50cnkgPT4gZW50cnkudG9QcmVmbGlnaHRQYXlsb2FkKCkpXG5cbiAgICAgIGxldCBwYXlsb2FkID0ge1xuICAgICAgICByZWY6IGlucHV0RWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSxcbiAgICAgICAgZW50cmllczogZW50cmllcyxcbiAgICAgICAgY2lkOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4KVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbXCJzZW5kaW5nIHByZWZsaWdodCByZXF1ZXN0XCIsIHBheWxvYWRdKVxuXG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJhbGxvd191cGxvYWRcIiwgcGF5bG9hZCwgcmVzcCA9PiB7XG4gICAgICAgIHRoaXMubG9nKFwidXBsb2FkXCIsICgpID0+IFtcImdvdCBwcmVmbGlnaHQgcmVzcG9uc2VcIiwgcmVzcF0pXG4gICAgICAgIGlmKHJlc3AuZXJyb3Ipe1xuICAgICAgICAgIHRoaXMudW5kb1JlZnMocmVmKVxuICAgICAgICAgIGxldCBbZW50cnlfcmVmLCByZWFzb25dID0gcmVzcC5lcnJvclxuICAgICAgICAgIHRoaXMubG9nKFwidXBsb2FkXCIsICgpID0+IFtgZXJyb3IgZm9yIGVudHJ5ICR7ZW50cnlfcmVmfWAsIHJlYXNvbl0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IG9uRXJyb3IgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5vbkVycm9yKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYodGhpcy5qb2luQ291bnQgPT09IGpvaW5Db3VudEF0VXBsb2FkKXsgY2FsbGJhY2soKSB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICB1cGxvYWRlci5pbml0QWRhcHRlclVwbG9hZChyZXNwLCBvbkVycm9yLCB0aGlzLmxpdmVTb2NrZXQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGRpc3BhdGNoVXBsb2FkcyhuYW1lLCBmaWxlc09yQmxvYnMpe1xuICAgIGxldCBpbnB1dHMgPSBET00uZmluZFVwbG9hZElucHV0cyh0aGlzLmVsKS5maWx0ZXIoZWwgPT4gZWwubmFtZSA9PT0gbmFtZSlcbiAgICBpZihpbnB1dHMubGVuZ3RoID09PSAwKXsgbG9nRXJyb3IoYG5vIGxpdmUgZmlsZSBpbnB1dHMgZm91bmQgbWF0Y2hpbmcgdGhlIG5hbWUgXCIke25hbWV9XCJgKSB9XG4gICAgZWxzZSBpZihpbnB1dHMubGVuZ3RoID4gMSl7IGxvZ0Vycm9yKGBkdXBsaWNhdGUgbGl2ZSBmaWxlIGlucHV0cyBmb3VuZCBtYXRjaGluZyB0aGUgbmFtZSBcIiR7bmFtZX1cImApIH1cbiAgICBlbHNlIHsgRE9NLmRpc3BhdGNoRXZlbnQoaW5wdXRzWzBdLCBQSFhfVFJBQ0tfVVBMT0FEUywge2ZpbGVzOiBmaWxlc09yQmxvYnN9KSB9XG4gIH1cblxuICBwdXNoRm9ybVJlY292ZXJ5KGZvcm0sIG5ld0NpZCwgY2FsbGJhY2spe1xuICAgIHRoaXMubGl2ZVNvY2tldC53aXRoaW5Pd25lcnMoZm9ybSwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgbGV0IGlucHV0ID0gZm9ybS5lbGVtZW50c1swXVxuICAgICAgbGV0IHBoeEV2ZW50ID0gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSB8fCBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpXG5cbiAgICAgIEpTLmV4ZWMoXCJjaGFuZ2VcIiwgcGh4RXZlbnQsIHZpZXcsIGlucHV0LCBbXCJwdXNoXCIsIHtfdGFyZ2V0OiBpbnB1dC5uYW1lLCBuZXdDaWQ6IG5ld0NpZCwgY2FsbGJhY2s6IGNhbGxiYWNrfV0pXG4gICAgfSlcbiAgfVxuXG4gIHB1c2hMaW5rUGF0Y2goaHJlZiwgdGFyZ2V0RWwsIGNhbGxiYWNrKXtcbiAgICBsZXQgbGlua1JlZiA9IHRoaXMubGl2ZVNvY2tldC5zZXRQZW5kaW5nTGluayhocmVmKVxuICAgIGxldCByZWZHZW4gPSB0YXJnZXRFbCA/ICgpID0+IHRoaXMucHV0UmVmKFt0YXJnZXRFbF0sIFwiY2xpY2tcIikgOiBudWxsXG4gICAgbGV0IGZhbGxiYWNrID0gKCkgPT4gdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuXG4gICAgbGV0IHB1c2ggPSB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuLCBcImxpdmVfcGF0Y2hcIiwge3VybDogaHJlZn0sIHJlc3AgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZihyZXNwLmxpbmtfcmVkaXJlY3Qpe1xuICAgICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXBsYWNlTWFpbihocmVmLCBudWxsLCBjYWxsYmFjaywgbGlua1JlZilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZih0aGlzLmxpdmVTb2NrZXQuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpe1xuICAgICAgICAgICAgdGhpcy5ocmVmID0gaHJlZlxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKVxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGxpbmtSZWYpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmKHB1c2gpe1xuICAgICAgcHVzaC5yZWNlaXZlKFwidGltZW91dFwiLCBmYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgZmFsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIGZvcm1zRm9yUmVjb3ZlcnkoaHRtbCl7XG4gICAgaWYodGhpcy5qb2luQ291bnQgPT09IDApeyByZXR1cm4gW10gfVxuXG4gICAgbGV0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKVxuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcblxuICAgIHJldHVybiAoXG4gICAgICBET00uYWxsKHRoaXMuZWwsIGBmb3JtWyR7cGh4Q2hhbmdlfV1gKVxuICAgICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5pZCAmJiB0aGlzLm93bnNFbGVtZW50KGZvcm0pKVxuICAgICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5lbGVtZW50cy5sZW5ndGggPiAwKVxuICAgICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSAhPT0gXCJpZ25vcmVcIilcbiAgICAgICAgLm1hcChmb3JtID0+IHtcbiAgICAgICAgICBsZXQgbmV3Rm9ybSA9IHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3RvcihgZm9ybVtpZD1cIiR7Zm9ybS5pZH1cIl1bJHtwaHhDaGFuZ2V9PVwiJHtmb3JtLmdldEF0dHJpYnV0ZShwaHhDaGFuZ2UpfVwiXWApXG4gICAgICAgICAgaWYobmV3Rm9ybSl7XG4gICAgICAgICAgICByZXR1cm4gW2Zvcm0sIG5ld0Zvcm0sIHRoaXMudGFyZ2V0Q29tcG9uZW50SUQobmV3Rm9ybSldXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbZm9ybSwgbnVsbCwgbnVsbF1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKFtmb3JtLCBuZXdGb3JtLCBuZXdDaWRdKSA9PiBuZXdGb3JtKVxuICAgIClcbiAgfVxuXG4gIG1heWJlUHVzaENvbXBvbmVudHNEZXN0cm95ZWQoZGVzdHJveWVkQ0lEcyl7XG4gICAgbGV0IHdpbGxEZXN0cm95Q0lEcyA9IGRlc3Ryb3llZENJRHMuZmlsdGVyKGNpZCA9PiB7XG4gICAgICByZXR1cm4gRE9NLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBjaWQpLmxlbmd0aCA9PT0gMFxuICAgIH0pXG4gICAgaWYod2lsbERlc3Ryb3lDSURzLmxlbmd0aCA+IDApe1xuICAgICAgdGhpcy5wcnVuaW5nQ0lEcy5wdXNoKC4uLndpbGxEZXN0cm95Q0lEcylcblxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc193aWxsX2Rlc3Ryb3lcIiwge2NpZHM6IHdpbGxEZXN0cm95Q0lEc30sICgpID0+IHtcbiAgICAgICAgLy8gVGhlIGNpZHMgYXJlIGVpdGhlciBiYWNrIG9uIHRoZSBwYWdlIG9yIHRoZXkgd2lsbCBiZSBmdWxseSByZW1vdmVkLFxuICAgICAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgcHJ1bmluZ0NJRHMuXG4gICAgICAgIHRoaXMucHJ1bmluZ0NJRHMgPSB0aGlzLnBydW5pbmdDSURzLmZpbHRlcihjaWQgPT4gd2lsbERlc3Ryb3lDSURzLmluZGV4T2YoY2lkKSAhPT0gLTEpXG5cbiAgICAgICAgLy8gU2VlIGlmIGFueSBvZiB0aGUgY2lkcyB3ZSB3YW50ZWQgdG8gZGVzdHJveSB3ZXJlIGFkZGVkIGJhY2ssXG4gICAgICAgIC8vIGlmIHRoZXkgd2VyZSBhZGRlZCBiYWNrLCB3ZSBkb24ndCBhY3R1YWxseSBkZXN0cm95IHRoZW0uXG4gICAgICAgIGxldCBjb21wbGV0ZWx5RGVzdHJveUNJRHMgPSB3aWxsRGVzdHJveUNJRHMuZmlsdGVyKGNpZCA9PiB7XG4gICAgICAgICAgcmV0dXJuIERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDBcbiAgICAgICAgfSlcblxuICAgICAgICBpZihjb21wbGV0ZWx5RGVzdHJveUNJRHMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiY2lkc19kZXN0cm95ZWRcIiwge2NpZHM6IGNvbXBsZXRlbHlEZXN0cm95Q0lEc30sIChyZXNwKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkLnBydW5lQ0lEcyhyZXNwLmNpZHMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBvd25zRWxlbWVudChlbCl7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKSA9PT0gdGhpcy5pZCB8fFxuICAgICAgbWF5YmUoZWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIG5vZGUgPT4gbm9kZS5pZCkgPT09IHRoaXMuaWRcbiAgfVxuXG4gIHN1Ym1pdEZvcm0oZm9ybSwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgb3B0cyA9IHt9KXtcbiAgICBET00ucHV0UHJpdmF0ZShmb3JtLCBQSFhfSEFTX1NVQk1JVFRFRCwgdHJ1ZSlcbiAgICBsZXQgcGh4RmVlZGJhY2sgPSB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhQSFhfRkVFREJBQ0tfRk9SKVxuICAgIGxldCBpbnB1dHMgPSBBcnJheS5mcm9tKGZvcm0uZWxlbWVudHMpXG4gICAgdGhpcy5saXZlU29ja2V0LmJsdXJBY3RpdmVFbGVtZW50KHRoaXMpXG4gICAgdGhpcy5wdXNoRm9ybVN1Ym1pdChmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCAoKSA9PiB7XG4gICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBET00uc2hvd0Vycm9yKGlucHV0LCBwaHhGZWVkYmFjaykpXG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpXG4gICAgfSlcbiAgfVxuXG4gIGJpbmRpbmcoa2luZCl7IHJldHVybiB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhraW5kKSB9XG59XG4iLCAiLyoqIEluaXRpYWxpemVzIHRoZSBMaXZlU29ja2V0XG4gKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRQb2ludCAtIFRoZSBzdHJpbmcgV2ViU29ja2V0IGVuZHBvaW50LCBpZSwgYFwid3NzOi8vZXhhbXBsZS5jb20vbGl2ZVwiYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXCIvbGl2ZVwiYCAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAqIEBwYXJhbSB7UGhvZW5peC5Tb2NrZXR9IHNvY2tldCAtIHRoZSByZXF1aXJlZCBQaG9lbml4IFNvY2tldCBjbGFzcyBpbXBvcnRlZCBmcm9tIFwicGhvZW5peFwiLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbiAqICAgICBpbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG4gKiAgICAgbGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwgey4uLn0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24uIE91dHNpZGUgb2Yga2V5cyBsaXN0ZWQgYmVsb3csIGFsbFxuICogY29uZmlndXJhdGlvbiBpcyBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIFBob2VuaXggU29ja2V0IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmRlZmF1bHRzXSAtIFRoZSBvcHRpb25hbCBkZWZhdWx0cyB0byB1c2UgZm9yIHZhcmlvdXMgYmluZGluZ3MsXG4gKiBzdWNoIGFzIGBwaHgtZGVib3VuY2VgLiBTdXBwb3J0cyB0aGUgZm9sbG93aW5nIGtleXM6XG4gKlxuICogICAtIGRlYm91bmNlIC0gdGhlIG1pbGxpc2Vjb25kIHBoeC1kZWJvdW5jZSB0aW1lLiBEZWZhdWx0cyAzMDBcbiAqICAgLSB0aHJvdHRsZSAtIHRoZSBtaWxsaXNlY29uZCBwaHgtdGhyb3R0bGUgdGltZS4gRGVmYXVsdHMgMzAwXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMucGFyYW1zXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3IgcGFzc2luZyBjb25uZWN0IHBhcmFtcy5cbiAqIFRoZSBmdW5jdGlvbiByZWNlaXZlcyB0aGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBMaXZlVmlldy4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIChlbCkgPT4ge3ZpZXc6IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtbXktdmlldy1uYW1lXCIsIHRva2VuOiB3aW5kb3cubXlUb2tlbn1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmluZGluZ1ByZWZpeF0gLSBUaGUgb3B0aW9uYWwgcHJlZml4IHRvIHVzZSBmb3IgYWxsIHBoeCBET00gYW5ub3RhdGlvbnMuXG4gKiBEZWZhdWx0cyB0byBcInBoeC1cIi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5ob29rc10gLSBUaGUgb3B0aW9uYWwgb2JqZWN0IGZvciByZWZlcmVuY2luZyBMaXZlVmlldyBob29rIGNhbGxiYWNrcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy51cGxvYWRlcnNdIC0gVGhlIG9wdGlvbmFsIG9iamVjdCBmb3IgcmVmZXJlbmNpbmcgTGl2ZVZpZXcgdXBsb2FkZXIgY2FsbGJhY2tzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5sb2FkZXJUaW1lb3V0XSAtIFRoZSBvcHRpb25hbCBkZWxheSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgYXBwbHlcbiAqIGxvYWRpbmcgc3RhdGVzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5tYXhSZWxvYWRzXSAtIFRoZSBtYXhpbXVtIHJlbG9hZHMgYmVmb3JlIGVudGVyaW5nIGZhaWxzYWZlIG1vZGUuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLnJlbG9hZEppdHRlck1pbl0gLSBUaGUgbWluaW11bSB0aW1lIGJldHdlZW4gbm9ybWFsIHJlbG9hZCBhdHRlbXB0cy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMucmVsb2FkSml0dGVyTWF4XSAtIFRoZSBtYXhpbXVtIHRpbWUgYmV0d2VlbiBub3JtYWwgcmVsb2FkIGF0dGVtcHRzLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5mYWlsc2FmZUppdHRlcl0gLSBUaGUgdGltZSBiZXR3ZWVuIHJlbG9hZCBhdHRlbXB0cyBpbiBmYWlsc2FmZSBtb2RlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMudmlld0xvZ2dlcl0gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9nIGRlYnVnIGluZm9ybWF0aW9uLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgKHZpZXcsIGtpbmQsIG1zZywgb2JqKSA9PiBjb25zb2xlLmxvZyhgJHt2aWV3LmlkfSAke2tpbmR9OiAke21zZ30gLSBgLCBvYmopXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLm1ldGFkYXRhXSAtIFRoZSBvcHRpb25hbCBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBmdW5jdGlvbnMgZm9yXG4gKiBwb3B1bGF0aW5nIGV2ZW50IG1ldGFkYXRhLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgbWV0YWRhdGE6IHtcbiAqICAgICAgIGNsaWNrOiAoZSwgZWwpID0+IHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gKiAgICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxuICogICAgICAgICAgIGRldGFpbDogZS5kZXRhaWwgfHwgMSxcbiAqICAgICAgICAgfVxuICogICAgICAgfSxcbiAqICAgICAgIGtleWRvd246IChlLCBlbCkgPT4ge1xuICogICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgIGtleTogZS5rZXksXG4gKiAgICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICogICAgICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAqICAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleVxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnNlc3Npb25TdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFVzZWZ1bCB3aGVuIExpdmVWaWV3IHdvbid0IGhhdmUgYWNjZXNzIHRvIGBzZXNzaW9uU3RvcmFnZWAuICBGb3IgZXhhbXBsZSwgVGhpcyBjb3VsZFxuICogaGFwcGVuIGlmIGEgc2l0ZSBsb2FkcyBhIGNyb3NzLWRvbWFpbiBMaXZlVmlldyBpbiBhbiBpZnJhbWUuICBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgICBjbGFzcyBJbk1lbW9yeVN0b3JhZ2Uge1xuICogICAgICAgY29uc3RydWN0b3IoKSB7IHRoaXMuc3RvcmFnZSA9IHt9IH1cbiAqICAgICAgIGdldEl0ZW0oa2V5TmFtZSkgeyByZXR1cm4gdGhpcy5zdG9yYWdlW2tleU5hbWVdIH1cbiAqICAgICAgIHJlbW92ZUl0ZW0oa2V5TmFtZSkgeyBkZWxldGUgdGhpcy5zdG9yYWdlW2tleU5hbWVdIH1cbiAqICAgICAgIHNldEl0ZW0oa2V5TmFtZSwga2V5VmFsdWUpIHsgdGhpcy5zdG9yYWdlW2tleU5hbWVdID0ga2V5VmFsdWUgfVxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMubG9jYWxTdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFVzZWZ1bCBmb3Igd2hlbiBMaXZlVmlldyB3b24ndCBoYXZlIGFjY2VzcyB0byBgbG9jYWxTdG9yYWdlYC5cbiAqIFNlZSBgb3B0cy5zZXNzaW9uU3RvcmFnZWAgZm9yIGV4YW1wbGVzLlxuKi9cblxuaW1wb3J0IHtcbiAgQklORElOR19QUkVGSVgsXG4gIENPTlNFQ1VUSVZFX1JFTE9BRFMsXG4gIERFRkFVTFRTLFxuICBGQUlMU0FGRV9KSVRURVIsXG4gIExPQURFUl9USU1FT1VULFxuICBNQVhfUkVMT0FEUyxcbiAgUEhYX0RFQk9VTkNFLFxuICBQSFhfRFJPUF9UQVJHRVQsXG4gIFBIWF9IQVNfRk9DVVNFRCxcbiAgUEhYX0tFWSxcbiAgUEhYX0xJTktfU1RBVEUsXG4gIFBIWF9MSVZFX0xJTkssXG4gIFBIWF9MVl9ERUJVRyxcbiAgUEhYX0xWX0xBVEVOQ1lfU0lNLFxuICBQSFhfTFZfUFJPRklMRSxcbiAgUEhYX01BSU4sXG4gIFBIWF9QQVJFTlRfSUQsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1RIUk9UVExFLFxuICBQSFhfVFJBQ0tfVVBMT0FEUyxcbiAgUEhYX1NFU1NJT04sXG4gIFJFTE9BRF9KSVRURVJfTUlOLFxuICBSRUxPQURfSklUVEVSX01BWCxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2xvbmUsXG4gIGNsb3Nlc3RQaHhCaW5kaW5nLFxuICBjbG9zdXJlLFxuICBkZWJ1ZyxcbiAgaXNPYmplY3QsXG4gIG1heWJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEJyb3dzZXIgZnJvbSBcIi4vYnJvd3NlclwiXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgSG9va3MgZnJvbSBcIi4vaG9va3NcIlxuaW1wb3J0IExpdmVVcGxvYWRlciBmcm9tIFwiLi9saXZlX3VwbG9hZGVyXCJcbmltcG9ydCBWaWV3IGZyb20gXCIuL3ZpZXdcIlxuaW1wb3J0IEpTIGZyb20gXCIuL2pzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZVNvY2tldCB7XG4gIGNvbnN0cnVjdG9yKHVybCwgcGh4U29ja2V0LCBvcHRzID0ge30pe1xuICAgIHRoaXMudW5sb2FkZWQgPSBmYWxzZVxuICAgIGlmKCFwaHhTb2NrZXQgfHwgcGh4U29ja2V0LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgIGEgcGhvZW5peCBTb2NrZXQgbXVzdCBiZSBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBMaXZlU29ja2V0IGNvbnN0cnVjdG9yLiBGb3IgZXhhbXBsZTpcblxuICAgICAgICAgIGltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXG4gICAgICAgICAgaW1wb3J0IHtMaXZlU29ja2V0fSBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuICAgICAgICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxuICAgICAgYClcbiAgICB9XG4gICAgdGhpcy5zb2NrZXQgPSBuZXcgcGh4U29ja2V0KHVybCwgb3B0cylcbiAgICB0aGlzLmJpbmRpbmdQcmVmaXggPSBvcHRzLmJpbmRpbmdQcmVmaXggfHwgQklORElOR19QUkVGSVhcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KVxuICAgIHRoaXMudmlld0xvZ2dlciA9IG9wdHMudmlld0xvZ2dlclxuICAgIHRoaXMubWV0YWRhdGFDYWxsYmFja3MgPSBvcHRzLm1ldGFkYXRhIHx8IHt9XG4gICAgdGhpcy5kZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oY2xvbmUoREVGQVVMVFMpLCBvcHRzLmRlZmF1bHRzIHx8IHt9KVxuICAgIHRoaXMuYWN0aXZlRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLnByZXZBY3RpdmUgPSBudWxsXG4gICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlXG4gICAgdGhpcy5tYWluID0gbnVsbFxuICAgIHRoaXMubGlua1JlZiA9IDFcbiAgICB0aGlzLmNsaWNrUmVmID0gMVxuICAgIHRoaXMucm9vdHMgPSB7fVxuICAgIHRoaXMuaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gICAgdGhpcy5wZW5kaW5nTGluayA9IG51bGxcbiAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGNsb25lKHdpbmRvdy5sb2NhdGlvbilcbiAgICB0aGlzLmhvb2tzID0gb3B0cy5ob29rcyB8fCB7fVxuICAgIHRoaXMudXBsb2FkZXJzID0gb3B0cy51cGxvYWRlcnMgfHwge31cbiAgICB0aGlzLmxvYWRlclRpbWVvdXQgPSBvcHRzLmxvYWRlclRpbWVvdXQgfHwgTE9BREVSX1RJTUVPVVRcbiAgICB0aGlzLm1heFJlbG9hZHMgPSBvcHRzLm1heFJlbG9hZHMgfHwgTUFYX1JFTE9BRFNcbiAgICB0aGlzLnJlbG9hZEppdHRlck1pbiA9IG9wdHMucmVsb2FkSml0dGVyTWluIHx8IFJFTE9BRF9KSVRURVJfTUlOXG4gICAgdGhpcy5yZWxvYWRKaXR0ZXJNYXggPSBvcHRzLnJlbG9hZEppdHRlck1heCB8fCBSRUxPQURfSklUVEVSX01BWFxuICAgIHRoaXMuZmFpbHNhZmVKaXR0ZXIgPSBvcHRzLmZhaWxzYWZlSml0dGVyIHx8IEZBSUxTQUZFX0pJVFRFUlxuICAgIHRoaXMubG9jYWxTdG9yYWdlID0gb3B0cy5sb2NhbFN0b3JhZ2UgfHwgd2luZG93LmxvY2FsU3RvcmFnZVxuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2UgPSBvcHRzLnNlc3Npb25TdG9yYWdlIHx8IHdpbmRvdy5zZXNzaW9uU3RvcmFnZVxuICAgIHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyA9IGZhbHNlXG4gICAgdGhpcy5kb21DYWxsYmFja3MgPSBPYmplY3QuYXNzaWduKHtvbk5vZGVBZGRlZDogY2xvc3VyZSgpLCBvbkJlZm9yZUVsVXBkYXRlZDogY2xvc3VyZSgpfSwgb3B0cy5kb20gfHwge30pXG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IG5ldyBUcmFuc2l0aW9uU2V0KClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9lID0+IHtcbiAgICAgIHRoaXMudW5sb2FkZWQgPSB0cnVlXG4gICAgfSlcbiAgICB0aGlzLnNvY2tldC5vbk9wZW4oKCkgPT4ge1xuICAgICAgaWYodGhpcy5pc1VubG9hZGVkKCkpe1xuICAgICAgICAvLyByZWxvYWQgcGFnZSBpZiBiZWluZyByZXN0b3JlZCBmcm9tIGJhY2svZm9yd2FyZCBjYWNoZSBhbmQgYnJvd3NlciBkb2VzIG5vdCBlbWl0IFwicGFnZXNob3dcIlxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gcHVibGljXG5cbiAgaXNQcm9maWxlRW5hYmxlZCgpeyByZXR1cm4gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9QUk9GSUxFKSA9PT0gXCJ0cnVlXCIgfVxuXG4gIGlzRGVidWdFbmFibGVkKCl7IHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0RFQlVHKSA9PT0gXCJ0cnVlXCIgfVxuXG4gIGVuYWJsZURlYnVnKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfREVCVUcsIFwidHJ1ZVwiKSB9XG5cbiAgZW5hYmxlUHJvZmlsaW5nKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfUFJPRklMRSwgXCJ0cnVlXCIpIH1cblxuICBkaXNhYmxlRGVidWcoKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFBIWF9MVl9ERUJVRykgfVxuXG4gIGRpc2FibGVQcm9maWxpbmcoKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFBIWF9MVl9QUk9GSUxFKSB9XG5cbiAgZW5hYmxlTGF0ZW5jeVNpbSh1cHBlckJvdW5kTXMpe1xuICAgIHRoaXMuZW5hYmxlRGVidWcoKVxuICAgIGNvbnNvbGUubG9nKFwibGF0ZW5jeSBzaW11bGF0b3IgZW5hYmxlZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoaXMgYnJvd3NlciBzZXNzaW9uLiBDYWxsIGRpc2FibGVMYXRlbmN5U2ltKCkgdG8gZGlzYWJsZVwiKVxuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0sIHVwcGVyQm91bmRNcylcbiAgfVxuXG4gIGRpc2FibGVMYXRlbmN5U2ltKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfTEFURU5DWV9TSU0pIH1cblxuICBnZXRMYXRlbmN5U2ltKCl7XG4gICAgbGV0IHN0ciA9IHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0pXG4gICAgcmV0dXJuIHN0ciA/IHBhcnNlSW50KHN0cikgOiBudWxsXG4gIH1cblxuICBnZXRTb2NrZXQoKXsgcmV0dXJuIHRoaXMuc29ja2V0IH1cblxuICBjb25uZWN0KCl7XG4gICAgbGV0IGRvQ29ubmVjdCA9ICgpID0+IHtcbiAgICAgIGlmKHRoaXMuam9pblJvb3RWaWV3cygpKXtcbiAgICAgICAgdGhpcy5iaW5kVG9wTGV2ZWxFdmVudHMoKVxuICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoW1wiY29tcGxldGVcIiwgXCJsb2FkZWRcIiwgXCJpbnRlcmFjdGl2ZVwiXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID49IDApe1xuICAgICAgZG9Db25uZWN0KClcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4gZG9Db25uZWN0KCkpXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdChjYWxsYmFjayl7IHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoY2FsbGJhY2spIH1cblxuICBleGVjSlMoZWwsIGVuY29kZWRKUywgZXZlbnRUeXBlID0gbnVsbCl7XG4gICAgdGhpcy5vd25lcihlbCwgdmlldyA9PiBKUy5leGVjKGV2ZW50VHlwZSwgZW5jb2RlZEpTLCB2aWV3LCBlbCkpXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgdHJpZ2dlckRPTShraW5kLCBhcmdzKXsgdGhpcy5kb21DYWxsYmFja3Nba2luZF0oLi4uYXJncykgfVxuXG4gIHRpbWUobmFtZSwgZnVuYyl7XG4gICAgaWYoIXRoaXMuaXNQcm9maWxlRW5hYmxlZCgpIHx8ICFjb25zb2xlLnRpbWUpeyByZXR1cm4gZnVuYygpIH1cbiAgICBjb25zb2xlLnRpbWUobmFtZSlcbiAgICBsZXQgcmVzdWx0ID0gZnVuYygpXG4gICAgY29uc29sZS50aW1lRW5kKG5hbWUpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgbG9nKHZpZXcsIGtpbmQsIG1zZ0NhbGxiYWNrKXtcbiAgICBpZih0aGlzLnZpZXdMb2dnZXIpe1xuICAgICAgbGV0IFttc2csIG9ial0gPSBtc2dDYWxsYmFjaygpXG4gICAgICB0aGlzLnZpZXdMb2dnZXIodmlldywga2luZCwgbXNnLCBvYmopXG4gICAgfSBlbHNlIGlmKHRoaXMuaXNEZWJ1Z0VuYWJsZWQoKSl7XG4gICAgICBsZXQgW21zZywgb2JqXSA9IG1zZ0NhbGxiYWNrKClcbiAgICAgIGRlYnVnKHZpZXcsIGtpbmQsIG1zZywgb2JqKVxuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3RET01VcGRhdGUoY2FsbGJhY2spe1xuICAgIHRoaXMudHJhbnNpdGlvbnMuYWZ0ZXIoY2FsbGJhY2spXG4gIH1cblxuICB0cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSA9IGZ1bmN0aW9uKCl7fSl7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5hZGRUcmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgfVxuXG4gIG9uQ2hhbm5lbChjaGFubmVsLCBldmVudCwgY2Ipe1xuICAgIGNoYW5uZWwub24oZXZlbnQsIGRhdGEgPT4ge1xuICAgICAgbGV0IGxhdGVuY3kgPSB0aGlzLmdldExhdGVuY3lTaW0oKVxuICAgICAgaWYoIWxhdGVuY3kpe1xuICAgICAgICBjYihkYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYHNpbXVsYXRpbmcgJHtsYXRlbmN5fW1zIG9mIGxhdGVuY3kgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50YClcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBjYihkYXRhKSwgbGF0ZW5jeSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgd3JhcFB1c2godmlldywgb3B0cywgcHVzaCl7XG4gICAgbGV0IGxhdGVuY3kgPSB0aGlzLmdldExhdGVuY3lTaW0oKVxuICAgIGxldCBvbGRKb2luQ291bnQgPSB2aWV3LmpvaW5Db3VudFxuICAgIGlmKCFsYXRlbmN5KXtcbiAgICAgIGlmKG9wdHMudGltZW91dCl7XG4gICAgICAgIHJldHVybiBwdXNoKCkucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgICAgIGlmKHZpZXcuam9pbkNvdW50ID09PSBvbGRKb2luQ291bnQgJiYgIXZpZXcuaXNEZXN0cm95ZWQoKSl7XG4gICAgICAgICAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXIodmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmxvZyh2aWV3LCBcInRpbWVvdXRcIiwgKCkgPT4gW1wicmVjZWl2ZWQgdGltZW91dCB3aGlsZSBjb21tdW5pY2F0aW5nIHdpdGggc2VydmVyLiBGYWxsaW5nIGJhY2sgdG8gaGFyZCByZWZyZXNoIGZvciByZWNvdmVyeVwiXSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHB1c2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBzaW11bGF0aW5nICR7bGF0ZW5jeX1tcyBvZiBsYXRlbmN5IGZyb20gY2xpZW50IHRvIHNlcnZlcmApXG4gICAgbGV0IGZha2VQdXNoID0ge1xuICAgICAgcmVjZWl2ZXM6IFtdLFxuICAgICAgcmVjZWl2ZShraW5kLCBjYil7IHRoaXMucmVjZWl2ZXMucHVzaChba2luZCwgY2JdKSB9XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYodmlldy5pc0Rlc3Ryb3llZCgpKXsgcmV0dXJuIH1cbiAgICAgIGZha2VQdXNoLnJlY2VpdmVzLnJlZHVjZSgoYWNjLCBba2luZCwgY2JdKSA9PiBhY2MucmVjZWl2ZShraW5kLCBjYiksIHB1c2goKSlcbiAgICB9LCBsYXRlbmN5KVxuICAgIHJldHVybiBmYWtlUHVzaFxuICB9XG5cbiAgcmVsb2FkV2l0aEppdHRlcih2aWV3LCBsb2cpe1xuICAgIHZpZXcuZGVzdHJveSgpXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICBsZXQgbWluTXMgPSB0aGlzLnJlbG9hZEppdHRlck1pblxuICAgIGxldCBtYXhNcyA9IHRoaXMucmVsb2FkSml0dGVyTWF4XG4gICAgbGV0IGFmdGVyTXMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4TXMgLSBtaW5NcyArIDEpKSArIG1pbk1zXG4gICAgbGV0IHRyaWVzID0gQnJvd3Nlci51cGRhdGVMb2NhbCh0aGlzLmxvY2FsU3RvcmFnZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLCBDT05TRUNVVElWRV9SRUxPQURTLCAwLCBjb3VudCA9PiBjb3VudCArIDEpXG4gICAgbG9nID8gbG9nKCkgOiB0aGlzLmxvZyh2aWV3LCBcImpvaW5cIiwgKCkgPT4gW2BlbmNvdW50ZXJlZCAke3RyaWVzfSBjb25zZWN1dGl2ZSByZWxvYWRzYF0pXG4gICAgaWYodHJpZXMgPiB0aGlzLm1heFJlbG9hZHMpe1xuICAgICAgdGhpcy5sb2codmlldywgXCJqb2luXCIsICgpID0+IFtgZXhjZWVkZWQgJHt0aGlzLm1heFJlbG9hZHN9IGNvbnNlY3V0aXZlIHJlbG9hZHMuIEVudGVyaW5nIGZhaWxzYWZlIG1vZGVgXSlcbiAgICAgIGFmdGVyTXMgPSB0aGlzLmZhaWxzYWZlSml0dGVyXG4gICAgfVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYodGhpcy5oYXNQZW5kaW5nTGluaygpKXtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gdGhpcy5wZW5kaW5nTGlua1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9XG4gICAgfSwgYWZ0ZXJNcylcbiAgfVxuXG4gIGdldEhvb2tDYWxsYmFja3MobmFtZSl7XG4gICAgcmV0dXJuIG5hbWUgJiYgbmFtZS5zdGFydHNXaXRoKFwiUGhvZW5peC5cIikgPyBIb29rc1tuYW1lLnNwbGl0KFwiLlwiKVsxXV0gOiB0aGlzLmhvb2tzW25hbWVdXG4gIH1cblxuICBpc1VubG9hZGVkKCl7IHJldHVybiB0aGlzLnVubG9hZGVkIH1cblxuICBpc0Nvbm5lY3RlZCgpeyByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSB9XG5cbiAgZ2V0QmluZGluZ1ByZWZpeCgpeyByZXR1cm4gdGhpcy5iaW5kaW5nUHJlZml4IH1cblxuICBiaW5kaW5nKGtpbmQpeyByZXR1cm4gYCR7dGhpcy5nZXRCaW5kaW5nUHJlZml4KCl9JHtraW5kfWAgfVxuXG4gIGNoYW5uZWwodG9waWMsIHBhcmFtcyl7IHJldHVybiB0aGlzLnNvY2tldC5jaGFubmVsKHRvcGljLCBwYXJhbXMpIH1cblxuICBqb2luUm9vdFZpZXdzKCl7XG4gICAgbGV0IHJvb3RzRm91bmQgPSBmYWxzZVxuICAgIERPTS5hbGwoZG9jdW1lbnQsIGAke1BIWF9WSUVXX1NFTEVDVE9SfTpub3QoWyR7UEhYX1BBUkVOVF9JRH1dKWAsIHJvb3RFbCA9PiB7XG4gICAgICBpZighdGhpcy5nZXRSb290QnlJZChyb290RWwuaWQpKXtcbiAgICAgICAgbGV0IHZpZXcgPSB0aGlzLm5ld1Jvb3RWaWV3KHJvb3RFbClcbiAgICAgICAgdmlldy5zZXRIcmVmKHRoaXMuZ2V0SHJlZigpKVxuICAgICAgICB2aWV3LmpvaW4oKVxuICAgICAgICBpZihyb290RWwuZ2V0QXR0cmlidXRlKFBIWF9NQUlOKSl7IHRoaXMubWFpbiA9IHZpZXcgfVxuICAgICAgfVxuICAgICAgcm9vdHNGb3VuZCA9IHRydWVcbiAgICB9KVxuICAgIHJldHVybiByb290c0ZvdW5kXG4gIH1cblxuICByZWRpcmVjdCh0bywgZmxhc2gpe1xuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgQnJvd3Nlci5yZWRpcmVjdCh0bywgZmxhc2gpXG4gIH1cblxuICByZXBsYWNlTWFpbihocmVmLCBmbGFzaCwgY2FsbGJhY2sgPSBudWxsLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSl7XG4gICAgbGV0IG9sZE1haW5FbCA9IHRoaXMubWFpbi5lbFxuICAgIGxldCBuZXdNYWluRWwgPSBET00uY2xvbmVOb2RlKG9sZE1haW5FbCwgXCJcIilcbiAgICB0aGlzLm1haW4uc2hvd0xvYWRlcih0aGlzLmxvYWRlclRpbWVvdXQpXG4gICAgdGhpcy5tYWluLmRlc3Ryb3koKVxuXG4gICAgdGhpcy5tYWluID0gdGhpcy5uZXdSb290VmlldyhuZXdNYWluRWwsIGZsYXNoKVxuICAgIHRoaXMubWFpbi5zZXRSZWRpcmVjdChocmVmKVxuICAgIHRoaXMudHJhbnNpdGlvblJlbW92ZXMoKVxuICAgIHRoaXMubWFpbi5qb2luKChqb2luQ291bnQsIG9uRG9uZSkgPT4ge1xuICAgICAgaWYoam9pbkNvdW50ID09PSAxICYmIHRoaXMuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpe1xuICAgICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIERPTS5maW5kUGh4U3RpY2t5KGRvY3VtZW50KS5mb3JFYWNoKGVsID0+IG5ld01haW5FbC5hcHBlbmRDaGlsZChlbCkpXG4gICAgICAgICAgb2xkTWFpbkVsLnJlcGxhY2VXaXRoKG5ld01haW5FbClcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgICAgICAgb25Eb25lKClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdHJhbnNpdGlvblJlbW92ZXMoZWxlbWVudHMpe1xuICAgIGxldCByZW1vdmVBdHRyID0gdGhpcy5iaW5kaW5nKFwicmVtb3ZlXCIpXG4gICAgZWxlbWVudHMgPSBlbGVtZW50cyB8fCBET00uYWxsKGRvY3VtZW50LCBgWyR7cmVtb3ZlQXR0cn1dYClcbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGlmKGRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpKXsgLy8gc2tpcCBjaGlsZHJlbiBhbHJlYWR5IHJlbW92ZWRcbiAgICAgICAgdGhpcy5leGVjSlMoZWwsIGVsLmdldEF0dHJpYnV0ZShyZW1vdmVBdHRyKSwgXCJyZW1vdmVcIilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaXNQaHhWaWV3KGVsKXsgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsIH1cblxuICBuZXdSb290VmlldyhlbCwgZmxhc2gpe1xuICAgIGxldCB2aWV3ID0gbmV3IFZpZXcoZWwsIHRoaXMsIG51bGwsIGZsYXNoKVxuICAgIHRoaXMucm9vdHNbdmlldy5pZF0gPSB2aWV3XG4gICAgcmV0dXJuIHZpZXdcbiAgfVxuXG4gIG93bmVyKGNoaWxkRWwsIGNhbGxiYWNrKXtcbiAgICBsZXQgdmlldyA9IG1heWJlKGNoaWxkRWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIGVsID0+IHRoaXMuZ2V0Vmlld0J5RWwoZWwpKSB8fCB0aGlzLm1haW5cbiAgICBpZih2aWV3KXsgY2FsbGJhY2sodmlldykgfVxuICB9XG5cbiAgd2l0aGluT3duZXJzKGNoaWxkRWwsIGNhbGxiYWNrKXtcbiAgICB0aGlzLm93bmVyKGNoaWxkRWwsIHZpZXcgPT4gY2FsbGJhY2sodmlldywgY2hpbGRFbCkpXG4gIH1cblxuICBnZXRWaWV3QnlFbChlbCl7XG4gICAgbGV0IHJvb3RJZCA9IGVsLmdldEF0dHJpYnV0ZShQSFhfUk9PVF9JRClcbiAgICByZXR1cm4gbWF5YmUodGhpcy5nZXRSb290QnlJZChyb290SWQpLCByb290ID0+IHJvb3QuZ2V0RGVzY2VuZGVudEJ5RWwoZWwpKVxuICB9XG5cbiAgZ2V0Um9vdEJ5SWQoaWQpeyByZXR1cm4gdGhpcy5yb290c1tpZF0gfVxuXG4gIGRlc3Ryb3lBbGxWaWV3cygpe1xuICAgIGZvcihsZXQgaWQgaW4gdGhpcy5yb290cyl7XG4gICAgICB0aGlzLnJvb3RzW2lkXS5kZXN0cm95KClcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3RzW2lkXVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lWaWV3QnlFbChlbCl7XG4gICAgbGV0IHJvb3QgPSB0aGlzLmdldFJvb3RCeUlkKGVsLmdldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCkpXG4gICAgaWYocm9vdCAmJiByb290LmlkID09PSBlbC5pZCl7XG4gICAgICByb290LmRlc3Ryb3koKVxuICAgICAgZGVsZXRlIHRoaXMucm9vdHNbcm9vdC5pZF1cbiAgICB9IGVsc2UgaWYocm9vdCl7XG4gICAgICByb290LmRlc3Ryb3lEZXNjZW5kZW50KGVsLmlkKVxuICAgIH1cbiAgfVxuXG4gIHNldEFjdGl2ZUVsZW1lbnQodGFyZ2V0KXtcbiAgICBpZih0aGlzLmFjdGl2ZUVsZW1lbnQgPT09IHRhcmdldCl7IHJldHVybiB9XG4gICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gdGFyZ2V0XG4gICAgbGV0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgIGlmKHRhcmdldCA9PT0gdGhpcy5hY3RpdmVFbGVtZW50KXsgdGhpcy5hY3RpdmVFbGVtZW50ID0gbnVsbCB9XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcylcbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcylcbiAgICB9XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGNhbmNlbClcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGNhbmNlbClcbiAgfVxuXG4gIGdldEFjdGl2ZUVsZW1lbnQoKXtcbiAgICBpZihkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KXtcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiBiZSBudWxsIGluIEludGVybmV0IEV4cGxvcmVyIDExXG4gICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5XG4gICAgfVxuICB9XG5cbiAgZHJvcEFjdGl2ZUVsZW1lbnQodmlldyl7XG4gICAgaWYodGhpcy5wcmV2QWN0aXZlICYmIHZpZXcub3duc0VsZW1lbnQodGhpcy5wcmV2QWN0aXZlKSl7XG4gICAgICB0aGlzLnByZXZBY3RpdmUgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgcmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpe1xuICAgIGlmKHRoaXMucHJldkFjdGl2ZSAmJiB0aGlzLnByZXZBY3RpdmUgIT09IGRvY3VtZW50LmJvZHkpe1xuICAgICAgdGhpcy5wcmV2QWN0aXZlLmZvY3VzKClcbiAgICB9XG4gIH1cblxuICBibHVyQWN0aXZlRWxlbWVudCgpe1xuICAgIHRoaXMucHJldkFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlRWxlbWVudCgpXG4gICAgaWYodGhpcy5wcmV2QWN0aXZlICE9PSBkb2N1bWVudC5ib2R5KXsgdGhpcy5wcmV2QWN0aXZlLmJsdXIoKSB9XG4gIH1cblxuICBiaW5kVG9wTGV2ZWxFdmVudHMoKXtcbiAgICBpZih0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMpeyByZXR1cm4gfVxuXG4gICAgdGhpcy5ib3VuZFRvcExldmVsRXZlbnRzID0gdHJ1ZVxuICAgIC8vIGVudGVyIGZhaWxzYWZlIHJlbG9hZCBpZiBzZXJ2ZXIgaGFzIGdvbmUgYXdheSBpbnRlbnRpb25hbGx5LCBzdWNoIGFzIFwiZGlzY29ubmVjdFwiIGJyb2FkY2FzdFxuICAgIHRoaXMuc29ja2V0Lm9uQ2xvc2UoZXZlbnQgPT4ge1xuICAgICAgaWYoZXZlbnQuY29kZSA9PT0gMTAwMCAmJiB0aGlzLm1haW4pe1xuICAgICAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXIodGhpcy5tYWluKVxuICAgICAgfVxuICAgIH0pXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCl7IH0pIC8vIGVuc3VyZSBhbGwgY2xpY2sgZXZlbnRzIGJ1YmJsZSBmb3IgbW9iaWxlIFNhZmFyaVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIiwgZSA9PiB7XG4gICAgICBpZihlLnBlcnNpc3RlZCl7IC8vIHJlbG9hZCBwYWdlIGlmIGJlaW5nIHJlc3RvcmVkIGZyb20gYmFjay9mb3J3YXJkIGNhY2hlXG4gICAgICAgIHRoaXMuZ2V0U29ja2V0KCkuZGlzY29ubmVjdCgpXG4gICAgICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzogd2luZG93LmxvY2F0aW9uLmhyZWYsIGtpbmQ6IFwicmVkaXJlY3RcIn0pXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0sIHRydWUpXG4gICAgdGhpcy5iaW5kTmF2KClcbiAgICB0aGlzLmJpbmRDbGlja3MoKVxuICAgIHRoaXMuYmluZEZvcm1zKClcbiAgICB0aGlzLmJpbmQoe2tleXVwOiBcImtleXVwXCIsIGtleWRvd246IFwia2V5ZG93blwifSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCBwaHhFdmVudCwgZXZlbnRUYXJnZXQpID0+IHtcbiAgICAgIGxldCBtYXRjaEtleSA9IHRhcmdldEVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0tFWSkpXG4gICAgICBsZXQgcHJlc3NlZEtleSA9IGUua2V5ICYmIGUua2V5LnRvTG93ZXJDYXNlKCkgLy8gY2hyb21lIGNsaWNrZWQgYXV0b2NvbXBsZXRlcyBzZW5kIGEga2V5ZG93biB3aXRob3V0IGtleVxuICAgICAgaWYobWF0Y2hLZXkgJiYgbWF0Y2hLZXkudG9Mb3dlckNhc2UoKSAhPT0gcHJlc3NlZEtleSl7IHJldHVybiB9XG5cbiAgICAgIGxldCBkYXRhID0ge2tleTogZS5rZXksIC4uLnRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldEVsKX1cbiAgICAgIEpTLmV4ZWModHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHtkYXRhfV0pXG4gICAgfSlcbiAgICB0aGlzLmJpbmQoe2JsdXI6IFwiZm9jdXNvdXRcIiwgZm9jdXM6IFwiZm9jdXNpblwifSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCBwaHhFdmVudCwgZXZlbnRUYXJnZXQpID0+IHtcbiAgICAgIGlmKCFldmVudFRhcmdldCl7XG4gICAgICAgIGxldCBkYXRhID0ge2tleTogZS5rZXksIC4uLnRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldEVsKX1cbiAgICAgICAgSlMuZXhlYyh0eXBlLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0RWwsIFtcInB1c2hcIiwge2RhdGF9XSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuYmluZCh7Ymx1cjogXCJibHVyXCIsIGZvY3VzOiBcImZvY3VzXCJ9LCAoZSwgdHlwZSwgdmlldywgdGFyZ2V0RWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIHBoeFRhcmdldCkgPT4ge1xuICAgICAgLy8gYmx1ciBhbmQgZm9jdXMgYXJlIHRyaWdnZXJlZCBvbiBkb2N1bWVudCBhbmQgd2luZG93LiBEaXNjYXJkIG9uZSB0byBhdm9pZCBkdXBzXG4gICAgICBpZihwaHhUYXJnZXQgPT09IFwid2luZG93XCIpe1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldEVsKVxuICAgICAgICBKUy5leGVjKHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgICAgfVxuICAgIH0pXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCBlID0+IGUucHJldmVudERlZmF1bHQoKSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGxldCBkcm9wVGFyZ2V0SWQgPSBtYXliZShjbG9zZXN0UGh4QmluZGluZyhlLnRhcmdldCwgdGhpcy5iaW5kaW5nKFBIWF9EUk9QX1RBUkdFVCkpLCB0cnVlVGFyZ2V0ID0+IHtcbiAgICAgICAgcmV0dXJuIHRydWVUYXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpKVxuICAgICAgfSlcbiAgICAgIGxldCBkcm9wVGFyZ2V0ID0gZHJvcFRhcmdldElkICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRyb3BUYXJnZXRJZClcbiAgICAgIGxldCBmaWxlcyA9IEFycmF5LmZyb20oZS5kYXRhVHJhbnNmZXIuZmlsZXMgfHwgW10pXG4gICAgICBpZighZHJvcFRhcmdldCB8fCBkcm9wVGFyZ2V0LmRpc2FibGVkIHx8IGZpbGVzLmxlbmd0aCA9PT0gMCB8fCAhKGRyb3BUYXJnZXQuZmlsZXMgaW5zdGFuY2VvZiBGaWxlTGlzdCkpeyByZXR1cm4gfVxuXG4gICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyhkcm9wVGFyZ2V0LCBmaWxlcylcbiAgICAgIGRyb3BUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiLCB7YnViYmxlczogdHJ1ZX0pKVxuICAgIH0pXG4gICAgdGhpcy5vbihQSFhfVFJBQ0tfVVBMT0FEUywgZSA9PiB7XG4gICAgICBsZXQgdXBsb2FkVGFyZ2V0ID0gZS50YXJnZXRcbiAgICAgIGlmKCFET00uaXNVcGxvYWRJbnB1dCh1cGxvYWRUYXJnZXQpKXsgcmV0dXJuIH1cbiAgICAgIGxldCBmaWxlcyA9IEFycmF5LmZyb20oZS5kZXRhaWwuZmlsZXMgfHwgW10pLmZpbHRlcihmID0+IGYgaW5zdGFuY2VvZiBGaWxlIHx8IGYgaW5zdGFuY2VvZiBCbG9iKVxuICAgICAgTGl2ZVVwbG9hZGVyLnRyYWNrRmlsZXModXBsb2FkVGFyZ2V0LCBmaWxlcylcbiAgICAgIHVwbG9hZFRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIsIHtidWJibGVzOiB0cnVlfSkpXG4gICAgfSlcbiAgfVxuXG4gIGV2ZW50TWV0YShldmVudE5hbWUsIGUsIHRhcmdldEVsKXtcbiAgICBsZXQgY2FsbGJhY2sgPSB0aGlzLm1ldGFkYXRhQ2FsbGJhY2tzW2V2ZW50TmFtZV1cbiAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhlLCB0YXJnZXRFbCkgOiB7fVxuICB9XG5cbiAgc2V0UGVuZGluZ0xpbmsoaHJlZil7XG4gICAgdGhpcy5saW5rUmVmKytcbiAgICB0aGlzLnBlbmRpbmdMaW5rID0gaHJlZlxuICAgIHJldHVybiB0aGlzLmxpbmtSZWZcbiAgfVxuXG4gIGNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpe1xuICAgIGlmKHRoaXMubGlua1JlZiAhPT0gbGlua1JlZil7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ocmVmID0gdGhpcy5wZW5kaW5nTGlua1xuICAgICAgdGhpcy5wZW5kaW5nTGluayA9IG51bGxcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgZ2V0SHJlZigpeyByZXR1cm4gdGhpcy5ocmVmIH1cblxuICBoYXNQZW5kaW5nTGluaygpeyByZXR1cm4gISF0aGlzLnBlbmRpbmdMaW5rIH1cblxuICBiaW5kKGV2ZW50cywgY2FsbGJhY2spe1xuICAgIGZvcihsZXQgZXZlbnQgaW4gZXZlbnRzKXtcbiAgICAgIGxldCBicm93c2VyRXZlbnROYW1lID0gZXZlbnRzW2V2ZW50XVxuXG4gICAgICB0aGlzLm9uKGJyb3dzZXJFdmVudE5hbWUsIGUgPT4ge1xuICAgICAgICBsZXQgYmluZGluZyA9IHRoaXMuYmluZGluZyhldmVudClcbiAgICAgICAgbGV0IHdpbmRvd0JpbmRpbmcgPSB0aGlzLmJpbmRpbmcoYHdpbmRvdy0ke2V2ZW50fWApXG4gICAgICAgIGxldCB0YXJnZXRQaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoYmluZGluZylcbiAgICAgICAgaWYodGFyZ2V0UGh4RXZlbnQpe1xuICAgICAgICAgIHRoaXMuZGVib3VuY2UoZS50YXJnZXQsIGUsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZXZlbnQsIHZpZXcsIGUudGFyZ2V0LCB0YXJnZXRQaHhFdmVudCwgbnVsbClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7d2luZG93QmluZGluZ31dYCwgZWwgPT4ge1xuICAgICAgICAgICAgbGV0IHBoeEV2ZW50ID0gZWwuZ2V0QXR0cmlidXRlKHdpbmRvd0JpbmRpbmcpXG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlKGVsLCBlLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGVsLCB2aWV3ID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlLCBldmVudCwgdmlldywgZWwsIHBoeEV2ZW50LCBcIndpbmRvd1wiKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGJpbmRDbGlja3MoKXtcbiAgICB0aGlzLmJpbmRDbGljayhcImNsaWNrXCIsIFwiY2xpY2tcIiwgZmFsc2UpXG4gICAgdGhpcy5iaW5kQ2xpY2soXCJtb3VzZWRvd25cIiwgXCJjYXB0dXJlLWNsaWNrXCIsIHRydWUpXG4gIH1cblxuICBiaW5kQ2xpY2soZXZlbnROYW1lLCBiaW5kaW5nTmFtZSwgY2FwdHVyZSl7XG4gICAgbGV0IGNsaWNrID0gdGhpcy5iaW5kaW5nKGJpbmRpbmdOYW1lKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZSA9PiB7XG4gICAgICBpZighdGhpcy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIH1cbiAgICAgIHRoaXMuY2xpY2tSZWYrK1xuICAgICAgbGV0IGNsaWNrUmVmV2FzID0gdGhpcy5jbGlja1JlZlxuICAgICAgbGV0IHRhcmdldCA9IG51bGxcbiAgICAgIGlmKGNhcHR1cmUpe1xuICAgICAgICB0YXJnZXQgPSBlLnRhcmdldC5tYXRjaGVzKGBbJHtjbGlja31dYCkgPyBlLnRhcmdldCA6IGUudGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoYFske2NsaWNrfV1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIGNsaWNrKVxuICAgICAgICB0aGlzLmRpc3BhdGNoQ2xpY2tBd2F5KGUsIGNsaWNrUmVmV2FzKVxuICAgICAgfVxuICAgICAgbGV0IHBoeEV2ZW50ID0gdGFyZ2V0ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoY2xpY2spXG4gICAgICBpZighcGh4RXZlbnQpeyByZXR1cm4gfVxuICAgICAgaWYodGFyZ2V0LmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiKXsgZS5wcmV2ZW50RGVmYXVsdCgpIH1cblxuICAgICAgdGhpcy5kZWJvdW5jZSh0YXJnZXQsIGUsICgpID0+IHtcbiAgICAgICAgdGhpcy53aXRoaW5Pd25lcnModGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgICBKUy5leGVjKFwiY2xpY2tcIiwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldCwgW1wicHVzaFwiLCB7ZGF0YTogdGhpcy5ldmVudE1ldGEoXCJjbGlja1wiLCBlLCB0YXJnZXQpfV0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0sIGNhcHR1cmUpXG4gIH1cblxuICBkaXNwYXRjaENsaWNrQXdheShlLCBjbGlja1JlZldhcyl7XG4gICAgbGV0IHBoeENsaWNrQXdheSA9IHRoaXMuYmluZGluZyhcImNsaWNrLWF3YXlcIilcbiAgICBsZXQgcGh4Q2xpY2sgPSB0aGlzLmJpbmRpbmcoXCJjbGlja1wiKVxuICAgIERPTS5hbGwoZG9jdW1lbnQsIGBbJHtwaHhDbGlja0F3YXl9XWAsIGVsID0+IHtcbiAgICAgIGlmKCEoZWwuaXNTYW1lTm9kZShlLnRhcmdldCkgfHwgZWwuY29udGFpbnMoZS50YXJnZXQpKSl7XG4gICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgICBsZXQgcGh4RXZlbnQgPSBlbC5nZXRBdHRyaWJ1dGUocGh4Q2xpY2tBd2F5KVxuICAgICAgICAgIGlmKEpTLmlzVmlzaWJsZShlbCkpe1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGUudGFyZ2V0LmNsb3Nlc3QoYFske3BoeENsaWNrfV1gKSB8fCBlLnRhcmdldFxuICAgICAgICAgICAgSlMuZXhlYyhcImNsaWNrXCIsIHBoeEV2ZW50LCB2aWV3LCBlbCwgW1wicHVzaFwiLCB7ZGF0YTogdGhpcy5ldmVudE1ldGEoXCJjbGlja1wiLCBlLCBlLnRhcmdldCl9XSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGJpbmROYXYoKXtcbiAgICBpZighQnJvd3Nlci5jYW5QdXNoU3RhdGUoKSl7IHJldHVybiB9XG4gICAgaWYoaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbil7IGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiIH1cbiAgICBsZXQgc2Nyb2xsVGltZXIgPSBudWxsXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgX2UgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVyKVxuICAgICAgc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgQnJvd3Nlci51cGRhdGVDdXJyZW50U3RhdGUoc3RhdGUgPT4gT2JqZWN0LmFzc2lnbihzdGF0ZSwge3Njcm9sbDogd2luZG93LnNjcm9sbFl9KSlcbiAgICAgIH0sIDEwMClcbiAgICB9KVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgZXZlbnQgPT4ge1xuICAgICAgaWYoIXRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pKXsgcmV0dXJuIH1cbiAgICAgIGxldCB7dHlwZSwgaWQsIHJvb3QsIHNjcm9sbH0gPSBldmVudC5zdGF0ZSB8fCB7fVxuICAgICAgbGV0IGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuXG4gICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZih0aGlzLm1haW4uaXNDb25uZWN0ZWQoKSAmJiAodHlwZSA9PT0gXCJwYXRjaFwiICYmIGlkID09PSB0aGlzLm1haW4uaWQpKXtcbiAgICAgICAgICB0aGlzLm1haW4ucHVzaExpbmtQYXRjaChocmVmLCBudWxsKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYocm9vdCl7IHRoaXMucmVwbGFjZVJvb3RIaXN0b3J5KCkgfVxuICAgICAgICAgICAgaWYodHlwZW9mKHNjcm9sbCkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc2Nyb2xsKVxuICAgICAgICAgICAgICB9LCAwKSAvLyB0aGUgYm9keSBuZWVkcyB0byByZW5kZXIgYmVmb3JlIHdlIHNjcm9sbC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgICBsZXQgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIFBIWF9MSVZFX0xJTkspXG4gICAgICBsZXQgdHlwZSA9IHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSVZFX0xJTkspXG4gICAgICBsZXQgd2FudHNOZXdUYWIgPSBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuYnV0dG9uID09PSAxXG4gICAgICBpZighdHlwZSB8fCAhdGhpcy5pc0Nvbm5lY3RlZCgpIHx8ICF0aGlzLm1haW4gfHwgd2FudHNOZXdUYWIpeyByZXR1cm4gfVxuICAgICAgbGV0IGhyZWYgPSB0YXJnZXQuaHJlZlxuICAgICAgbGV0IGxpbmtTdGF0ZSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoUEhYX0xJTktfU1RBVEUpXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGlmKHRoaXMucGVuZGluZ0xpbmsgPT09IGhyZWYpeyByZXR1cm4gfVxuXG4gICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICBpZih0eXBlID09PSBcInBhdGNoXCIpe1xuICAgICAgICAgIHRoaXMucHVzaEhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIHRhcmdldClcbiAgICAgICAgfSBlbHNlIGlmKHR5cGUgPT09IFwicmVkaXJlY3RcIil7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5UmVkaXJlY3QoaHJlZiwgbGlua1N0YXRlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHtQSFhfTElWRV9MSU5LfSB0byBiZSBcInBhdGNoXCIgb3IgXCJyZWRpcmVjdFwiLCBnb3Q6ICR7dHlwZX1gKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuICB9XG5cbiAgZGlzcGF0Y2hFdmVudChldmVudCwgcGF5bG9hZCA9IHt9KXtcbiAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIGBwaHg6JHtldmVudH1gLCBwYXlsb2FkKVxuICB9XG5cbiAgZGlzcGF0Y2hFdmVudHMoZXZlbnRzKXtcbiAgICBldmVudHMuZm9yRWFjaCgoW2V2ZW50LCBwYXlsb2FkXSkgPT4gdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50LCBwYXlsb2FkKSlcbiAgfVxuXG4gIHdpdGhQYWdlTG9hZGluZyhpbmZvLCBjYWxsYmFjayl7XG4gICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwgaW5mbylcbiAgICBsZXQgZG9uZSA9ICgpID0+IERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwgaW5mbylcbiAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhkb25lKSA6IGRvbmVcbiAgfVxuXG4gIHB1c2hIaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCB0YXJnZXRFbCl7XG4gICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiBocmVmLCBraW5kOiBcInBhdGNoXCJ9LCBkb25lID0+IHtcbiAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGhyZWYsIHRhcmdldEVsLCBsaW5rUmVmID0+IHtcbiAgICAgICAgdGhpcy5oaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmKVxuICAgICAgICBkb25lKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIGxpbmtSZWYgPSB0aGlzLnNldFBlbmRpbmdMaW5rKGhyZWYpKXtcbiAgICBpZighdGhpcy5jb21taXRQZW5kaW5nTGluayhsaW5rUmVmKSl7IHJldHVybiB9XG5cbiAgICBCcm93c2VyLnB1c2hTdGF0ZShsaW5rU3RhdGUsIHt0eXBlOiBcInBhdGNoXCIsIGlkOiB0aGlzLm1haW4uaWR9LCBocmVmKVxuICAgIHRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pXG4gIH1cblxuICBoaXN0b3J5UmVkaXJlY3QoaHJlZiwgbGlua1N0YXRlLCBmbGFzaCl7XG4gICAgbGV0IHNjcm9sbCA9IHdpbmRvdy5zY3JvbGxZXG4gICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiBocmVmLCBraW5kOiBcInJlZGlyZWN0XCJ9LCBkb25lID0+IHtcbiAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgZmxhc2gsICgpID0+IHtcbiAgICAgICAgQnJvd3Nlci5wdXNoU3RhdGUobGlua1N0YXRlLCB7dHlwZTogXCJyZWRpcmVjdFwiLCBpZDogdGhpcy5tYWluLmlkLCBzY3JvbGw6IHNjcm9sbH0sIGhyZWYpXG4gICAgICAgIHRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pXG4gICAgICAgIGRvbmUoKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcmVwbGFjZVJvb3RIaXN0b3J5KCl7XG4gICAgQnJvd3Nlci5wdXNoU3RhdGUoXCJyZXBsYWNlXCIsIHtyb290OiB0cnVlLCB0eXBlOiBcInBhdGNoXCIsIGlkOiB0aGlzLm1haW4uaWR9KVxuICB9XG5cbiAgcmVnaXN0ZXJOZXdMb2NhdGlvbihuZXdMb2NhdGlvbil7XG4gICAgbGV0IHtwYXRobmFtZSwgc2VhcmNofSA9IHRoaXMuY3VycmVudExvY2F0aW9uXG4gICAgaWYocGF0aG5hbWUgKyBzZWFyY2ggPT09IG5ld0xvY2F0aW9uLnBhdGhuYW1lICsgbmV3TG9jYXRpb24uc2VhcmNoKXtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGNsb25lKG5ld0xvY2F0aW9uKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBiaW5kRm9ybXMoKXtcbiAgICBsZXQgaXRlcmF0aW9ucyA9IDBcbiAgICB0aGlzLm9uKFwic3VibWl0XCIsIGUgPT4ge1xuICAgICAgbGV0IHBoeEV2ZW50ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInN1Ym1pdFwiKSlcbiAgICAgIGlmKCFwaHhFdmVudCl7IHJldHVybiB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGUudGFyZ2V0LmRpc2FibGVkID0gdHJ1ZVxuICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZS50YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICBKUy5leGVjKFwic3VibWl0XCIsIHBoeEV2ZW50LCB2aWV3LCBlLnRhcmdldCwgW1wicHVzaFwiLCB7fV0pXG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuXG4gICAgZm9yKGxldCB0eXBlIG9mIFtcImNoYW5nZVwiLCBcImlucHV0XCJdKXtcbiAgICAgIHRoaXMub24odHlwZSwgZSA9PiB7XG4gICAgICAgIGxldCBpbnB1dCA9IGUudGFyZ2V0XG4gICAgICAgIGxldCBwaHhFdmVudCA9IGlucHV0LmZvcm0gJiYgaW5wdXQuZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpKVxuICAgICAgICBpZighcGh4RXZlbnQpeyByZXR1cm4gfVxuICAgICAgICBpZihpbnB1dC50eXBlID09PSBcIm51bWJlclwiICYmIGlucHV0LnZhbGlkaXR5ICYmIGlucHV0LnZhbGlkaXR5LmJhZElucHV0KXsgcmV0dXJuIH1cbiAgICAgICAgbGV0IGN1cnJlbnRJdGVyYXRpb25zID0gaXRlcmF0aW9uc1xuICAgICAgICBpdGVyYXRpb25zKytcbiAgICAgICAgbGV0IHthdDogYXQsIHR5cGU6IGxhc3RUeXBlfSA9IERPTS5wcml2YXRlKGlucHV0LCBcInByZXYtaXRlcmF0aW9uXCIpIHx8IHt9XG4gICAgICAgIC8vIGRldGVjdCBkdXAgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGRpc3BhdGNoIGJvdGggXCJpbnB1dFwiIGFuZCBcImNoYW5nZVwiXG4gICAgICAgIGlmKGF0ID09PSBjdXJyZW50SXRlcmF0aW9ucyAtIDEgJiYgdHlwZSAhPT0gbGFzdFR5cGUpeyByZXR1cm4gfVxuXG4gICAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0LCBcInByZXYtaXRlcmF0aW9uXCIsIHthdDogY3VycmVudEl0ZXJhdGlvbnMsIHR5cGU6IHR5cGV9KVxuXG4gICAgICAgIHRoaXMuZGVib3VuY2UoaW5wdXQsIGUsICgpID0+IHtcbiAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhpbnB1dC5mb3JtLCB2aWV3ID0+IHtcbiAgICAgICAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQsIHRydWUpXG4gICAgICAgICAgICBpZighRE9NLmlzVGV4dHVhbElucHV0KGlucHV0KSl7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlRWxlbWVudChpbnB1dClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEpTLmV4ZWMoXCJjaGFuZ2VcIiwgcGh4RXZlbnQsIHZpZXcsIGlucHV0LCBbXCJwdXNoXCIsIHtfdGFyZ2V0OiBlLnRhcmdldC5uYW1lfV0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0sIGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIGRlYm91bmNlKGVsLCBldmVudCwgY2FsbGJhY2spe1xuICAgIGxldCBwaHhEZWJvdW5jZSA9IHRoaXMuYmluZGluZyhQSFhfREVCT1VOQ0UpXG4gICAgbGV0IHBoeFRocm90dGxlID0gdGhpcy5iaW5kaW5nKFBIWF9USFJPVFRMRSlcbiAgICBsZXQgZGVmYXVsdERlYm91bmNlID0gdGhpcy5kZWZhdWx0cy5kZWJvdW5jZS50b1N0cmluZygpXG4gICAgbGV0IGRlZmF1bHRUaHJvdHRsZSA9IHRoaXMuZGVmYXVsdHMudGhyb3R0bGUudG9TdHJpbmcoKVxuICAgIERPTS5kZWJvdW5jZShlbCwgZXZlbnQsIHBoeERlYm91bmNlLCBkZWZhdWx0RGVib3VuY2UsIHBoeFRocm90dGxlLCBkZWZhdWx0VGhyb3R0bGUsIGNhbGxiYWNrKVxuICB9XG5cbiAgc2lsZW5jZUV2ZW50cyhjYWxsYmFjayl7XG4gICAgdGhpcy5zaWxlbmNlZCA9IHRydWVcbiAgICBjYWxsYmFjaygpXG4gICAgdGhpcy5zaWxlbmNlZCA9IGZhbHNlXG4gIH1cblxuICBvbihldmVudCwgY2FsbGJhY2spe1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBlID0+IHtcbiAgICAgIGlmKCF0aGlzLnNpbGVuY2VkKXsgY2FsbGJhY2soZSkgfVxuICAgIH0pXG4gIH1cbn1cblxuY2xhc3MgVHJhbnNpdGlvblNldCB7XG4gIGNvbnN0cnVjdG9yKCl7XG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IG5ldyBTZXQoKVxuICAgIHRoaXMucGVuZGluZ09wcyA9IFtdXG4gICAgdGhpcy5yZXNldCgpXG4gIH1cblxuICByZXNldCgpe1xuICAgIHRoaXMudHJhbnNpdGlvbnMuZm9yRWFjaCh0aW1lciA9PiB7XG4gICAgICBjYW5jZWxUaW1lb3V0KHRpbWVyKVxuICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpXG4gICAgfSlcbiAgICB0aGlzLmZsdXNoUGVuZGluZ09wcygpXG4gIH1cblxuICBhZnRlcihjYWxsYmFjayl7XG4gICAgaWYodGhpcy5zaXplKCkgPT09IDApe1xuICAgICAgY2FsbGJhY2soKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hQZW5kaW5nT3AoY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgYWRkVHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpe1xuICAgIG9uU3RhcnQoKVxuICAgIGxldCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2l0aW9ucy5kZWxldGUodGltZXIpXG4gICAgICBvbkRvbmUoKVxuICAgICAgaWYodGhpcy5zaXplKCkgPT09IDApeyB0aGlzLmZsdXNoUGVuZGluZ09wcygpIH1cbiAgICB9LCB0aW1lKVxuICAgIHRoaXMudHJhbnNpdGlvbnMuYWRkKHRpbWVyKVxuICB9XG5cbiAgcHVzaFBlbmRpbmdPcChvcCl7IHRoaXMucGVuZGluZ09wcy5wdXNoKG9wKSB9XG5cbiAgc2l6ZSgpeyByZXR1cm4gdGhpcy50cmFuc2l0aW9ucy5zaXplIH1cblxuICBmbHVzaFBlbmRpbmdPcHMoKXtcbiAgICB0aGlzLnBlbmRpbmdPcHMuZm9yRWFjaChvcCA9PiBvcCgpKVxuICAgIHRoaXMucGVuZGluZ09wcyA9IFtdXG4gIH1cbn1cbiIsICIvLyBXZSBpbXBvcnQgdGhlIENTUyB3aGljaCBpcyBleHRyYWN0ZWQgdG8gaXRzIG93biBmaWxlIGJ5IGVzYnVpbGQuXHJcbi8vIFJlbW92ZSB0aGlzIGxpbmUgaWYgeW91IGFkZCBhIHlvdXIgb3duIENTUyBidWlsZCBwaXBlbGluZSAoZS5nIHBvc3Rjc3MpLlxyXG5pbXBvcnQgXCIuLi9jc3MvYXBwLmNzc1wiO1xyXG5cclxuLy8gSWYgeW91IHdhbnQgdG8gdXNlIFBob2VuaXggY2hhbm5lbHMsIHJ1biBgbWl4IGhlbHAgcGh4Lmdlbi5jaGFubmVsYFxyXG4vLyB0byBnZXQgc3RhcnRlZCBhbmQgdGhlbiB1bmNvbW1lbnQgdGhlIGxpbmUgYmVsb3cuXHJcbi8vIGltcG9ydCBcIi4vdXNlcl9zb2NrZXQuanNcIlxyXG5cclxuLy8gWW91IGNhbiBpbmNsdWRlIGRlcGVuZGVuY2llcyBpbiB0d28gd2F5cy5cclxuLy9cclxuLy8gVGhlIHNpbXBsZXN0IG9wdGlvbiBpcyB0byBwdXQgdGhlbSBpbiBhc3NldHMvdmVuZG9yIGFuZFxyXG4vLyBpbXBvcnQgdGhlbSB1c2luZyByZWxhdGl2ZSBwYXRoczpcclxuLy9cclxuLy8gICAgIGltcG9ydCBcIi4uL3ZlbmRvci9zb21lLXBhY2thZ2UuanNcIlxyXG4vL1xyXG4vLyBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIGBucG0gaW5zdGFsbCBzb21lLXBhY2thZ2UgLS1wcmVmaXggYXNzZXRzYCBhbmQgaW1wb3J0XHJcbi8vIHRoZW0gdXNpbmcgYSBwYXRoIHN0YXJ0aW5nIHdpdGggdGhlIHBhY2thZ2UgbmFtZTpcclxuLy9cclxuLy8gICAgIGltcG9ydCBcInNvbWUtcGFja2FnZVwiXHJcbi8vXHJcblxyXG5yZXF1aXJlKFwiYm9vdHN0cmFwLWljb25zL2ZvbnQvYm9vdHN0cmFwLWljb25zLmNzc1wiKTtcclxucmVxdWlyZShcIm1hdGVyaWFsLWljb25zL2ljb25mb250L21hdGVyaWFsLWljb25zLmNzc1wiKTtcclxuXHJcbi8vIGltcG9ydCAnYm9vdHN0cmFwLWljb25zL2ZvbnQvYm9vdHN0cmFwLWljb25zLmNzcyc7XHJcbi8vIGltcG9ydCAnbWF0ZXJpYWwtaWNvbnMvaWNvbmZvbnQvbWF0ZXJpYWwtaWNvbnMuY3NzJztcclxuXHJcbi8vIEluY2x1ZGUgcGhvZW5peF9odG1sIHRvIGhhbmRsZSBtZXRob2Q9UFVUL0RFTEVURSBpbiBmb3JtcyBhbmQgYnV0dG9ucy5cclxuaW1wb3J0IFwicGhvZW5peF9odG1sXCI7XHJcbi8vIEVzdGFibGlzaCBQaG9lbml4IFNvY2tldCBhbmQgTGl2ZVZpZXcgY29uZmlndXJhdGlvbi5cclxuaW1wb3J0IHsgU29ja2V0IH0gZnJvbSBcInBob2VuaXhcIjtcclxuaW1wb3J0IHsgTGl2ZVNvY2tldCB9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiO1xyXG5pbXBvcnQgeyBTb3J0YWJsZSwgUGx1Z2lucyB9IGZyb20gXCJAc2hvcGlmeS9kcmFnZ2FibGVcIjtcclxuaW1wb3J0IHRvcGJhciBmcm9tIFwiLi4vdmVuZG9yL3RvcGJhclwiO1xyXG5pbXBvcnQge1xyXG4gIERvdWdoTnV0Q2hhcnQsXHJcbiAgSG9yaXpvbnRhbEJhckNoYXJ0LFxyXG4gIFN0YWNrZWRCYXJDaGFydCxcclxuICBMaW5lQ2hhcnQsXHJcbiAgU3VydmV5Q2hhcnRcclxufSBmcm9tIFwiLi9jaGFydC5qc1wiO1xyXG5pbXBvcnQgY2hhcnQgZnJvbSBcImNoYXJ0LmpzL2Rpc3QvY2hhcnRcIjtcclxuXHJcbmNvbnN0IEhvb2tzID0ge307XHJcblxyXG4vLyBIb29rcy5Eb3VnaE51dENoYXJ0ID0ge1xyXG4vLyAgIG1vdW50ZWQoKSB7XHJcbi8vICAgICBjb25zdCB7IGxhYmVsc190YXNrc19ieV9jb250cmlidXRvcnMsIHZhbHVlc190YXNrc19ieV9jb250cmlidXRvcnMgfSA9IEpTT04ucGFyc2UodGhpcy5lbC5kYXRhc2V0LmNoYXJ0RGF0YSlcclxuLy8gICAgIHRoaXMuY2hhcnQgPSBuZXcgRG91Z2hOdXRDaGFydCh0aGlzLmVsLCBsYWJlbHNfdGFza3NfYnlfY29udHJpYnV0b3JzLCB2YWx1ZXNfdGFza3NfYnlfY29udHJpYnV0b3JzKVxyXG4vLyAgIH1cclxuLy8gfVxyXG5cclxuSG9va3MuSG9yaXpvbnRhbEJhckNoYXJ0ID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICBjb25zdCB7IGxhYmVsc190YXNrc19ieV9jb250cmlidXRvcnMsIHZhbHVlc190YXNrc19ieV9jb250cmlidXRvcnMgfSA9XHJcbiAgICAgIEpTT04ucGFyc2UodGhpcy5lbC5kYXRhc2V0LmNoYXJ0RGF0YSk7XHJcbiAgICB0aGlzLmNoYXJ0ID0gbmV3IEhvcml6b250YWxCYXJDaGFydChcclxuICAgICAgdGhpcy5lbCxcclxuICAgICAgbGFiZWxzX3Rhc2tzX2J5X2NvbnRyaWJ1dG9ycyxcclxuICAgICAgdmFsdWVzX3Rhc2tzX2J5X2NvbnRyaWJ1dG9yc1xyXG4gICAgKTtcclxuICB9LFxyXG59O1xyXG5cclxuSG9va3MuU3RhY2tlZEJhckNoYXJ0ID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHZhbHVlc190YXNrc190b2RvX2J5X21vbnRoLFxyXG4gICAgICB2YWx1ZXNfYmxvY2tpbmdfdGFza3NfYnlfbW9udGgsXHJcbiAgICAgIHZhbHVlc190YXNrc19pbl9wcm9ncmVzc19ieV9tb250aCxcclxuICAgICAgdmFsdWVzX3Rhc2tzX2luX2NvbnRyb2xfYnlfbW9udGgsXHJcbiAgICAgIHZhbHVlc190YXNrc19hY2hpZXZlZF9ieV9tb250aCxcclxuICAgIH0gPSBKU09OLnBhcnNlKHRoaXMuZWwuZGF0YXNldC5jaGFydERhdGEpO1xyXG4gICAgdGhpcy5jaGFydCA9IG5ldyBTdGFja2VkQmFyQ2hhcnQoXHJcbiAgICAgIHRoaXMuZWwsXHJcbiAgICAgIHZhbHVlc190YXNrc190b2RvX2J5X21vbnRoLFxyXG4gICAgICB2YWx1ZXNfYmxvY2tpbmdfdGFza3NfYnlfbW9udGgsXHJcbiAgICAgIHZhbHVlc190YXNrc19pbl9wcm9ncmVzc19ieV9tb250aCxcclxuICAgICAgdmFsdWVzX3Rhc2tzX2luX2NvbnRyb2xfYnlfbW9udGgsXHJcbiAgICAgIHZhbHVlc190YXNrc19hY2hpZXZlZF9ieV9tb250aFxyXG4gICAgKTtcclxuICB9LFxyXG59O1xyXG5cclxuXHJcbkhvb2tzLlN1cnZleUNoYXJ0ID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcImlzIG1vdW50ZWRcIik7XHJcblxyXG4gICAgY29uc3QgeyB2YWx1ZXMgfSA9IEpTT04ucGFyc2UodGhpcy5lbC5kYXRhc2V0LmNoYXJ0RGF0YSk7XHJcblxyXG4gICAgdGhpcy5teWNoYXJ0ID0gbmV3IFN1cnZleUNoYXJ0KHRoaXMuZWwsIHZhbHVlcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gSG9va3MuTGluZUNoYXJ0ID0ge1xyXG4vLyAgIG1vdW50ZWQoKSB7XHJcbi8vICAgICBjb25zdCB7IHZhbHVlc190YXNrc190b2RvX2J5X21vbnRoLCB2YWx1ZXNfYmxvY2tpbmdfdGFza3NfYnlfbW9udGgsIHZhbHVlc190YXNrc19pbl9wcm9ncmVzc19ieV9tb250aCwgdmFsdWVzX3Rhc2tzX2luX2NvbnRyb2xfYnlfbW9udGgsIHZhbHVlc190YXNrc19hY2hpZXZlZF9ieV9tb250aCB9ID0gSlNPTi5wYXJzZSh0aGlzLmVsLmRhdGFzZXQuY2hhcnREYXRhKVxyXG4vLyAgICAgdGhpcy5jaGFydCA9IG5ldyBMaW5lQ2hhcnQodGhpcy5lbCwgdmFsdWVzX3Rhc2tzX3RvZG9fYnlfbW9udGgsIHZhbHVlc19ibG9ja2luZ190YXNrc19ieV9tb250aCwgdmFsdWVzX3Rhc2tzX2luX3Byb2dyZXNzX2J5X21vbnRoLCB2YWx1ZXNfdGFza3NfaW5fY29udHJvbF9ieV9tb250aCwgdmFsdWVzX3Rhc2tzX2FjaGlldmVkX2J5X21vbnRoKVxyXG4vLyAgIH1cclxuLy8gfVxyXG5cclxuSG9va3MuQm9hcmQgPSB7XHJcbiAgbW91bnRlZCgpIHtcclxuICAgIHRoaXMuaW5pdERyYWdnYWJsZXMoKTtcclxuICB9LFxyXG5cclxuICB1cGRhdGVkKCkge1xyXG4gICAgdGhpcy5zb3J0YWJsZUNhcmQuZGVzdHJveSgpO1xyXG4gICAgdGhpcy5zb3J0YWJsZVN0YWdlLmRlc3Ryb3koKTtcclxuICAgIHRoaXMuaW5pdERyYWdnYWJsZXMoKTtcclxuICB9LFxyXG5cclxuICBpbml0RHJhZ2dhYmxlcygpIHtcclxuICAgIHRoaXMuc29ydGFibGVDYXJkID0gbmV3IFNvcnRhYmxlKFxyXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnN0YWdlX19jYXJkc1wiKSxcclxuICAgICAge1xyXG4gICAgICAgIGRyYWdnYWJsZTogXCIuY2FyZFwiLFxyXG4gICAgICAgIG1pcnJvcjoge1xyXG4gICAgICAgICAgY29uc3RyYWluRGltZW5zaW9uczogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN3YXBBbmltYXRpb246IHtcclxuICAgICAgICAgIGR1cmF0aW9uOiAyMDAsXHJcbiAgICAgICAgICBlYXNpbmdGdW5jdGlvbjogXCJlYXNlLWluLW91dFwiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGx1Z2luczogW1BsdWdpbnMuU3dhcEFuaW1hdGlvbl0sXHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5zb3J0YWJsZUNhcmQub24oXCJzb3J0YWJsZTpzdG9wXCIsIChldmVudCkgPT4ge1xyXG4gICAgICBjb25zdCBzb3VyY2UgPSBldmVudC5kYXRhLmRyYWdFdmVudC5kYXRhLnNvdXJjZTtcclxuICAgICAgY29uc3QgY2FyZElkID0gcGFyc2VJbnQoc291cmNlLmdldEF0dHJpYnV0ZShcImRhdGEtY2FyZC1pZFwiKSk7XHJcbiAgICAgIGNvbnN0IG5ld1N0YWdlSWQgPSBwYXJzZUludChcclxuICAgICAgICBldmVudC5kYXRhLm5ld0NvbnRhaW5lci5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN0YWdlLWlkXCIpXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gcGFyc2VJbnQoZXZlbnQuZGF0YS5uZXdJbmRleCk7XHJcbiAgICAgIGNvbnN0IGNhcmRQYXlsb2FkID0ge1xyXG4gICAgICAgIGNhcmQ6IHtcclxuICAgICAgICAgIGlkOiBjYXJkSWQsXHJcbiAgICAgICAgICBzdGFnZV9pZDogbmV3U3RhZ2VJZCxcclxuICAgICAgICAgIHBvc2l0aW9uOiBuZXdJbmRleCxcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnB1c2hFdmVudChcInVwZGF0ZV9jYXJkXCIsIGNhcmRQYXlsb2FkKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuc29ydGFibGVTdGFnZSA9IG5ldyBTb3J0YWJsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmJvYXJkXCIpLCB7XHJcbiAgICAgIGRyYWdnYWJsZTogXCIuc3RhZ2VcIixcclxuICAgICAgaGFuZGxlOiBcIi5kcmFnZ2FibGUtaGFuZGxlXCIsXHJcbiAgICAgIG1pcnJvcjoge1xyXG4gICAgICAgIGNvbnN0cmFpbkRpbWVuc2lvbnM6IHRydWUsXHJcbiAgICAgICAgeUF4aXM6IGZhbHNlLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5zb3J0YWJsZVN0YWdlLm9uKFwic29ydGFibGU6c3RvcFwiLCAoZXZlbnQpID0+IHtcclxuICAgICAgY29uc3Qgc291cmNlID0gZXZlbnQuZGF0YS5kcmFnRXZlbnQuZGF0YS5zb3VyY2U7XHJcbiAgICAgIGNvbnN0IHN0YWdlSWQgPSBwYXJzZUludChzb3VyY2UuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdGFnZS1pZFwiKSk7XHJcbiAgICAgIGNvbnN0IG5ld0luZGV4ID0gcGFyc2VJbnQoZXZlbnQuZGF0YS5uZXdJbmRleCk7XHJcbiAgICAgIGNvbnN0IHN0YWdlUGF5bG9hZCA9IHtcclxuICAgICAgICBzdGFnZToge1xyXG4gICAgICAgICAgaWQ6IHN0YWdlSWQsXHJcbiAgICAgICAgICBwb3NpdGlvbjogbmV3SW5kZXgsXHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5wdXNoRXZlbnQoXCJ1cGRhdGVfc3RhZ2VcIiwgc3RhZ2VQYXlsb2FkKTtcclxuICAgIH0pO1xyXG4gIH0sXHJcbn07XHJcblxyXG5Ib29rcy5BbmltYXRlQWxlcnQgPSB7XHJcbiAgbW91bnRlZCgpIHtcclxuICAgIC8vIGNvbnNvbGUubG9nKFwidGFmaWRpdHJhIGFsZXJ0XCIpXHJcbiAgICB0aGlzLmhhbmRsZUV2ZW50KFwiQW5pbWF0ZUFsZXJ0XCIsICh7fSkgPT4gdGhpcy5yZXNldF9vcGFjaXR5KCkpO1xyXG4gIH0sXHJcbiAgdXBkYXRlZCgpIHt9LFxyXG4gIHJlc2V0X29wYWNpdHkoKSB7XHJcbiAgICB2YXIgYWxlcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2FsZXJ0X2FuaW1cIik7XHJcbiAgICBhbGVydC5zdHlsZS5vcGFjaXR5ID0gMTtcclxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgLyogYWxlcnQuc3R5bGUub3BhY2l0eSA9IDA7ICovXHJcbiAgICAgIGFsZXJ0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgIH0sIDIwMDApO1xyXG4gIH0sXHJcbiAgYW5pbV9vbmxvYWQoKSB7XHJcbiAgICB2YXIgYWxlcnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5hbGVydFwiKTtcclxuICAgIC8vICBjb25zb2xlLmxvZyhhbGVydHMpO1xyXG5cclxuICAgIGFsZXJ0cy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgIGl0ZW0uc3R5bGUub3BhY2l0eSA9IDE7XHJcbiAgICAgIGl0ZW0ub25sb2FkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGl0ZW0uc3R5bGUub3BhY2l0eSA9IDA7XHJcbiAgICAgIH0sIDIwMDApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGVydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgYWxlcnRzW2ldLnN0eWxlLm9wYWNpdHkgPSAxO1xyXG4gICAgICBhbGVydHNbaV0ub25sb2FkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFsZXJ0c1tpXS5zdHlsZS5vcGFjaXR5ID0gMDtcclxuICAgICAgfSwgMjAwMCk7XHJcbiAgICB9XHJcbiAgfSxcclxufTtcclxuXHJcbkhvb2tzLmJsdXJIb29rID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhcInRhZmlkaXRyYSBibHVySG9va1wiKVxyXG4gICAgdGhpcy5oYW5kbGVFdmVudChcImJsdXJCb2R5XCIsICh7IHBhcmFtMSwgcGFyYW0yIH0pID0+XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHBhcmFtMSlcclxuICAgICAgdGhpcy5ibHVyQm9keSgpXHJcbiAgICApO1xyXG4gIH0sXHJcbiAgYmx1ckJvZHkoKSB7XHJcbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XHJcbiAgICB2YXIgcmVxdWVzdF9mb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0aGVfcmVxdWVzdF9mb3JtXCIpO1xyXG4gICAgLy8gY29uc29sZS5sb2cocmVxdWVzdF9mb3JtKTtcclxuXHJcbiAgICAvLyBjb25zb2xlLmxvZyhib2R5KTtcclxuICAgIGJvZHkuc3R5bGUub3BhY2l0eSA9IDAuNTtcclxuXHJcbiAgICAvLyB2YXIgbW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLm1vZGFsLWNvbnRhaW5lclwiKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKG1vZGFsKTtcclxuICAgIC8vIG1vZGFsLnN0eWxlLmZpbHRlciA9IFwiYmx1cigxcHgpXCI7XHJcbiAgICByZXF1ZXN0X2Zvcm0uc3R5bGUub3BhY2l0eSA9IDE7XHJcbiAgfSxcclxufTtcclxuXHJcbkhvb2tzLk1lc3NhZ2VCb2R5ID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICB2YXIgbWVzc2FnZUJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI21lc3NhZ2VCb2R5XCIpO1xyXG4gICAgdGhpcy5oYW5kbGVFdmVudChcclxuICAgICAgXCJ1cGRhdGVTY3JvbGxcIixcclxuICAgICAgKHt9KSA9PlxyXG4gICAgICAgIChtZXNzYWdlQm9keS5zY3JvbGxUb3AgPVxyXG4gICAgICAgICAgbWVzc2FnZUJvZHkuc2Nyb2xsSGVpZ2h0IC0gbWVzc2FnZUJvZHkuY2xpZW50SGVpZ2h0KVxyXG4gICAgKTtcclxuICB9LFxyXG59O1xyXG5cclxuLy8gR2V0IHVybCBsb2NhdGlvblxyXG5Ib29rcy51cmxQcm9jZXNzID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICBsZXQgbWFpbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbWFpblwiKTtcclxuXHJcbiAgICB2YXIgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XHJcblxyXG4gICAgLy8gVGVybmFyeSBmdW5jdGlvblxyXG4gICAgdXJsLmluY2x1ZGVzKFwiL2xvZ3NcIilcclxuICAgICAgPyBtYWluLmNsYXNzTGlzdC5yZW1vdmUoXCJjb250YWluZXJcIilcclxuICAgICAgOiBtYWluLmNsYXNzTGlzdC5hZGQoXCJjb250YWluZXJcIik7XHJcbiAgfSxcclxufTtcclxuXHJcbkhvb2tzLlNwaW5UZXN0ID0ge1xyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhcInRhZmlkaXRyYSBob29rXCIpXHJcbiAgICB0aGlzLmhhbmRsZUV2ZW50KFwiU3BpblRlc3RcIiwgKHt9KSA9PiB0aGlzLnNwaW5faWNvbigpKTtcclxuICAgIHRoaXMuaGFuZGxlRXZlbnQoXCJTcGluQ29tbWVudFwiLCAoe30pID0+IHRoaXMuc3Bpbl9jb21tZW50X2ljb24oKSk7XHJcbiAgfSxcclxuICBzcGluX2ljb24oKSB7XHJcbiAgICB2YXIgc3BpbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm5vdGlmX19sb2FkXCIpO1xyXG4gICAgLy8gY29uc29sZS5sb2coc3Bpbik7XHJcbiAgICAvLyBzcGlucy5jbGFzc0xpc3QuYWRkKCdyb3RhdGVfX2ljb24nKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKHNwaW4pO1xyXG4gICAgLy8gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtzcGlucy5jbGFzc0xpc3QucmVtb3ZlKCdyb3RhdGVfX2ljb24nKTt9LCA1MDApO1xyXG4gICAgLy8gY29uc29sZS5sb2coJ25vdGlmJylcclxuICAgIHNwaW5zLmZvckVhY2goKGl0ZW0pID0+IHtcclxuICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKFwibmV3X19yb3RhdGVfX2ljb25cIik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBzcGlucy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoXCJuZXdfX3JvdGF0ZV9faWNvblwiKTtcclxuICAgICAgfSwgNTAwKTtcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgc3Bpbl9jb21tZW50X2ljb24oKSB7XHJcbiAgICAvLyBjb25zb2xlLmxvZygnY29tbWVudCcpXHJcbiAgICB2YXIgY2xvY2tfY29tbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2xvY2tfY29tbWVudFwiKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKGNsb2NrX2NvbW1lbnQpO1xyXG4gICAgY2xvY2tfY29tbWVudC5jbGFzc0xpc3QuYWRkKFwicm90YXRlX19pY29uXCIpO1xyXG4gICAgLy8gY29uc29sZS5sb2coY2xvY2tfY29tbWVudCk7XHJcbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGNsb2NrX2NvbW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcInJvdGF0ZV9faWNvblwiKTtcclxuICAgIH0sIDUwMCk7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhjbG9ja19jb21tZW50KTtcclxuICB9LFxyXG59O1xyXG5cclxubGV0IG5hdlRvZ2dsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubmF2X190b2dnbGVcIik7XHJcbmxldCBuYXZXcmFwcGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5uYXZfX3dyYXBwZXJcIik7XHJcbm5hdlRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gIGlmIChuYXZXcmFwcGVyLmNsYXNzTGlzdC5jb250YWlucyhcImFjdGl2ZVwiKSkge1xyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIik7XHJcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJtZW51XCIpO1xyXG4gICAgbmF2V3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBuYXZXcmFwcGVyLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XHJcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJjbG9zZSBtZW51XCIpO1xyXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKTtcclxuICB9XHJcbn0pO1xyXG5cclxuY29uc3QgbWVudUJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubWVudS1idG5cIik7XHJcbmxldCBtZW51T3BlbiA9IGZhbHNlO1xyXG5tZW51QnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XHJcbiAgaWYgKCFtZW51T3Blbikge1xyXG4gICAgbWVudUJ0bi5jbGFzc0xpc3QuYWRkKFwib3BlblwiKTtcclxuICAgIG1lbnVPcGVuID0gdHJ1ZTtcclxuICB9IGVsc2Uge1xyXG4gICAgbWVudUJ0bi5jbGFzc0xpc3QucmVtb3ZlKFwib3BlblwiKTtcclxuICAgIG1lbnVPcGVuID0gZmFsc2U7XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciBhbGVydHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFsZXJ0XCIpO1xyXG5cclxuYWxlcnRzLmZvckVhY2goKGl0ZW0pID0+IHtcclxuICBpdGVtLnN0eWxlLm9wYWNpdHkgPSAxO1xyXG4gIGl0ZW0ub25sb2FkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgaXRlbS5zdHlsZS5vcGFjaXR5ID0gMDtcclxuICB9LCAyMDAwKTtcclxufSk7XHJcblxyXG5sZXQgY3NyZlRva2VuID0gZG9jdW1lbnRcclxuICAucXVlcnlTZWxlY3RvcihcIm1ldGFbbmFtZT0nY3NyZi10b2tlbiddXCIpXHJcbiAgLmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIik7XHJcbmxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHtcclxuICBwYXJhbXM6IHsgX2NzcmZfdG9rZW46IGNzcmZUb2tlbiB9LFxyXG4gIGhvb2tzOiBIb29rcyxcclxufSk7XHJcblxyXG5sZXQgdG9wQmFyU2NoZWR1bGVkID0gdW5kZWZpbmVkO1xyXG5cclxuLy8gU2hvdyBwcm9ncmVzcyBiYXIgb24gbGl2ZSBuYXZpZ2F0aW9uIGFuZCBmb3JtIHN1Ym1pdHNcclxudG9wYmFyLmNvbmZpZyh7IGJhckNvbG9yczogeyAwOiBcIiMyOWRcIiB9LCBzaGFkb3dDb2xvcjogXCJyZ2JhKDAsIDAsIDAsIC4zKVwiIH0pO1xyXG5cclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIChpbmZvKSA9PiB0b3BiYXIuc2hvdygpKTtcclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwgKGluZm8pID0+IHRvcGJhci5oaWRlKCkpO1xyXG5cclxuLy8gY29ubmVjdCBpZiB0aGVyZSBhcmUgYW55IExpdmVWaWV3cyBvbiB0aGUgcGFnZVxyXG5saXZlU29ja2V0LmNvbm5lY3QoKTtcclxuXHJcbi8vIGV4cG9zZSBsaXZlU29ja2V0IG9uIHdpbmRvdyBmb3Igd2ViIGNvbnNvbGUgZGVidWcgbG9ncyBhbmQgbGF0ZW5jeSBzaW11bGF0aW9uOlxyXG4vLyA+PiBsaXZlU29ja2V0LmVuYWJsZURlYnVnKClcclxuLy8gPj4gbGl2ZVNvY2tldC5lbmFibGVMYXRlbmN5U2ltKDEwMDApICAvLyBlbmFibGVkIGZvciBkdXJhdGlvbiBvZiBicm93c2VyIHNlc3Npb25cclxuLy8gPj4gbGl2ZVNvY2tldC5kaXNhYmxlTGF0ZW5jeVNpbSgpXHJcbndpbmRvdy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldDtcclxuIiwgImltcG9ydCBDaGFydCBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2hhcnQuanNcIjtcclxuaW1wb3J0IENoYXJ0RGF0YUxhYmVscyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvZGlzdC9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzLmpzXCI7XHJcbmltcG9ydCBcIi4uL25vZGVfbW9kdWxlcy9jaGFydC5qcy1wbHVnaW4tbGFiZWxzLWR2L2Rpc3QvY2hhcnRqcy1wbHVnaW4tbGFiZWxzLm1pbi5qc1wiO1xyXG5cclxuY29uc3QgY29sb3JzID0gW1wiIzM2YTJlYlwiXTtcclxuY29uc3QgbW9udGggPSBbXHJcbiAgXCJKYW52aWVyXCIsXHJcbiAgXCJGXHUwMEU5dnJpZXJcIixcclxuICBcIk1hcnNcIixcclxuICBcIkF2cmlsXCIsXHJcbiAgXCJNYWlcIixcclxuICBcIkp1aW5cIixcclxuICBcIkp1aWxsZXRcIixcclxuICBcIkFvXHUwMEZCdFwiLFxyXG4gIFwiU2VwdGVtYnJlXCIsXHJcbiAgXCJPY3RvYnJlXCIsXHJcbiAgXCJOb3ZlbWJyZVwiLFxyXG4gIFwiRFx1MDBFOWNlbWJyZVwiLFxyXG5dO1xyXG5cclxuY29uc3QgU1VSVkVZID0gW1xyXG4gIFwiUXVhbGl0XHUwMEU5IGR1IHRyYXZhaWwgZWZmZWN0dVx1MDBFOVwiLFxyXG4gIFwiR2FpbiBkZSB0ZW1wcyBkdSBjbGllbnRcIixcclxuICBcIlJlc3BlY3QgZHUgZFx1MDBFOWxhaSBkZSBsaXZyYWlzb25cIixcclxuICBcIlF1YWxpdFx1MDBFOSBkZSBsYSBjb21tdW5pY2F0aW9uXCIsXHJcbl07XHJcblxyXG5jbGFzcyBEb3VnaE51dENoYXJ0IHtcclxuICBjb25zdHJ1Y3RvcihjdHgsIGxhYmVscywgdmFsdWVzKSB7XHJcbiAgICB0aGlzLmNoYXJ0ID0gbmV3IENoYXJ0KGN0eCwge1xyXG4gICAgICB0eXBlOiBcImRvdWdobnV0XCIsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICBsYWJlbHM6IGxhYmVscyxcclxuICAgICAgICBkYXRhc2V0czogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBsYWJlbDogXCJMaXN0ZSBkZXMgdFx1MDBFMmNoZXNcIixcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMsXHJcbiAgICAgICAgICAgIGRhdGE6IHZhbHVlcyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfSxcclxuICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbiAgICAgICAgcGx1Z2luczoge1xyXG4gICAgICAgICAgbGVnZW5kOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcInRvcFwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHQ6IFwiTGlzdGUgZGVzIHRcdTAwRTJjaGVzIHBhciBjb250cmlidXRldXJzXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIHBsdWdpbnM6IENoYXJ0RGF0YUxhYmVscyxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgSG9yaXpvbnRhbEJhckNoYXJ0IHtcclxuICBjb25zdHJ1Y3RvcihjdHgsIGxhYmVscywgdmFsdWVzKSB7XHJcbiAgICB0aGlzLmNoYXJ0ID0gbmV3IENoYXJ0KGN0eCwge1xyXG4gICAgICB0eXBlOiBcImJhclwiLFxyXG4gICAgICBkYXRhOiB7XHJcbiAgICAgICAgbGFiZWxzOiBsYWJlbHMsXHJcbiAgICAgICAgZGF0YXNldHM6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgYXhpczogXCJ4XCIsXHJcbiAgICAgICAgICAgIGxhYmVsOiBcIkxpc3RlIGRlcyB0XHUwMEUyY2hlc1wiLFxyXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZXMsXHJcbiAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogY29sb3JzLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycyxcclxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsXHJcbiAgICAgICAgICAgIGNvbG9yOiBcIiNmZmZcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfSxcclxuICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgIGluZGV4QXhpczogXCJ4XCIsXHJcbiAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuICAgICAgICBwbHVnaW5zOiB7XHJcbiAgICAgICAgICBsYWJlbHM6IHtcclxuICAgICAgICAgICAgcmVuZGVyOiBcInZhbHVlXCIsXHJcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCIjNWM1YzVjXCIsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcIm91dHNpZGVcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBsZWdlbmQ6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuICAgICAgICAgICAgdGV4dDogXCJMaXN0ZSBkZXMgdFx1MDBFMmNoZXMgcGFyIGNvbnRyaWJ1dGV1cnNcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkYXRhbGFiZWxzOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiBcIiNmZmZcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY2xhc3MgU3RhY2tlZEJhckNoYXJ0IHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGN0eCxcclxuICAgIHRvZG9fdGFza3MsXHJcbiAgICBibG9ja2VkX3Rhc2tzLFxyXG4gICAgdGFza3NfaW5fcHJvZ3Jlc3MsXHJcbiAgICB0YXNrc19pbl9jb250cm9sLFxyXG4gICAgYWNoaWV2ZWRfdGFza3NcclxuICApIHtcclxuICAgIHRoaXMuY2hhcnQgPSBuZXcgQ2hhcnQoY3R4LCB7XHJcbiAgICAgIHR5cGU6IFwiYmFyXCIsXHJcbiAgICAgIGRhdGE6IHtcclxuICAgICAgICBsYWJlbHM6IG1vbnRoLFxyXG4gICAgICAgIGRhdGFzZXRzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGxhYmVsOiBcIlRcdTAwRTJjaGVzIFx1MDBFMCBmYWlyZVwiLFxyXG4gICAgICAgICAgICBkYXRhOiB0b2RvX3Rhc2tzLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgZW4gYmxvY2FnZVwiLFxyXG4gICAgICAgICAgICBkYXRhOiBibG9ja2VkX3Rhc2tzLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2U2N2UyMlwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgZW4gY291cnNcIixcclxuICAgICAgICAgICAgZGF0YTogdGFza3NfaW5fcHJvZ3Jlc3MsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMjdhZTYwXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBsYWJlbDogXCJUXHUwMEUyY2hlcyBlbiBjb250clx1MDBGNGxlXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHRhc2tzX2luX2NvbnRyb2wsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjOGU0NGFkXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBsYWJlbDogXCJUXHUwMEUyY2hlcyBhY2hldlx1MDBFOWVzXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IGFjaGlldmVkX3Rhc2tzLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmNjM4NFwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICB9LFxyXG4gICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgcGx1Z2luczoge1xyXG4gICAgICAgICAgbGFiZWxzOiB7XHJcbiAgICAgICAgICAgIHJlbmRlcjogXCJ2YWx1ZVwiLFxyXG4gICAgICAgICAgICBmb250Q29sb3I6IFwiIzVjNWM1Y1wiLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJvdXRzaWRlXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbGVnZW5kOiB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHRpdGxlOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHQ6IFwiVFx1MDBFMmNoZXMgcGFyIG1vaXNcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBMaW5lQ2hhcnQge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgY3R4LFxyXG4gICAgdG9kb190YXNrcyxcclxuICAgIGJsb2NrZWRfdGFza3MsXHJcbiAgICB0YXNrc19pbl9wcm9ncmVzcyxcclxuICAgIHRhc2tzX2luX2NvbnRyb2wsXHJcbiAgICBhY2hpZXZlZF90YXNrc1xyXG4gICkge1xyXG4gICAgdGhpcy5jaGFydCA9IG5ldyBDaGFydChjdHgsIHtcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIGxhYmVsczogbW9udGgsXHJcbiAgICAgICAgZGF0YXNldHM6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogXCJiYXJcIixcclxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgXHUwMEUwIGZhaXJlXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHRvZG9fdGFza3MsXHJcbiAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiBcIm1vbm90b25lXCIsXHJcbiAgICAgICAgICAgIHRlbnNpb246IDAuNCxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiI2ZmNjM4NFwiLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmNjM4NFwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogXCJiYXJcIixcclxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgZW4gYmxvY2thZ2VcIixcclxuICAgICAgICAgICAgZGF0YTogYmxvY2tlZF90YXNrcyxcclxuICAgICAgICAgICAgZmlsbDogZmFsc2UsXHJcbiAgICAgICAgICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6IFwibW9ub3RvbmVcIixcclxuICAgICAgICAgICAgdGVuc2lvbjogMC40LFxyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjMzZhMmViXCIsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzZhMmViXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB0eXBlOiBcImJhclwiLFxyXG4gICAgICAgICAgICBsYWJlbDogXCJUXHUwMEUyY2hlcyBlbiBjb3Vyc1wiLFxyXG4gICAgICAgICAgICBkYXRhOiB0YXNrc19pbl9wcm9ncmVzcyxcclxuICAgICAgICAgICAgZmlsbDogZmFsc2UsXHJcbiAgICAgICAgICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6IFwibW9ub3RvbmVcIixcclxuICAgICAgICAgICAgdGVuc2lvbjogMC40LFxyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjMzZhMmViXCIsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzZhMmViXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB0eXBlOiBcImJhclwiLFxyXG4gICAgICAgICAgICBsYWJlbDogXCJUXHUwMEUyY2hlcyBlbiBjb250clx1MDBGNGxlXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHRhc2tzX2luX2NvbnRyb2wsXHJcbiAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiBcIm1vbm90b25lXCIsXHJcbiAgICAgICAgICAgIHRlbnNpb246IDAuNCxcclxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzM2YTJlYlwiLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogXCJiYXJcIixcclxuICAgICAgICAgICAgbGFiZWw6IFwiVFx1MDBFMmNoZXMgYWNoZXZcdTAwRTllc1wiLFxyXG4gICAgICAgICAgICBkYXRhOiBhY2hpZXZlZF90YXNrcyxcclxuICAgICAgICAgICAgZmlsbDogZmFsc2UsXHJcbiAgICAgICAgICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6IFwibW9ub3RvbmVcIixcclxuICAgICAgICAgICAgdGVuc2lvbjogMC40LFxyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogXCIjMzZhMmViXCIsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzZhMmViXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIF0sXHJcbiAgICAgIH0sXHJcbiAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxyXG4gICAgICAgIHBsdWdpbnM6IHtcclxuICAgICAgICAgIGxlZ2VuZDoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB0aXRsZToge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgICAgICAgICB0ZXh0OiBcIlRcdTAwRTJjaGVzIHBhciBtb2lzXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFN1cnZleUNoYXJ0IHtcclxuICBjb25zdHJ1Y3RvcihjdHgsIHZhbHVlcykge1xyXG4gICAgdGhpcy5jaGFydCA9IG5ldyBDaGFydChjdHgsIHtcclxuICAgICAgdHlwZTogXCJiYXJcIixcclxuICAgICAgZGF0YToge1xyXG4gICAgICAgIGxhYmVsczogU1VSVkVZLFxyXG4gICAgICAgIGRhdGFzZXRzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGF4aXM6IFwieFwiLFxyXG4gICAgICAgICAgICBsYWJlbDogXCJQb3VyY2VudGFnZSBkZSBzYXRpc2ZhY3Rpb24gZW4gJVwiLFxyXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZXMsXHJcbiAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogY29sb3JzLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycyxcclxuICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXHJcbiAgICAgICAgICAgIGNvbG9yOiBcIiNmZmZcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgfSxcclxuICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4gICAgICAgIGluZGV4QXhpczogXCJ5XCIsXHJcbiAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuICAgICAgICBwbHVnaW5zOiB7XHJcbiAgICAgICAgICBsYWJlbHM6IHtcclxuICAgICAgICAgICAgcmVuZGVyOiBcInZhbHVlXCIsXHJcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCIjNWM1YzVjXCIsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcIm91dHNpZGVcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBsZWdlbmQ6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuICAgICAgICAgICAgdGV4dDogXCJUYXV4IGRlIHNhdGlzZmFjdGlvbiBkdSBjbGllbnRcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkYXRhbGFiZWxzOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiBcIiNmZmZcIixcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IHtcclxuICBEb3VnaE51dENoYXJ0LFxyXG4gIEhvcml6b250YWxCYXJDaGFydCxcclxuICBTdGFja2VkQmFyQ2hhcnQsXHJcbiAgTGluZUNoYXJ0LFxyXG4gIFN1cnZleUNoYXJ0XHJcbn07XHJcbiIsICIhZnVuY3Rpb24odCl7XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSh0KTp0KCl9KChmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO1xyXG4vKipcclxuICAgKiBbY2hhcnRqcy1wbHVnaW4tbGFiZWxzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRlVmlvbGFudGUvY2hhcnRqcy1wbHVnaW4tbGFiZWxzfVxyXG4gICAqXHJcbiAgICogQHZlcnNpb24gMy4xLjBcclxuICAgKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXSwgRGF2aWRlIFZpb2xhbnRlXHJcbiAgICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE3LTIwMThcclxuICAgKiBAbGljZW5zZSBNSVRcclxuICAgKi8hZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgQ2hhcnQpcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcIkNhbm5vdCBmaW5kIENoYXJ0IG9iamVjdC5cIik7Y29uc3QgdD1DaGFydC5oZWxwZXJzO1wiZnVuY3Rpb25cIiE9dHlwZW9mIE9iamVjdC5hc3NpZ24mJihPYmplY3QuYXNzaWduPWZ1bmN0aW9uKHQpe2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIik7Y29uc3QgZT1PYmplY3QodCk7Zm9yKGxldCB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7Y29uc3Qgbz1hcmd1bWVudHNbdF07aWYobylmb3IoY29uc3QgdCBpbiBvKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLHQpJiYoZVt0XT1vW3RdKX1yZXR1cm4gZX0pO2NvbnN0IGU9e307ZnVuY3Rpb24gbygpe3RoaXMucmVuZGVyVG9EYXRhc2V0PXRoaXMucmVuZGVyVG9EYXRhc2V0LmJpbmQodGhpcyl9W1wicGllXCIsXCJkb3VnaG51dFwiLFwicG9sYXJBcmVhXCIsXCJiYXJcIl0uZm9yRWFjaCgoZnVuY3Rpb24odCl7ZVt0XT0hMH0pKSxvLnByb3RvdHlwZS5zZXR1cD1mdW5jdGlvbih0LGUpe3RoaXMuY2hhcnQ9dCx0aGlzLmN0eD10LmN0eCx0aGlzLmFyZ3M9e30sdGhpcy5iYXJUb3RhbD17fTtjb25zdCBvPXQuY29uZmlnLm9wdGlvbnM7dGhpcy5vcHRpb25zPU9iamVjdC5hc3NpZ24oe3Bvc2l0aW9uOlwiZGVmYXVsdFwiLHByZWNpc2lvbjowLGZvbnRTaXplOm8uZm9udD9vLmZvbnQuc2l6ZToxMixmb250Q29sb3I6by5jb2xvcnx8XCIjMzMzMzMzXCIsZm9udFN0eWxlOm8uZm9udD9vLmZvbnQuc3R5bGU6XCJub3JtYWxcIixmb250RmFtaWx5Om8uZm9udD9vLmZvbnQuZmFtaWx5OlwiJ0hlbHZldGljYSBOZXVlJywgJ0hlbHZldGljYScsICdBcmlhbCcsIHNhbnMtc2VyaWZcIixzaGFkb3dPZmZzZXRYOjMsc2hhZG93T2Zmc2V0WTozLHNoYWRvd0NvbG9yOlwicmdiYSgwLDAsMCwwLjMpXCIsc2hhZG93Qmx1cjo2LGltYWdlczpbXSxvdXRzaWRlUGFkZGluZzoyLHRleHRNYXJnaW46MixvdmVybGFwOiEwfSxlKSxcImJhclwiPT09dC5jb25maWcudHlwZSYmKHRoaXMub3B0aW9ucy5wb3NpdGlvbj1cImRlZmF1bHRcIix0aGlzLm9wdGlvbnMuYXJjPSExLHRoaXMub3B0aW9ucy5vdmVybGFwPSEwKX0sby5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKCl7dGhpcy5sYWJlbEJvdW5kcz1bXSx0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCh0aGlzLnJlbmRlclRvRGF0YXNldCl9LG8ucHJvdG90eXBlLnJlbmRlclRvRGF0YXNldD1mdW5jdGlvbih0LGUpe3RoaXMudG90YWxQZXJjZW50YWdlPTAsdGhpcy50b3RhbD1udWxsO2NvbnN0IG89dGhpcy5hcmdzW2VdO28ubWV0YS5kYXRhLmZvckVhY2goZnVuY3Rpb24oZSxuKXt0aGlzLnJlbmRlclRvRWxlbWVudCh0LG8sZSxuKX0uYmluZCh0aGlzKSl9LG8ucHJvdG90eXBlLnJlbmRlclRvRWxlbWVudD1mdW5jdGlvbihlLG8sbixpKXtpZighdGhpcy5zaG91bGRSZW5kZXJUb0VsZW1lbnQoby5tZXRhLG4pKXJldHVybjt0aGlzLnBlcmNlbnRhZ2U9bnVsbDtjb25zdCBzPXRoaXMuZ2V0TGFiZWwoZSxuLGkpO2lmKCFzKXJldHVybjtjb25zdCByPXRoaXMuY3R4O3Iuc2F2ZSgpLHIuZm9udD10LmZvbnRTdHJpbmcodGhpcy5vcHRpb25zLmZvbnRTaXplLHRoaXMub3B0aW9ucy5mb250U3R5bGUsdGhpcy5vcHRpb25zLmZvbnRGYW1pbHkpO2NvbnN0IGE9dGhpcy5nZXRSZW5kZXJJbmZvKG4scyk7dGhpcy5kcmF3YWJsZShuLHMsYSk/KHIuYmVnaW5QYXRoKCksci5maWxsU3R5bGU9dGhpcy5nZXRGb250Q29sb3IoZSxuLGkpLHRoaXMucmVuZGVyTGFiZWwocyxhKSxyLnJlc3RvcmUoKSk6ci5yZXN0b3JlKCl9LG8ucHJvdG90eXBlLnJlbmRlckxhYmVsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMub3B0aW9ucy5hcmM/dGhpcy5yZW5kZXJBcmNMYWJlbCh0LGUpOnRoaXMucmVuZGVyQmFzZUxhYmVsKHQsZSl9LG8ucHJvdG90eXBlLnJlbmRlckJhc2VMYWJlbD1mdW5jdGlvbih0LGUpe2NvbnN0IG89dGhpcy5jdHg7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpby5kcmF3SW1hZ2UodCxlLngtdC53aWR0aC8yLGUueS10LmhlaWdodC8yLHQud2lkdGgsdC5oZWlnaHQpO2Vsc2V7by5zYXZlKCksby50ZXh0QmFzZWxpbmU9XCJ0b3BcIixvLnRleHRBbGlnbj1cImNlbnRlclwiLHRoaXMub3B0aW9ucy50ZXh0U2hhZG93JiYoby5zaGFkb3dPZmZzZXRYPXRoaXMub3B0aW9ucy5zaGFkb3dPZmZzZXRYLG8uc2hhZG93T2Zmc2V0WT10aGlzLm9wdGlvbnMuc2hhZG93T2Zmc2V0WSxvLnNoYWRvd0NvbG9yPXRoaXMub3B0aW9ucy5zaGFkb3dDb2xvcixvLnNoYWRvd0JsdXI9dGhpcy5vcHRpb25zLnNoYWRvd0JsdXIpO2NvbnN0IG49dC5zcGxpdChcIlxcblwiKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyl7Y29uc3QgaT1lLnktdGhpcy5vcHRpb25zLmZvbnRTaXplLzIqbi5sZW5ndGgrdGhpcy5vcHRpb25zLmZvbnRTaXplKnQ7by5maWxsVGV4dChuW3RdLGUueCxpKX1vLnJlc3RvcmUoKX19LG8ucHJvdG90eXBlLnJlbmRlckFyY0xhYmVsPWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbz10aGlzLmN0eCxuPWUucmFkaXVzLGk9ZS52aWV3O2lmKG8uc2F2ZSgpLG8udHJhbnNsYXRlKGkueCxpLnkpLFwic3RyaW5nXCI9PXR5cGVvZiB0KXtvLnJvdGF0ZShlLnN0YXJ0QW5nbGUpLG8udGV4dEJhc2VsaW5lPVwibWlkZGxlXCIsby50ZXh0QWxpZ249XCJsZWZ0XCI7Y29uc3QgaT10LnNwbGl0KFwiXFxuXCIpO2xldCBzPTA7Y29uc3Qgcj1bXTtsZXQgYSxoPTA7XCJib3JkZXJcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbiYmKGg9KGkubGVuZ3RoLTEpKnRoaXMub3B0aW9ucy5mb250U2l6ZS8yKTtmb3IobGV0IHQ9MDt0PGkubGVuZ3RoOysrdClhPW8ubWVhc3VyZVRleHQoaVt0XSksYS53aWR0aD5zJiYocz1hLndpZHRoKSxyLnB1c2goYS53aWR0aCk7Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDsrK3Qpe2NvbnN0IGU9aVt0XSxsPShpLmxlbmd0aC0xLXQpKi10aGlzLm9wdGlvbnMuZm9udFNpemUraDtvLnNhdmUoKTtjb25zdCBjPShzLXJbdF0pLzI7by5yb3RhdGUoYy9uKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3QgaT1lLmNoYXJBdCh0KTthPW8ubWVhc3VyZVRleHQoaSksby5zYXZlKCksby50cmFuc2xhdGUoMCwtMSpuKSxvLmZpbGxUZXh0KGksMCxsKSxvLnJlc3RvcmUoKSxvLnJvdGF0ZShhLndpZHRoL24pfW8ucmVzdG9yZSgpfX1lbHNlIG8ucm90YXRlKChpLnN0YXJ0QW5nbGUrTWF0aC5QSS8yK2UuZW5kQW5nbGUpLzIpLG8udHJhbnNsYXRlKDAsLTEqbiksdGhpcy5yZW5kZXJMYWJlbCh0LHt4OjAseTowfSk7by5yZXN0b3JlKCl9LG8ucHJvdG90eXBlLnNob3VsZFJlbmRlclRvRWxlbWVudD1mdW5jdGlvbih0LGUpe3JldHVybiF0LmhpZGRlbiYmKHRoaXMub3B0aW9ucy5zaG93WmVyb3x8XCJwb2xhckFyZWFcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGU/MCE9PWUub3V0ZXJSYWRpdXM6MCE9PWUuY2lyY3VtZmVyZW5jZSl9LG8ucHJvdG90eXBlLmdldExhYmVsPWZ1bmN0aW9uKHQsZSxvKXtsZXQgbjtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLm9wdGlvbnMucmVuZGVyKW49dGhpcy5vcHRpb25zLnJlbmRlcih7bGFiZWw6dGhpcy5jaGFydC5jb25maWcuZGF0YS5sYWJlbHNbb10sdmFsdWU6dC5kYXRhW29dLHBlcmNlbnRhZ2U6dGhpcy5nZXRQZXJjZW50YWdlKHQsZSxvKSxkYXRhc2V0OnQsaW5kZXg6b30pO2Vsc2Ugc3dpdGNoKHRoaXMub3B0aW9ucy5yZW5kZXIpe2Nhc2VcInZhbHVlXCI6bj10LmRhdGFbb107YnJlYWs7Y2FzZVwibGFiZWxcIjpuPXRoaXMuY2hhcnQuY29uZmlnLmRhdGEubGFiZWxzW29dO2JyZWFrO2Nhc2VcImltYWdlXCI6bj10aGlzLm9wdGlvbnMuaW1hZ2VzW29dP3RoaXMubG9hZEltYWdlKHRoaXMub3B0aW9ucy5pbWFnZXNbb10pOlwiXCI7YnJlYWs7Y2FzZVwicGVyY2VudGFnZVwiOmRlZmF1bHQ6bj10aGlzLmdldFBlcmNlbnRhZ2UodCxlLG8pK1wiJVwifXJldHVyblwib2JqZWN0XCI9PXR5cGVvZiBuP249dGhpcy5sb2FkSW1hZ2Uobik6biYmKG49bi50b1N0cmluZygpKSxufSxvLnByb3RvdHlwZS5nZXRGb250Q29sb3I9ZnVuY3Rpb24odCxlLG8pe2xldCBuPXRoaXMub3B0aW9ucy5mb250Q29sb3I7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uPW4oe2xhYmVsOnRoaXMuY2hhcnQuY29uZmlnLmRhdGEubGFiZWxzW29dLHZhbHVlOnQuZGF0YVtvXSxwZXJjZW50YWdlOnRoaXMuZ2V0UGVyY2VudGFnZSh0LGUsbyksYmFja2dyb3VuZENvbG9yOnQuYmFja2dyb3VuZENvbG9yW29dLGRhdGFzZXQ6dCxpbmRleDpvfSk6XCJzdHJpbmdcIiE9dHlwZW9mIG4mJihuPW5bb118fHRoaXMuY2hhcnQuY29uZmlnLm9wdGlvbnMuY29sb3IpLG59LG8ucHJvdG90eXBlLmdldFBlcmNlbnRhZ2U9ZnVuY3Rpb24odCxlLG8pe2lmKHRoaXMucGVyY2VudGFnZSlyZXR1cm4gdGhpcy5wZXJjZW50YWdlO2xldCBuO2lmKFwicG9sYXJBcmVhXCI9PT10aGlzLmNoYXJ0LmNvbmZpZy50eXBlfHxcImRvdWdobnV0XCI9PT10aGlzLmNoYXJ0LmNvbmZpZy50eXBlfHxcInBpZVwiPT09dGhpcy5jaGFydC5jb25maWcudHlwZSl7aWYoIXRoaXMudG90YWwpe3RoaXMudG90YWw9MDtmb3IobGV0IGU9MDtlPHQuZGF0YS5sZW5ndGg7KytlKXRoaXMudG90YWwrPXQuZGF0YVtlXX1uPXQuZGF0YVtvXS90aGlzLnRvdGFsKjEwMH1lbHNlIGlmKFwiYmFyXCI9PT10aGlzLmNoYXJ0LmNvbmZpZy50eXBlKXtpZighdGhpcy5iYXJUb3RhbFtvXSl7dGhpcy5iYXJUb3RhbFtvXT0wO2ZvcihsZXQgdD0wO3Q8dGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsrK3QpdGhpcy5iYXJUb3RhbFtvXSs9dGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RdLmRhdGFbb119bj10LmRhdGFbb10vdGhpcy5iYXJUb3RhbFtvXSoxMDB9ZWxzZSBuPWUuY2lyY3VtZmVyZW5jZS90aGlzLmNoYXJ0LmNvbmZpZy5vcHRpb25zLmNpcmN1bWZlcmVuY2UqMTAwO3JldHVybiBuPXBhcnNlRmxvYXQobi50b0ZpeGVkKHRoaXMub3B0aW9ucy5wcmVjaXNpb24pKSx0aGlzLm9wdGlvbnMuc2hvd0FjdHVhbFBlcmNlbnRhZ2VzfHwoXCJiYXJcIj09PXRoaXMuY2hhcnQuY29uZmlnLnR5cGUmJih0aGlzLnRvdGFsUGVyY2VudGFnZT10aGlzLmJhclRvdGFsUGVyY2VudGFnZVtvXXx8MCksdGhpcy50b3RhbFBlcmNlbnRhZ2UrPW4sdGhpcy50b3RhbFBlcmNlbnRhZ2U+MTAwJiYobi09dGhpcy50b3RhbFBlcmNlbnRhZ2UtMTAwLG49cGFyc2VGbG9hdChuLnRvRml4ZWQodGhpcy5vcHRpb25zLnByZWNpc2lvbikpKSxcImJhclwiPT09dGhpcy5jaGFydC5jb25maWcudHlwZSYmKHRoaXMuYmFyVG90YWxQZXJjZW50YWdlW29dPXRoaXMudG90YWxQZXJjZW50YWdlKSksdGhpcy5wZXJjZW50YWdlPW4sbn0sby5wcm90b3R5cGUuZ2V0UmVuZGVySW5mbz1mdW5jdGlvbih0LGUpe3JldHVyblwiYmFyXCI9PT10aGlzLmNoYXJ0LmNvbmZpZy50eXBlP3RoaXMuZ2V0QmFyUmVuZGVySW5mbyh0LGUpOnRoaXMub3B0aW9ucy5hcmM/dGhpcy5nZXRBcmNSZW5kZXJJbmZvKHQsZSk6dGhpcy5nZXRCYXNlUmVuZGVySW5mbyh0LGUpfSxvLnByb3RvdHlwZS5nZXRCYXNlUmVuZGVySW5mbz1mdW5jdGlvbih0LGUpe2lmKFwib3V0c2lkZVwiPT09dGhpcy5vcHRpb25zLnBvc2l0aW9ufHxcImJvcmRlclwiPT09dGhpcy5vcHRpb25zLnBvc2l0aW9uKXtsZXQgbyxuPXt9O2NvbnN0IGk9dCxzPWkuc3RhcnRBbmdsZSsoaS5lbmRBbmdsZS1pLnN0YXJ0QW5nbGUpLzIscj1pLm91dGVyUmFkaXVzLzI7aWYoXCJib3JkZXJcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbj9vPShpLm91dGVyUmFkaXVzLXIpLzIrcjpcIm91dHNpZGVcIj09PXRoaXMub3B0aW9ucy5wb3NpdGlvbiYmKG89aS5vdXRlclJhZGl1cy1yK3IrdGhpcy5vcHRpb25zLnRleHRNYXJnaW4pLG49e3g6aS54K01hdGguY29zKHMpKm8seTppLnkrTWF0aC5zaW4ocykqb30sXCJvdXRzaWRlXCI9PT10aGlzLm9wdGlvbnMucG9zaXRpb24pe2NvbnN0IHQ9dGhpcy5vcHRpb25zLnRleHRNYXJnaW4rdGhpcy5tZWFzdXJlTGFiZWwoZSkud2lkdGgvMjtuLngrPW4ueDxpLng/LXQ6dH1yZXR1cm4gbn1yZXR1cm4gdC50b29sdGlwUG9zaXRpb24oKX0sby5wcm90b3R5cGUuZ2V0QXJjUmVuZGVySW5mbz1mdW5jdGlvbih0LGUpe2xldCBvO2NvbnN0IG49dDtvPVwib3V0c2lkZVwiPT09dGhpcy5vcHRpb25zLnBvc2l0aW9uP24ub3V0ZXJSYWRpdXMrdGhpcy5vcHRpb25zLmZvbnRTaXplK3RoaXMub3B0aW9ucy50ZXh0TWFyZ2luOlwiYm9yZGVyXCI9PT10aGlzLm9wdGlvbnMucG9zaXRpb24/KG4ub3V0ZXJSYWRpdXMvMituLm91dGVyUmFkaXVzKS8yOihuLmlubmVyUmFkaXVzK24ub3V0ZXJSYWRpdXMpLzI7bGV0IGk9bi5zdGFydEFuZ2xlLHM9bi5lbmRBbmdsZTtjb25zdCByPXMtaTtpKz1NYXRoLlBJLzIscys9TWF0aC5QSS8yO3JldHVybiBpKz0ocy0odGhpcy5tZWFzdXJlTGFiZWwoZSkud2lkdGgvbytpKSkvMix7cmFkaXVzOm8sc3RhcnRBbmdsZTppLGVuZEFuZ2xlOnMsdG90YWxBbmdsZTpyLHZpZXc6bn19LG8ucHJvdG90eXBlLmdldEJhclJlbmRlckluZm89ZnVuY3Rpb24odCxlKXtjb25zdCBvPXQudG9vbHRpcFBvc2l0aW9uKCk7cmV0dXJuIG8ueS09dGhpcy5tZWFzdXJlTGFiZWwoZSkuaGVpZ2h0LzIrdGhpcy5vcHRpb25zLnRleHRNYXJnaW4sb30sby5wcm90b3R5cGUuZHJhd2FibGU9ZnVuY3Rpb24odCxlLG8pe2lmKHRoaXMub3B0aW9ucy5vdmVybGFwKXJldHVybiEwO2lmKHRoaXMub3B0aW9ucy5hcmMpcmV0dXJuIG8uZW5kQW5nbGUtby5zdGFydEFuZ2xlPD1vLnRvdGFsQW5nbGU7e2NvbnN0IG49dGhpcy5tZWFzdXJlTGFiZWwoZSksaT1vLngtbi53aWR0aC8yLHM9by54K24ud2lkdGgvMixyPW8ueS1uLmhlaWdodC8yLGE9by55K24uaGVpZ2h0LzI7cmV0dXJuXCJvdXRzaWRlXCI9PT10aGlzLm9wdGlvbnMucG9zaXRpb24/dGhpcy5vdXRzaWRlSW5SYW5nZShpLHMscixhKTp0LmluUmFuZ2UoaSxyKSYmdC5pblJhbmdlKGksYSkmJnQuaW5SYW5nZShzLHIpJiZ0LmluUmFuZ2UocyxhKX19LG8ucHJvdG90eXBlLm91dHNpZGVJblJhbmdlPWZ1bmN0aW9uKHQsZSxvLG4pe2NvbnN0IGk9dGhpcy5sYWJlbEJvdW5kcztmb3IobGV0IHM9MDtzPGkubGVuZ3RoOysrcyl7Y29uc3Qgcj1pW3NdO2xldCBhPVtbdCxvXSxbdCxuXSxbZSxvXSxbZSxuXV07Zm9yKGxldCB0PTA7dDxhLmxlbmd0aDsrK3Qpe2NvbnN0IGU9YVt0XVswXSxvPWFbdF1bMV07aWYoZT49ci5sZWZ0JiZlPD1yLnJpZ2h0JiZvPj1yLnRvcCYmbzw9ci5ib3R0b20pcmV0dXJuITF9YT1bW3IubGVmdCxyLnRvcF0sW3IubGVmdCxyLmJvdHRvbV0sW3IucmlnaHQsci50b3BdLFtyLnJpZ2h0LHIuYm90dG9tXV07Zm9yKGxldCBpPTA7aTxhLmxlbmd0aDsrK2kpe2NvbnN0IHM9YVtpXVswXSxyPWFbaV1bMV07aWYocz49dCYmczw9ZSYmcj49byYmcjw9bilyZXR1cm4hMX19cmV0dXJuIGkucHVzaCh7bGVmdDp0LHJpZ2h0OmUsdG9wOm8sYm90dG9tOm59KSwhMH0sby5wcm90b3R5cGUubWVhc3VyZUxhYmVsPWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0KXJldHVybnt3aWR0aDp0LndpZHRoLGhlaWdodDp0LmhlaWdodH07e2xldCBlPTA7Y29uc3Qgbz10LnNwbGl0KFwiXFxuXCIpO2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7Kyt0KXtjb25zdCBuPXRoaXMuY3R4Lm1lYXN1cmVUZXh0KG9bdF0pO24ud2lkdGg+ZSYmKGU9bi53aWR0aCl9cmV0dXJue3dpZHRoOmUsaGVpZ2h0OnRoaXMub3B0aW9ucy5mb250U2l6ZSpvLmxlbmd0aH19fSxvLnByb3RvdHlwZS5sb2FkSW1hZ2U9ZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgSW1hZ2U7cmV0dXJuIGUuc3JjPXQuc3JjLGUud2lkdGg9dC53aWR0aCxlLmhlaWdodD10LmhlaWdodCxlfSxDaGFydC5yZWdpc3Rlcih7aWQ6XCJsYWJlbHNcIixiZWZvcmVEYXRhc2V0c1VwZGF0ZTpmdW5jdGlvbih0LG4saSl7aWYoIWVbdC5jb25maWcudHlwZV0pcmV0dXJuO2kubGVuZ3RofHwoaT1baV0pO2NvbnN0IHM9aS5sZW5ndGg7dC5fbGFiZWxzJiZzPT09dC5fbGFiZWxzLmxlbmd0aHx8KHQuX2xhYmVscz1pLm1hcCgoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG99KSkpO2xldCByPSExLGE9MDtmb3IobGV0IGU9MDtlPHM7KytlKXtjb25zdCBvPXQuX2xhYmVsc1tlXTtpZihvLnNldHVwKHQsaVtlXSksXCJvdXRzaWRlXCI9PT1vLm9wdGlvbnMucG9zaXRpb24pe3I9ITA7Y29uc3QgdD0xLjUqby5vcHRpb25zLmZvbnRTaXplK28ub3B0aW9ucy5vdXRzaWRlUGFkZGluZzt0PmEmJihhPXQpfX1yJiYodC5jaGFydEFyZWEudG9wKz1hLHQuY2hhcnRBcmVhLmJvdHRvbS09YSl9LGFmdGVyRGF0YXNldFVwZGF0ZTpmdW5jdGlvbih0LG8pe2VbdC5jb25maWcudHlwZV0mJnQuX2xhYmVscy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmFyZ3Nbby5pbmRleF09b30pKX0sYmVmb3JlRHJhdzpmdW5jdGlvbih0KXtlW3QuY29uZmlnLnR5cGVdJiZ0Ll9sYWJlbHMuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5iYXJUb3RhbFBlcmNlbnRhZ2U9e319KSl9LGFmdGVyRGF0YXNldHNEcmF3OmZ1bmN0aW9uKHQpe2VbdC5jb25maWcudHlwZV0mJnQuX2xhYmVscy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnJlbmRlcigpfSkpfX0pfSgpfSkpO1xyXG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQSxNQUFDLDJDQUEwQyxNQUFNLFNBQVM7QUFDekQsWUFBRyxPQUFPLFlBQVksWUFBWSxPQUFPLFdBQVc7QUFDbkQsaUJBQU8sVUFBVTtBQUFBLGlCQUNWLE9BQU8sV0FBVyxjQUFjLE9BQU87QUFDOUMsaUJBQU8sYUFBYSxJQUFJO0FBQUEsaUJBQ2pCLE9BQU8sWUFBWTtBQUMxQixrQkFBUSxlQUFlO0FBQUE7QUFFdkIsZUFBSyxlQUFlO0FBQUEsU0FDbkIsUUFBUSxXQUFXO0FBQ3RCLGVBQWlCLFNBQVMsU0FBUztBQUV6QixjQUFJLG1CQUFtQjtBQUd2Qix1Q0FBNkIsVUFBVTtBQUd0QyxnQkFBRyxpQkFBaUIsV0FBVztBQUM5QixxQkFBTyxpQkFBaUIsVUFBVTtBQUFBO0FBR25DLGdCQUFJLFVBQVMsaUJBQWlCLFlBQVk7QUFBQSxjQUN6QyxHQUFHO0FBQUEsY0FDSCxHQUFHO0FBQUEsY0FDSCxTQUFTO0FBQUE7QUFJVixvQkFBUSxVQUFVLEtBQUssUUFBTyxTQUFTLFNBQVEsUUFBTyxTQUFTO0FBRy9ELG9CQUFPLElBQUk7QUFHWCxtQkFBTyxRQUFPO0FBQUE7QUFLZiw4QkFBb0IsSUFBSTtBQUd4Qiw4QkFBb0IsSUFB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QSxVQUNILEdBQUc7QUFBQSxVQUNILEdBQUc7QUFBQSxVQUNILEdBQUc7QUFBQTtBQUVMLGNBQU0sVUFBVTtBQUFBLFVBQ2QsUUFBUTtBQUFBLFVBQ1IsYUFBYTtBQUFBLFVBQ2IsTUFBTTtBQUFBLFVBQ04sV0FBVztBQUFBLFVBQ1gsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsUUFBUTtBQUFBLFVBQ1IsT0FBTztBQUFBLFVBQ1AsY0FBYztBQUFBLFVBQ2QsSUFBSTtBQUFBLFVBQ0osU0FBUztBQUFBLFVBQ1QsTUFBTTtBQUFBLFVBQ04sV0FBVztBQUFBLFVBQ1gsUUFBUTtBQUFBLFVBQ1IsVUFBVTtBQUFBLFVBQ1YsU0FBUztBQUFBLFVBQ1QsS0FBSztBQUFBLFVBQ0wsYUFBYTtBQUFBLFVBQ2IsU0FBUztBQUFBLFVBQ1QsU0FBUztBQUFBLFVBQ1QsTUFBTTtBQUFBLFVBQ04sS0FBSztBQUFBLFVBQ0wsT0FBTztBQUFBLFVBQ1AsU0FBUztBQUFBLFVBQ1QsTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04sUUFBUTtBQUFBLFVBQ1IsU0FBUztBQUFBLFVBQ1QsVUFBVTtBQUFBLFVBQ1YsUUFBUTtBQUFBLFVBQ1IsT0FBTztBQUFBLFVBQ1AsS0FBSztBQUFBLFVBQ0wsUUFBUTtBQUFBLFVBQ1IsUUFBUTtBQUFBLFVBQ1IsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsT0FBTztBQUFBLFVBQ1AsS0FBSztBQUFBLFVBQ0wsUUFBUTtBQUFBLFVBQ1IsUUFBUTtBQUFBLFVBQ1IsVUFBVTtBQUFBLFVBQ1YsUUFBUTtBQUFBLFVBQ1IsUUFBUTtBQUFBLFVBQ1IsVUFBVTtBQUFBLFVBQ1YsVUFBVTtBQUFBLFVBQ1YsVUFBVTtBQUFBLFVBQ1YsVUFBVTtBQUFBLFVBQ1YsUUFBUTtBQUFBLFVBQ1IsU0FBUztBQUFBLFVBQ1QsV0FBVztBQUFBLFVBQ1gsS0FBSztBQUFBLFVBQ0wsUUFBUTtBQUFBLFVBQ1IsS0FBSztBQUFBLFVBQ0wsS0FBSztBQUFBLFVBQ0wsT0FBTztBQUFBLFVBQ1AsS0FBSztBQUFBLFVBQ0wsU0FBUztBQUFBLFVBQ1QsUUFBUTtBQUFBLFVBQ1IsU0FBUztBQUFBLFVBQ1QsT0FBTztBQUFBLFVBQ1AsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsUUFBUTtBQUFBLFVBQ1IsV0FBVztBQUFBLFVBQ1gsU0FBUztBQUFBLFVBQ1QsWUFBWTtBQUFBLFVBQ1osS0FBSztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsV0FBVztBQUFBLFVBQ1gsTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFVBQ04sUUFBUTtBQUFBLFVBQ1IsUUFBUTtBQUFBLFVBQ1IsUUFBUTtBQUFBLFVBQ1IsT0FBTztBQUFBLFVBQ1AsT0FBTztBQUFBLFVBQ1AsU0FBUztBQUFBLFVBQ1QsS0FBSztBQUFBLFVBQ0wsTUFBTTtBQUFBLFVBQ04sU0FBUztBQUFBLFVBQ1QsS0FBSztBQUFBLFVBQ0wsUUFBUTtBQUFBLFVBQ1IsT0FBTztBQUFBLFVBQ1AsWUFBWTtBQUFBLFVBQ1osS0FBSztBQUFBLFVBQ0wsT0FBTztBQUFBLFVBQ1AsUUFBUTtBQUFBLFVBQ1IsUUFBUTtBQUFBLFVBQ1IsTUFBTTtBQUFBLFVBQ04sV0FBVztBQUFBLFVBQ1gsS0FBSztBQUFBLFVBQ0wsVUFBVTtBQUFBLFVBQ1YsWUFBWTtBQUFBLFVBQ1osU0FBUztBQUFBLFVBQ1QsVUFBVTtBQUFBLFVBQ1YsU0FBUztBQUFBLFVBQ1QsWUFBWTtBQUFBLFVBQ1osTUFBTTtBQUFBLFVBQ04sUUFBUTtBQUFBLFVBQ1IsTUFBTTtBQUFBLFVBQ04sU0FBUztBQUFBLFVBQ1QsT0FBTztBQUFBLFVBQ1AsU0FBUztBQUFBLFVBQ1QsTUFBTTtBQUFBLFVBQ04sV0FBVztBQUFBLFVBQ1gsUUFBUTtBQUFBLFVBQ1IsT0FBTztBQUFBLFVBQ1AsWUFBWTtBQUFBLFVBQ1osV0FBVztBQUFBLFVBQ1gsU0FBUztBQUFBLFVBQ1QsTUFBTTtBQUFBLFVBQ04sS0FB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QUEsVUFDUDtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FB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
